continuous: '{{$.common.purpose.cf.continuous}}'
shared:
  target: '{{ $.pipelineSteps.targetLabel }}'
  targets: '{{ $.pipeline.targets.title }}'
  targetManagement: Target Management
  segment: Target group
  segments: Target Groups
  lastEvaluated: Last Evaluated
  variation: Variation
  variations: Variations
  prerequisites: '{{$.preRequisitesTitle}}'
  selectEnvironment: Select Environment
  evaluations: Evaluations
  flags: '{{$.common.purpose.cf.flags}}'
  rules: Rules
  archived: archived
  selected: '{{ counter }} selected'
  pleaseSelectVariation: Please select a variation first.
  getStarted: '{{ $.getStarted }}'
  quickGuide: Quick Guide
  readDocumentation: Read the docs
  variationRequired: Variation is required
  serveVariationToTargets: Serve variation to targets
  serveVariationToTargetGroups: Serve variation to target groups
  servePercentageRolloutToTargetGroup: Serve percentage rollout to target group
  governancePolicies: '{{ $.governance.permissions.governancePolicies }}'
  gitSync: '{{ $.gitsync.label }}'
messages:
  flagCreated: Flag created.
  flagUpdated: Flag updated.
  flagDeleted: Flag deleted.
  targetCreated: Target(s) created.
  targetDeleted: Target deleted.
  segmentCreated: Target group created.
  segmentDeleted: Target group deleted.
auditTrail:
  label: 'CF'
  tgResourceLabel: 'Target Group'
rbac:
  category: '{{ $.common.purpose.cf.continuous }}'
  featureflag:
    label: Feature flags
    delete: '{{ $.delete }}'
    toggle: Toggle
  targetgroup:
    label: '{{ $.cf.shared.targetManagement }}'
    delete: '{{ $.delete }}'
creationModal:
  jsonType: JSON
  variationSettingsHeading: Variation settings
  flagType: Flag Type
  defaultRules: Default rules for the flag
  flagOn: If the flag is Enabled, serve
  flagOff: If the flag is Disabled, serve
  saveAndClose: '{{$.common.saveAndClose}}'
  nameIsRequired: Variation name is required
  valueIsRequired: Variation value is required
  idIsRequired: Variation identifier is required
  defaultVariationIsRequired: Default variation is required
  mustBeNumber: Value must be a number
  mustBeValidJSON: Value must be a valid JSON object.
  mustContainLetter: Id must contain at least one letter
  dataType: Data type
  defaultRulesTooltip: Define which variation users will see by default when the flag is ON or OFF

  aboutFlag:
    aboutFlagHeading: About the flag
    permaFlag: This is a permanent flag
    nameRequired: Flag name is required
    idRequired: Flag identifier is required
    ffNamePlaceholder: Enter Feature Flag name...
    ffRegex: '{{$.common.validation.formatMustBeAlphanumeric}}'
    permaFlagTooltip: A flag is permanent if you wish to keep it in your code for the long term. We won't remind you to these types of flags.
editVariation:
  title: Edit Variations
  envNote: Changes will only apply to newly created environments. Existing environments won’t be affected.
  applyToExistingEnvironments: Also apply to existing environments
  remove: Remove variation
addPrerequisites:
  addPrerequisitesHeading: Add Prerequisites
  addPrerequisitesDesc: The following must be met before your flag can be enabled
  selectFlag: Select a Flag
  selectVariation: Select a Variation
  editPrerequisitesHeading: Edit Prerequisites
editDetails:
  editDetailsHeading: Edit Flag Details
  permaFlag: '{{ $.cf.creationModal.aboutFlag.permaFlag }}'
boolean: Boolean
multivariate: Multivariate
noResultMatch: No results match your search criteria
loading: 'Loading ...'
homepage:
  slogan: '{{ $.common.purpose.cf.descriptionOnly }}'
  learnMore: Learn more about Feature Flags
selectFlagRepo:
  introText: 'Git Experience has already been enabled for your project. Please confirm your Git setup before creating feature flags.'
  useExistingRepo: 'Use an Existing Repository'
  newRepo: 'Set up a New Repository'
  dialogTitle: 'Set up with Existing Repository'
  createRepoError: 'Unable to save flags to repository'
clause:
  operators:
    and: '{{ $.common.and }}'
    in: '{{ $.common.in }}'
    startsWith: 'starts with'
    endsWith: 'ends with'
    match: 'match'
    contains: 'contains'
    equal: 'equals'
    equalSensitive: 'equals (sensitive)'
    matchSegment: 'Match Target Group'
featureFlags:
  newFlag: New Feature Flag
  true: 'True'
  false: 'False'
  noFlagsInProject: There are no Flags in this Project
  flagsDescription: A Feature Flag controls what you want to release, who receives it, and how it will be delivered.
  noFlagsToGetStarted: To get started with Feature Flags, you can <a href="https://docs.harness.io/article/1j7pdkqh7j-create-a-feature-flag" target="_blank" rel="noreferrer">create your first Flag</a>, <a href="https://docs.harness.io/category/rtce97j1wu-ff-sdks" target="_blank" rel="noreferrer">get started with our SDKs</a>, or <a href="https://docs.harness.io/category/iqgyied1c0-ff-getting-started" target="_blank" rel="noreferrer">read our getting started guide</a>.
  noFeatureFlagsDescription: Use Feature Flags to turn changes on or off for everyone, for a subset of your users, or for specific audiences.
  rampUpChanges: Ramp changes up across your traffic
  targetUsers: Target a subset of beta users with new features
  testChanges: Test changes on internal accounts first
  rollbackChanges: Turn off problematic changes in production with a rollback
  getStartedWithFF: Get Started with Feature Flags
  typeOfFlag: Select the Type of Flag You Want to Create
  startVariation: Start by selecting the variation type that the flag will use
  booleanBtnText: This is a simple ON/OFF toggle
  multiBtnText: This is suitable for experiments
  percentageRollout: 'Percentage Rollout'
  turnOnHeading: Turn ON Flag
  turnOffHeading: Turn OFF Flag
  turnOnMessage: 'Please confirm that you want to turn on <strong>{{name}}</strong> on <strong>{{env}}</strong> environment.'
  turnOffMessage: 'Please confirm that you want to turn off <strong>{{name}}</strong> on <strong>{{env}}</strong> environment.'
  defaultWillBeServed: '<strong>{{defaultVariation}}</strong> will be served.'
  customRuleMessage: There are custom rules configured for this flag, please review the rules on detail page.
  defaultServedOn: '{{defaultVariation}} when flag is Enabled'
  defaultServedOff: '{{defaultVariation}} when flag is Disabled'
  createdDate: 'Created: {{date}}'
  modifiedDate: 'Modified: {{date}}'
  prerequisitesDesc: 'What’s required before enabling this flag'
  newPrerequisite: New Prerequisite
  ifFlagOnServe: 'If the flag is <strong>ON</strong>, serve '
  ifFlagOffServe: 'If the flag is <strong>OFF</strong>, serve '
  bucketBy: Bucket by <strong>{{targetField}}</strong>
  bucketOverflow: Cannot set above 100%
  serveVariationToTarget: '+ Serve variation to Target'
  serveVariationToTargetLabel: Serve Variation to Target
  customRuleOnRequest: '+ On Request, check for condition and serve variation'
  toTarget: to target
  ifClause: 'If <strong>{{attribute}}</strong> {{operator}} {{values}}'
  ifClauseServe: 'If <strong>{{attribute}}</strong> {{operator}} {{values}}, serve'
  ifClauseServePercentageRollout: 'If <strong>{{attribute}}</strong> {{operator}} {{values}}, serve <strong>percentage rollout</strong>'
  andClause: '- and <strong>{{attribute}}</strong> {{operator}} {{values}}'
  commaSeparator: ', '
  serve: serve
  servePercentageRollout: serve <strong>percentage rollout</strong>
  deleteFlag: Delete Flag
  deleteFlagMessage: Are you sure you want to delete flag <strong>{{name}}</strong>? This action cannot be undone.
  deleteFlagWarning: 'Warning: deleting a flag removes it from all environments, not just the currently selected environment'
  flagOff: Flag is Disabled
  flagOn: Flag is Enabled
  flagWillTurnOn: Enable flag for this environment upon save
  flagWillTurnOff: Disable flag for this environment upon save
  targeting: Targeting
  activity: '{{ $.activity }}'
  results: '{{$.common.results}}'
  makeSure: Make sure your code is deployed
  changeOrReset: Change your filter criteria or reset
  resetFilters: Reset Filters
  clearSearch: Clear Search
  setupGitSync: Set Up Git Sync
  archiving:
    archiveFlag: Archive Flag
    archiveSuccess: Flag successfully archived
    cannotArchive: '<strong>{{ flagName }}</strong> cannot be archived because it is still being used by the following flags as a prerequisite'
    confirmFlag: Type the flag identifier to confirm
    mismatchIdentifierError: The flag identifier does not match
    removeFlag: You must remove the flag as a prerequisite before you can archive it.
    restore: Restore
    restoreFlag: Restore Flag
    restoreDescription: 'Restoring <strong>{{ flagName }}</strong> restores it to all environments. All flag configurations in an environment (including enabled or disabled) will be restored to the state they were in when the flag was archived. If new environments were created since it was archived, the flag will be disabled in those.'
    restoreSuccess: Flag successfully restored
    warningDescription: '<strong>{{ flagIdentifier }}</strong> is being served in at least one environment.<br/><br/>
      Archiving a flag removes it from all environments, but you can restore it within 30 days.<br/><br/>
      Please ensure all references to this flag are removed prior to archiving. <br/><br/>'
  tagging:
    emptyState: No tags assigned
    maxTagsError: Exceeded max number of tags allowed per flag (10)
  rules:
    whenFlagEnabled: When the Flag is Enabled
    whenFlagDisabled: When the Flag is Disabled
    editRules: Edit Rules
    defaultRules: Default Rules
    defaultRule: Default Rule
    customRules: Custom Rules (Serve specific targets differently)
    onRequest: On Request
    addTargeting: Add Targeting
    specificTargeting: Specific Targeting
    ruleChangeModalTitle: Changing default rule?
    ruleChangeModalDescriptionEnabled: 'Changing the default rule will result in the value of <strong>{{ variationValue }}</strong> being served to all SDK clients unless there are specific rules in place. <br/><br/> Are you sure you want to make this change?'
    ruleChangeModalDescriptionDisabled: 'Changing the default rule will result in the value of <strong>{{ variationValue }}</strong> being served to all SDK clients. <br/><br/> Are you sure you want to make this change?'
    toTargetGroups: To Target Groups
    toTargets: To Targets
    searchTargetGroups: 'Search Target Groups'
    searchTargets: 'Search Targets'
    validation:
      selectTarget: Please select a target
      selectTargetGroup: Please select a target group
      valueRequired: Please enter a value
      valueMustAddTo100: Values must add up to 100%
  jira:
    newJiraIssueButton: New Jira Issue
    jiraIssueRequiredError: Jira Issue is Required
    jiraModalTitle: Add Jira Issue
    inputLabel: Jira Issue
    inputPlaceholder: Search for Jira Issue by Issue
    successMessage: Successfully added Jira Issue
    errorMessage: Unable to add Jira Issue
    searchErrorMessage: Unable to fetch Jira Issues

  metrics:
    title: 'Metrics '
    noMetrics: No Evaluations
    evaluations: '{{ count }} evaluations'
    evaluationStatistics: Evaluation Statistics
    flagEvaluations: Flag Evaluations ({{ count }})
    targetServed: Target Served  ({{ count }})
    noData: No metrics found in this time range.
    totalEvaluations: Total Evaluations
  flagPipeline:
    deleteModalTitle: Remove this Pipeline from this Flag?
    deleteModalText:
      If you remove the Pipeline from the Flag, the automated steps in this Pipeline won’t be triggered, for example, automated approval steps.
      The Pipeline will be saved and you can add it again later.

      Are you sure you want to separate the Pipeline?
    title: Flag Pipeline
    noDataMessage: Automate processes with Flag Pipelines
    noDataDescription: Flag Pipelines help to automate routine processes like approval requests, notifications, Jira ticket creation or update
    drawerTitle: Flag Pipelines
    drawerDescription: |
      You can only set Pipelines that:
      <ul>
        <li>Have a Flag stage configured</li>
        <li>The Flag must be set as a runtime input</li>
        <li>Don’t include a Build or Deploy stage</li>
      <ul>
    drawerButtonText: Set as Flag Pipeline
    envText: 'Set all Flags in {{ env }}'
    saveSuccess: Flag Pipeline updated
    noAvailablePipelinesMessage: There are no Pipelines available
    noAvailablePipelinesDescription: You can create a Flag Pipeline in Pipeline Studio to automate your workflow
    noExecutionMessage: There are no Pipeline executions yet
    noExecutionDescription: Once a Pipeline has been triggered, the execution details will appear here
    triggerDetails: Trigger Details
    flagState: Flag State
    defaultOffVariation: When Flag is Disabled - Default Rule
    defaultServe: When Flag is Enabled - Default Rule
    to: to {{ target }}
    buildID: Build ID
    openExecution: Open Pipeline Execution
    pipelineDeleted: The Pipeline in use has been deleted from the Pipelines library
    targeting: When Flag is Enabled - Specific Targeting
    validation:
      setFlagSwitch:
        state: Flag state is required
      defaultRules:
        onOrOffVariation: An ON or OFF variation is required
      defaultOnRule:
        onVariation: ON variation is required
      defaultOffRule:
        offVariation: OFF variation is required
      serveVariationToTargets:
        variation: '{{ $.cf.shared.variationRequired }}'
        targets: Targets are required
      serveVariationToTargetGroups:
        variation: '{{ $.cf.shared.variationRequired }}'
        segments: Target groups are required
      serveVariationToIndividualTarget:
        variationTargets: Targets/variation is required
      serveVariationToTargetGroup:
        variationTargetGroups: Target Groups/variation is required
      servePercentageRollout:
        targetGroup: Target Group is required
        variations: Variations are required
  flagVideoLabel: 'What is a feature flag?'
featureFlagDetail:
  variationCount: '{{ count }} variations'
  serviceDescription: Monitored Services this flag is associated with
  serviceUpdateSuccess: Monitored Services updated
  noServices: 'No Monitored Service available'
  searchService: 'Search for Monitored Service name'
  jiraIssuesTitle: Jira Issues
  jiraIssuesDescription: Jira Issues associated with this Flag
  flagPipelineVideoLabel: 'What is a flag pipeline?'
flagFilters:
  active: Active Flags
  allFlags: All Flags
  archivedFlags: Archived Flags
  enabled: Enabled Flags
  recentlyAccessed: Recently Changed Flags
  permanent: Permanent Flags
  potentiallyStale: Potentially Stale Flags
staleFlagAction:
  notStale: Mark as Not Stale
  readyForCleanup: Mark as Ready for Cleanup
  selectAllPotentiallyStaleFlags: Select all potentially stale flags
  learnMore: Learn more about flag lifecycle
  flagsSelected: '{{ count }} Flags Selected'
  checkStaleFlag: Check potentially stale flag
  checkAllStaleFlags: Check all potentially stale flags
  waitingForCleanup: Waiting for cleanup
  notStaleDesc: These Flags will be removed from the queue to cleanup and marked as not stale.
  readyForCleanupDesc: These Flags will be added to the queue for cleanup.
targets:
  createdDate: Created Date
  create: New Target
  list: Add a target
  upload: Upload a list of targets (CSV files only)
  enterName: 'Enter target name'
  enterValue: 'Enter target identifier'
  addRow: Add row
  removeRow: Remove row
  addTargetsLabel: Add Target(s)
  uploadHeadline: Please upload a CSV file according to our <a href="https://docs.harness.io/article/dbk9uoaid3-add-targets#step_upload_a_list_of_targets" target="_blank" rel="noreferrer">template</a>.
  uploadHelp: 'Target CSV entry format: Name,Identifier'
  uploadYourFile: Click to upload your file
  uploadStats: <strong>Targets</strong> ({{ count }})
  noneDefined: None Defined
  deleteTarget: Delete Target
  deleteTargetMessage: Are you sure you want to delete target <strong>{{name}}</strong>? This action cannot be undone.
  deleteTargetSuccess: Target <strong>{{name}}</strong> deleted.
  pageDescription: This list displays targets manually added or impacted by flags.
  uploadError: CSV processing failed
  newEnvironmentTarget: New Environment for setting up a target
  noTargetForEnv: There are no Targets in this Environment
  noTargetDescription: <a href="https://docs.harness.io/article/dbk9uoaid3-add-targets#step_add_a_target" target="_blank" rel="noreferrer">Targets</a> are individual evaluations of Flags based on attributes you define in our SDKs. For instance, a Target can be a single customer or account that toggle a Flag.
targetDetail:
  createdOnDate: Created on {{ date }}, {{ time }} PST
  targetSetting: Target Settings
  flagSetting: Flag Settings
  attributes: Attributes ({{ counter }})
  manuallyAdded: MANUALLY ADDED
  addToSegment: Add to {{count}} Target Groups
  exclusionList: EXCLUSION LIST
  excludeFromSegment: Exclude from {{count}} Target Groups
  removeSegment: Remove from list
  targetDescription: 'Define Targets to decide who flag changes will impact.'
  targetGroupDescription: 'Create reusable cohorts of Targets based on any criteria you like.'
  targetsForUsers: 'Use Targets for your users to flag changes for individual end users'
  accountLevelTargets: 'Account-level targeting lets you change Flags for all users in an account'
  targetByGeo: 'Target by geo, tenant or any other account property'
  vipTargets: 'Include or exclude VIP Targets in groups'
  groupsForLocations: 'Create groups for locations, instances, account plans or any other attribute'
  regions: 'Perfect for regions, beta users or any other custom combination'
  noSegmentAdded: No Target Group added
  noSegmentExcluded: No Target Group excluded
  addTargetToSegment: Add Target to Target Group
  excludeTargetFromSegment: Exclude Target from Target Group
  removeFromIncludeList: Are you sure you want to remove target <strong>{{targetName}}</strong> from include target group <strong>{{ segmentName}}</strong>? This action cannot be undone.
  noFlagConfigured: No Feature Flags configured for this Target
  searchPlaceholder: Search Feature Flags...
  flagDisabled: This flag is disabled. The default off value will be served.
  addTargetToTargetGroup: Add Target to Target Group {{name}}
  noTargetGroupsAvailable: No Target Groups available
  addFlagToTarget: Add Flag to Target
targetManagementFlagConfiguration:
  allFlagsRemoved: All Feature Flags removed
  addFlag: Add Flag
  addFlags: 'Add {{ flagCount }} Flags'
  removeFlag: Remove Flag
  noFlagsAvailable: No flags available
  selectVariation: select variation
segments:
  create: New Target Group
  usingSegment: Flags using this target group
  usingSegmentWithCount: Flags using this target group ({{ count }})
  modalTitle: Create a Target Group
  delete:
    message: 'Are you sure you want to delete Target Group <strong>{{segmentName}}</strong>? <br/>This action cannot be undone.'
    title: Delete Target Group
  nameRequired: Target Group name is required
  idRequired: Target Group identifier is required
  noTargetGroupsForEnv: There are no Target Groups in this Environment
  noTargetGroupsDescription: <a href="https://docs.harness.io/article/5qz1qrugyk-add-target-groups#manage-target-groups" target="_blank" rel="noreferrer">Target Groups</a> are larger collection of Targets used to toggle Flags for entire cohorts. For instance, a Target Group could be an entire country, an early adopter list or an internal team.
  pageDescription: Target Groups allow you to serve flag variations to a list of targets in bulk.
environments:
  environmentID: 'Id:'
  prod: PROD
  nonProd: NON-PROD
  delete:
    message: 'If you want to delete environment <strong>{{name}}</strong>, the SDK keys for this environment will also be deleted. Delete environment <strong>{{name}}</strong>?'
    title: '{{ $.common.deleteEnvironment.title }}?'
  create:
    title: 'Create an Environment'
    description: 'An environment is the representation of your production or non-production infrastructure'
    envTypeLabel: 'Environment type'
    nameLabel: 'Name of your environment'
    duplicateName: 'Environment with this name already exists. Try another name'
  apiKeys:
    create: 'Key created'
    addKeyTitle: Create SDK Key
    message: 'Secrets are only visible right after creation and redacted once you leave the page. Please make sure to copy and store your secret somewhere safe'
    title: 'SDK Keys'
    description: 'SDK Keys authenticate the SDK and connect to a specific environment.'
    keysForEnvironment: 'Create different keys for each environment'
    keysForLanguages: 'Create different keys for different languages'
    rotateAndMonitor: 'Easy to rotate and monitor keys'
    emptyName: 'SDK Key name is required'
    addKey: 'New SDK Key'
    duplicateKey: 'A SDK key with this name already exists. Try another name'
    clientType: Client
    clientDescription: 'A client id will be generated as your client-side SDK key.'
    serverType: Server
    serverDescription: 'A secret will be generated as your server-side SDK key.'
    deleteTitle: 'Confirm Key Delete?'
    deleteMessage: 'Are you sure you want to delete Key: <strong>{{keyName}}</strong>? You cannot recover it afterwards'
    deleteSuccess: 'Successfully deleted Key: {{keyName}}'
    keyType: 'Key Type'
    applicableLanguages: 'Applicable Languages:'
    noKeysFoundTitle: There are no SDK keys for this environment
    noKeysFoundMessage: Create an <a href="https://docs.harness.io/article/1j7pdkqh7j-create-a-feature-flag#step_3_create_an_sdk_key" target="_blank" rel="noreferrer"> SDK key</a> for this Environment so that your application can connect to our FF client. We support SDK keys for multiple programming languages.
    redactionWarning: Your secret will be redacted once you leave the page. Please make sure to copy and store your secret.
    lastUsed: 'Last Used'
  noEnvironmentSection:
    message: 'Change flags, manage access and see history per environment.'
    configurations: 'Different configurations on Dev vs Prod environments'
    limitation: 'Limit who can access Prod'
    auditTrails: 'Audit trails to see what changes in each environment'
auditLogs:
  summaryHeading: 'Module: Feature Flags • Project: {{project}} • Environment: {{environment}}'
  searchPlaceholder: Search Activity
  viewEventSummary: View Event Summary
  timePST: 'TIME (PST)'
  user: USER
  action: ACTION
  flagCreated: Feature activation created
  segmentCreated: Target Group created
  flagUpdated: Feature activation updated
  flagArchived: Flag archived
  flagRestored: Flag restored
  unknown: Unknown activity
  empty: No activity found during this time.
  createdMessageFF: 'created feature flag'
  createdMessageFFUpdate: 'updated feature flag'
  createdMessageSegment: 'created target group'
  updateMessageSegment: 'updated target group'
  changeDetails: Change details
  events:
    updateClause: A clause was updated for a rule
    removeClause: A clause was removed
    addClause: A clause was added
    addToIncludeList: '{{target}} added to included Targets'
    removeFromIncludeList: '{{target}} removed from included Targets'
    addToExcludeList: '{{target}} added to excluded Targets'
    removeFromExcludeList: '{{target}} removed from excluded Targets'
    reorderRules: Rules reordered
    updateDefaultServe:
      bucketBy: Default serve updated for bucket by '{{bucketBy}}'
      variation: Default serve updated with variation '{{variation}}'
    targetAddedForVariation: Target '{{target}}' was added for Variation '{{variation}}'
    updateDescription: Description updated to '{{description}}'
    updateName: Name updated to '{{name}}'
    updatePermanent: Permanent set to '{{permanent}}'
    addRule: Target Group '{{targetGroup}}' was added for Variation '{{variation}}'
    addPercentageRollout: Target Group '{{targetGroup}}' was added with percentage rollout
    updateRule: Rule updated
    removeRule: Rule removed
    addVariation: Variation '{{variation}}' added
    updateVariation: Variation '{{variation}}' updated
    deleteVariation: Variation '{{variation}}' deleted
    setDefaultOnVariation: Default on variation set to '{{variation}}'
    setDefaultOffVariation: Default off variation set to '{{variation}}'
    addSegmentToVariationTargetMap: Target Group '{{segment}}' added for Variation '{{variation}}'
    setFeatureFlagStateOn: Flag turned on
    setFeatureFlagStateOff: Flag turned off
    tagUpdated: Tags updated
    tagRemoved: Tags removed
    tagAdded: Tags added
    addPrerequisite: Prerequisite '{{name}}' added
    removePrerequisite: Prerequisite '{{name}}' removed
    updatePrerequisite: Prerequisite '{{name}}' updated
    removeTargetsToVariationTargetMap: Variation '{{variation}}' removed for targets '{{targets}}'
    clearVariationTargetMapping: Variation target mapping removed
    updateOffVariation: Off variation updated to '{{variation}}'
    addService: Service {{name}} added
    removeService: Service {{name}} removed
noEnvironment:
  title: There are no Environments in this Project
  message: <a href="https://docs.harness.io/article/1j7pdkqh7j-create-a-feature-flag#step_2_create_an_environment" target="_blank" rel="noreferrer">Environments</a> are the different places you run your application where you can configure Flags - i.e. your dev server, your QA server and your production server
pipeline:
  rolloutStrategy:
    title: Rollout Strategy
  advanced:
    title: '{{ $.advancedTitle }}'
  flagConfiguration:
    environmentRequired: An environment is required
    flagRequired: A feature flag is required
    stepName: 'Step Name '
    selectEnvironment: '{{ $.cf.shared.selectEnvironment }}'
    selectFlag: Select Flag
    selectTargets: Select targets
    selectTargetGroups: Select target groups
    selectTargetGroup: Select target group
    switchTo: Set Flag Switch To
    configureMore: + Configure More
    serve: Serve
    serveVariation: Serve variation
    flagChanges: Flag Changes
    flagChangesRuntime: 'At runtime, you may choose the following flag configuration changes:'
    flagChangesRuntimeSetDefaultRules: Set default rules
    flagChangesRuntimeServeVariationToTargets: '{{ $.cf.shared.serveVariationToTargets }}'
    flagChangesRuntimeServeVariationToTargetGroups: '{{ $.cf.shared.serveVariationToTargetGroups }}'
    flagChangesRuntimeServePercentageRollout: Serve a percentage rollout
    setFlagSwitch: Set flag switch
    setDefaultOnRule: Set default ON rule
    setDefaultOffRule: Set default OFF rule
    serveVariationToTargets: '{{ $.cf.shared.serveVariationToTargets }}'
    serveVariationToIndividualTarget: Serve Variation to Individual Target
    serveVariationToTargetGroup: Serve Variation to Target Group
    serveVariationToTargetGroups: '{{ $.cf.shared.serveVariationToTargetGroups }}'
    servePercentageRolloutToTargetGroup: '{{ $.cf.shared.servePercentageRolloutToTargetGroup }}'
    servePercentageRollout: Serve Percentage Rollout
    selectOnOrOff: Select ON or OFF
    whenTheFlagIsOnServe: 'When the flag is ON, serve:'
    whenTheFlagIsOffServe: 'When the flag is OFF, serve:'
    addEditVariationToSpecificTargets: + Add/edit variation to specific targets
    addEditVariationToTargetGroups: + Add/edit variation to target groups
    enterTarget: Enter Target
    enterTargetGroup: Enter Target Group
    selectVariation: Select a variation
    variationServed: Variation Served
    toTargets: to targets
    toTargetGroup: to target group
    toTargetGroups: to target groups
    pleaseSelectAFeatureFlag: Please select an environment and feature flag.
    pleaseSelectFlag: Please select a feature flag.
    pleaseSelectEnvironment: Please select an environment.
    noFlagChanges: Please add a flag change.
    removeFlagChange: Remove flag change
    addFlagChange: Add Flag Change
segmentDetail:
  directlyAdded: Directly Added
  autoAdded: Automatically Added Through Conditions
  removeFomFlag: Remove from Flag
  noFlagsUseThisSegment: No Flags use this target group.
  addToFlag: + Add to Flag
  addSegmentToFlag: Add Target Group to Flag
  criteria: Criteria
  specificTargets: Specific Targets
  targetBasedOnCondition: Target based on condition
  noTargetDefined: No Target defined
  includeTheFollowing: Include the following
  excludeTheFollowing: Exclude the following
  noConditionDefined: No Condition defined
  targetGroupCriteria: Target Group Criteria
  specifyIndividualTargets: Specify individual Targets
  removeRule: Remove Rule
  addRule: Add Rule
  attribute: Select attribute
  operator: Select operator
  values: Enter value(s)
  updated: Target Group updated successfully
  searchTarget: Search Target
  noFlags: There are no Flags specified for this Target Group
  headingFeatureFlag: FEATURE FLAG
  headingVariation: VARIATION
  variationIsRequired: '{{ $.cf.shared.variationRequired }}'
  addFlagNameToTargetGroup: 'Add {{ flagName }} to Target Group'
  addFlagToTargetGroup: Add Flag to Target Group
  updateSuccessful: Update successful
  flagsAddedSuccessfully: Flag(s) added successfully
selectFlagsModal:
  empty: No feature flags found.
  searchPlaceholder: Search for Flag by name or description
gitSync:
  saveFlagToGit: Save {{ flagName }} to Git
  commitChanges: Commit Changes
  autoCommitMsg: '[AUTO-COMMIT] : {{msg}}'
  commitMsgRequired: Commit message is required
  autoCommitLabel: Always commit to this branch and do not prompt for commit message.
  branchStatus: Auto-commit to {{branch}} is {{status}}
  syncingPaused: Syncing with Git is currently OFF. Click to view settings
  toggleGitSyncPause: Sync with Git
  autoCommitStatusLabel: Auto-commit to selected branch
  turnOffGitAndContinue: Turn off Git and Continue
  gitErrorModalTitle: Changes can't be saved to Git
  gitServiceApiError: To continue work you can turn off Git Synchronization. All changes will be saved to Harness. When Git Sync is re-enabled we'll attempt to push the latest changes to Git
  goToGit: Go to Git to fix issue
  invalidYaml: 'We are unable to render your {{{ flagsYamlFilename }}} file because it is invalid. Fix the following issues on Git and try again.'
  setUpGitConnection: Set up a Git connection
  setUpGitSuccess: 'Successfully connected to repository {{ repoName }}'
  resetGitSettings: Reset Git Settings
  resetGitWarning: This will delete all git configurations and you will have to set it up from the beginning
  resetGitSuccess: Successfully reset Git settings
  resetGitError: Error resetting Git settings
policyEvaluations:
  failedToSave: Flag cannot be saved due to the policy evaluation failures
  warning: Flag saved with policy warnings
planEnforcement:
  upgradeRequiredDev: Total Developers managing feature flags has exceeded the Subscribed developer count.
  upgradeRequiredMau: 'Total Monthly Active Users (MAU) has reached the free plan limit. Upgrade to manage unlimited MAUs.'
  freePlan:
    approachingLimit: 'You have used {{ clientMauUsagePercentage }}% of Monthly Active Users (MAU) included in the free plan. After {{ clientMauPlanLimitFormatted }} MAUs, flag management will be restricted.'
    upgradeRequired: 'You have used {{ clientMauPlanLimitFormatted }} / {{ clientMauPlanLimitFormatted }}  free Monthly Active Users (MAU) this month. Consider upgrading to manage more MAUs.'
  teamEnterprisePlan:
    approachingLimit: 'You have used {{ clientMauUsagePercentage }}% of your Monthly Active Users (MAU) subscription limit.'
    upgradeRequired: 'You have exceeded your Monthly Active Users (MAU) subscription limit.'
onboarding:
  typeNewFeatureName: Type the name of a new flag
  typeNewEnvName: Type the name of a new environment
  multiStep:
    createEnv: Create an Environment and SDK key
    validate: Validate
  freeBanner: All Products are free forever. For greater functionality explore plans.
  simpliestFlag: Our Simplest Flag
  simpliestFlagDescription: 'You’re creating our simplest feature flag type: Boolean Flag. This flag type is commonly used as a feature toggle, which effectively shows/hides features from your targets.'
  otherTypes: Check out other flag types
  complete: Complete
  title: Feature Flags Quick Start Guide
  subTitle: Everything you need to know in less than 15 minutes.
  tryItOut: '{{ $.getStarted }}'
  createEnvAndSdk: Create an Environment and SDK Key
  setupCode: Setup your Code
  oneCreateAFlag: '1. Create a Flag'
  setUpApp: '2. Set Up Your Application'
  testYourFlag: '3. Test Your Flag'
  letsGetStarted: Let's get started
  createFlag: Create a Feature Flag
  flagInputLabel: Select an existing Flag or type the name to create new one
  selectOrCreateFlag: Select or Create a Flag
  youCreated: You've created
  youreUsing: You're using
  youveSelected: You've selected
  selectEnvAndSdk: Select Environment and SDK
  selectLanguage: Select your language
  createEnv: Create an environment
  selectOrCreateEnvironment: Select or Create an Environment
  environmentDescription: Environments are spaces within a project where you can independently configure Feature Flags. You can have multiple Environments and the same Flags can have a different state in each Environment.
  selectOrTypeEnv: Select an existing Environment or type the name to create new one
  envCreated: Environment Created
  enterKeyName: Enter key name
  createSdkKey: Create an SDK Key
  sdkKeyDescription: SDK keys are unique to each Environment and they authorize the connection between your application and the Feature Flag SDK Client.
  keyDescriptionServer: We generated a secret as the server-side SDK key for <b>{{env}}</b> Environment for you to use in your code below. This secret will be redacted once you leave the page, so make sure to copy and store your secret somewhere safe.
  keyDescriptionClient: We generated a client-side SDK key for <b>{{env}}</b> Environment. Use this in your code to authenticate the connection between your application and the Feature Flag SDK client.
  keyGeneratedBelow: We generated a {{langType}} SDK key of your new environment for you to use in your code below.
  secret: SDK Secret
  clientKey: Client SDK Key
  selectedLanguageAndEnv: <b>{{language}}</b> and <b>{{env}}</b> environment
  ios: iOS
  android: Android
  setUpYourCode: Set up your code
  listenToEvent: We're listening for the change to your Flag status...<br>Be patient, it may take up to 3-5 minutes
  validatingYourFlag: Validating your Flag
  validatingFlagInfo: 'Enable your Flag to verify that the event we received has the same value. Learn more about <a target="_blank" href="https://docs.harness.io/article/7ikyqtmjce-communication-sdks-harness-feature-flags">Events and Evaluation</a>'
  eventWeReceived: Event we received
  sdkWarning: The SDK must run for at least 60 seconds to allow for metrics to be processed and sent. Also, please double-check that metrics were not inadvertently disabled in the SDK configuration.
  createdAndValidated: Congrats! You have created and validated your first Flag! <br><br>Now you can define which Targets and Target Groups this Flag should be enabled for, and then see how that affects your application.
  errorReceivingEvent: We couldn't receive a Flag status from your application, check the <a target="_blank" href="https://docs.harness.io/category/eyzngtupao-sdk-overview"> SDK reference guide</a> to ensure you've set up the SDK correctly, then toggle the Flag to try again.
  furtherAssistance: '<br>If you are still having issues,'
  toggleError: We couldn't receive events, check possible reasons below and toggle the Flag to try again
  help:
    heading1: The Importance of Your Flag Id
    text1: Your flag Id is required to reference the flag in your code.
    heading2: Installing an SDK to Your Environment
    text2: Your flag is automatically available for use in all environments of your project. However, you need to install our SDK to environments you wish to initiate your flag in.
    getStarted: Get started with SDKs
  readme:
    java: |
      # Install

      To use this SDK, make sure you have:
      - Installed <a href="https://openjdk.java.net/install/">JDK 8</a> or a newer version
      - Installed Maven, Gradle or an alternative build automation tool for your application

      # Usage

      Create a java project with a package called 'examples'.

      Maven - add the following Maven dependency in your project's 'pom.xml' file:
      ```
      <dependencies>
        <dependency>
            <groupId>io.harness</groupId>
            <artifactId>ff-java-server-sdk</artifactId>
            <version>1.1.6</version>
        </dependency>
      </dependencies>
      ```

      Gradle
      ```
      implementation group: 'io.harness', name: 'ff-java-server-sdk', version: '1.1.6'
      ```

      Create a class called 'GettingStarted' in your project, copy and paste the code below into that class. 
      After installing the SDK, enter the SDK keys that you created for your environment. 
      The SDK keys authorize your application to connect to the FF client.

      ```
      package io.harness.ff.examples;

      import io.harness.cf.client.api.*;
      import io.harness.cf.client.dto.Target;

      import java.util.concurrent.Executors;
      import java.util.concurrent.ScheduledExecutorService;
      import java.util.concurrent.TimeUnit;

      public class GettingStarted {
          // API Key - set this as an env variable
          private static String apiKey = "{{apiKey}}";

          // Flag Identifier
          private static String flagIdentifier = "{{flagIdentifier}}";

          private static final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

          public static void main(String[] args) {
              System.out.println("Harness SDK Getting Started");

              try {
                  //Create a Feature Flag Client
                  CfClient cfClient = new CfClient(apiKey);
                  cfClient.waitForInitialization();

                  // Create a target (different targets can get different results based on rules.  This includes a custom attribute 'location')
                  final Target target = Target.builder()
                          .identifier("javasdk")
                          .name("JavaSDK")
                          .attribute("location", "emea")
                          .build();

                  // Loop forever reporting the state of the flag
                  scheduler.scheduleAtFixedRate(
                          () -> {
                              boolean result = cfClient.boolVariation(flagIdentifier, target, false);
                              System.out.println("Boolean variation is " + result);
                          },
                          0,
                          10,
                          TimeUnit.SECONDS);

              } catch (Exception e) {
                  e.printStackTrace();
              } finally {
                  // Close the SDK
                  CfClient.getInstance().close();
              }
          }
      }
      ```
      # Test your application 

      ```
      mvn clean package
      //Ensure the below command is pointing to your class
      mvn exec:java -Dexec.mainClass="io.harness.ff.examples.GettingStarted"
      ```

    javascript: |
      # Install

      You can use npm or yarn to install <a href="https://www.npmjs.com/package/@harnessio/ff-javascript-client-sdk">ff-javascript-client-sdk</a> into your project:

      ```
      npm i @harnessio/ff-javascript-client-sdk
      ```

      If you use yarn

      ```
      yarn add @harnessio/ff-javascript-client-sdk
      ```

      # Usage

      Create a file called `index.html` and add the following code below:

      ```
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <title>Feature Flags</title>
        </head>
        <body>
          <p>The value of flag "{{flagIdentifier}}" is: <pre>...</pre></p>

          <script type="module">
            import {
              initialize,
              Event as SDKEvent
            } from 'https://unpkg.com/@harnessio/ff-javascript-client-sdk/dist/sdk.client.js'

            const target = {
              identifier: 'MyTargetID',
              name: 'MyTargetName'
            }

            const client = initialize('{{apiKey}}', target)

            // Listen for events
            // Event happens when connection to server is established
            client.on(SDKEvent.READY, (flags) => {
              console.log('READY', flags)

              // update the value on screen every 5 seconds
              const updateValue = () => {
                document.querySelector('pre').innerText = JSON.stringify(
                  client.variation('{{flagIdentifier}}', 'DEFAULT')
                )

                setTimeout(updateValue, 5000)
              }

              updateValue()
            })

            // Event happens when a changed event is pushed
            client.on(SDKEvent.CHANGED, (changeInfo) => {
              console.log('CHANGED', changeInfo)
            })
          </script>
        </body>
      </html>

          
      ```
      # Test your application 

      Run your application by opening `index.html` in your browser. Open the browser dev tools and refresh the page.

    golang: |
      # Install

      To use this SDK, make sure you have:

       <a href="https://go.dev/doc/install">Golang 1.16</a> or newer (go version)

      Install the golang SDK using go
      ```
      go get github.com/harness/ff-golang-server-sdk
      ```

      # Usage

      Create a file called `getting_started.go` and add the following code below:

      ```
      package main

      import (
        "log"
        "os"
        "time"

        harness "github.com/harness/ff-golang-server-sdk/client"
        "github.com/harness/ff-golang-server-sdk/evaluation"
      )

      var (
        flagIdentifier string = "{{flagIdentifier}}"
        sdkKey   string = "{{apiKey}}"
      )

      func main() {
        log.Println("Harness SDK Getting Started")

        // Create a feature flag client instance
        client, err := harness.NewCfClient(sdkKey)
        if err != nil {
          log.Fatalf("could not connect to FF servers %s\n", err)
        }
        defer func() { client.Close() }()

        // Create a target (different targets can get different results based on rules)
        target := evaluation.Target{
          Identifier: "HT_1",
          Name:       "Harness_Target_1",
          Attributes: &map[string]interface{}{"email": "demo@harness.io"},
        }

        // Loop forever reporting the state of the flag
        for {
          resultBool, err := client.BoolVariation(flagIdentifier, &target, false)
          if err != nil {
            log.Fatal("failed to get evaluation: ", err)
          }
          log.Printf("Flag variation %v\n", resultBool)
          time.Sleep(10 * time.Second)
        }

      }

      ```

      # Test your application

      ```
      go run getting_started.go
      ```

    android: |
      # Setup

      Add following snippet to root project's `build.gradle` file:

      ```
      buildscript {
          repositories {
              mavenCentral()
          }
      ```

      In app module's `build.gradle` file add dependency for Harness's SDK (version >= 1.0.3)
      `implementation 'io.harness:ff-android-client-sdk:1.0.3'`

      After this step, the SDK elements, primarily `CfClient` should be accessible in main application.

      # Initialization

      `CfClient` is base class that provides all features of SDK. This is singleton and it is accessed with `CfClient.getInstance()`.

      ```Kotlin
      val sdkConfiguration = CfConfiguration.builder()
          .baseUrl("BASE_API_URL")
          .pollingInterval(30) //time in seconds
          .enableStream(true)
          .streamUrl("STREAM_URL")
          .build()

      val target = Target().identifier("target")

      CfClient.getInstance().initialize(context, '{{apiKey}}', sdkConfiguration, target)
      ```

      `target` represents a desired target for which we want features to be evaluated.

      **Your Harness SDK is now initialized. Congratulations!!!**

      # Public API Methods

      The Public API exposes a few methods that you can utilize:

      ```
      public void initialize(Context context, String clientId, CfConfiguration configuration, CloudCache cloudCache, AuthCallback authCallback)

      public boolean boolEvaluation(String evaluationId, boolean defaultValue)

      public String stringEvaluation(String evaluationId, String defaultValue)

      public double numberEvaluation(String evaluationId, double defaultValue)

      public JSONObject jsonVariation(String evaluationId, JSONObject defaultValue)

      public void registerEventsListener(EventsListener listener)

      public void unregisterEventsListener(EventsListener observer)

      public void destroy()
      ```

      # Fetch evaluation's value

      It is possible to fetch a value for a given evaluation. Evaluation is performed based on different type. In case there is no evaluation with provided id, the default value is returned.

      Use appropriate method to fetch the desired Evaluation of a certain type.

      # boolEvaluation(String evaluationId, boolean defaultValue)

      ```Kotlin
      //get boolean evaluation
      val evaluation: Boolean = CfClient.getInstance().boolVariation("demo_evaluation", false)
      ```

      # numberEvaluation(String evaluationId, double defaultValue)

      ```Kotlin
      //get number evaluation
      val numberEvaluation: Double = CfClient.getInstance().numberVariation("demo_number_evaluation", 0)
      ```

      # stringEvaluation(String evaluationId, String defaultValue)

      ```Kotlin
      //get String evaluation
      val stringEvaluation: String = CfClient.getInstance().stringVariation("demo_string_evaluation", "demo_value")
      ```

      # Register for events

      This method provides a way to register a listener for different events that might be triggered by SDK, indicating specific change in SDK itself.

      ```Kotlin
      private final EventsListener eventsListener = statusEvent -> {
          if (statusEvent.getEventType() == EVALUATION_CHANGE) {
              Evaluation evaluation = statusEvent.extractPayload();
          }
      }

      CfClient.getInstance().registerEventsListener(eventsListener)
      ```

      Triggered event will have one of the following types:

      ```Java
      public enum EVENT_TYPE {
              SSE_START,
              SSE_END,
              EVALUATION_CHANGE,
              EVALUATION_RELOAD
          }
      ```

      Following table provides summary on possible event types and corresponding responses.

      ```
      | EVENT_TYPE        | Response          |
      | -------------     |:-------:          |
      | SSE_START         | -                 |
      | SSE_END           | -                 |
      | EVALUATION_CHANGE | `Evaluation`      |
      | EVALUATION_RELOAD | `List<Evaluation>`|
      ```

      To avoid unexpected behaviour, when listener is not needed anymore, a caller should call
      `CfClient.getInstance().unregisterEventsListener(eventsListener)`. This way the sdk will remove desired listener from internal list.

      # Shutting down the SDK

      To avoid potential memory leak, when SDK is no longer needed (when the app is closed, for example), a caller should call this method

      ```Kotlin
      CfClient.getInstance().destroy()
      ```

      # Using SDK in unit tests

      To be able to use the SDK in unit tests it is required to set SDKs logging to the console output:

      ```Kotlin
      CfLog.testModeOn()
      ```

      `testModeOn` will turn on the use of the system output logging strategy.
      On the other hand, to turn on the usage of the Android <a href="https://developer.android.com/reference/android/util/Log">log class</a> use:

      ```Kotlin
      CfLog.runtimeModeOn()
      ```

      Standard Android logging is the default logging strategy so turning on runtime mode is not required.
    ios: |
      # Installing the `ff-ios-client-sdk`

      Installing ff-ios-client-sdk is possible with `Swift Package Manager (SPM), CocoaPods and Carthage`

      # Swift Package Manager (SPM)

      The [Swift Package Manager](https://swift.org/package-manager/) is a dependency manager integrated into the `swift` compiler and `Xcode`.

      To integrate `ff-ios-client-sdk` into an Xcode project, go to the project editor, and select `Swift Packages`. From here hit the `+` button and follow the prompts using  `https://github.com/drone/ff-ios-client-sdk.git` as the URL.

      To include `ff-ios-client-sdk` in a Swift package, simply add it to the dependencies section of your `Package.swift` file. And add the product `ff-ios-client-sdk` as a dependency for your targets.

      ```Swift
      dependencies: [
          .package(url: "https://github.com/drone/ff-ios-client-sdk.git", .upToNextMinor(from: "1.0.2"))
      ]
      ```

      # CocoaPods

      [CocoaPods](https://cocoapods.org//) is a dependency manager for Swift and Objective-C Cocoa projects. It has over 81 thousand libraries and is used in over 3 million apps. CocoaPods can help you scale your projects elegantly.

      CocoaPods is built with Ruby and it will be installable with the default Ruby available on macOS. You can use a Ruby Version manager, however we recommend that you use the standard Ruby available on macOS unless you know what you're doing.

      Using the default Ruby install will require you to use sudo when installing gems. (This is only an issue for the duration of the gem installation, though.)

      ```Swift
      $ sudo gem install cocoapods
      ```

      Once Cocoapods is installed, from your root project folder, create a `Podfile`, which will be located in your project's root folder, by entering the next command in your terminal:

      ```Swift
      $ pod init
      ```

      To import `ff-ios-client-sdk` to your `.xcproject`, simply add `ff-ios-client-sdk` to your newly created Podfile and save the Podfile changes.

      ```Swift
      platform :ios, '10.0'
      use_frameworks!

      target 'MyApp' do
        pod 'ff-ios-client-sdk'
      end
      ```

      Only thing left to do is to install your packages by running the next command.

      ```Swift
      $ pod install
      ```

      NOTE: A new `.xcworkspace` will be created and you should use that, instead of your `.xcodeproj` from now on in order to utilize the imported Pods.

      # Carthage

      Carthage is intended to be the simplest way to add frameworks to your Cocoa application. Carthage builds your dependencies and provides you with binary frameworks, but you retain full control over your project structure and setup. Carthage does not automatically modify your project files or your build settings.

      In order to integrate `ff-ios-client-sdk` into your app, there are a few steps to follow.

      Navigate to the root folder of your project and create a `Cartfile`. This is the file where you would input all of your dependencies that you plan to use with Carthage. You can create it by entering

      ```Swift
      $ touch Cartfile
      ```

      in Terminal at your project's root folder. Once you open the `Cartfile`, you can copy/paste below line and save the changes.

      ```Swift
      github "drone/ff-ios-client-sdk"
      ```

      Now, you need to run

      ```Swift
      $ carthage update --no-build
      ```

      This command will fetch the source for `ff-ios-client-sdk` from the repository specified in the `Cartfile`.

      You will now have a new folder, named `Carthage` at the same location your `Cartfile` and your `.xcodeproj` are.

      Within the `Carthage` folder, you will see another `Checkout` folder where the source code is located.

      Next, we need to create a project for `ff-ios-client-sdk` dependency. We can do this easily by entering the following in the terminal.

      ```Swift
      //From your project's root folder
      $ cd Carthage/Checkouts/ff-ios-client-sdk
      ```

      followed by

      ```Swift
      $ swift package generate-xcodeproj
      ```
      or you can enter it all on the same line.

      ```Swift
      // From your project's root folder
      $ cd Carthage/Checkouts/ff-ios-client-sdk && swift package generate-xcodeproj
      ```

      Go back into your project's root folder and enter the next command:

      ```Swift
      $ carthage build --use-xcframeworks --platform iOS
      ```

      This command will build the project and place it in the `Build` folder next to `Checkouts`. On your application targets’ `General` settings tab, in the `Frameworks, Libraries, and Embedded Content` section, drag and drop the `.xcframework` file from the `Carthage/Build` folder. In the `"Embed"` section, select `"Embed & Sign"`.

      Only thing left to do is:

      ```Swift
      import ff_ios_client_sdk
      ```

      wherever you need to use `ff-ios-client-sdk`

      When a new version of `ff-ios-client-sdk` is available and you wish to update this dependency, run

      ```Swift
      $ carthage update --use-xcframeworks --platform iOS
      ```
      And your embedded library will be updated.

      # Using the `ff-ios-client-sdk`

      In order to use `ff-ios-client-sdk` in your application, there are a few steps that you would need to take.

      # Initialization

      1. Setup your configuration by calling `CfConfiguration`'s static method `builder()` and pass-in your preferred configuration settings through possible chaining methods. The chaining needs to be ended with `build()` method. (See the `build()`'s description for possible chaining methods and their default values.)

      2. Setup your target by calling `CfTarget`'s static method `builder()` and pass-in your preferred target settings through possible chaining methods. The chaining needs to be ended with `build()` method. (See the `build()`'s description for possible chaining methods and their default values). Target's `identifier` is mandatory and represents the `Account` from which you wish to receive evaluations.

      3. Call `CfClient.sharedInstance.initialize(apiKey:configuration:target:cache:onCompletion:)` and pass in your Harness CF `apiKey`, previously created configuration object, target and an optional cache object adopting `StorageRepositoryProtocol`.

      If `cache` object is omitted, internal built-in cache will be used. You can also omit `onCompletion` parameter if you don't need initialization/authorization information.

      **Your `ff-ios-client-sdk` is now initialized. Congratulations!!!**

      Upon successful initialization and authorization, the completion block of `CfClient.sharedInstance.initialize(apiKey:configuration:target:cache:onCompletion:)` will deliver `Swift.Result<Void, CFError>` object. You can then switch through it's `.success(Void)` and `.failure(CFError)` cases and decide on further steps depending on a result.

      # initialize(apiKey:configuration:cache:onCompletion:)

      ```Swift
      let configuration = CfConfiguration.builder().setStreamEnabled(true).build()
      let target = CfTarget.builder().setIdentifier("YOUR_ACCOUNT_IDENTIFIER").build()
      CfClient.sharedInstance.initialize(apiKey: '{{apiKey}}', configuration: configuration, target: target) { (result) in
          switch result {
              case .failure(let error):
                  //Do something to gracefully handle initialization/authorization failure
              case .success:
                  //Continue to the next step after successful initialization/authorization
          }
      }
      ```

      ## Implementation

      The Public API exposes few methods that you can utilize. Please note that all of the below methods are called on `CfClient.sharedInstance`

      ```
      public func initialize(apiKey:configuration:target:cache:onCompletion:)` -> Called first as described above in the **_initialization_** section. `(Mandatory)

      public func registerEventsListener(events:onCompletion:)` -> Called in the ViewController where you would like to receive the events. `(Mandatory)

      public func destroy()

      // Fetching from cache methods

      public func stringVariation(evaluationId:defaultValue:completion:)

      public func boolVariation(evaluationId:defaultValue:completion:)

      public func numberVariation(evaluationId:defaultValue:completion:)

      public func jsonVariation(evaluationId:defaultValue:completion:)
      ```

      # registerEventsListener(events:onCompletion:)

      `events` is an array of events that you would like to subscribe to. It defaults to `*`, which means ALL events.
      In order to be notified of the SSE events sent from the server, you need to call `CfClient.sharedInstance.registerEventsListener()` method

      **NOTE**: Registering to events is usually done in `viewDidLoad()` method when events are required in only one ViewController _OR_ `viewDidAppear()` if there are more than one registration calls throughout the app, so the events could be re-registered for the currently visible ViewController.

      The completion block of this method will deliver `Swift.Result<EventType, CFError>` object. You can use `switch` statement within it's `.success(EventType)` case to distinguish which event has been received and act accordingly as in the example below or handle the error gracefully from it's `.failure(CFError)` case.

      ```Swift
      CfClient.sharedInstance.registerEventsListener() { (result) in
          switch result {
              case .failure(let error):
                  //Gracefully handle error
              case .success(let eventType):
                  switch eventType {
                      case .onPolling(let evaluations):
                          //Received all evaluation flags -> [Evaluation]
                      case .onEventListener(let evaluation):
                          //Received an evaluation flag -> Evaluation
                      case .onComplete:
                          //Received a completion event, meaning that the
                          //SSE has been disconnected
                      case .onOpen(_):
                          //SSE connection has been established and is active
                      case .onMessage(let messageObj):
                          //An empty Message object has been received
                  }
              }
          }
      }
      ```

      ## Fetching from cache methods

      The following methods can be used to fetch an Evaluation from cache, by it's known key. Completion handler delivers `Evaluation` result. If `defaultValue` is specified, it will be returned if key does not exist. If `defaultValue` is omitted, `nil` will be delivered in the completion block. Fetching is done for specified target identifier during initialize() call.

      Use appropriate method to fetch the desired Evaluation of a certain type.

      # stringVariation(forKey:defaultValue:completion:)

      ```Swift
      CfClient.sharedInstance.stringVariation("your_evaluation_id", defaultValue: String?) { (evaluation) in
          //Make use of the fetched `String` Evaluation
      }
      ```

      # boolVariation(forKey:defaultValue:completion:)

      ```Swift
      CfClient.sharedInstance.boolVariation("your_evaluation_id", defaultValue: Bool?) { (evaluation) in
          //Make use of the fetched `Bool` Evaluation
      }
      ```

      # numberVariation(forKey:defaultValue:completion:)

      ```Swift
      CfClient.sharedInstance.numberVariation("your_evaluation_id", defaultValue: Int?) { (evaluation) in
          //Make use of the fetched `Int` Evaluation
      }
      ```

      # jsonVariation(forKey:defaultValue:completion:)

      ```Swift
      CfClient.sharedInstance.jsonVariation("your_evaluation_id", defaultValue: [String:ValueType]?) { (evaluation) in
          //Make use of the fetched `[String:ValueType]` Evaluation
      }
      ```

      `ValueType` can be one of the following:

      ValueType.bool(Bool)`
      ValueType.string(String)
      ValueType.int(Int)
      ValueType.object([String:ValueType])

      ## Shutting down the SDK

      To avoid potential memory leak, when SDK is no longer needed (when the app is closed, for example), a caller should call this method.
      Also, you need to call this method when changing accounts through `CfTarget` object, in order to re-initialize and fetch Evaluations for the right account.

      ```Swift
      CfClient.sharedInstance.destroy()
      ```
    dotnet: |
      # Install

      You can reference the SDK in your project using NuGet package. The package is published to default package repository (nuget.org) and can be installed
      with the following command:
      ```
      dotnet add package ff-dotnet-server-sdk
      ```

      More information can be found <a href="https://docs.microsoft.com/en-us/nuget/quickstart/install-and-use-a-package-using-the-dotnet-cli">here</>

      After the dependency has been added, the SDK elements, primarily `CfClient`, should be accessible in the main application.

      # Use

      `CfClient` is a base class that provides all features of the SDK.

      ```
      using io.harness.cfsdk.client.dto;
      using io.harness.cfsdk.client.api;

      /**
       * Put the API Key here from your environment
       */
      String API_KEY = '{{apiKey}}';

      config = Config.Builder()
                      .SetPollingInterval(60000)
                      .SetAnalyticsEnabled()
                      .SetStreamEnabled(true)
                      .Build();

      CfClient cfClient = await CfClient.getInstance(API_KEY, config);

      /**
       * Define the target for which you would like to evaluate
       * the featureFlag
       */

      Target target = io.harness.cfsdk.client.dto.Target.builder()
                      .Name("User1") //can change with your target name
                      .Identifier("user1@example.com") //can change with your target identifier
                      .build();
      ```

      `target` represents the desired target for which we want features to be evaluated.

      # Your Harness SDK is now initialized. Congratulations!

      # Public API Methods 

      The Public API exposes a few methods that you can utilize:

      ```
      public async Task<bool> boolVariation(string key, dto.Target target, bool defaultValue)

      public async Task<string> stringVariation(string key, dto.Target target, string defaultValue)

      public async Task<double> numberVariation(string key, dto.Target target, int defaultValue)

      public async Task<JObject> jsonVariation(string key, dto.Target target, JObject defaultValue)
      ```

      # Fetch evaluation's value

      It is possible to fetch a value for a given evaluation. Evaluation is performed based on a different type. In case there
      is no evaluation with the provided id, the default value is returned.

      Use the appropriate method to fetch the desired Evaluation of a certain type.

      # Bool variation

      ```
      boolean result = await cfClient.boolVariation("sample_boolean_flag", target, false);
      ```

      # Number variation

      ```
      double result = await cfClient.numberVariation("sample_number_flag", target, 0);
      ```

      # String variation

      ```
      string result = await cfClient.stringVariation("sample_string_flag", target, "");
      ```

      # Using feature flags metrics

      The Metrics API endpoint can be changed like this:

      ```
      Config.builder()
                    .EventUrl("METRICS_API_EVENTS_URL")
                    .build();
      ```

      Otherwise, the default metrics endpoint URL will be used.
    nodejs: |
      # Install

      To use this SDK, make sure you have:

      - Installed Node.js v12 or a newer version

      Install the SDK as a dependency in your application:

      Install with npm

      ```
      npm install @harnessio/ff-nodejs-server-sdk
      ```

      Install with yarn
      ```
      yarn add @harnessio/ff-nodejs-server-sdk
      ```

      # Usage

      Create a js file called 'example.js'. Copy and paste the following complete code example into that file. 

      ```

      const { Client } = require('@harnessio/ff-nodejs-server-sdk');

      // set apiKey to your SDK API Key
      const apiKey = '{{apiKey}}';

      // set flagIdentifier to your flag identifier from the UI
      const flagIdentifier = '{{flagIdentifier}}';

      // Create Client
      const client = new Client(apiKey);

      // Create a target (different targets can receive different results based on rules.
      const target = {
        identifier: 'nodeserversdk',
        name: 'NodeServerSDK',
      };

      client.waitForInitialization()
        .then(() => client.boolVariation(flagIdentifier, target))
        .then(value => console.log(`${flagIdentifier} is ${value}`))
        .finally(() => process.exit(0))

      ```

      # Run the code sample

      Run the sample using the following command:

      ```
      node example.js
      ```

    python: |
      # Setup

      Using terminal install the SDK with:

      ```
      pip install harness-featureflags
      ```

      After the package has been added, the SDK elements, primarily CfClient should be accessible in the main application.


      # Initialization

      CfClient is a base class that provides all features of the SDK.

      Add CFClient and Target imports to your app.py

      ```
      from featureflags.client import CfClient
      from featureflags.evaluations.auth_target import Target
      ```

      Put the API Key here from your environment

      ```
      api_key = '{{apiKey}}';

      cf = CfClient(api_key);
      ```

      Define the target on which you would like to evaluate the feature flag

      ```
      target = Target(identifier="user1", name="user1")
      ```

      'target' represents the desired target for which we want features to be evaluated.


      # Your Harness SDK is now initialized. Congratulations!


      # Public API Methods

      The Public API exposes a few methods that you can utilize:

      ```
      bool_variation(key: str, target: Target, default: bool) -> bool
      ```

      ```
      string_variation(key: str, target: Target, default: str) -> str
      ```

      ```
      number_variation(key: str, target: Target, default: float) -> float
      ```

      ```
      json_variation(String key, Target target, default: dict) -> dict
      ```

      ```
      close()
      ```

      # Fetch evaluation's value
      It is possible to fetch a value for a given evaluation. Evaluation is performed based on a different type. In case there is no evaluation with provided id, the default value is returned.

      Use the appropriate method to fetch the desired Evaluation of a certain type.

      # Bool variation

      ```
      result = cf.bool_variation("sample_boolean_flag", target, False);
      ```

      # Number variation
      ```
      result = cf.number_variation("sample_number_flag", target, 0);
      ```

      # String variation
      ```
      result = cf.string_variation("sample_string_flag", target, "");
      ```

      # Using feature flags metrics

      Metrics API endpoint can be changed like this:
      ```
      cf = CfClient(api_key, with_events_url('METRICS_API_EVENTS_URL'));
      ```

      Otherwise, the default metrics endpoint URL will be used.
      ```
      https://events.ff.harness.io/api/1.0
      ```

      # Shutting down the SDK

      To avoid potential memory leak, when SDK is no longer needed (when the app is closed, for example), a caller should call this method:

      ```
      cf.close();
      ```

    php: |
      # Install

      To use this SDK, make sure you have:

      - Installed <a href="https://www.php.net/">PHP 7.4</a> or a newer version
      - Installed <a href="https://getcomposer.org/">Composer</a>

      The first step is to install the SDK as a dependency in your application using Composer.

      ```shell
      composer require harness/ff-server-sdk:0.1.0-beta
      ```

      # Usage

      Create a php file called 'example.php'. Copy and paste the following complete code example into that file.

      ```php
      <?php

      require_once __DIR__ . '/vendor/autoload.php';

      use Harness\Client;
      use OpenAPI\Client\Model\Target;

      $SDK_KEY = '{{apiKey}}';
      $FLAG_IDENTIFIER = '{{flagIdentifier}}';

      $client = new Client(
          $SDK_KEY,
          new Target(['name' => 'harness', 'identifier' => 'harness']),
          [
              'base_url' => 'https://config.ff.harness.io/api/1.0/',
              'events_url' => 'https://events.ff.harness.io/api/1.0'
          ]
      );

      $result = $client->evaluate($FLAG_IDENTIFIER, false);
      echo "Evaluation value for flag '$FLAG_IDENTIFIER' with target 'harness': " . json_encode($result);
      ```

      # Test your application 

      Open your terminal and type:

      ```shell
      php example.php
      ```

    ruby: |
      # Requirements

      Ruby 2.7 or newer (ruby --version)

      # Setup

      Install the ruby SDK using gem
      ```bash
      gem install harness-featureflags
      ```
      or by adding the following snippet to your project's `Gemfile` file:

      ```
      gem "ff-ruby-server-sdk"
      ```

      # Code Sample

      Here is a complete example that will connect to the feature flag service and report the flag value every 10 seconds until the connection is closed.  
      Any time a flag is toggled from the feature flag service you will receive the updated value.

      ```ruby
        require 'ff/ruby/server/sdk/api/config'
        require 'ff/ruby/server/sdk/dto/target'
        require 'ff/ruby/server/sdk/api/cf_client'
        require 'ff/ruby/server/sdk/api/config_builder'

        require "logger"
        require "securerandom"

        $stdout.sync = true
        logger = Logger.new $stdout

        # API Key
        apiKey = '{{apiKey}}''

        # Flag Identifier
        flagIdentifier = '{{flagIdentifier}}'

        # Create a Feature Flag Client and wait for it to initialize
        client = CfClient.instance
        client.init(apiKey, ConfigBuilder.new.logger(logger).build)
        client.wait_for_initialization

        # Create a target (different targets can get different results based on rules.  This include a custom 
        attribute 'location')
        target = Target.new("RubySDK", identifier="rubysdk", attributes={"location": "emea"})

        # Loop forever reporting the state of the flag
        loop do
          result = client.bool_variation(flagIdentifier, target, false)
          logger.info "Flag variation:  #{result}"
          sleep 10
        end

        client.close
      ```

      # Running the example

      ```bash
        #Install the deps
        gem install ff-ruby-server-sdk typhoeus

        # Run the example
        ruby ./example/getting_started.rb
      ```

    xamarinIOS: |
      The Xamarin SDK uses a Harness binding library in a NuGet package for iOS.

      To reference iOS binding library add package:
      ```
      Install-Package ff-ios-xamarin-client-sdk -Version 0.5.0
      ```
      # Usage

      Library Initialization snippet
      ```
      //create configuration
      var config = new CfConfigurationProxy
      {
          StreamEnabled = true,
          AnalyticsEnabled = true,
          ConfigUrl = "https://config.feature-flags.uat.harness.io/api/1.0",
          EventUrl = "https://event.feature-flags.uat.harness.io/api/1.0",
          StreamUrl = "https://config.feature-flags.uat.harness.io/api/1.0/stream"
      };

      // set selected identifier
      var target = new CfTargetProxy
      {
          Identifier = "target_identifier",
          Name = "target_name"
      };
      // Initialize authentication. 
      CfClientProxy.Shared.InitializeWithApiKey( "{{apiKey}}", config, target);
      ```
      Subscribing on receiving library events.

      ```
      using System;
      using ff_ios_client_sdk_proxy;

      public class CfListener : CfClientDelegate
      {

          public CfListener()
          {
              // Subscribe on getting events from native iOS library
              CfClientProxy.Shared.Delegate = this;
          }
          // Received in case of error
          public override void OnErrorWithError(CfErrorProxy error){}

          // Contains array with flags received each pooling interval
          public override void OnPollingEventReceivedWithEvaluations(CxEvaluation[] evaluations){}

          // Event when flag value is changed
          public override void OnStreamEventReceivedWithEvaluation(CxEvaluation evaluation){}

          // Message received from library event
          public override void OnMessageReceivedWithMessage(CxMessage message){}

          // On Stream opened event
          public override void OnStreamOpened() {}
          
          // On Stream closed event
          public override void OnStreamCompleted() {}
      }
      ```
    xamarinAndroid: |
      Xamarin client uses Harness Binding library NuGet package for iOS and Android application.

      To reference Android binding library add package:
      ```
      Install-Package ff-android-xamarin-client-sdk -Version 0.5.4
      ```
      # Usage

      Library Initialization snippet

      ```
      CfConfiguration configuration = new CfConfiguration.Builder()
          .EnableStream(true)
          .EnableAnalytics(true)
          .EventUrl("https://event.feature-flags.uat.harness.io/api/1.0")
          .StreamUrl("https://config.feature-flags.uat.harness.io/api/1.0/stream")
          .BaseUrl("https://config.feature-flags.uat.harness.io/api/1.0")
          .Build();

      Target target = new Target()
          .InvokeName(account)
          .InvokeIdentifier(account);

      // Initialize authentication. Listener object should implement IAuthCallback interface.
      CfClient.Instance.Initialize(this.context, "{{apiKey}}", configuration, target, listener);
      ```
      Subscribing on receiving library events.

      ```
      using System;
      using System.Linq;
      using IO.Harness.Cfsdk.Cloud.Events;
      using IO.Harness.Cfsdk.Cloud.Model;
      using IO.Harness.Cfsdk.Cloud.Oksse;
      using IO.Harness.Cfsdk.Cloud.Oksse.Model;
      using Java.Interop;
      using Java.Util;
      using IO.Harness.Cfsdk;

      public class CfListener : Java.Lang.Object, IAuthCallback, IEventsListener
      {


          public CfListener()
          {
              // Subscribe on getting events from native Android library
              CfClient.Instance.RegisterEventsListener(this);
          }
          public void AuthorizationSuccess(AuthInfo p0, AuthResult p1)
          {
              // p1.Success contains status of authorization
              // In case of error p1.Error contains error message
          }
          public void OnEventReceived(StatusEvent p0)
          {
              var eventType = p0.EventType;
              if(StatusEvent.EVENT_TYPE.SseStart == eventType)
              {
                  // Stream started
              }
              else if( StatusEvent.EVENT_TYPE.SseEnd == eventType)
              {
                  // Stream Ended
              }
              else if (StatusEvent.EVENT_TYPE.EvaluationChange == eventType)
              {
                  Java.Lang.Object payload = p0.ExtractPayload();
                  var ev = payload as IO.Harness.Cfsdk.Cloud.Core.Model.Evaluation;
                  // Flag changed event
              }
              else if (StatusEvent.EVENT_TYPE.EvaluationReload == eventType)
              {
                  Java.Lang.Object payload = p0.ExtractPayload();
                  var t = payload.JavaCast<ArrayList>();
                  var arr = t.ToEnumerable<IO.Harness.Cfsdk.Cloud.Core.Model.Evaluation>().ToArray();
                  // Each pulling interval we will receive array of available flags.
              }
          }
      }
      ```

    flutter: |
      # Requirements

      To use this SDK, make sure you've:

      Installed <a href="https://docs.flutter.dev/get-started/install">Flutter SDK >= 2.10.4</a>
      For iOS Apps <a href="https://docs.flutter.dev/get-started/install/macos#install-xcode">Xcode</a>
      For Android Apps <a href="https://developer.android.com/studio?gclid=CjwKCAjwp7eUBhBeEiwAZbHwkRqdhQkk6wroJeWGu0uGWjW9Ue3hFXc4SuB6lwYU4LOZiZ-MQ4p57BoCvF0QAvD_BwE&gclsrc=aw.ds">Android Studio</a> or the <a href="https://developer.android.com/studio">Android SDK</a> for CLI only

      You can use Flutter doctor to verify you have the necessary prerequisites
      ```shell
      flutter doctor
      ```
      # Setup

      To add the SDK to your own project run
      ```Dart
      ff_flutter_client_sdk: ^1.0.4
      ```

      Then, you may import package to your project
      ```Dart
      import 'package:ff_flutter_client_sdk/CfClient.dart';
      ```

      # Code Sample

      The following is a complete code example that you can use to test {{flagIdentifier}} you have just created on the Harness Platform. When you run the code it will:

      1. Connect to the FF service.
      2. Report the value of the Flag every 10 seconds until the connection is closed. Every time {{flagIdentifier}} is toggled on 
         or off on the Harness Platform, the updated value is reported.
      3. Close the SDK.

      To use this sample, copy it into your project.

      ```Dart
      // @dart=2.9
      import 'dart:async';
      import 'package:flutter/material.dart';
      import 'package:ff_flutter_client_sdk/CfClient.dart';

      // The SDK API Key to use for authentication.  
      const apiKey = '{{apiKey}}'

      // The flag identifier
      const flagIdentifier = '{{flagIdentifier}}';

      void main() => runApp(MyApp());

      // A simple StatelessWidget that fetches the latest value from the FF Service.
      // Everytime it receives an update the value of the flag is updated.
      class MyApp extends StatelessWidget {
        @override
        Widget build(BuildContext context) {
          return MaterialApp(title: 'Harness Flutter SDK Getting Started', home: FlagState());
        }
      }

      class FlagState extends StatefulWidget {
        @override
        _FlagState createState() => _FlagState();
      }

      class _FlagState extends State<FlagState> {
        bool _flagValue = false;

        @override
        void initState() {
          super.initState();

          // Create Default Configuration for the SDK.  We can use this to disable streaming,
          // change the URL the client connects to etc
          var conf = CfConfigurationBuilder().build();

          // Create a target (different targets can get different results based on rules.  This include a custom attribute 'location')
          var target = CfTargetBuilder().setIdentifier("fluttersdk").setName("FlutterSDK").build();

          // Init the default instance of the Feature Flag Client
            CfClient.getInstance().initialize(apiKey, conf, target)
              .then((value){
            if (value.success) {
              print("Successfully initialized client");

              // Evaluate flag and set initial state
              CfClient.getInstance().boolVariation(flagIdentifier, false).then((value) {
                print("$flagIdentifier: $value");
                setState(() {
                  _flagValue = value;
                });
              });

              // Setup Event Handler
              CfClient.getInstance().registerEventsListener((data, eventType) {
                print("received event: ${eventType.toString()} with Data: ${data.toString()}");
                switch (eventType) {
                      case EventType.EVALUATION_CHANGE:
                          String flag = (data as EvaluationResponse).flag;
                          dynamic value = (data as EvaluationResponse).value;
                          // If the change concerns the flag we care about, then update the state
                          if ( flag == flagIdentifier ) {
                              setState(() {
                                  _flagValue = value.toLowerCase() == 'true';
                              });
                          }
                          break;
                  }
                });
              }
            });
          }
        
          @override
          Widget build(BuildContext context) {
            return Scaffold(
              appBar: AppBar(
                title: const Text('Harness Flutter SDK Getting Started'),
            ),
            body: Container(
              child: Center(
                child: new Text("${flagIdentifier} : ${_flagValue}", style: TextStyle(fontSize: 25)),
              ),
            ),
          );
        }
      } 
      ```
      # Running the example

      If you want to run the getting started example, then you can use flutter to on the cli. You just need to have either an Android or iOS emulator running.

      To start an android emulator run (replace @Pixel_4.4_API_32 with your own device id)
      ```
      $ANDROID_SDK/emulator/emulator @Pixel_4.4_API_32
      ```

      or for iOS run

      ```shell
      open -a simulator
      ```

      Confirm you have an iOS or Android device with
      ```shell
      flutter devices
      2 connected devices:

      sdk gphone64 x86 64 (mobile) • emulator-5554                        • android-x64    • Android 12 (API 32) (emulator)
      iPhone 13 (mobile)           • 425E99F8-702F-4E15-8BBE-B792BF15ED88 • ios            • com.apple.CoreSimulator.SimRuntime.iOS-15-5 (simulator)
      ```

      # Build the project

      Using the SDK API key, and a device ID from above you can build and install your app
      on a emulator
      ```shell
      flutter pub get
      flutter run -d <device id>
      ```

      The app should show the configured flags current value. As you toggle the flag in the Harness UI you will see the value update.

    react: |
      # Quickstart

      To follow along with our test code sample, make sure you've:

      - Installed Node.js v12 or a newer version
      - Installed React.js v16.7 or a newer version

      # Install

      The first step is to install the FF SDK as a dependency in your application. To install using npm, use:
      ```
      npm install @harnessio/ff-react-client-sdk
      ```

      Or to install with yarn, use:
      ```
      yarn add @harnessio/ff-react-client-sdk
      ```

      # Usage

      Create a new React project with a file called 'index.js'. Copy and paste the following complete code example into that file. 

      ```
      import React from 'react'
      import ReactDOM from 'react-dom'

      import {
        FFContextProvider,
        useFeatureFlag,
        useFeatureFlags
      } from '@harnessio/ff-react-client-sdk'

      ReactDOM.render(<App />, document.querySelector('#react-root'))

      function App() {
        const reactTarget = { name: 'ReactClientSDK', identifier: 'reactclientsdk' }
        const sdkApiKey = '{{apiKey}}'
        
        return (
          <FFContextProvider apiKey={sdkApiKey} target={reactTarget}>
            <SingleFeatureFlag />
            <MultipleFeatureFlags />
          </FFContextProvider>
        )
      }

      function SingleFeatureFlag() {
        const flagValue = useFeatureFlag('{{flagIdentifier}}')

        return (
          <p>The value of {{flagIdentifier}} is {JSON.stringify(flagValue)}</p>
        )
      }

      function MultipleFeatureFlags() {
        const flags = useFeatureFlags()

        return (
          <>
            <p>Here are all our flags:</p>
            <pre>{JSON.stringify(flags, null, 2)}</pre>
          </>
        )
      }
      ```

    reactNative: |
      # Requirements

      <a href="https://reactjs.org/">React 16</a> or newer<br>
      <a href="https://reactnative.dev/docs/environment-setup">React Native 0.63</a> or newer<br>

      # Setup

      Install the React Native SDK by adding it to your project's `package.json` file:
      ```
      "@harnessio/ff-react-native-client-sdk": "^1.0.2"
      ```

      Or install using npm:
      ```shell
      $ npm install --save @harnessio/ff-react-native-client-sdk
      ```

      For iOS, run the following commands from project root folder
      ```shell
      $ cd ios
      $ pod install
      ```
      # Code Sample

      The following is a complete code example with a fresh React-Native project that you can use to test the {{flagIdentifier}} Flag you 
      created on the Harness Platform. When you run the code it will:

      Connect to the FF service.
      Report the value of the Flag in the mobile simulator. 

      Install expo.
      ```shell
      npm install -g expo-cli
      ```

      Using Expo, initialize a project. For the best experience, select `Minimal` as the template when prompted.
      ```shell
      expo init SampleProject
      cd SampleProject
      ```

      Add the Harness React Native SDK to the `package.json` under the `dependencies` section.
      ```json
      "@harnessio/ff-react-native-client-sdk": "^1.0.2"
      ```

      Replace the code in `App.js` with the following Sample Code, and replace `apiKey` with your Client SDK Key.
      ```javascript

      import cfClientInstance, {CfConfiguration, CfTarget} from '@harnessio/ff-react-native-client-sdk';
          
      export default function App() {
        const flagIdentifier = '{{flagIdentifier}}';

        const [client, setClient] = useState(null);
        const [flagValue, setFlagValue] = useState(null);

        async function initializeClient() {
          let cfClient = cfClientInstance;
          let cfConfig = new CfConfiguration();
          cfConfig.streamEnabled = true;

          const cfTarget = new CfTarget();
          cfTarget.identifier = 'Harness RN Sample App'

          const apiKey = "your-client-sdk-key";

          try {
            await cfClientInstance.initialize(apiKey, cfConfig, cfTarget);
          } catch (err) {
            console.log(err);
          }
          setClient(cfClient);
        }
        
        async function evalFlag() {
          let res = await client.boolVariation(flagIdentifier, false);
          setFlagValue(res.value);
        }

        useEffect(() => {
          if (client == null) {
            initializeClient();
          } else {
            evalFlag();
          }
        });

        return (
          <View style={styles.container}>
            <Text>
              Feature flag '{{flagIdentifier}}' is {JSON.stringify(flagValue)}
            </Text>
          </View>
        );
      }

      const styles = StyleSheet.create({
        container: {
          flex: 1,
          backgroundColor: '#fff',
          alignItems: 'center',
          justifyContent: 'center',
        },
      });
      ```
      # Running the example

      Start your desired simulator, either Android or iOS and run
      ```shell
      yarn run ios
      ```
      or
      ```shell
      expo run:ios
      ```
      Replace `ios` above with `android` if running on an Android simulator.

learnMore: '{{ $.cf.homepage.learnMore }}'
cfTrialHomePage:
  forDevelopers:
    title: For Developers
    createFlag: Create your first flag in 15 minutes
    shipCode: Ship code as soon as it's ready without merge conflicts
    realTime: Real-time user targeting. <br>No complex manual config management
  forDevOps:
    title: For DevOps
    automatedFeature: Automated feature release governance
    avoidRollbacks: Avoid production rollbacks
    scaleManagement: Scale feature management org-wide
  startFreePlanBtn: Start Free Plan
  featureFlagsDescription: Ship more features and reduce risk with Feature Flags!
  dontCode:
    title: Don't write code?
    description: If writing code and installing SDK's isn't your thing, you can have an engineer on your team get you started in 15 minutes
    inviteDeveloper: Invite a Developer
  startTrial:
    description: Take your feature release processes to the next level using our Harness Feature Flags.
    startBtn:
      description: Start 14 day FF Enterprise trial
percentageRollout:
  toTargetGroup: 'To Target Group:'
  assignToVariation: '% needs to be assigned to a Variation.'
