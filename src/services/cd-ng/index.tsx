/*
 * Copyright 2023 Harness Inc. All rights reserved.
 * Use of this source code is governed by the PolyForm Shield 1.0.0 license
 * that can be found in the licenses directory at the root of this repository, also available at
 * https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt.
 */

/* Generated by restful-react */

import React from 'react'
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'

import { getConfig, getUsingFetch, mutateUsingFetch, GetUsingFetchProps, MutateUsingFetchProps } from '../config'
export const SPEC_VERSION = '2.0'
export interface ACLAggregateFilter {
  resourceGroupIdentifiers?: string[]
  roleIdentifiers?: string[]
}

export type ACRStepInfo = StepSpecType & {
  baseImageConnectorRefs?: string[]
  buildArgs?: {
    [key: string]: string
  }
  cacheFrom?: string[]
  cacheTo?: string
  caching?: boolean
  connectorRef: string
  context?: string
  dockerfile?: string
  labels?: {
    [key: string]: string
  }
  optimize?: boolean
  remoteCacheImage?: string
  repository: string
  resources?: ContainerResource
  runAsUser?: number
  subscriptionId?: string
  tags: string[]
  target?: string
  version?: string
}

export type AMIArtifactConfig = ArtifactConfig & {
  connectorRef: string
  filters?: AMIFilter[]
  region: string
  tags?: AMITag[]
  version?: string
  versionRegex?: string
}

export type AMIArtifactSummary = ArtifactSummary & {
  version?: string
}

export interface AMIFilter {
  name?: string
  value?: string
}

export interface AMIRequestBody {
  filters?: AMIFilter[]
  runtimeInputYaml?: string
  tags?: AMITag[]
}

export interface AMITag {
  name?: string
  value?: string
}

export interface AMITagObject {
  tagName?: string
}

export type AWSIAMRoleCredentialSpec = TerraformProviderCredentialSpec & {
  connectorRef: string
  region?: string
  roleArn?: string
}

export type AbortFailureActionConfig = FailureStrategyActionConfig & {
  type: 'Abort'
}

export interface AccessControlCheckError {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'ACCOUNT_MIGRATED_TO_NEXT_GEN'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'SCM_REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_INTERRUPT_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SPOTNIST_REST_EXCEPTION'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'MISSING_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
    | 'ABORT_ALL_ALREADY_NG'
  correlationId?: string
  detailedMessage?: string
  failedPermissionChecks?: PermissionCheck[]
  message?: string
  metadata?: ErrorMetadataDTO
  responseMessages?: ResponseMessage[]
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface Account {
  accountActivelyUsed?: boolean
  accountEvents?: AccountEvent[]
  accountName: string
  accountPreferences?: AccountPreferences
  appId: string
  authenticationMechanism?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
  cannyUsernameAbbreviationEnabled?: boolean
  ceAutoCollectK8sEvents?: boolean
  ceLicenseInfo?: CeLicenseInfo
  cloudCostEnabled?: boolean
  companyName: string
  createdAt?: number
  createdBy?: EmbeddedUser
  createdFromNG?: boolean
  crossGenerationAccessEnabled?: boolean
  dataRetentionDurationMs?: number
  defaultExperience?: 'NG' | 'CG'
  defaults?: {
    [key: string]: string
  }
  delegateConfiguration?: DelegateConfiguration
  encryption?: EncryptionInterface
  forImport?: boolean
  globalDelegateAccount?: boolean
  harnessSupportAccessAllowed?: boolean
  immutableDelegateEnabled?: boolean
  importantDelegateTaskLimit?: number
  lastUpdatedAt: number
  lastUpdatedBy?: EmbeddedUser
  licenseId?: string
  licenseInfo?: LicenseInfo
  localEncryptionEnabled?: boolean
  migratedToClusterUrl?: string
  nextGenEnabled?: boolean
  oauthEnabled?: boolean
  optionalDelegateTaskLimit?: number
  povAccount?: boolean
  productLed?: boolean
  publicAccessEnabled?: boolean
  ringName?: string
  serviceAccountConfig?: ServiceAccountConfig
  serviceGuardLimit?: number
  sessionTimeOutInMinutes?: number
  smpAccount?: boolean
  subdomainUrl?: string
  techStacks?: TechStack[]
  trialSignupOptions?: TrialSignupOptions
  trustLevel?: number
  twoFactorAdminEnforced?: boolean
  uuid: string
  whitelistedDomains?: string[]
}

export interface AccountCreditCardValidationResponse {
  hasAtleastOneValidCreditCard?: boolean
}

export interface AccountDTO {
  authenticationMechanism?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
  cannyUsernameAbbreviationEnabled?: boolean
  cluster?: string
  companyName?: string
  createdAt?: number
  crossGenerationAccessEnabled?: boolean
  defaultExperience?: 'NG' | 'CG'
  harnessSupportAccessAllowed?: boolean
  identifier?: string
  name?: string
  nextGenEnabled?: boolean
  productLed?: boolean
  publicAccessEnabled?: boolean
  ringName?: string
  serviceAccountConfig?: ServiceAccountConfig
  sessionTimeoutInMinutes?: number
  twoFactorAdminEnforced?: boolean
}

export interface AccountEvent {
  accountEventType?:
    | 'APP_CREATED'
    | 'SERVICE_CREATED'
    | 'ENV_CREATED'
    | 'WORKFLOW_CREATED'
    | 'WORKFLOW_DEPLOYED'
    | 'PIPELINE_DEPLOYED'
    | 'DELEGATE_INSTALLED'
    | 'CLOUD_PROVIDER_CREATED'
    | 'ARTIFACT_REPO_CREATED'
    | 'PIPELINE_CREATED'
    | 'ARTIFACT_STREAM_ADDED'
    | 'INFRA_MAPPING_ADDED'
    | 'INFRA_DEFINITION_ADDED'
    | 'CUSTOM'
  category?: string
  customMsg?: string
  properties?: {
    [key: string]: string
  }
}

export interface AccountLevelOverrideMigrationResponseDTO {
  accountId?: string
  environmentsInfo?: SingleEnvMigrationResponse[]
  envsMigrationSuccessful?: boolean
  migratedEnvironmentsCount?: number
  migratedServiceOverridesCount?: number
  overridesMigrationSuccessFul?: boolean
  serviceOverridesInfo?: SingleServiceOverrideMigrationResponse[]
  targetEnvironmentsCount?: number
  totalServiceOverridesCount?: number
}

export interface AccountLevelOverrideV2SettingsUpdateResponseDTO {
  accountId?: string
  settingResponseDTO?: SettingResponseDTO[]
  settingsUpdateSuccessFul?: boolean
}

export interface AccountLicenseDTO {
  accountId?: string
  allModuleLicenses?: {
    [key: string]: ModuleLicenseDTO[]
  }
  createdAt?: number
  lastUpdatedAt?: number
  moduleLicenses?: {
    [key: string]: ModuleLicenseDTO
  }
}

export interface AccountPermissions {
  permissions?: (
    | 'ACCOUNT'
    | 'LOGGED_IN'
    | 'DELEGATE'
    | 'NONE'
    | 'APP'
    | 'ALL_APP_ENTITIES'
    | 'ENV'
    | 'SERVICE'
    | 'WORKFLOW'
    | 'PIPELINE'
    | 'DEPLOYMENT'
    | 'APPLICATION_CREATE_DELETE'
    | 'USER_PERMISSION_MANAGEMENT'
    | 'ACCOUNT_MANAGEMENT'
    | 'PROVISIONER'
    | 'TEMPLATE_MANAGEMENT'
    | 'APP_TEMPLATE'
    | 'USER_PERMISSION_READ'
    | 'AUDIT_VIEWER'
    | 'TAG_MANAGEMENT'
    | 'CE_ADMIN'
    | 'CE_VIEWER'
    | 'MANAGE_CLOUD_PROVIDERS'
    | 'MANAGE_CONNECTORS'
    | 'MANAGE_APPLICATIONS'
    | 'MANAGE_APPLICATION_STACKS'
    | 'MANAGE_DELEGATES'
    | 'MANAGE_ALERT_NOTIFICATION_RULES'
    | 'MANAGE_DELEGATE_PROFILES'
    | 'MANAGE_CONFIG_AS_CODE'
    | 'MANAGE_SECRETS'
    | 'MANAGE_SECRET_MANAGERS'
    | 'MANAGE_SSH_AND_WINRM'
    | 'MANAGE_AUTHENTICATION_SETTINGS'
    | 'MANAGE_USER_AND_USER_GROUPS_AND_API_KEYS'
    | 'VIEW_USER_AND_USER_GROUPS_AND_API_KEYS'
    | 'MANAGE_IP_WHITELIST'
    | 'MANAGE_IP_WHITELISTING'
    | 'MANAGE_DEPLOYMENT_FREEZES'
    | 'ALLOW_DEPLOYMENTS_DURING_FREEZE'
    | 'MANAGE_PIPELINE_GOVERNANCE_STANDARDS'
    | 'MANAGE_API_KEYS'
    | 'MANAGE_TAGS'
    | 'MANAGE_ACCOUNT_DEFAULTS'
    | 'MANAGE_CUSTOM_DASHBOARDS'
    | 'CREATE_CUSTOM_DASHBOARDS'
    | 'MANAGE_RESTRICTED_ACCESS'
    | 'HIDE_NEXTGEN_BUTTON'
  )[]
}

export interface AccountPreferences {
  delegateSecretsCacheTTLInHours?: number
}

export interface AccountResourcesDTO {
  connectorsCount?: number
  delegatesCount?: number
  secretsCount?: number
  templatesCount?: number
}

export interface AccountSettingConfig {
  [key: string]: any
}

export interface AccountSettingResponse {
  accountSettings?: AccountSettings
  createdAt?: number
  lastModifiedAt?: number
}

export interface AccountSettings {
  accountIdentifier?: string
  config: AccountSettingConfig
  orgIdentifier?: string
  projectIdentifier?: string
  type: 'Connector'
}

export interface AccountSummaryResponseDto {
  deploymentPipelines?: number
  errorSummary?: string
  infrastructures?: string[]
  orgs?: number
  pipelinesDetails?: PipelineDetailsDto[]
  pipelinesWithGitXDisabled?: number
  pipelinesWithGitXEnabled?: number
  pipelinesWithServiceV2?: number
  projectWithServiceV1?: number
  projects?: number
  serviceDefinitions?: string[]
  v1Services?: number
  v2Services?: number
}

export type AcrArtifactConfig = ArtifactConfig & {
  connectorRef: string
  digest?: string
  registry: string
  repository: string
  subscriptionId: string
  tag?: string
  tagRegex?: string
}

export type AcrArtifactSummary = ArtifactSummary & {
  imagePath?: string
  tag?: string
}

export interface AcrBuildDetailsDTO {
  buildUrl?: string
  labels?: {
    [key: string]: string
  }
  metadata?: {
    [key: string]: string
  }
  repository?: string
  tag?: string
}

export interface AcrRegistriesDTO {
  registries?: AcrRegistryDTO[]
}

export interface AcrRegistryDTO {
  registry: string
}

export interface AcrRepositoriesDTO {
  repositories?: AcrRepositoryDTO[]
}

export interface AcrRepositoryDTO {
  repository: string
}

export interface AcrRequestDTO {
  runtimeInputYaml?: string
  tag?: string
  tagRegex?: string
  tagsList?: string[]
}

export interface AcrResponseDTO {
  buildDetailsList?: AcrBuildDetailsDTO[]
}

export type ActionStepInfo = StepSpecType & {
  env?: ParameterFieldMapStringString
  uses: string
  version?: string
  with?: ParameterFieldMapStringString
}

export type ActionStepInfoV1 = StepSpecType & {
  envs?: ParameterFieldMapStringString
  outputs?: string[]
  resources?: ContainerResource
  uses: string
  version?: string
  with?: ParameterFieldMapStringString
}

export interface ActiveProjectsCountDTO {
  count?: number
}

export interface ActiveServiceDTO {
  accountIdentifier?: string
  identifier: string
  instanceCount?: number
  lastDeployed?: number
  licensesConsumed?: number
  module?: string
  name?: string
  orgIdentifier?: string
  orgName?: string
  projectIdentifier?: string
  projectName?: string
  timestamp?: number
}

export interface ActiveServiceInstanceSummary {
  changeRate?: number
  countDetails?: InstanceCountDetailsByEnvTypeBase
}

export interface ActiveServiceInstanceSummaryV2 {
  changeRate?: ChangeRate
  countDetails?: InstanceCountDetailsByEnvTypeBase
}

export interface ActiveServicesFilterParams {
  orgIdentifier?: string
  projectIdentifier?: string
  serviceIdentifier?: string
}

export interface Activity {
  accountIdentifier?: string
  activityStatus: 'SUCCESS' | 'FAILED'
  activityTime: number
  description?: string
  detail?: ActivityDetail
  referredEntity?: EntityDetail
  type: 'CONNECTIVITY_CHECK' | 'ENTITY_USAGE' | 'ENTITY_CREATION' | 'ENTITY_UPDATE'
}

export interface ActivityDetail {
  [key: string]: any
}

export interface ActivitySummary {
  endTime?: number
  failedActivitiesCount?: number
  heartBeatFailuresCount?: number
  startTime?: number
  successfulActivitiesCount?: number
}

export type AddOperation = PatchOperation & {
  value?: JsonNode
}

export interface AddUsers {
  emails: string[]
  roleBindings?: RoleBinding[]
  userGroups?: string[]
}

export interface AddUsersResponse {
  addUserResponseMap?: {
    [key: string]:
      | 'USER_INVITED_SUCCESSFULLY'
      | 'USER_ADDED_SUCCESSFULLY'
      | 'USER_ALREADY_ADDED'
      | 'USER_ALREADY_INVITED'
      | 'USER_INVITE_NOT_REQUIRED'
      | 'FAIL'
  }
}

export interface AdditionalMetadata {
  values?: {
    [key: string]: string
  }
}

export interface AddressDto {
  city: string
  country: string
  line1: string
  line2?: string
  postalCode: string
  state: string
}

export interface AgentApplicationTargets {
  agentId: string
  applicationName: string
}

export interface AgentMtlsEndpointDetails {
  accountId?: string
  caCertificates?: string
  fqdn?: string
  mode?: 'LOOSE' | 'STRICT'
  uuid?: string
}

export interface AgentMtlsEndpointRequest {
  caCertificates?: string
  domainPrefix?: string
  mode?: 'LOOSE' | 'STRICT'
}

export type AllHostsFilter = HostFilterSpec & { [key: string]: any }

export type AllowAllFilter = FilterSpec & { [key: string]: any }

export type AmazonS3ArtifactConfig = ArtifactConfig & {
  bucketName: string
  connectorRef: string
  fileFilter?: string
  filePath?: string
  filePathRegex?: string
  region?: string
}

export interface ApiKeyAggregateDTO {
  apiKey: ApiKeyDTO
  createdAt: number
  lastModifiedAt: number
  tokensCount?: number
}

export interface ApiKeyDTO {
  accountIdentifier: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  defaultTimeToExpireToken?: number
  description?: string
  identifier: string
  name: string
  orgIdentifier?: string
  parentIdentifier: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
}

export type ApiKeyPrincipal = Principal & {}

export type AppDynamicsConnectorDTO = ConnectorConfigDTO & {
  accountname: string
  authType?: 'UsernamePassword' | 'ApiClientToken'
  clientId?: string
  clientSecretRef?: string
  controllerUrl: string
  delegateSelectors?: string[]
  passwordRef?: string
  username?: string
}

export type AppFilter = Filter & {
  filterType?: string
}

export interface AppPermission {
  actions?: (
    | 'ALL'
    | 'CREATE'
    | 'READ'
    | 'UPDATE'
    | 'DELETE'
    | 'EXECUTE'
    | 'EXECUTE_WORKFLOW'
    | 'EXECUTE_PIPELINE'
    | 'EXECUTE_WORKFLOW_ROLLBACK'
    | 'ABORT_WORKFLOW'
    | 'DEFAULT'
  )[]
  appFilter?: AppFilter
  entityFilter?: Filter
  permissionType?:
    | 'ACCOUNT'
    | 'LOGGED_IN'
    | 'DELEGATE'
    | 'NONE'
    | 'APP'
    | 'ALL_APP_ENTITIES'
    | 'ENV'
    | 'SERVICE'
    | 'WORKFLOW'
    | 'PIPELINE'
    | 'DEPLOYMENT'
    | 'APPLICATION_CREATE_DELETE'
    | 'USER_PERMISSION_MANAGEMENT'
    | 'ACCOUNT_MANAGEMENT'
    | 'PROVISIONER'
    | 'TEMPLATE_MANAGEMENT'
    | 'APP_TEMPLATE'
    | 'USER_PERMISSION_READ'
    | 'AUDIT_VIEWER'
    | 'TAG_MANAGEMENT'
    | 'CE_ADMIN'
    | 'CE_VIEWER'
    | 'MANAGE_CLOUD_PROVIDERS'
    | 'MANAGE_CONNECTORS'
    | 'MANAGE_APPLICATIONS'
    | 'MANAGE_APPLICATION_STACKS'
    | 'MANAGE_DELEGATES'
    | 'MANAGE_ALERT_NOTIFICATION_RULES'
    | 'MANAGE_DELEGATE_PROFILES'
    | 'MANAGE_CONFIG_AS_CODE'
    | 'MANAGE_SECRETS'
    | 'MANAGE_SECRET_MANAGERS'
    | 'MANAGE_SSH_AND_WINRM'
    | 'MANAGE_AUTHENTICATION_SETTINGS'
    | 'MANAGE_USER_AND_USER_GROUPS_AND_API_KEYS'
    | 'VIEW_USER_AND_USER_GROUPS_AND_API_KEYS'
    | 'MANAGE_IP_WHITELIST'
    | 'MANAGE_IP_WHITELISTING'
    | 'MANAGE_DEPLOYMENT_FREEZES'
    | 'ALLOW_DEPLOYMENTS_DURING_FREEZE'
    | 'MANAGE_PIPELINE_GOVERNANCE_STANDARDS'
    | 'MANAGE_API_KEYS'
    | 'MANAGE_TAGS'
    | 'MANAGE_ACCOUNT_DEFAULTS'
    | 'MANAGE_CUSTOM_DASHBOARDS'
    | 'CREATE_CUSTOM_DASHBOARDS'
    | 'MANAGE_RESTRICTED_ACCESS'
    | 'HIDE_NEXTGEN_BUTTON'
}

export interface Application {
  agentIdentifier?: string
  autoSyncEnabled?: boolean
  healthStatus?: string
  identifier?: string
  name?: string
  revision?: string
  syncError?: string
  syncMessage?: string
  syncStatus?: string
  url?: string
}

export interface ApplicationSettingsConfiguration {
  metadata?: string
  store: StoreConfigWrapper
}

export type ArtifactBundleStore = StoreConfig & {
  artifactBundleType: 'ZIP' | 'TAR' | 'TAR_GZIP'
  deployableUnitPath: string
  manifestPath: string
  metadata?: string
}

export interface ArtifactConfig {
  [key: string]: any
}

export interface ArtifactCorrelationDetails {
  image?: string
}

export interface ArtifactDeploymentDetail {
  artifact?: string
  chartVersion?: string
  envId?: string
  envName?: string
  lastDeployedAt?: number
  lastPipelineExecutionId?: string
  pipelineId?: string
}

export interface ArtifactFileMetadata {
  fileName?: string
  url?: string
}

export interface ArtifactInstanceDetail {
  artifact?: string
  environmentGroupInstanceDetails: EnvironmentGroupInstanceDetails
}

export interface ArtifactInstanceDetails {
  artifactInstanceDetails: ArtifactInstanceDetail[]
}

export interface ArtifactListConfig {
  primary?: PrimaryArtifact
  sidecars?: SidecarArtifactWrapper[]
}

export interface ArtifactOverrideSetWrapper {
  overrideSet?: ArtifactOverrideSets
}

export interface ArtifactOverrideSets {
  artifacts?: ArtifactListConfig
  identifier?: string
}

export interface ArtifactSource {
  identifier: string
  metadata?: string
  name?: string
  spec?: ArtifactConfig
  template?: TemplateLinkConfig
  type?:
    | 'DockerRegistry'
    | 'Gcr'
    | 'Ecr'
    | 'Nexus3Registry'
    | 'Nexus2Registry'
    | 'ArtifactoryRegistry'
    | 'CustomArtifact'
    | 'Acr'
    | 'Jenkins'
    | 'AmazonS3'
    | 'GoogleArtifactRegistry'
    | 'GithubPackageRegistry'
    | 'AzureArtifacts'
    | 'AmazonMachineImage'
    | 'Bamboo'
    | 'GoogleCloudStorage'
    | 'GoogleCloudSource'
}

export interface ArtifactSourceConfig {
  spec?: ArtifactConfig
  type?:
    | 'DockerRegistry'
    | 'Gcr'
    | 'Ecr'
    | 'Nexus3Registry'
    | 'Nexus2Registry'
    | 'ArtifactoryRegistry'
    | 'CustomArtifact'
    | 'Acr'
    | 'Jenkins'
    | 'AmazonS3'
    | 'GoogleArtifactRegistry'
    | 'GithubPackageRegistry'
    | 'AzureArtifacts'
    | 'AmazonMachineImage'
    | 'Bamboo'
    | 'GoogleCloudStorage'
    | 'GoogleCloudSource'
}

export interface ArtifactSourceYamlRequest {
  entityYaml: string
}

export interface ArtifactSourcesResponseDTO {
  sourceIdentifierToSourceInputMap?: {
    [key: string]: string
  }
  sourceIdentifiers?: string[]
}

export interface ArtifactSummary {
  artifactIdentity?: ArtifactCorrelationDetails
  displayName?: string
  type?: string
}

export interface ArtifactoryArtifactBuildDetailsDTO {
  artifactName?: string
  artifactPath?: string
}

export type ArtifactoryArtifactSummary = ArtifactSummary & {
  artifactPath?: string
  tag?: string
}

export interface ArtifactoryAuthCredentials {
  [key: string]: any
}

export interface ArtifactoryAuthentication {
  spec?: ArtifactoryAuthCredentials
  type: 'UsernamePassword' | 'Anonymous'
}

export interface ArtifactoryBuildDetailsDTO {
  [key: string]: any
}

export type ArtifactoryConnector = ConnectorConfigDTO & {
  artifactoryServerUrl: string
  auth?: ArtifactoryAuthentication
  delegateSelectors?: string[]
  executeOnDelegate?: boolean
}

export type ArtifactoryGenericArtifactSummary = ArtifactSummary & {
  artifactDirectory?: string
  artifactPath?: string
  tag?: string
}

export interface ArtifactoryImagePath {
  imagePath?: string
}

export interface ArtifactoryImagePathsDTO {
  imagePaths?: ArtifactoryImagePath[]
}

export type ArtifactoryRegistryArtifactConfig = ArtifactConfig & {
  artifactDirectory?: string
  artifactFilter?: string
  artifactPath?: string
  artifactPathFilter?: string
  connectorRef: string
  digest?: string
  repository: string
  repositoryFormat: 'docker' | 'generic'
  repositoryUrl?: string
  tag?: string
  tagRegex?: string
}

export interface ArtifactoryRepoDetailsDTO {
  repositories?: {
    [key: string]: string
  }
}

export interface ArtifactoryRequestDTO {
  runtimeInputYaml?: string
  tag?: string
  tagRegex?: string
}

export interface ArtifactoryResponseDTO {
  buildDetailsList?: ArtifactoryBuildDetailsDTO[]
}

export type ArtifactoryStoreConfig = StoreConfig & {
  artifactPaths?: string[]
  connectorRef: string
  metadata?: string
  repositoryName: string
}

export type ArtifactoryUsernamePasswordAuth = ArtifactoryAuthCredentials & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export interface ArtifactsSummary {
  artifactDisplayName?: string
  primary?: ArtifactSummary
  sidecars?: ArtifactSummary[]
}

export type AsgBlueGreenDeployStepInfo = StepSpecType & {
  asgName?: string
  delegateSelectors?: string[]
  instances?: AsgInstances
  loadBalancer?: string
  loadBalancers?: AwsAsgLoadBalancerConfigYaml[]
  prodListener?: string
  prodListenerRuleArn?: string
  stageListener?: string
  stageListenerRuleArn?: string
  useAlreadyRunningInstances?: boolean
}

export type AsgBlueGreenRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type AsgBlueGreenSwapServiceStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  downsizeOldAsg: boolean
}

export type AsgCanaryDeleteStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type AsgCanaryDeployStepInfo = StepSpecType & {
  asgName?: string
  delegateSelectors?: string[]
  instanceSelection: Capacity
}

export type AsgConfigurationManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export type AsgCurrentRunningInstances = AsgInstancesSpec & { [key: string]: any }

export type AsgDeploymentMetaData = DeploymentMetaData & { [key: string]: any }

export type AsgFixedInstances = AsgInstancesSpec & {
  desired: number
  max: number
  min: number
}

export type AsgInfrastructure = Infrastructure & {
  baseAsgName?: string
  connectorRef: string
  metadata?: string
  provisioner?: string
  region: string
}

export type AsgInfrastructureDetails = InfrastructureDetails & {
  asgName?: string
  region?: string
}

export type AsgInstanceInfoDTO = InstanceInfoDTO & {
  asgName: string
  asgNameWithoutSuffix: string
  executionStrategy?: string
  infrastructureKey: string
  instanceId?: string
  production?: boolean
  region: string
}

export interface AsgInstances {
  spec?: AsgInstancesSpec
  type: 'Fixed' | 'CurrentRunning'
}

export interface AsgInstancesSpec {
  type?: 'Fixed' | 'CurrentRunning'
}

export type AsgLaunchTemplateManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export type AsgRollingDeployStepInfo = StepSpecType & {
  asgName?: string
  delegateSelectors?: string[]
  instanceWarmup?: number
  instances?: AsgInstances
  minimumHealthyPercentage?: number
  skipMatching?: boolean
  useAlreadyRunningInstances?: boolean
}

export type AsgRollingRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type AsgScalingPolicyManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export type AsgScheduledUpdateGroupActionManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export type AsgServiceSpec = ServiceSpec & {
  userData?: UserDataConfiguration
}

export type AsgShiftTrafficStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  downsizeOldAsg: boolean
  weight: number
}

export type AuditFilterProperties = FilterProperties & {
  actions?: (
    | 'CREATE'
    | 'UPDATE'
    | 'RESTORE'
    | 'DELETE'
    | 'FORCE_DELETE'
    | 'UPSERT'
    | 'INVITE'
    | 'RESEND_INVITE'
    | 'REVOKE_INVITE'
    | 'ADD_COLLABORATOR'
    | 'REMOVE_COLLABORATOR'
    | 'CREATE_TOKEN'
    | 'REVOKE_TOKEN'
    | 'LOGIN'
    | 'LOGIN2FA'
    | 'UNSUCCESSFUL_LOGIN'
    | 'ADD_MEMBERSHIP'
    | 'REMOVE_MEMBERSHIP'
    | 'ERROR_BUDGET_RESET'
    | 'START'
    | 'END'
    | 'STAGE_START'
    | 'STAGE_END'
    | 'PAUSE'
    | 'RESUME'
    | 'ABORT'
    | 'TIMEOUT'
    | 'SIGNED_EULA'
    | 'ROLE_ASSIGNMENT_CREATED'
    | 'ROLE_ASSIGNMENT_UPDATED'
    | 'ROLE_ASSIGNMENT_DELETED'
  )[]
  endTime?: number
  environments?: Environment[]
  modules?: (
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  )[]
  principals?: Principal[]
  resources?: ResourceDTO[]
  scopes?: ResourceScopeDTO[]
  startTime?: number
  staticFilter?: 'EXCLUDE_LOGIN_EVENTS' | 'EXCLUDE_SYSTEM_EVENTS'
}

export interface AuthenticationSettingsResponse {
  authenticationMechanism?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
  ngAuthSettings?: NGAuthSettings[]
  oauthEnabled?: boolean
  publicAccessEnabled?: boolean
  sessionTimeoutInMinutes?: number
  twoFactorEnabled?: boolean
  whitelistedDomains?: string[]
}

export interface AuthorInfo {
  name?: string
  url?: string
}

export type AutoScalerManifest = ManifestAttributes & {
  metadata?: string
  skipResourceVersioning?: ParameterFieldBoolean
  store?: StoreConfigWrapper
}

export type AvailabilityRestrictionDTO = RestrictionDTO & {
  enabled?: boolean
}

export type AvailabilityRestrictionMetadataDTO = RestrictionMetadataDTO & {
  enabled?: boolean
}

export interface AwsAsgLoadBalancerConfigYaml {
  loadBalancer: string
  prodListener: string
  prodListenerRuleArn: string
  stageListener?: string
  stageListenerRuleArn?: string
}

export interface AwsCFTemplateParamsData {
  defaultValue?: string
  paramKey?: string
  paramType?: string
}

export type AwsCdkBootstrapStepInfo = StepSpecType & {
  appPath?: string
  commandOptions?: string[]
  connectorRef: string
  delegateSelectors?: string[]
  envVariables?: {
    [key: string]: string
  }
  image: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
}

export type AwsCdkDeployStepInfo = StepSpecType & {
  appPath?: string
  commandOptions?: string[]
  connectorRef: string
  delegateSelectors?: string[]
  envVariables?: {
    [key: string]: string
  }
  image: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  parameters?: {
    [key: string]: string
  }
  privileged?: boolean
  provisionerIdentifier: string
  resources?: ContainerResource
  runAsUser?: number
  stackNames?: string[]
}

export type AwsCdkDestroyStepInfo = StepSpecType & {
  appPath?: string
  commandOptions?: string[]
  connectorRef: string
  delegateSelectors?: string[]
  envVariables?: {
    [key: string]: string
  }
  image: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  stackNames?: string[]
}

export type AwsCdkDiffStepInfo = StepSpecType & {
  appPath?: string
  commandOptions?: string[]
  connectorRef: string
  delegateSelectors?: string[]
  envVariables?: {
    [key: string]: string
  }
  image: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  stackNames?: string[]
}

export type AwsCdkRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  envVariables?: {
    [key: string]: string
  }
  provisionerIdentifier: string
}

export type AwsCdkSynthStepInfo = StepSpecType & {
  appPath?: string
  commandOptions?: string[]
  connectorRef: string
  delegateSelectors?: string[]
  envVariables?: {
    [key: string]: string
  }
  exportTemplate?: boolean
  image: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  stackNames?: string[]
}

export type AwsCloudProviderBasicConfig = CloudProviderSpec & {
  connectorRef: string
  region: string
}

export interface AwsCodeCommitAuthenticationDTO {
  spec: AwsCodeCommitCredentialsDTO
  type: 'HTTPS'
}

export type AwsCodeCommitConnectorDTO = ConnectorConfigDTO & {
  authentication: AwsCodeCommitAuthenticationDTO
  delegateSelectors?: string[]
  type: 'Repo' | 'Region'
  url: string
}

export interface AwsCodeCommitCredentialsDTO {
  [key: string]: any
}

export type AwsCodeCommitHttpsCredentialsDTO = AwsCodeCommitCredentialsDTO & {
  spec: AwsCodeCommitHttpsCredentialsSpecDTO
  type: 'AWSCredentials'
}

export interface AwsCodeCommitHttpsCredentialsSpecDTO {
  [key: string]: any
}

export type AwsCodeCommitSCMDTO = SourceCodeManagerDTO & {
  authentication: AwsCodeCommitAuthenticationDTO
}

export type AwsCodeCommitSecretKeyAccessKeyDTO = AwsCodeCommitHttpsCredentialsSpecDTO & {
  accessKey?: string
  accessKeyRef?: string
  secretKeyRef: string
}

export type AwsConnector = ConnectorConfigDTO & {
  awsSdkClientBackOffStrategyOverride?: AwsSdkClientBackoffStrategy
  credential: AwsCredential
  delegateSelectors?: string[]
  executeOnDelegate?: boolean
}

export interface AwsCredential {
  crossAccountAccess?: CrossAccountAccess
  region?: string
  spec?: AwsCredentialSpec
  type: 'InheritFromDelegate' | 'ManualConfig' | 'Irsa'
}

export interface AwsCredentialSpec {
  [key: string]: any
}

export interface AwsCurAttributes {
  region?: string
  reportName: string
  s3BucketName: string
  s3Prefix?: string
}

export type AwsEqualJitterBackoffStrategy = AwsSdkClientBackOffStrategySpec & {
  baseDelay?: number
  maxBackoffTime?: number
  retryCount?: number
}

export type AwsFixedDelayBackoffStrategy = AwsSdkClientBackOffStrategySpec & {
  fixedBackoff?: number
  retryCount?: number
}

export type AwsFullJitterBackoffStrategy = AwsSdkClientBackOffStrategySpec & {
  baseDelay?: number
  maxBackoffTime?: number
  retryCount?: number
}

export interface AwsInstanceFilter {
  tags?: {
    [key: string]: string
  }
  vpcs?: string[]
}

export interface AwsKmsConnectorCredential {
  spec?: AwsKmsCredentialSpec
  type: 'AssumeIAMRole' | 'AssumeSTSRole' | 'ManualConfig'
}

export type AwsKmsConnectorDTO = ConnectorConfigDTO & {
  credential: AwsKmsConnectorCredential
  default?: boolean
  delegateSelectors?: string[]
  kmsArn: string
  region: string
}

export interface AwsKmsCredentialSpec {
  [key: string]: any
}

export type AwsKmsCredentialSpecAssumeIAM = AwsKmsCredentialSpec & {
  delegateSelectors: string[]
}

export type AwsKmsCredentialSpecAssumeSTS = AwsKmsCredentialSpec & {
  assumeStsRoleDuration?: number
  delegateSelectors: string[]
  externalName?: string
  roleArn: string
}

export type AwsKmsCredentialSpecManualConfig = AwsKmsCredentialSpec & {
  accessKey: string
  secretKey: string
}

export type AwsLambdaDefinitionManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export type AwsLambdaDeployStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type AwsLambdaDeploymentMetaData = DeploymentMetaData & { [key: string]: any }

export type AwsLambdaFunctionAliasDefinitionManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export type AwsLambdaInfrastructure = Infrastructure & {
  connectorRef: string
  metadata?: string
  provisioner?: string
  region: string
}

export type AwsLambdaInfrastructureDetails = InfrastructureDetails & {
  region?: string
}

export type AwsLambdaInstanceInfoDTO = InstanceInfoDTO & {
  aliases?: string[]
  artifactId?: string
  description?: string
  functionArn?: string
  functionName: string
  handler?: string
  infraStructureKey?: string
  memorySize?: number
  region: string
  runTime?: string
  source?: string
  tags?: Tag[]
  updatedTime?: string
  version?: string
}

export type AwsLambdaRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type AwsLambdaServiceSpec = ServiceSpec & {}

export interface AwsListInstancesFilter {
  autoScalingGroupName?: string
  region: string
  tags?: {
    [key: string]: string
  }
  vpcIds?: string[]
  winRm?: boolean
}

export type AwsLoadBalancerConfigYaml = LoadBalancerSpec & {
  loadBalancer: string
  prodListenerPort: string
  prodListenerRuleArn: string
  stageListenerPort: string
  stageListenerRuleArn: string
}

export type AwsManualConfigSpec = AwsCredentialSpec & {
  accessKey?: string
  accessKeyRef?: string
  secretKeyRef: string
}

export type AwsSMCredentialSpecAssumeIAM = AwsSecretManagerCredentialSpec & { [key: string]: any }

export type AwsSMCredentialSpecAssumeSTS = AwsSecretManagerCredentialSpec & {
  assumeStsRoleDuration?: number
  externalId?: string
  roleArn: string
}

export type AwsSMCredentialSpecManualConfig = AwsSecretManagerCredentialSpec & {
  accessKey: string
  secretKey: string
}

export type AwsSamBuildStepInfo = StepSpecType & {
  buildCommandOptions?: string[]
  connectorRef?: string
  delegateSelectors?: string[]
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  samBuildDockerRegistryConnectorRef?: string
  samVersion?: string
}

export type AwsSamDeployStepInfo = StepSpecType & {
  connectorRef?: string
  delegateSelectors?: string[]
  deployCommandOptions?: string[]
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  samVersion?: string
  stackName: string
}

export type AwsSamDeploymentMetaData = DeploymentMetaData & { [key: string]: any }

export type AwsSamDirectoryManifest = ManifestAttributes & {
  metadata?: string
  samTemplateFile?: string
  store?: StoreConfigWrapper
}

export type AwsSamInfrastructure = Infrastructure & {
  connectorRef: string
  metadata?: string
  provisioner?: string
  region: string
}

export type AwsSamInfrastructureDetails = InfrastructureDetails & {
  region?: string
}

export type AwsSamInstanceInfoDTO = InstanceInfoDTO & {
  functionName: string
  handler?: string
  infraStructureKey: string
  memorySize?: string
  region: string
  runTime?: string
}

export type AwsSamRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type AwsSamServiceSpec = ServiceSpec & {}

export interface AwsSdkClientBackOffStrategySpec {
  [key: string]: any
}

export interface AwsSdkClientBackoffStrategy {
  spec?: AwsSdkClientBackOffStrategySpec
  type: 'FixedDelayBackoffStrategy' | 'EqualJitterBackoffStrategy' | 'FullJitterBackoffStrategy'
}

export interface AwsSecretManagerCredential {
  spec?: AwsSecretManagerCredentialSpec
  type: 'AssumeIAMRole' | 'AssumeSTSRole' | 'ManualConfig'
}

export interface AwsSecretManagerCredentialSpec {
  [key: string]: any
}

export type AwsSecretManagerDTO = ConnectorConfigDTO & {
  credential: AwsSecretManagerCredential
  default?: boolean
  delegateSelectors?: string[]
  region: string
  secretNamePrefix?: string
}

export type AwsSshWinrmInstanceInfoDTO = InstanceInfoDTO & {
  host: string
  infrastructureKey: string
  serviceType: string
}

export interface AwsVPC {
  id?: string
  name?: string
}

export type AzureARMRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  provisionerIdentifier: string
}

export interface AzureArtifactsAuthentication {
  spec: AzureArtifactsHttpCredentials
}

export type AzureArtifactsConfig = ArtifactConfig & {
  connectorRef: string
  feed: string
  package: string
  packageType: 'maven' | 'nuget' | 'upack'
  project?: string
  scope: 'project' | 'org'
  version?: string
  versionRegex?: string
}

export type AzureArtifactsConnector = ConnectorConfigDTO & {
  auth: AzureArtifactsAuthentication
  azureArtifactsUrl: string
  delegateSelectors?: string[]
  executeOnDelegate?: boolean
}

export interface AzureArtifactsFeed {
  fullyQualifiedName?: string
  id?: string
  name?: string
  project?: AzureDevopsProject
}

export interface AzureArtifactsHttpCredentials {
  spec: AzureArtifactsUsernameToken
  type: 'PersonalAccessToken'
}

export interface AzureArtifactsPackage {
  id?: string
  name?: string
  protocolType?: string
}

export type AzureArtifactsSummary = ArtifactSummary & {
  packageId?: string
  packageName?: string
  tag?: string
  version?: string
}

export interface AzureArtifactsUsernameToken {
  tokenRef: string
}

export interface AzureAuthCredentialDTO {
  [key: string]: any
}

export interface AzureAuthDTO {
  spec: AzureAuthCredentialDTO
  type: 'Secret' | 'Certificate'
}

export type AzureClientKeyCertDTO = AzureAuthCredentialDTO & {
  certificateRef: string
}

export type AzureClientSecretKeyDTO = AzureAuthCredentialDTO & {
  secretRef: string
}

export interface AzureClusterDTO {
  cluster: string
}

export interface AzureClustersDTO {
  clusters?: AzureClusterDTO[]
}

export type AzureConnector = ConnectorConfigDTO & {
  azureEnvironmentType: 'AZURE' | 'AZURE_US_GOVERNMENT'
  credential: AzureCredential
  delegateSelectors?: string[]
  executeOnDelegate?: boolean
}

export interface AzureCreateARMResourceParameterFile {
  store: StoreConfigWrapper
}

export interface AzureCreateARMResourceStepConfiguration {
  connectorRef: string
  parameters?: AzureCreateARMResourceParameterFile
  scope: AzureCreateARMResourceStepScope
  template: AzureTemplateFile
}

export type AzureCreateARMResourceStepInfo = StepSpecType & {
  configuration: AzureCreateARMResourceStepConfiguration
  delegateSelectors?: string[]
  metadata?: string
  provisionerIdentifier: string
}

export interface AzureCreateARMResourceStepScope {
  spec: AzureScopeType
  type: string
}

export interface AzureCreateBPStepConfiguration {
  assignmentName?: string
  connectorRef: string
  scope: 'Subscription' | 'ManagementGroup'
  template: AzureTemplateFile
}

export type AzureCreateBPStepInfo = StepSpecType & {
  configuration: AzureCreateBPStepConfiguration
  delegateSelectors?: string[]
  metadata?: string
}

export interface AzureCredential {
  spec?: AzureCredentialSpec
  type: 'InheritFromDelegate' | 'ManualConfig'
}

export interface AzureCredentialSpec {
  [key: string]: any
}

export interface AzureDeploymentSlotDTO {
  name: string
  type: string
}

export interface AzureDeploymentSlotsDTO {
  deploymentSlots?: AzureDeploymentSlotDTO[]
}

export interface AzureDevopsProject {
  id?: string
  name?: string
}

export interface AzureImageGalleriesDTO {
  azureImageGalleries?: AzureImageGallery[]
}

export interface AzureImageGallery {
  name?: string
  regionName?: string
  resourceGroupName?: string
  subscriptionId?: string
}

export type AzureInheritFromDelegateDetails = AzureCredentialSpec & {
  auth: AzureMSIAuth
}

export type AzureKeyVaultConnectorDTO = ConnectorConfigDTO & {
  azureEnvironmentType?: 'AZURE' | 'AZURE_US_GOVERNMENT'
  azureManagedIdentityType?: 'SystemAssignedManagedIdentity' | 'UserAssignedManagedIdentity'
  clientId?: string
  default?: boolean
  delegateSelectors?: string[]
  enablePurge?: boolean
  managedClientId?: string
  secretKey?: string
  subscription: string
  tenantId?: string
  useManagedIdentity?: boolean
  vaultConfiguredManually?: boolean
  vaultName: string
}

export type AzureKeyVaultMetadataRequestSpecDTO = SecretManagerMetadataRequestSpecDTO & {
  azureEnvironmentType?: 'AZURE' | 'AZURE_US_GOVERNMENT'
  azureManagedIdentityType?: 'SystemAssignedManagedIdentity' | 'UserAssignedManagedIdentity'
  clientId?: string
  delegateSelectors?: string[]
  enablePurge?: boolean
  managedClientId?: string
  secretKey?: string
  subscription: string
  tenantId?: string
  useManagedIdentity?: boolean
}

export type AzureKeyVaultMetadataSpecDTO = SecretManagerMetadataSpecDTO & {
  vaultNames?: string[]
}

export interface AzureLocationsDTO {
  locations?: string[]
}

export interface AzureMSIAuth {
  [key: string]: any
}

export interface AzureManagementGroupsDTO {
  managementGroups?: ManagementGroupData[]
}

export type AzureManagementSpec = AzureScopeType & {
  location: string
  managementGroupId: string
}

export type AzureManualDetails = AzureCredentialSpec & {
  applicationId: string
  auth: AzureAuthDTO
  tenantId: string
}

export interface AzureRepoApiAccess {
  spec?: AzureRepoApiAccessSpecDTO
  type: 'Token'
}

export interface AzureRepoApiAccessSpecDTO {
  [key: string]: any
}

export interface AzureRepoAuthentication {
  spec: AzureRepoCredentialsDTO
  type: 'Http' | 'Ssh'
}

export interface AzureRepoAuthenticationDTO {
  apiAccessDTO?: AzureRepoApiAccess
}

export type AzureRepoConnector = ConnectorConfigDTO & {
  apiAccess?: AzureRepoApiAccess
  authentication: AzureRepoAuthentication
  delegateSelectors?: string[]
  executeOnDelegate?: boolean
  type: 'Project' | 'Repo'
  url: string
  validationRepo?: string
}

export interface AzureRepoCredentialsDTO {
  [key: string]: any
}

export type AzureRepoHttpCredentials = AzureRepoCredentialsDTO & {
  spec: AzureRepoHttpCredentialsSpecDTO
  type: 'UsernameToken'
}

export interface AzureRepoHttpCredentialsSpecDTO {
  [key: string]: any
}

export type AzureRepoSCMDTO = SourceCodeManagerDTO & {
  authentication?: AzureRepoAuthentication
}

export type AzureRepoSCMRequestDTO = UserSourceCodeManagerRequestDTO & {
  authentication?: AzureRepoAuthenticationDTO
}

export type AzureRepoSshCredentials = AzureRepoCredentialsDTO & {
  sshKeyRef: string
}

export type AzureRepoStore = StoreConfig & {
  branch?: string
  commitId?: string
  connectorRef: string
  folderPath?: string
  gitFetchType: 'Branch' | 'Commit'
  paths?: string[]
  repoName?: string
}

export type AzureRepoTokenSpec = AzureRepoApiAccessSpecDTO & {
  tokenRef: string
}

export type AzureRepoUsernameToken = AzureRepoHttpCredentialsSpecDTO & {
  tokenRef: string
  username?: string
  usernameRef?: string
}

export interface AzureResourceGroupDTO {
  resourceGroup: string
}

export type AzureResourceGroupSpec = AzureScopeType & {
  mode?: 'Incremental' | 'Complete'
  resourceGroup: string
  subscription: string
}

export interface AzureResourceGroupsDTO {
  resourceGroups?: AzureResourceGroupDTO[]
}

export interface AzureScopeType {
  [key: string]: any
}

export type AzureSshWinrmInstanceInfoDTO = InstanceInfoDTO & {
  host: string
  infrastructureKey: string
  serviceType: string
}

export interface AzureSubscriptionDTO {
  subscriptionId: string
  subscriptionName: string
}

export type AzureSubscriptionSpec = AzureScopeType & {
  location: string
  subscription: string
}

export interface AzureSubscriptionsDTO {
  subscriptions?: AzureSubscriptionDTO[]
}

export type AzureSystemAssignedMSIAuth = AzureAuthCredentialDTO & { [key: string]: any }

export interface AzureTagDTO {
  tag: string
}

export interface AzureTagsDTO {
  tags?: AzureTagDTO[]
}

export interface AzureTemplateFile {
  store: StoreConfigWrapper
}

export type AzureTenantSpec = AzureScopeType & {
  location: string
}

export type AzureUserAssignedMSIAuth = AzureAuthCredentialDTO & {
  clientId: string
}

export type AzureWebAppDeploymentMetaData = DeploymentMetaData & { [key: string]: any }

export type AzureWebAppInfrastructure = Infrastructure & {
  connectorRef: string
  provisioner?: string
  resourceGroup: string
  subscriptionId: string
}

export type AzureWebAppInfrastructureDetails = InfrastructureDetails & {
  resourceGroup?: string
  subscriptionId?: string
}

export type AzureWebAppInstanceInfoDTO = InstanceInfoDTO & {
  appName: string
  appServicePlanId?: string
  deploySlot: string
  deploySlotId?: string
  hostName?: string
  instanceId?: string
  instanceIp?: string
  instanceName?: string
  instanceState?: string
  instanceType?: string
  resourceGroup: string
  subscriptionId: string
}

export interface AzureWebAppNamesDTO {
  webAppNames?: string[]
}

export type AzureWebAppRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type AzureWebAppServiceSpec = ServiceSpec & {
  applicationSettings?: ApplicationSettingsConfiguration
  connectionStrings?: ConnectionStringsConfiguration
  startupCommand?: StartupCommandConfiguration
}

export type AzureWebAppSlotDeploymentStepInfo = StepSpecType & {
  clean?: boolean
  delegateSelectors?: string[]
  deploymentSlot: string
  webApp: string
}

export type AzureWebAppSwapSlotStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  targetSlot: string
}

export type AzureWebAppTrafficShiftStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  traffic: ParameterFieldString
}

export type BackgroundStepInfo = StepSpecType & {
  command?: string
  connectorRef?: string
  entrypoint?: string[]
  envVariables?: {
    [key: string]: string
  }
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  portBindings?: {
    [key: string]: string
  }
  privileged?: boolean
  reports?: UnitTestReport
  resources?: ContainerResource
  runAsUser?: number
  shell?: 'Sh' | 'Bash' | 'Powershell' | 'Pwsh' | 'Python'
  version?: string
}

export type BackgroundStepInfoV1 = StepSpecType & {
  args?: string[]
  entrypoint?: string
  entrypointList?: ParameterFieldListString
  envs?: {
    [key: string]: string
  }
  image?: string
  network?: string
  ports?: string[]
  privileged?: boolean
  pull?: 'always' | 'never' | 'if-not-exists'
  resources?: ContainerResource
  run: string
  shell?: 'sh' | 'bash' | 'powershell' | 'pwsh' | 'python'
  user?: number
  version?: string
}

export type BambooArtifactConfig = ArtifactConfig & {
  artifactPaths?: string[]
  build?: string
  connectorRef: string
  planKey: string
}

export type BambooArtifactSummary = ArtifactSummary & {
  build?: string
  planKey?: string
  tag?: string
}

export interface BambooAuthCredentialsDTO {
  [key: string]: any
}

export interface BambooAuthenticationDTO {
  spec?: BambooAuthCredentialsDTO
  type: 'UsernamePassword' | 'Anonymous' | 'Bearer Token(HTTP Header)'
}

export type BambooBuildStepInfo = StepSpecType & {
  connectorRef: string
  delegateSelectors?: string[]
  metadata?: string
  planName: string
  planParameter?: BambooParameterField[]
}

export type BambooConnectorDTO = ConnectorConfigDTO & {
  auth?: BambooAuthenticationDTO
  bambooUrl: string
  delegateSelectors?: string[]
}

export interface BambooParameterField {
  metadata?: string
  name?: string
  type?: 'String' | 'Number'
  value: string
}

export interface BambooPlanKeysDTO {
  planKeys?: BambooPlanNames[]
}

export interface BambooPlanNames {
  name?: string
  value?: string
}

export type BambooUserNamePasswordDTO = BambooAuthCredentialsDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export interface BaseSSHSpecDTO {
  [key: string]: any
}

export interface BaseWinRmSpecDTO {
  [key: string]: any
}

export interface BillingExportSpec {
  containerName: string
  directoryName: string
  reportName: string
  storageAccountName: string
  subscriptionId: string
}

export interface BitbucketApiAccess {
  spec: BitbucketApiAccessSpecDTO
  type: 'UsernameToken' | 'OAuth'
}

export interface BitbucketApiAccessSpecDTO {
  [key: string]: any
}

export interface BitbucketAuthentication {
  spec: BitbucketCredentialsDTO
  type: 'Http' | 'Ssh'
}

export interface BitbucketAuthenticationDTO {
  apiAccessDTO?: BitbucketApiAccess
}

export type BitbucketConnector = ConnectorConfigDTO & {
  apiAccess?: BitbucketApiAccess
  authentication: BitbucketAuthentication
  delegateSelectors?: string[]
  executeOnDelegate?: boolean
  type: 'Account' | 'Repo' | 'Project'
  url: string
  validationRepo?: string
}

export interface BitbucketCredentialsDTO {
  [key: string]: any
}

export type BitbucketHttpCredentials = BitbucketCredentialsDTO & {
  spec: BitbucketHttpCredentialsSpecDTO
  type: 'UsernamePassword'
}

export interface BitbucketHttpCredentialsSpecDTO {
  [key: string]: any
}

export type BitbucketOauth = BitbucketApiAccessSpecDTO & {
  refreshTokenRef: string
  tokenRef: string
}

export type BitbucketSCMDTO = SourceCodeManagerDTO & {
  authentication?: BitbucketAuthentication
}

export type BitbucketSCMRequestDTO = UserSourceCodeManagerRequestDTO & {
  authentication?: BitbucketAuthenticationDTO
}

export type BitbucketSshCredentials = BitbucketCredentialsDTO & {
  sshKeyRef: string
}

export type BitbucketStore = StoreConfig & {
  branch?: string
  commitId?: string
  connectorRef: string
  folderPath?: string
  gitFetchType: 'Branch' | 'Commit'
  paths?: string[]
  repoName?: string
}

export type BitbucketUsernamePassword = BitbucketHttpCredentialsSpecDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type BitbucketUsernameTokenApiAccess = BitbucketApiAccessSpecDTO & {
  tokenRef: string
  username?: string
  usernameRef?: string
}

export type BitriseStepInfo = StepSpecType & {
  env?: ParameterFieldMapStringString
  uses: string
  version?: string
  with?: ParameterFieldMapStringString
}

export type BitriseStepInfoV1 = StepSpecType & {
  envs?: ParameterFieldMapStringString
  outputs?: string[]
  resources?: ContainerResource
  uses: string
  version?: string
  with?: ParameterFieldMapStringString
}

export interface Board {
  id?: string
  name?: string
}

export type BranchBuildSpec = BuildSpec & {
  branch: string
}

export interface BucketResponse {
  bucketName?: string
}

export interface Build {
  spec: BuildSpec
  type: 'branch' | 'tag' | 'PR' | 'commitSha'
}

export interface BuildDetails {
  artifactDownloadMetadata?: ArtifactFileMetadata[]
  artifactFileMetadataList?: ArtifactFileMetadata[]
  artifactFileSize?: string
  artifactPath?: string
  buildDisplayName?: string
  buildFullDisplayName?: string
  buildParameters?: {
    [key: string]: string
  }
  buildUrl?: string
  description?: string
  labels?: {
    [key: string]: string
  }
  metadata?: {
    [key: string]: string
  }
  number?: string
  revision?: string
  status?: 'FAILURE' | 'UNSTABLE' | 'SUCCESS'
  uiDisplayName?: string
  updateTime?: number
}

export interface BuildIdAndInstanceCount {
  buildId?: string
  count?: number
}

export interface BuildSpec {
  [key: string]: any
}

export type CDLicenseSummaryDTO = LicensesWithSummaryDTO & {
  totalServiceInstances?: number
  totalWorkload?: number
}

export type CDModuleLicenseDTO = ModuleLicenseDTO & {
  cdLicenseType?: 'SERVICES' | 'SERVICE_INSTANCES'
  serviceInstances?: number
  workloads?: number
}

export interface CDPipelineModuleInfo {
  artifactDisplayNames?: string[]
  envGroupIdentifiers?: string[]
  envIdentifiers?: string[]
  environmentTypes?: ('PreProduction' | 'Production')[]
  freezeIdentifiers?: string[]
  gitOpsAppIdentifiers?: string[]
  helmChartVersions?: string[]
  infrastructureIdentifiers?: string[]
  infrastructureNames?: string[]
  infrastructureTypes?: string[]
  serviceDefinitionTypes?: string[]
  serviceIdentifiers?: string[]
}

export interface CDStageMetaDataDTO {
  environmentRef?: string
  serviceEnvRefList?: ServiceEnvRef[]
  serviceRef?: string
}

export interface CDStageModuleInfo {
  freezeExecutionSummary?: FreezeExecutionSummary
  gitOpsAppSummary?: GitOpsAppSummary
  gitopsExecutionSummary?: GitOpsExecutionSummary
  infraExecutionSummary?: InfraExecutionSummary
  nodeExecutionId?: string
  rollbackDuration?: number
  serviceInfo?: ServiceExecutionSummary
}

export interface CDStageSummaryResponseDTO {
  Environment?: string
  'Infrastructure Definition'?: string
  Service?: string
}

export type CEAwsConnector = ConnectorConfigDTO & {
  awsAccountId?: string
  crossAccountAccess: CrossAccountAccess
  curAttributes?: AwsCurAttributes
  featuresEnabled?: (
    | 'BILLING'
    | 'OPTIMIZATION'
    | 'VISIBILITY'
    | 'GOVERNANCE'
    | 'COMMITMENT_ORCHESTRATOR'
    | 'CLUSTER_ORCHESTRATOR'
  )[]
  isAWSGovCloudAccount?: boolean
}

export type CEAzureConnector = ConnectorConfigDTO & {
  billingExportSpec?: BillingExportSpec
  featuresEnabled?: (
    | 'BILLING'
    | 'OPTIMIZATION'
    | 'VISIBILITY'
    | 'GOVERNANCE'
    | 'COMMITMENT_ORCHESTRATOR'
    | 'CLUSTER_ORCHESTRATOR'
  )[]
  subscriptionId: string
  tenantId: string
}

export type CEKubernetesClusterConfig = ConnectorConfigDTO & {
  connectorRef: string
  featuresEnabled?: (
    | 'BILLING'
    | 'OPTIMIZATION'
    | 'VISIBILITY'
    | 'GOVERNANCE'
    | 'COMMITMENT_ORCHESTRATOR'
    | 'CLUSTER_ORCHESTRATOR'
  )[]
}

export type CELicenseSummaryDTO = LicensesWithSummaryDTO & {
  totalSpendLimit?: number
}

export type CEModuleLicenseDTO = ModuleLicenseDTO & {
  spendLimit?: number
}

export type CETModuleLicenseDTO = ModuleLicenseDTO & {
  numberOfAgents?: number
}

export type CFLicenseSummaryDTO = LicensesWithSummaryDTO & {
  totalClientMAUs?: number
  totalFeatureFlagUnits?: number
}

export type CFModuleLicenseDTO = ModuleLicenseDTO & {
  numberOfClientMAUs?: number
  numberOfUsers?: number
}

export type CICreditDTO = CreditDTO & {}

export type CILicenseSummaryDTO = LicensesWithSummaryDTO & {
  cacheSizeAllowance?: number
  totalDevelopers?: number
}

export type CIModuleLicenseDTO = ModuleLicenseDTO & {
  cacheAllowance?: number
  hostingCredits?: number
  numberOfCommitters?: number
}

export interface CIVolume {
  type?: 'EmptyDir' | 'PersistentVolumeClaim' | 'HostPath'
}

export type CVLicenseSummaryDTO = LicensesWithSummaryDTO & {
  totalServices?: number
}

export type CVModuleLicenseDTO = ModuleLicenseDTO & {
  numberOfServices?: number
}

export interface CacheResponseMetadata {
  cacheState: 'VALID_CACHE' | 'STALE_CACHE' | 'UNKNOWN'
  isSyncEnabled: boolean
  lastUpdatedAt: number
  ttlLeft: number
}

export interface CannyBoardsResponseDTO {
  boards?: Board[]
  message?: string
}

export interface CannyPostResponseDTO {
  message?: string
  postURL?: string
}

export interface Capabilities {
  add?: string[]
  drop?: string[]
}

export interface Capacity {
  spec?: CapacitySpec
  type: string
}

export interface CapacitySpec {
  type?: string
}

export interface CardDTO {
  addressCity?: string
  addressCountry?: string
  addressLine1?: string
  addressLine2?: string
  addressState?: string
  addressZip?: string
  brand?: string
  cvcCheck?: string
  expireMonth?: number
  expireYear?: number
  fingerPrint?: string
  funding?: string
  id?: string
  isDefaultCard?: boolean
  last4?: string
  name?: string
}

export interface CcmConnectorFilter {
  awsAccountId?: string
  awsAccountIds?: string[]
  azureSubscriptionId?: string
  azureTenantId?: string
  featuresDisabled?: (
    | 'BILLING'
    | 'OPTIMIZATION'
    | 'VISIBILITY'
    | 'GOVERNANCE'
    | 'COMMITMENT_ORCHESTRATOR'
    | 'CLUSTER_ORCHESTRATOR'
  )[]
  featuresEnabled?: (
    | 'BILLING'
    | 'OPTIMIZATION'
    | 'VISIBILITY'
    | 'GOVERNANCE'
    | 'COMMITMENT_ORCHESTRATOR'
    | 'CLUSTER_ORCHESTRATOR'
  )[]
  gcpProjectId?: string
  k8sConnectorRef?: string[]
}

export interface CcmK8sConnectorResponse {
  ccmk8sConnector?: ConnectorResponse[]
  k8sConnector?: ConnectorResponse
}

export interface CdDeployStageMetadataRequestDTO {
  pipelineYaml: string
  stageIdentifier: string
}

export interface CeLicenseInfo {
  expiryTime?: number
  licenseType?: 'FULL_TRIAL' | 'LIMITED_TRIAL' | 'PAID'
}

export interface ChangeRate {
  percentChange?: number
  trend?: 'UP_TREND' | 'DOWN_TREND' | 'NO_CHANGE' | 'INVALID'
}

export type ChaosModuleLicenseDTO = ModuleLicenseDTO & {
  totalChaosExperimentRuns?: number
  totalChaosInfrastructures?: number
}

export type ChaosStepInfo = StepSpecType & {
  assertion?: string
  expectedResilienceScore: number
  experimentRef: string
}

export interface ChartVersionInstanceDetail {
  chartVersion?: string
  environmentGroupInstanceDetails: EnvironmentGroupInstanceDetails
}

export interface ChartVersionInstanceDetails {
  chartVersionInstanceDetails: ChartVersionInstanceDetail[]
}

export interface CloudProvider {
  spec?: CloudProviderSpec
  type: 'AWS'
}

export interface CloudProviderSpec {
  type?: 'AWS'
}

export interface CloudformationCreateStackStepConfiguration {
  capabilities?: string[]
  connectorRef: string
  parameterOverrides?: NGVariable[]
  parameters?: CloudformationParametersFileSpec[]
  region: string
  roleArn?: string
  skipOnStackStatuses?: string[]
  stackName: string
  tags?: CloudformationTags
  templateFile: CloudformationTemplateFile
}

export type CloudformationCreateStackStepInfo = StepSpecType & {
  configuration: CloudformationCreateStackStepConfiguration
  delegateSelectors?: string[]
  metadata?: string
  provisionerIdentifier: string
}

export interface CloudformationDeleteStackStepConfiguration {
  spec: CloudformationDeleteStackStepConfigurationSpec
  type: string
}

export interface CloudformationDeleteStackStepConfigurationSpec {
  type?: string
}

export type CloudformationDeleteStackStepInfo = StepSpecType & {
  configuration: CloudformationDeleteStackStepConfiguration
  delegateSelectors?: string[]
  metadata?: string
}

export interface CloudformationParametersFileSpec {
  identifier: string
  store: StoreConfigWrapper
}

export interface CloudformationRollbackStepConfiguration {
  provisionerIdentifier: string
}

export type CloudformationRollbackStepInfo = StepSpecType & {
  configuration: CloudformationRollbackStepConfiguration
  delegateSelectors?: string[]
  metadata?: string
}

export interface CloudformationTags {
  spec: CloudformationTagsFileSpec
  type: string
}

export interface CloudformationTagsFileSpec {
  type?: string
}

export interface CloudformationTemplateFile {
  spec: CloudformationTemplateFileSpec
  type: string
}

export interface CloudformationTemplateFileSpec {
  type?: string
}

export interface Cluster {
  agentId?: string
  clusterId?: string
  clusterName?: string
  envGroupId?: string
  envGroupName?: string
  envId?: string
  envName?: string
  scope?: string
}

export interface ClusterBasicDTO {
  agentIdentifier?: string
  identifier?: string
  name?: string
  scope?: 'ACCOUNT' | 'ORGANIZATION' | 'PROJECT'
}

export interface ClusterBatchRequest {
  clusters?: ClusterBasicDTO[]
  envRef?: string
  linkAllClusters?: boolean
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  unlinkAllClusters?: boolean
}

export interface ClusterBatchResponse {
  linked?: number
  unlinked?: number
}

export interface ClusterFromGitops {
  agentIdentifier?: string
  identifier?: string
  name?: string
  scopeLevel?: 'ACCOUNT' | 'ORGANIZATION' | 'PROJECT'
  tags?: {
    [key: string]: string
  }
}

export interface ClusterRequest {
  agentIdentifier?: string
  envRef?: string
  identifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  scope?: 'ACCOUNT' | 'ORGANIZATION' | 'PROJECT'
}

export interface ClusterResponse {
  accountIdentifier?: string
  agentIdentifier?: string
  clusterRef?: string
  envRef?: string
  linkedAt?: number
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  scope?: 'ACCOUNT' | 'ORGANIZATION' | 'PROJECT'
  tags?: {
    [key: string]: string
  }
}

export interface ClusterYaml {
  agentIdentifier?: string
  identifier: string
  metadata?: string
}

export type CommandStepInfo = StepSpecType & {
  commandUnits?: CommandUnitWrapper[]
  delegateSelectors?: string[]
  environmentVariables?: NGVariable[]
  host?: string
  metadata?: string
  onDelegate: boolean
  outputVariables?: NGVariable[]
}

export interface CommandUnitBaseSpec {
  type?: string
}

export interface CommandUnitWrapper {
  identifier: string
  name: string
  spec?: CommandUnitBaseSpec
  type: string
}

export type CommitShaBuildSpec = BuildSpec & {
  commitSha: string
}

export interface ConfigFile {
  identifier: string
  spec: ConfigFileAttributes
}

export interface ConfigFileAttributeStepParameters {
  store?: StoreConfigWrapperParameters
}

export interface ConfigFileAttributes {
  configFileAttributeStepParameters?: ConfigFileAttributeStepParameters
  store: StoreConfigWrapper
}

export interface ConfigFileOverrideSetWrapper {
  overrideSet?: ConfigFileOverrideSets
}

export interface ConfigFileOverrideSets {
  configFiles?: ConfigFileWrapper[]
  identifier?: string
}

export interface ConfigFileWrapper {
  configFile?: ConfigFile
}

export type ConnectedArgoGitOpsInfoDTO = GitOpsInfoDTO & {
  adapterUrl: string
}

export interface ConnectionStringsConfiguration {
  metadata?: string
  store: StoreConfigWrapper
}

export interface ConnectivityCheckSummary {
  endTime?: number
  failureCount?: number
  startTime?: number
  successCount?: number
}

export interface Connector {
  connector?: ConnectorInfoDTO
}

export interface ConnectorActivityDetails {
  lastActivityTime?: number
}

export interface ConnectorCatalogueItem {
  category?:
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  connectors?: (
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Azure'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
    | 'ErrorTracking'
    | 'Pdc'
    | 'AzureRepo'
    | 'Jenkins'
    | 'OciHelmRepo'
    | 'CustomSecretManager'
    | 'ElasticSearch'
    | 'GcpSecretManager'
    | 'AzureArtifacts'
    | 'Tas'
    | 'Spot'
    | 'Bamboo'
    | 'TerraformCloud'
    | 'SignalFX'
    | 'Harness'
    | 'Rancher'
  )[]
}

export interface ConnectorCatalogueResponse {
  catalogue?: ConnectorCatalogueItem[]
}

export interface ConnectorConfigDTO {
  [key: string]: any
}

export interface ConnectorConnectivityDetails {
  errorSummary?: string
  errors?: ErrorDetail[]
  lastAlertSent?: number
  lastConnectedAt?: number
  lastTestedAt?: number
  status?: 'SUCCESS' | 'FAILURE' | 'PARTIAL' | 'UNKNOWN'
  testedAt?: number
}

export type ConnectorFilterProperties = FilterProperties & {
  categories?: (
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  )[]
  ccmConnectorFilter?: CcmConnectorFilter
  connectivityStatuses?: ('SUCCESS' | 'FAILURE' | 'PARTIAL' | 'UNKNOWN')[]
  connectorConnectivityModes?: ('DELEGATE' | 'MANAGER')[]
  connectorIdentifiers?: string[]
  connectorIds?: string[]
  connectorNames?: string[]
  description?: string
  inheritingCredentialsFromDelegate?: boolean
  types?: (
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Azure'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
    | 'ErrorTracking'
    | 'Pdc'
    | 'AzureRepo'
    | 'Jenkins'
    | 'OciHelmRepo'
    | 'CustomSecretManager'
    | 'ElasticSearch'
    | 'GcpSecretManager'
    | 'AzureArtifacts'
    | 'Tas'
    | 'Spot'
    | 'Bamboo'
    | 'TerraformCloud'
    | 'SignalFX'
    | 'Harness'
    | 'Rancher'
  )[]
}

export interface ConnectorInfoDTO {
  accountIdentifier?: string
  description?: string
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  spec: ConnectorConfigDTO
  tags?: {
    [key: string]: string
  }
  type:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Azure'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
    | 'ErrorTracking'
    | 'Pdc'
    | 'AzureRepo'
    | 'Jenkins'
    | 'OciHelmRepo'
    | 'CustomSecretManager'
    | 'ElasticSearch'
    | 'GcpSecretManager'
    | 'AzureArtifacts'
    | 'Tas'
    | 'Spot'
    | 'Bamboo'
    | 'TerraformCloud'
    | 'SignalFX'
    | 'Harness'
    | 'Rancher'
}

export type ConnectorInternalFilterProperties = FilterProperties & {
  accountIdentifiers?: string[]
  ccmConnectorFilter?: CcmConnectorFilter
  connectivityStatuses?: ('SUCCESS' | 'FAILURE' | 'PARTIAL' | 'UNKNOWN')[]
  types?: (
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Azure'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
    | 'ErrorTracking'
    | 'Pdc'
    | 'AzureRepo'
    | 'Jenkins'
    | 'OciHelmRepo'
    | 'CustomSecretManager'
    | 'ElasticSearch'
    | 'GcpSecretManager'
    | 'AzureArtifacts'
    | 'Tas'
    | 'Spot'
    | 'Bamboo'
    | 'TerraformCloud'
    | 'SignalFX'
    | 'Harness'
    | 'Rancher'
  )[]
}

export interface ConnectorResponse {
  activityDetails?: ConnectorActivityDetails
  connector?: ConnectorInfoDTO
  createdAt?: number
  entityValidityDetails?: EntityValidityDetails
  gitDetails?: EntityGitDetails
  governanceMetadata?: GovernanceMetadata
  harnessManaged?: boolean
  isFavorite?: boolean
  lastModifiedAt?: number
  status?: ConnectorConnectivityDetails
}

export type ConnectorSettings = AccountSettingConfig & {
  builtInSMDisabled?: boolean
}

export interface ConnectorStatistics {
  statusStats?: ConnectorStatusStatistics[]
  typeStats?: ConnectorTypeStatistics[]
}

export interface ConnectorStatusStatistics {
  count?: number
  status?: 'SUCCESS' | 'FAILURE' | 'PARTIAL' | 'UNKNOWN'
}

export interface ConnectorTypeStatistics {
  count?: number
  type?:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Azure'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
    | 'ErrorTracking'
    | 'Pdc'
    | 'AzureRepo'
    | 'Jenkins'
    | 'OciHelmRepo'
    | 'CustomSecretManager'
    | 'ElasticSearch'
    | 'GcpSecretManager'
    | 'AzureArtifacts'
    | 'Tas'
    | 'Spot'
    | 'Bamboo'
    | 'TerraformCloud'
    | 'SignalFX'
    | 'Harness'
    | 'Rancher'
}

export type ConnectorValidationErrorMetadataDTO = ErrorMetadataDTO & {
  taskId?: string
}

export interface ConnectorValidationResult {
  delegateId?: string
  errorSummary?: string
  errors?: ErrorDetail[]
  status?: 'SUCCESS' | 'FAILURE' | 'PARTIAL' | 'UNKNOWN'
  taskId?: string
  testedAt?: number
}

export interface ContainerInfraYamlSpec {
  annotations?: {
    [key: string]: string
  }
  automountServiceAccountToken?: boolean
  connectorRef: string
  containerSecurityContext?: SecurityContext
  harnessImageConnectorRef?: string
  hostNames?: string[]
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  initTimeout?: string
  labels?: {
    [key: string]: string
  }
  namespace: string
  nodeSelector?: {
    [key: string]: string
  }
  os?: 'Linux' | 'MacOS' | 'Windows'
  priorityClassName?: string
  resources?: ContainerResource
  runAsUser?: number
  serviceAccountName?: string
  tolerations?: Toleration[]
  volumes?: CIVolume[]
}

export interface ContainerResource {
  limits: Limits
}

export interface ContextElement {
  elementType?:
    | 'SERVICE'
    | 'INFRAMAPPING'
    | 'SERVICE_TEMPLATE'
    | 'TAG'
    | 'SHELL'
    | 'HOST'
    | 'INSTANCE'
    | 'STANDARD'
    | 'PARAM'
    | 'PARTITION'
    | 'OTHER'
    | 'FORK'
    | 'CONTAINER_SERVICE'
    | 'CLUSTER'
    | 'AWS_LAMBDA_FUNCTION'
    | 'AMI_SERVICE_SETUP'
    | 'AMI_SERVICE_DEPLOY'
    | 'ECS_SERVICE_SETUP'
    | 'AMI_SWITCH_ROUTES'
    | 'PCF_SERVICE_SETUP'
    | 'PCF_SERVICE_DEPLOY'
    | 'PCF_ROUTE_SWAP_ROLLBACK'
    | 'PCF_INSTANCE'
    | 'SPOTINST_SERVICE_SETUP'
    | 'SPOTINST_SERVICE_DEPLOY'
    | 'ARTIFACT'
    | 'ARTIFACT_VARIABLE'
    | 'HELM_DEPLOY'
    | 'CLOUD_FORMATION_PROVISION'
    | 'CLOUD_FORMATION_ROLLBACK'
    | 'CLOUD_FORMATION_DEPROVISION'
    | 'TERRAFORM_PROVISION'
    | 'SHELL_SCRIPT_PROVISION'
    | 'K8S'
    | 'TERRAFORM_INHERIT_PLAN'
    | 'TERRAGRUNT_INHERIT_PLAN'
    | 'AZURE_VMSS_SETUP'
    | 'AZURE_WEBAPP_SETUP'
    | 'HELM_CHART'
    | 'MANIFEST_VARIABLE'
    | 'RANCHER_K8S_CLUSTER_CRITERIA'
  name?: string
  uuid?: string
}

export type CopyCommandUnitSpec = CommandUnitBaseSpec & {
  destinationPath: string
  sourceType: 'Artifact' | 'Config'
}

export type CountCapacitySpec = CapacitySpec & {
  count: number
}

export interface CountGroupedOnArtifact {
  artifact?: string
  artifactPath?: string
  artifactVersion?: string
  count?: number
  executionCountGroupedOnStatusList?: CountGroupedOnStatus[]
}

export interface CountGroupedOnService {
  count?: number
  executionCountGroupedOnArtifactList?: CountGroupedOnArtifact[]
  executionCountGroupedOnStatusList?: CountGroupedOnStatus[]
  serviceName?: string
  serviceReference?: string
}

export interface CountGroupedOnStatus {
  count?: number
  status?: string
}

export type CountInstanceSelection = InstanceSelectionBase & {
  count?: ParameterFieldString
}

export interface CreatePRDTO {
  prNumber?: number
}

export interface CreatePRRequest {
  connectorRef?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repoName?: string
  sourceBranchName?: string
  targetBranchName?: string
  title?: string
}

export interface CreatePRResponse {
  prNumber?: number
}

export interface CreditCardDTO {
  accountIdentifier: string
  creditCardIdentifier: string
}

export interface CreditCardResponse {
  createdAt?: number
  creditCardDTO: CreditCardDTO
  lastUpdatedAt?: number
}

export interface CreditCardValidationResponse {
  valid?: boolean
}

export interface CreditDTO {
  accountIdentifier?: string
  creditStatus?: 'ACTIVE' | 'EXPIRED'
  creditType?: 'PAID' | 'FREE'
  expiryTime?: number
  id?: string
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  purchaseTime?: number
  quantity?: number
}

export interface CrossAccountAccess {
  crossAccountRoleArn: string
  externalId?: string
}

export interface CurrentOrUpcomingWindow {
  endTime?: number
  startTime?: number
}

export type CustomArtifactConfig = ArtifactConfig & {
  delegateSelectors?: string[]
  inputs?: NGVariable[]
  metadata?: string
  scripts?: CustomArtifactScripts
  timeout?: string
  version: string
  versionRegex?: string
}

export interface CustomArtifactScriptInfo {
  shell: 'Bash' | 'PowerShell'
  source: CustomArtifactScriptSourceWrapper
}

export interface CustomArtifactScriptSourceWrapper {
  spec: CustomScriptBaseSource
  type: string
}

export interface CustomArtifactScripts {
  fetchAllArtifacts: FetchAllArtifacts
}

export type CustomArtifactSummary = ArtifactSummary & {
  version?: string
}

export type CustomDeploymentConnectorNGVariable = CustomDeploymentNGVariable & {
  name?: string
  type?: 'Connector'
  value: string
}

export interface CustomDeploymentInfraResponse {
  obsolete: boolean
}

export type CustomDeploymentInfrastructure = Infrastructure & {
  customDeploymentRef: StepTemplateRef
  metadata?: string
  provisioner?: string
  variables?: CustomDeploymentNGVariable[]
}

export type CustomDeploymentInstanceInfoDTO = InstanceInfoDTO & {
  infrastructureKey: string
  instanceName: string
  properties?: {
    [key: string]: { [key: string]: any }
  }
}

export type CustomDeploymentMetaData = DeploymentMetaData & { [key: string]: any }

export interface CustomDeploymentNGVariable {
  description?: string
  name?: string
  required?: boolean
  type?: 'String' | 'Number' | 'Secret' | 'Connector'
}

export type CustomDeploymentNumberNGVariable = CustomDeploymentNGVariable & {
  name?: string
  type?: 'Number'
  value: number
}

export interface CustomDeploymentRefreshYaml {
  refreshedYaml: string
}

export type CustomDeploymentSecretNGVariable = CustomDeploymentNGVariable & {
  name?: string
  type?: 'Secret'
  value: string
}

export type CustomDeploymentServiceSpec = ServiceSpec & {
  customDeploymentRef: StepTemplateRef
}

export type CustomDeploymentStringNGVariable = CustomDeploymentNGVariable & {
  name?: string
  type?: 'String'
  value: string
}

export interface CustomDeploymentVariableProperties {
  aliasFqn?: string
  fqn: string
  localName?: string
  variableName: string
  visible?: boolean
}

export interface CustomDeploymentVariableResponse {
  metadataMap: {
    [key: string]: CustomDeploymentVariableProperties
  }
  yaml: string
}

export interface CustomDeploymentYaml {
  yaml: string
}

export interface CustomDeploymentYamlRequest {
  entityYaml: string
}

export type CustomHealthConnectorDTO = ConnectorConfigDTO & {
  baseURL: string
  delegateSelectors?: string[]
  headers?: CustomHealthKeyAndValue[]
  method: 'GET' | 'POST'
  params?: CustomHealthKeyAndValue[]
  validationBody?: string
  validationPath?: string
}

export interface CustomHealthKeyAndValue {
  encryptedValueRef?: string
  key: string
  value?: string
  valueEncrypted?: boolean
}

export type CustomRemoteStoreConfig = StoreConfig & {
  delegateSelectors?: string[]
  extractionScript: string
  filePath: string
}

export type CustomRestrictionDTO = RestrictionDTO & { [key: string]: any }

export type CustomRestrictionMetadataDTO = RestrictionMetadataDTO & {}

export interface CustomScriptBaseSource {
  type?: string
}

export interface CustomScriptInfo {
  delegateSelector?: TaskSelectorYaml[]
  inputs?: NGVariable[]
  runtimeInputYaml?: string
  script: string
}

export type CustomScriptInlineSource = CustomScriptBaseSource & {
  script?: string
}

export type CustomSecretManager = ConnectorConfigDTO & {
  connectorRef?: string
  default?: boolean
  delegateSelectors?: string[]
  host?: string
  onDelegate?: boolean
  template: TemplateLinkConfigForCustomSecretManager
  workingDirectory?: string
}

export interface CustomSequenceDTO {
  envAndEnvGroupCardList?: EnvAndEnvGroupCard[]
}

export type CustomStageConfig = StageInfoConfig & {
  environment?: EnvironmentYamlV2
  execution: ExecutionElementConfig
  metadata?: string
}

export interface CustomerDTO {
  address?: AddressDto
  billingEmail?: string
  companyName?: string
  defaultPaymentMethod?: string
}

export interface CustomerDetailDTO {
  address?: AddressDto
  billingEmail?: string
  companyName?: string
  customerId?: string
  defaultSource?: string
}

export interface DOMConfiguration {
  parameterNames?: DOMStringList
}

export interface DOMImplementation {
  [key: string]: any
}

export interface DOMStringList {
  length?: number
}

export interface DashboardExecutionStatusInfo {
  active?: ExecutionStatusInfo[]
  failure?: ExecutionStatusInfo[]
  pending?: ExecutionStatusInfo[]
}

export interface DashboardWorkloadDeployment {
  workloadDeploymentInfoList?: WorkloadDeploymentInfo[]
}

export interface DashboardWorkloadDeploymentV2 {
  workloadDeploymentInfoList?: WorkloadDeploymentInfoV2[]
}

export type DatadogConnectorDTO = ConnectorConfigDTO & {
  apiKeyRef: string
  applicationKeyRef: string
  delegateSelectors?: string[]
  url: string
}

export interface DefaultBranchCacheResponse {
  defaultBranch?: string
  repo?: string
}

export interface DelegateConfiguration {
  action?: 'SELF_DESTRUCT'
  delegateVersions?: string[]
  validTillNextRelease?: boolean
  validUntil?: number
}

export interface DelegateConnectionDetails {
  lastGrpcHeartbeat?: number
  lastHeartbeat?: number
  uuid?: string
  version?: string
}

export interface DelegateDeleteResponse {
  responseMsg?: string
}

export interface DelegateDownloadRequest {
  clusterPermissionType?: 'CLUSTER_ADMIN' | 'CLUSTER_VIEWER' | 'NAMESPACE_ADMIN'
  customClusterNamespace?: string
  description?: string
  name: string
  size?: 'LAPTOP' | 'SMALL' | 'MEDIUM' | 'LARGE'
  tags?: string[]
  tokenName?: string
}

export interface DelegateEntityOwner {
  identifier?: string
}

export interface DelegateFilterProperties {
  delegateGroupIdentifier?: string
  delegateInstanceFilter?: 'EXPIRED' | 'AVAILABLE'
  delegateName?: string
  delegateTags?: string[]
  delegateType?: string
  description?: string
  filterType?:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
    | 'Trigger'
    | 'EnvironmentGroup'
    | 'FileStore'
    | 'CCMRecommendation'
    | 'Anomaly'
    | 'Environment'
    | 'RuleExecution'
    | 'Override'
    | 'InputSet'
  hostName?: string
  labels?: {
    [key: string]: string
  }
  status?: 'CONNECTED' | 'DISCONNECTED' | 'ENABLED' | 'WAITING_FOR_APPROVAL' | 'DISABLED' | 'DELETED'
  tags?: {
    [key: string]: string
  }
}

export interface DelegateGroup {
  accountId?: string
  delegateConfigurationId?: string
  delegateExpiryAlertNextIteration?: number
  delegateType?: string
  delegatesExpireOn?: number
  description?: string
  identifier?: string
  k8sConfigDetails?: K8sConfigDetails
  name?: string
  ng?: boolean
  owner?: DelegateEntityOwner
  runnerTypes?: string[]
  sizeDetails?: DelegateSizeDetails
  status?: 'ENABLED' | 'DELETED'
  tags?: string[]
  upgraderLastUpdated?: number
  uuid: string
  validUntil?: string
}

export interface DelegateGroupDTO {
  accountIdentifier?: string
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: string[]
}

export interface DelegateGroupDetails {
  activelyConnected?: boolean
  autoUpgrade?: 'ON' | 'OFF' | 'DETECTING'
  connectivityStatus?: string
  delegateConfigurationId?: string
  delegateDescription?: string
  delegateGroupExpirationTime?: number
  delegateGroupIdentifier?: string
  delegateInstanceDetails?: DelegateInner[]
  delegateType?: string
  delegateVersion?: string
  groupCustomSelectors?: string[]
  groupId?: string
  groupImplicitSelectors?: {
    [key: string]:
      | 'PROFILE_NAME'
      | 'DELEGATE_NAME'
      | 'HOST_NAME'
      | 'GROUP_NAME'
      | 'GROUP_SELECTORS'
      | 'PROFILE_SELECTORS'
  }
  groupName?: string
  groupVersion?: string
  grpcActive?: boolean
  immutable?: boolean
  lastHeartBeat?: number
  tokenActive?: boolean
  upgraderLastUpdated?: number
}

export interface DelegateGroupListing {
  delegateGroupDetails?: DelegateGroupDetails[]
}

export interface DelegateGroupTags {
  tags?: string[]
}

export interface DelegateInner {
  activelyConnected?: boolean
  connections?: DelegateConnectionDetails[]
  delegateExpirationTime?: number
  hostName?: string
  lastHeartbeat?: number
  tokenActive?: boolean
  uuid?: string
  version?: string
}

export interface DelegateListResponse {
  autoUpgrade?: 'ON' | 'OFF' | 'DETECTING'
  connected?: boolean
  delegateReplicas?: DelegateReplica[]
  description?: string
  lastHeartBeat?: number
  legacy?: boolean
  name?: string
  tags?: string[]
  type?: string
}

export interface DelegateMetaInfo {
  host_name?: string
  id?: string
}

export interface DelegateProfileDetailsNg {
  accountId?: string
  approvalRequired?: boolean
  createdAt?: number
  createdBy?: EmbeddedUserDetails
  description?: string
  identifier?: string
  lastUpdatedAt?: number
  lastUpdatedBy?: EmbeddedUserDetails
  name?: string
  numberOfDelegates?: number
  orgIdentifier?: string
  primary?: boolean
  projectIdentifier?: string
  scopingRules?: ScopingRuleDetailsNg[]
  selectors?: string[]
  startupScript?: string
  uuid?: string
}

export interface DelegateProfileFilterProperties {
  approvalRequired?: boolean
  description?: string
  filterType?:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
    | 'Trigger'
    | 'EnvironmentGroup'
    | 'FileStore'
    | 'CCMRecommendation'
    | 'Anomaly'
    | 'Environment'
    | 'RuleExecution'
    | 'Override'
    | 'InputSet'
  identifier?: string
  labels?: {
    [key: string]: string
  }
  name?: string
  selectors?: string[]
  tags?: {
    [key: string]: string
  }
}

export interface DelegateReplica {
  connected?: boolean
  expiringAt?: number
  hostName?: string
  lastHeartbeat?: number
  uuid?: string
  version?: string
}

export interface DelegateResponseData {
  [key: string]: any
}

export interface DelegateSetupDetails {
  delegateConfigurationId?: string
  delegateType: string
  description?: string
  hostName?: string
  identifier?: string
  k8sConfigDetails?: K8sConfigDetails
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  runAsRoot?: boolean
  size?: 'LAPTOP' | 'SMALL' | 'MEDIUM' | 'LARGE'
  tags?: string[]
  tokenName?: string
  version?: string
}

export interface DelegateSizeDetails {
  cpu?: number
  label?: string
  ram?: number
  replicas?: number
  size?: 'LAPTOP' | 'SMALL' | 'MEDIUM' | 'LARGE'
}

export interface DelegateTokenDetails {
  accountId?: string
  createdAt?: number
  createdBy?: EmbeddedUser
  createdByNgUser?: Principal
  name?: string
  ownerIdentifier?: string
  revokeAfter?: number
  status?: 'ACTIVE' | 'REVOKED'
  uuid?: string
  value?: string
}

export interface DeleteInstancesRequest {
  deletedCount?: number
  status?: boolean
}

export type DeleteManifestPathSpec = DeleteResourcesBaseSpec & {
  allManifestPaths?: boolean
  manifestPaths?: string[]
}

export type DeleteReleaseNameSpec = DeleteResourcesBaseSpec & {
  deleteNamespace?: boolean
}

export type DeleteResourceNameSpec = DeleteResourcesBaseSpec & {
  resourceNames: string[]
}

export interface DeleteResourcesBaseSpec {
  [key: string]: any
}

export interface DeleteResourcesWrapper {
  spec?: DeleteResourcesBaseSpec
  type?: 'ResourceName' | 'ReleaseName' | 'ManifestPath'
}

export interface Deployment {
  count?: number
}

export interface DeploymentChangeRates {
  failureRate?: number
  failureRateChangeRate?: number
  frequency?: number
  frequencyChangeRate?: number
}

export interface DeploymentChangeRatesV2 {
  failureRate?: number
  failureRateChangeRate?: ChangeRate
  frequency?: number
  frequencyChangeRate?: ChangeRate
}

export interface DeploymentCount {
  failure?: number
  success?: number
  total?: number
}

export interface DeploymentDateAndCount {
  deployments?: Deployment
  time?: number
}

export interface DeploymentDetails {
  [key: string]: any
}

export interface DeploymentInfo {
  count?: number
  countList?: DeploymentDateAndCount[]
  rate?: number
}

export interface DeploymentInfoV2 {
  count?: number
  countList?: DeploymentDateAndCount[]
  rate?: ChangeRate
}

export interface DeploymentMetaData {
  [key: string]: any
}

export interface DeploymentReleaseDetails {
  deploymentDetails?: DeploymentDetails[]
  deploymentType?: string
  taskInfoId?: string
}

export type DeploymentStageConfig = StageInfoConfig & {
  customDeploymentRef?: StepTemplateRef
  deploymentMetadata?: DeploymentMetaData
  deploymentType?:
    | 'Kubernetes'
    | 'NativeHelm'
    | 'Ssh'
    | 'WinRm'
    | 'ServerlessAwsLambda'
    | 'AzureWebApp'
    | 'CustomDeployment'
    | 'ECS'
    | 'Elastigroup'
    | 'TAS'
    | 'Asg'
    | 'GoogleCloudFunctions'
    | 'AwsLambda'
    | 'AWS_SAM'
  environment?: EnvironmentYamlV2
  environmentGroup?: EnvironmentGroupYaml
  environments?: EnvironmentsYaml
  execution: ExecutionElementConfig
  gitOpsEnabled?: boolean
  infrastructure?: PipelineInfrastructure
  service?: ServiceYamlV2
  serviceConfig?: ServiceConfig
  services?: ServicesYaml
}

export interface DeploymentStatsSummary {
  deploymentRate?: number
  deploymentRateChangeRate?: number
  failureRate?: number
  failureRateChangeRate?: number
  timeBasedDeploymentInfoList?: TimeBasedDeploymentInfo[]
  totalCount?: number
  totalCountChangeRate?: number
}

export interface DeploymentsInfo {
  deployments?: ExecutionStatusInfo[]
}

export interface DeveloperMappingDTO {
  accountIdentifier?: string
  developerCount?: number
  id?: string
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  secondaryEntitlement?: 'WORK_LOADS'
  secondaryEntitlementCount?: number
}

export type DockerArtifactSummary = ArtifactSummary & {
  imagePath?: string
  tag?: string
}

export interface DockerAuthCredentialsDTO {
  [key: string]: any
}

export interface DockerAuthenticationDTO {
  spec?: DockerAuthCredentialsDTO
  type: 'UsernamePassword' | 'Anonymous'
}

export interface DockerBuildDetailsDTO {
  buildUrl?: string
  imagePath?: string
  labels?: {
    [key: string]: string
  }
  metadata?: {
    [key: string]: string
  }
  tag?: string
}

export type DockerConnectorDTO = ConnectorConfigDTO & {
  auth?: DockerAuthenticationDTO
  delegateSelectors?: string[]
  dockerRegistryUrl: string
  executeOnDelegate?: boolean
  providerType: 'DockerHub' | 'Harbor' | 'Quay' | 'Other'
}

export type DockerHubArtifactConfig = ArtifactConfig & {
  connectorRef: string
  digest?: string
  imagePath: string
  tag?: string
  tagRegex?: string
}

export interface DockerRequestDTO {
  runtimeInputYaml?: string
  tag?: string
  tagRegex?: string
  tagsList?: string[]
}

export interface DockerResponseDTO {
  buildDetailsList?: DockerBuildDetailsDTO[]
}

export type DockerStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  buildArgs?: {
    [key: string]: string
  }
  cacheFrom?: string[]
  cacheTo?: string
  caching?: boolean
  connectorRef: string
  context?: string
  dockerfile?: string
  labels?: {
    [key: string]: string
  }
  optimize?: boolean
  remoteCacheRepo?: string
  repo: string
  resources?: ContainerResource
  runAsUser?: number
  tags: string[]
  target?: string
  version?: string
}

export type DockerUserNamePasswordDTO = DockerAuthCredentialsDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export interface Document {
  attributes?: NamedNodeMap
  baseURI?: string
  childNodes?: NodeList
  doctype?: DocumentType
  documentElement?: Element
  documentURI?: string
  domConfig?: DOMConfiguration
  firstChild?: Node
  implementation?: DOMImplementation
  inputEncoding?: string
  lastChild?: Node
  localName?: string
  namespaceURI?: string
  nextSibling?: Node
  nodeName?: string
  nodeType?: number
  nodeValue?: string
  ownerDocument?: Document
  parentNode?: Node
  prefix?: string
  previousSibling?: Node
  strictErrorChecking?: boolean
  textContent?: string
  xmlEncoding?: string
  xmlStandalone?: boolean
  xmlVersion?: string
}

export interface DocumentType {
  attributes?: NamedNodeMap
  baseURI?: string
  childNodes?: NodeList
  entities?: NamedNodeMap
  firstChild?: Node
  internalSubset?: string
  lastChild?: Node
  localName?: string
  name?: string
  namespaceURI?: string
  nextSibling?: Node
  nodeName?: string
  nodeType?: number
  nodeValue?: string
  notations?: NamedNodeMap
  ownerDocument?: Document
  parentNode?: Node
  prefix?: string
  previousSibling?: Node
  publicId?: string
  systemId?: string
  textContent?: string
}

export type DownloadArtifactCommandUnitSpec = CommandUnitBaseSpec & {
  destinationPath: string
}

export type DownloadManifestsStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type DurationRestrictionDTO = RestrictionDTO & {
  timeUnit?: TimeUnit
}

export type DurationRestrictionMetadataDTO = RestrictionMetadataDTO & {
  timeUnit?: TimeUnit
}

export type DynatraceConnectorDTO = ConnectorConfigDTO & {
  apiTokenRef: string
  delegateSelectors?: string[]
  url: string
}

export type ECRStepInfo = StepSpecType & {
  account: string
  baseImageConnectorRefs?: string[]
  buildArgs?: {
    [key: string]: string
  }
  cacheFrom?: string[]
  cacheTo?: string
  caching?: boolean
  connectorRef: string
  context?: string
  dockerfile?: string
  imageName: string
  labels?: {
    [key: string]: string
  }
  optimize?: boolean
  region: string
  remoteCacheImage?: string
  resources?: ContainerResource
  runAsUser?: number
  tags: string[]
  target?: string
  version?: string
}

export type ELKConnectorDTO = ConnectorConfigDTO & {
  apiKeyId?: string
  apiKeyRef?: string
  authType?: 'UsernamePassword' | 'ApiClientToken' | 'None' | 'Bearer Token(HTTP Header)'
  delegateSelectors?: string[]
  passwordRef?: string
  url: string
  username?: string
}

export interface EOLBannerRequestDTO {
  entityType?: string
  orgIdentifier?: string
  pipelineIdentifier?: string
  projectIdentifier?: string
  templateIdentifier?: string
  versionLabel?: string
}

export interface EOLBannerResponseDTO {
  failures?: string[]
  showBanner?: boolean
  stageIdentifiers?: string[]
}

export type EcrArtifactConfig = ArtifactConfig & {
  connectorRef: string
  digest?: string
  imagePath: string
  metadata?: string
  region: string
  registryId?: string
  tag?: string
  tagRegex?: string
}

export type EcrArtifactSummary = ArtifactSummary & {
  imagePath?: string
  tag?: string
}

export interface EcrBuildDetailsDTO {
  buildUrl?: string
  imagePath?: string
  labels?: {
    [key: string]: string
  }
  metadata?: {
    [key: string]: string
  }
  tag?: string
}

export interface EcrListImagesDTO {
  images?: string[]
}

export interface EcrRequestDTO {
  region?: string
  runtimeInputYaml?: string
  tag?: string
  tagRegex?: string
  tagsList?: string[]
}

export interface EcrResponseDTO {
  buildDetailsList?: EcrBuildDetailsDTO[]
}

export type EcsBasicRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type EcsBlueGreenCreateServiceStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  enableAutoScalingInSwapStep?: boolean
  loadBalancer: string
  prodListener: string
  prodListenerRuleArn: string
  sameAsAlreadyRunningInstances?: boolean
  stageListener: string
  stageListenerRuleArn: string
  updateGreenService?: boolean
}

export type EcsBlueGreenRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type EcsBlueGreenSwapTargetGroupsStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  doNotDownsizeOldService?: boolean
  downsizeOldServiceDelayInSecs?: number
}

export type EcsCanaryDeleteStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type EcsCanaryDeployStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export interface EcsContainer {
  containerArn?: string
  image?: string
  name?: string
  runtimeId?: string
}

export type EcsDeploymentMetaData = DeploymentMetaData & { [key: string]: any }

export type EcsInfrastructure = Infrastructure & {
  cluster: string
  connectorRef: string
  metadata?: string
  provisioner?: string
  region: string
}

export type EcsInfrastructureDetails = InfrastructureDetails & {
  cluster?: string
  region?: string
}

export type EcsInstanceInfoDTO = InstanceInfoDTO & {
  clusterArn: string
  containers: EcsContainer[]
  infraStructureKey?: string
  launchType?: string
  region: string
  serviceName: string
  startedAt?: number
  startedBy?: string
  taskArn: string
  taskDefinitionArn: string
  version?: number
}

export type EcsRollingDeployStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  forceNewDeployment?: boolean
  sameAsAlreadyRunningInstances?: boolean
}

export type EcsRollingRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type EcsRunTaskStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  runTaskRequestDefinition: StoreConfigWrapper
  skipSteadyStateCheck?: boolean
  taskDefinition?: StoreConfigWrapper
  taskDefinitionArn?: string
}

export type EcsScalableTargetDefinitionManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export type EcsScalingPolicyDefinitionManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export type EcsServiceDefinitionManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export type EcsServiceSetupStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  resizeStrategy?: string
  sameAsAlreadyRunningInstances?: boolean
}

export type EcsServiceSpec = ServiceSpec & {
  ecsTaskDefinitionArn?: string
}

export type EcsTaskDefinitionManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export type EcsUpgradeContainerStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  downsizeOldServiceInstanceCount?: number
  downsizeOldServiceInstanceUnit?: string
  newServiceInstanceCount: number
  newServiceInstanceUnit: string
}

export interface EditionActionDTO {
  action?:
    | 'START_FREE'
    | 'START_TRIAL'
    | 'EXTEND_TRIAL'
    | 'SUBSCRIBE'
    | 'UPGRADE'
    | 'CONTACT_SALES'
    | 'CONTACT_SUPPORT'
    | 'MANAGE'
    | 'DISABLED_BY_TEAM'
    | 'DISABLED_BY_ENTERPRISE'
  reason?: string
}

export type ElastiGroupDeploymentMetaData = DeploymentMetaData & { [key: string]: any }

export type ElastigroupBGStageSetupStepInfo = StepSpecType & {
  connectedCloudProvider: CloudProvider
  delegateSelectors?: string[]
  instances: ElastigroupInstances
  loadBalancers: LoadBalancer[]
  name?: string
}

export interface ElastigroupConfiguration {
  metadata?: string
  store: StoreConfigWrapper
}

export type ElastigroupCurrentRunningInstances = ElastigroupInstancesSpec & { [key: string]: any }

export type ElastigroupDeployStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  metadata?: string
  newService: Capacity
  oldService?: Capacity
}

export type ElastigroupFixedInstances = ElastigroupInstancesSpec & {
  desired: number
  max: number
  min: number
}

export type ElastigroupInfrastructure = Infrastructure & {
  configuration: ElastigroupConfiguration
  connectorRef: string
  metadata?: string
  provisioner?: string
}

export interface ElastigroupInstances {
  spec?: ElastigroupInstancesSpec
  type: 'Fixed' | 'CurrentRunning'
}

export interface ElastigroupInstancesSpec {
  type?: 'Fixed' | 'CurrentRunning'
}

export type ElastigroupRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  metadata?: string
}

export type ElastigroupServiceSpec = ServiceSpec & {
  startupScript?: StartupScriptConfiguration
}

export type ElastigroupSetupStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  instances: ElastigroupInstances
  name?: string
}

export type ElastigroupSwapRouteStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  downsizeOldElastigroup: boolean
}

export interface Element {
  attributes?: NamedNodeMap
  baseURI?: string
  childNodes?: NodeList
  firstChild?: Node
  lastChild?: Node
  localName?: string
  namespaceURI?: string
  nextSibling?: Node
  nodeName?: string
  nodeType?: number
  nodeValue?: string
  ownerDocument?: Document
  parentNode?: Node
  prefix?: string
  previousSibling?: Node
  schemaTypeInfo?: TypeInfo
  tagName?: string
  textContent?: string
}

export type EmailConfig = NotificationSettingConfig & {
  groupEmail?: string
  sendEmailToAllUsers?: boolean
}

export type EmailConfigDTO = NotificationSettingConfigDTO & {
  groupEmail: string
  sendEmailToAllUsers: boolean
}

export interface EmbeddedUser {
  email?: string
  externalUserId?: string
  name?: string
  uuid?: string
}

export interface EmbeddedUserDetails {
  email?: string
  name?: string
  uuid?: string
}

export interface EmbeddedUserDetailsDTO {
  email?: string
  name?: string
}

export type EmptyDirYaml = CIVolume & {
  mountPath: string
  spec: EmptyDirYamlSpec
  type: 'EmptyDir' | 'PersistentVolumeClaim' | 'HostPath'
}

export interface EmptyDirYamlSpec {
  medium?: string
  size?: string
}

export interface EncryptionInterface {
  [key: string]: any
}

export interface EntityDetail {
  entityGitMetadata?: EntityGitMetadata
  entityRef?: EntityReference
  name?: string
  type?:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
}

export interface EntityDetailProtoDTO {
  [key: string]: any
}

export interface EntityGitDetails {
  branch?: string
  commitId?: string
  filePath?: string
  fileUrl?: string
  objectId?: string
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  repoIdentifier?: string
  repoName?: string
  repoUrl?: string
  rootFolder?: string
}

export interface EntityGitMetadata {
  branch?: string
  repo?: string
}

export interface EntityReference {
  accountIdentifier?: string
  branch?: string
  default?: boolean
  identifier?: string
  metadata?: {
    [key: string]: string
  }
  orgIdentifier?: string
  projectIdentifier?: string
  repoIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export type EntityReferredByInfraSetupUsageDetail = SetupUsageDetail & {
  environmentIdentifier?: string
  environmentName?: string
}

export type EntityReferredByPipelineSetupUsageDetail = SetupUsageDetail & {
  identifier?: string
  referenceType?: string
}

export interface EntitySetupUsageDTO {
  accountIdentifier?: string
  createdAt?: number
  detail?: SetupUsageDetail
  referredByEntity: EntityDetail
  referredEntity?: EntityDetail
}

export interface EntityValidityDetails {
  invalidYaml?: string
  valid?: boolean
}

export interface EntityWithGitInfo {
  branch?: string
  ref: string
}

export interface EnvAndEnvGroupCard {
  envGroup?: boolean
  environmentTypes?: ('PreProduction' | 'Production')[]
  identifier?: string
  name?: string
  new?: boolean
}

export interface EnvBuildIdAndInstanceCountInfo {
  buildIdAndInstanceCountList?: BuildIdAndInstanceCount[]
  envId?: string
  envName?: string
}

export interface EnvBuildIdAndInstanceCountInfoList {
  envBuildIdAndInstanceCountInfoList?: EnvBuildIdAndInstanceCountInfo[]
}

export interface EnvCount {
  newCount?: number
  totalCount?: number
}

export type EnvFilter = Filter & {
  filterTypes?: string[]
}

export interface EnvIdCountPair {
  count?: number
  envId?: string
}

export interface EnvSwaggerObjectWrapper {
  envFilterEntityType?: 'infrastructures' | 'gitOpsClusters' | 'environments'
  serviceOverrideConfig?: NGServiceOverrideConfig
}

export interface Environment {
  envGroupIdentifier?: string
  envGroupName?: string
  identifier?: string
  name?: string
  type?: string
}

export interface EnvironmentAndServiceOverridesMetadataInput {
  entityWithGitInfoList?: EntityWithGitInfo[]
  envGroupIdentifier?: string
  serviceIdentifiers: string[]
}

export interface EnvironmentDeploymentInfo {
  environmentInfoByServiceId?: EnvironmentInfoByServiceId[]
}

export interface EnvironmentDeploymentsInfo {
  envId?: string
  envName?: string
  envType?: string
  infrastructureDetails?: InfrastructureInfo[]
}

export interface EnvironmentFilterProperties {
  description?: string
  environmentIdentifiers?: string[]
  environmentNames?: string[]
  environmentTypes?: ('PreProduction' | 'Production')[]
  filterType?:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
    | 'Trigger'
    | 'EnvironmentGroup'
    | 'FileStore'
    | 'CCMRecommendation'
    | 'Anomaly'
    | 'Environment'
    | 'RuleExecution'
    | 'Override'
    | 'InputSet'
  labels?: {
    [key: string]: string
  }
  tags?: {
    [key: string]: string
  }
}

export interface EnvironmentGroupDeleteResponse {
  accountId?: string
  deleted?: boolean
  identifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type EnvironmentGroupFilterProperties = FilterProperties & {
  description?: string
  envGroupName?: string
  envGroupTags?: NGTag[]
  envIdentifiers?: string[]
}

export interface EnvironmentGroupInstanceDetail {
  artifactDeploymentDetails?: ArtifactDeploymentDetail[]
  count?: number
  environmentTypes?: ('PreProduction' | 'Production')[]
  id: string
  isDrift: boolean
  isEnvGroup: boolean
  isRevert?: boolean
  isRollback?: boolean
  name?: string
}

export interface EnvironmentGroupInstanceDetails {
  environmentGroupInstanceDetails: EnvironmentGroupInstanceDetail[]
}

export interface EnvironmentGroupMetadata {
  parallel?: boolean
}

export interface EnvironmentGroupRequestDTO {
  color?: string
  identifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  yaml: string
}

export interface EnvironmentGroupResponse {
  createdAt?: number
  envGroup?: EnvironmentGroupResponseDTO
  lastModifiedAt?: number
}

export interface EnvironmentGroupResponseDTO {
  accountId?: string
  color?: string
  deleted?: boolean
  description?: string
  envIdentifiers?: string[]
  envResponse?: EnvironmentResponse[]
  gitDetails?: EntityGitDetails
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
  yaml?: string
}

export interface EnvironmentGroupYaml {
  __uuid?: string
  deployToAll?: boolean
  envGroupRef: string
  environments?: EnvironmentYamlV2[]
  filters?: FilterYaml[]
  metadata?: EnvironmentGroupMetadata
}

export interface EnvironmentInfoByServiceId {
  artifactImage?: string
  environmentId?: string
  environmentName?: string
  serviceId?: string
  serviceName?: string
  service_endTs?: number
  service_startTs?: number
  tag?: string
}

export interface EnvironmentInfraUseFromStage {
  metadata?: string
  stage: string
}

export interface EnvironmentInputsMergedResponseDto {
  environmentYaml?: string
  mergedEnvironmentInputsYaml?: string
}

export interface EnvironmentInputsetYamlAndServiceOverridesMetadata {
  connectorRef?: string
  entityGitDetails?: EntityGitDetails
  envRef?: string
  envRuntimeInputYaml?: string
  envYaml?: string
  fallbackBranch?: string
  orgIdentifier?: string
  projectIdentifier?: string
  servicesOverrides?: ServiceOverridesMetadata[]
  storeType?: 'INLINE' | 'REMOTE'
}

export interface EnvironmentInputsetYamlAndServiceOverridesMetadataInput {
  envGroupIdentifier?: string
  envIdentifiers?: string[]
  serviceIdentifiers: string[]
}

export interface EnvironmentRequestDTO {
  color?: string
  description?: string
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
  type: 'PreProduction' | 'Production'
  yaml?: string
}

export interface EnvironmentResponse {
  createdAt?: number
  environment?: EnvironmentResponseDTO
  lastModifiedAt?: number
}

export interface EnvironmentResponseDTO {
  accountId?: string
  cacheResponseMetadataDTO?: CacheResponseMetadata
  color?: string
  connectorRef?: string
  deleted?: boolean
  description?: string
  entityGitDetails?: EntityGitDetails
  fallbackBranch?: string
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  storeType?: 'INLINE' | 'REMOTE'
  tags?: {
    [key: string]: string
  }
  type?: 'PreProduction' | 'Production'
  yaml?: string
}

export interface EnvironmentYaml {
  description?: string
  identifier: string
  name: string
  tags?: {
    [key: string]: string
  }
  type: 'PreProduction' | 'Production'
}

export interface EnvironmentYamlMetadataDTO {
  environmentsInputYamlAndServiceOverrides?: EnvironmentInputsetYamlAndServiceOverridesMetadata[]
}

export interface EnvironmentYamlV2 {
  deployToAll?: boolean
  environmentInputs?: JsonNode
  environmentRef?: string
  filters?: FilterYaml[]
  gitBranch?: string
  gitOpsClusters?: ClusterYaml[]
  infrastructureDefinition?: InfraStructureDefinitionYaml
  infrastructureDefinitions?: InfraStructureDefinitionYaml[]
  provisioner?: ExecutionElementConfig
  serviceOverrideInputs?: JsonNode
  servicesOverrides?: ServiceOverrideInputsYaml[]
  useFromStage?: EnvironmentInfraUseFromStage
}

export interface EnvironmentsMetadata {
  parallel?: boolean
}

export interface EnvironmentsYaml {
  filters?: FilterYaml[]
  metadata?: EnvironmentsMetadata
  values?: EnvironmentYamlV2[]
}

export interface Error {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'ACCOUNT_MIGRATED_TO_NEXT_GEN'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'SCM_REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_INTERRUPT_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SPOTNIST_REST_EXCEPTION'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'MISSING_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
    | 'ABORT_ALL_ALREADY_NG'
  correlationId?: string
  detailedMessage?: string
  message?: string
  metadata?: ErrorMetadataDTO
  responseMessages?: ResponseMessage[]
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ErrorDetail {
  code?: number
  message?: string
  reason?: string
}

export interface ErrorMetadata {
  errorCode?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'ACCOUNT_MIGRATED_TO_NEXT_GEN'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'SCM_REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_INTERRUPT_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SPOTNIST_REST_EXCEPTION'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'MISSING_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
    | 'ABORT_ALL_ALREADY_NG'
  errorMessage?: string
}

export interface ErrorMetadataDTO {
  type?: string
}

export interface ErrorNodeSummary {
  childrenErrorNodes?: ErrorNodeSummary[]
  nodeInfo?: NodeInfo
  templateInfo?: TemplateInfo
  templateResponse?: TemplateResponse
}

export type ErrorTrackingConnectorDTO = ConnectorConfigDTO & {
  apiKeyRef: string
  delegateSelectors?: string[]
  url: string
}

export type ExecutableElementsFilter = Filter & {
  executableElementFilterType?: string
  filter?: GenericEntityFilter
  filterTypes?: string[]
}

export interface ExecutionDataValue {
  displayName?: string
  value?: { [key: string]: any }
}

export interface ExecutionDeployment {
  deployments?: DeploymentCount
  time?: number
}

export interface ExecutionDeploymentInfo {
  executionDeploymentList?: ExecutionDeployment[]
}

export interface ExecutionElementConfig {
  rollbackSteps?: ExecutionWrapperConfig[]
  steps: ExecutionWrapperConfig[]
}

export interface ExecutionStatusInfo {
  author?: AuthorInfo
  endTs?: number
  environmentInfoList?: EnvironmentDeploymentsInfo[]
  gitInfo?: GitInfo
  orgIdentifier?: string
  pipelineIdentifier?: string
  pipelineName?: string
  planExecutionId?: string
  projectIdentifier?: string
  serviceInfoList?: ServiceDeploymentInfo[]
  startTs?: number
  status?: string
  triggerType?: string
}

export interface ExecutionWrapperConfig {
  parallel?: ParallelStepElementConfig
  step?: StepElementConfig
  stepGroup?: StepGroupElementConfig
}

export interface Failure {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'ACCOUNT_MIGRATED_TO_NEXT_GEN'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'SCM_REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_INTERRUPT_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SPOTNIST_REST_EXCEPTION'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'MISSING_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
    | 'ABORT_ALL_ALREADY_NG'
  correlationId?: string
  errors?: ValidationError[]
  message?: string
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface FailureStrategyActionConfig {
  type:
    | 'Ignore'
    | 'Retry'
    | 'MarkAsSuccess'
    | 'Abort'
    | 'StageRollback'
    | 'StepGroupRollback'
    | 'PipelineRollback'
    | 'ManualIntervention'
    | 'ProceedWithDefaultValues'
    | 'MarkAsFailure'
    | 'RetryStepGroup'
}

export interface FailureStrategyConfig {
  onFailure: OnFailureConfig
}

export interface FeatureRestrictionDetailListRequestDTO {
  names: (
    | 'TEST1'
    | 'TEST2'
    | 'TEST3'
    | 'TEST4'
    | 'TEST5'
    | 'TEST6'
    | 'TEST7'
    | 'PERSPECTIVES'
    | 'CCM_K8S_CLUSTERS'
    | 'CCM_AUTOSTOPPING_RULES'
    | 'MULTIPLE_ORGANIZATIONS'
    | 'MULTIPLE_PROJECTS'
    | 'MULTIPLE_SECRETS'
    | 'MULTIPLE_USER_GROUPS'
    | 'MULTIPLE_USERS'
    | 'MULTIPLE_SERVICE_ACCOUNTS'
    | 'MULTIPLE_VARIABLES'
    | 'MULTIPLE_CONNECTORS'
    | 'MULTIPLE_API_KEYS'
    | 'MULTIPLE_API_TOKENS'
    | 'INTEGRATED_APPROVALS_WITH_HARNESS_UI'
    | 'INTEGRATED_APPROVALS_WITH_CUSTOM_SCRIPT'
    | 'INTEGRATED_APPROVALS_WITH_JIRA'
    | 'SECRET_MANAGERS'
    | 'DEPLOYMENTS'
    | 'INITIAL_DEPLOYMENTS'
    | 'DEPLOYMENTS_PER_MONTH'
    | 'SERVICES'
    | 'BUILDS'
    | 'SAML_SUPPORT'
    | 'OAUTH_SUPPORT'
    | 'LDAP_SUPPORT'
    | 'TWO_FACTOR_AUTH_SUPPORT'
    | 'CUSTOM_ROLES'
    | 'CUSTOM_RESOURCE_GROUPS'
    | 'MAX_TOTAL_BUILDS'
    | 'MAX_BUILDS_PER_MONTH'
    | 'MAX_BUILDS_PER_DAY'
    | 'ACTIVE_COMMITTERS'
    | 'TEST_INTELLIGENCE'
    | 'TEMPLATE_SERVICE'
    | 'CACHE_SIZE_ALLOWANCE'
    | 'SRM_SERVICES'
    | 'ANALYZE_DEPLOYMENT_STEP'
    | 'TERRAFORM_APPLY'
    | 'TERRAFORM_PLAN'
    | 'TERRAFORM_DESTROY'
    | 'TERRAFORM_ROLLBACK'
    | 'INTEGRATED_APPROVALS_WITH_SERVICE_NOW'
    | 'CREATE_STACK'
    | 'DELETE_STACK'
    | 'ROLLBACK_STACK'
    | 'COMMAND'
    | 'AZURE_SLOT_DEPLOYMENT'
    | 'AZURE_TRAFFIC_SHIFT'
    | 'AZURE_SWAP_SLOT'
    | 'AZURE_WEBAPP_ROLLBACK'
    | 'JENKINS_BUILD'
    | 'AZURE_CREATE_ARM_RESOURCE'
    | 'AZURE_CREATE_BP_RESOURCE'
    | 'AZURE_ROLLBACK_ARM_RESOURCE'
    | 'SHELL_SCRIPT_PROVISION'
    | 'TERRAFORM_CLOUD_RUN'
    | 'TERRAFORM_CLOUD_ROLLBACK'
    | 'SECURITY'
    | 'DEVELOPERS'
    | 'MONTHLY_ACTIVE_USERS'
    | 'STRATEGY_MAX_CONCURRENT'
    | 'MAX_PARALLEL_STEP_IN_A_PIPELINE'
    | 'PIPELINE_EXECUTION_DATA_RETENTION_DAYS'
    | 'MAX_PIPELINE_TIMEOUT_SECONDS'
    | 'MAX_STAGE_TIMEOUT_SECONDS'
    | 'MAX_STEP_TIMEOUT_SECONDS'
    | 'MAX_CONCURRENT_ACTIVE_PIPELINE_EXECUTIONS'
    | 'MAX_CHAOS_EXPERIMENT_RUNS_PER_MONTH'
    | 'MAX_CHAOS_INFRASTRUCTURES'
    | 'TERRAGRUNT_PLAN'
    | 'TERRAGRUNT_APPLY'
    | 'TERRAGRUNT_DESTROY'
    | 'TERRAGRUNT_ROLLBACK'
    | 'SEI_MAX_NUMBER_OF_CONTRIBUTORS'
  )[]
}

export interface FeatureRestrictionDetailRequestDTO {
  name:
    | 'TEST1'
    | 'TEST2'
    | 'TEST3'
    | 'TEST4'
    | 'TEST5'
    | 'TEST6'
    | 'TEST7'
    | 'PERSPECTIVES'
    | 'CCM_K8S_CLUSTERS'
    | 'CCM_AUTOSTOPPING_RULES'
    | 'MULTIPLE_ORGANIZATIONS'
    | 'MULTIPLE_PROJECTS'
    | 'MULTIPLE_SECRETS'
    | 'MULTIPLE_USER_GROUPS'
    | 'MULTIPLE_USERS'
    | 'MULTIPLE_SERVICE_ACCOUNTS'
    | 'MULTIPLE_VARIABLES'
    | 'MULTIPLE_CONNECTORS'
    | 'MULTIPLE_API_KEYS'
    | 'MULTIPLE_API_TOKENS'
    | 'INTEGRATED_APPROVALS_WITH_HARNESS_UI'
    | 'INTEGRATED_APPROVALS_WITH_CUSTOM_SCRIPT'
    | 'INTEGRATED_APPROVALS_WITH_JIRA'
    | 'SECRET_MANAGERS'
    | 'DEPLOYMENTS'
    | 'INITIAL_DEPLOYMENTS'
    | 'DEPLOYMENTS_PER_MONTH'
    | 'SERVICES'
    | 'BUILDS'
    | 'SAML_SUPPORT'
    | 'OAUTH_SUPPORT'
    | 'LDAP_SUPPORT'
    | 'TWO_FACTOR_AUTH_SUPPORT'
    | 'CUSTOM_ROLES'
    | 'CUSTOM_RESOURCE_GROUPS'
    | 'MAX_TOTAL_BUILDS'
    | 'MAX_BUILDS_PER_MONTH'
    | 'MAX_BUILDS_PER_DAY'
    | 'ACTIVE_COMMITTERS'
    | 'TEST_INTELLIGENCE'
    | 'TEMPLATE_SERVICE'
    | 'CACHE_SIZE_ALLOWANCE'
    | 'SRM_SERVICES'
    | 'ANALYZE_DEPLOYMENT_STEP'
    | 'TERRAFORM_APPLY'
    | 'TERRAFORM_PLAN'
    | 'TERRAFORM_DESTROY'
    | 'TERRAFORM_ROLLBACK'
    | 'INTEGRATED_APPROVALS_WITH_SERVICE_NOW'
    | 'CREATE_STACK'
    | 'DELETE_STACK'
    | 'ROLLBACK_STACK'
    | 'COMMAND'
    | 'AZURE_SLOT_DEPLOYMENT'
    | 'AZURE_TRAFFIC_SHIFT'
    | 'AZURE_SWAP_SLOT'
    | 'AZURE_WEBAPP_ROLLBACK'
    | 'JENKINS_BUILD'
    | 'AZURE_CREATE_ARM_RESOURCE'
    | 'AZURE_CREATE_BP_RESOURCE'
    | 'AZURE_ROLLBACK_ARM_RESOURCE'
    | 'SHELL_SCRIPT_PROVISION'
    | 'TERRAFORM_CLOUD_RUN'
    | 'TERRAFORM_CLOUD_ROLLBACK'
    | 'SECURITY'
    | 'DEVELOPERS'
    | 'MONTHLY_ACTIVE_USERS'
    | 'STRATEGY_MAX_CONCURRENT'
    | 'MAX_PARALLEL_STEP_IN_A_PIPELINE'
    | 'PIPELINE_EXECUTION_DATA_RETENTION_DAYS'
    | 'MAX_PIPELINE_TIMEOUT_SECONDS'
    | 'MAX_STAGE_TIMEOUT_SECONDS'
    | 'MAX_STEP_TIMEOUT_SECONDS'
    | 'MAX_CONCURRENT_ACTIVE_PIPELINE_EXECUTIONS'
    | 'MAX_CHAOS_EXPERIMENT_RUNS_PER_MONTH'
    | 'MAX_CHAOS_INFRASTRUCTURES'
    | 'TERRAGRUNT_PLAN'
    | 'TERRAGRUNT_APPLY'
    | 'TERRAGRUNT_DESTROY'
    | 'TERRAGRUNT_ROLLBACK'
    | 'SEI_MAX_NUMBER_OF_CONTRIBUTORS'
}

export interface FeatureRestrictionDetailsDTO {
  allowed?: boolean
  description?: string
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  name?:
    | 'TEST1'
    | 'TEST2'
    | 'TEST3'
    | 'TEST4'
    | 'TEST5'
    | 'TEST6'
    | 'TEST7'
    | 'PERSPECTIVES'
    | 'CCM_K8S_CLUSTERS'
    | 'CCM_AUTOSTOPPING_RULES'
    | 'MULTIPLE_ORGANIZATIONS'
    | 'MULTIPLE_PROJECTS'
    | 'MULTIPLE_SECRETS'
    | 'MULTIPLE_USER_GROUPS'
    | 'MULTIPLE_USERS'
    | 'MULTIPLE_SERVICE_ACCOUNTS'
    | 'MULTIPLE_VARIABLES'
    | 'MULTIPLE_CONNECTORS'
    | 'MULTIPLE_API_KEYS'
    | 'MULTIPLE_API_TOKENS'
    | 'INTEGRATED_APPROVALS_WITH_HARNESS_UI'
    | 'INTEGRATED_APPROVALS_WITH_CUSTOM_SCRIPT'
    | 'INTEGRATED_APPROVALS_WITH_JIRA'
    | 'SECRET_MANAGERS'
    | 'DEPLOYMENTS'
    | 'INITIAL_DEPLOYMENTS'
    | 'DEPLOYMENTS_PER_MONTH'
    | 'SERVICES'
    | 'BUILDS'
    | 'SAML_SUPPORT'
    | 'OAUTH_SUPPORT'
    | 'LDAP_SUPPORT'
    | 'TWO_FACTOR_AUTH_SUPPORT'
    | 'CUSTOM_ROLES'
    | 'CUSTOM_RESOURCE_GROUPS'
    | 'MAX_TOTAL_BUILDS'
    | 'MAX_BUILDS_PER_MONTH'
    | 'MAX_BUILDS_PER_DAY'
    | 'ACTIVE_COMMITTERS'
    | 'TEST_INTELLIGENCE'
    | 'TEMPLATE_SERVICE'
    | 'CACHE_SIZE_ALLOWANCE'
    | 'SRM_SERVICES'
    | 'ANALYZE_DEPLOYMENT_STEP'
    | 'TERRAFORM_APPLY'
    | 'TERRAFORM_PLAN'
    | 'TERRAFORM_DESTROY'
    | 'TERRAFORM_ROLLBACK'
    | 'INTEGRATED_APPROVALS_WITH_SERVICE_NOW'
    | 'CREATE_STACK'
    | 'DELETE_STACK'
    | 'ROLLBACK_STACK'
    | 'COMMAND'
    | 'AZURE_SLOT_DEPLOYMENT'
    | 'AZURE_TRAFFIC_SHIFT'
    | 'AZURE_SWAP_SLOT'
    | 'AZURE_WEBAPP_ROLLBACK'
    | 'JENKINS_BUILD'
    | 'AZURE_CREATE_ARM_RESOURCE'
    | 'AZURE_CREATE_BP_RESOURCE'
    | 'AZURE_ROLLBACK_ARM_RESOURCE'
    | 'SHELL_SCRIPT_PROVISION'
    | 'TERRAFORM_CLOUD_RUN'
    | 'TERRAFORM_CLOUD_ROLLBACK'
    | 'SECURITY'
    | 'DEVELOPERS'
    | 'MONTHLY_ACTIVE_USERS'
    | 'STRATEGY_MAX_CONCURRENT'
    | 'MAX_PARALLEL_STEP_IN_A_PIPELINE'
    | 'PIPELINE_EXECUTION_DATA_RETENTION_DAYS'
    | 'MAX_PIPELINE_TIMEOUT_SECONDS'
    | 'MAX_STAGE_TIMEOUT_SECONDS'
    | 'MAX_STEP_TIMEOUT_SECONDS'
    | 'MAX_CONCURRENT_ACTIVE_PIPELINE_EXECUTIONS'
    | 'MAX_CHAOS_EXPERIMENT_RUNS_PER_MONTH'
    | 'MAX_CHAOS_INFRASTRUCTURES'
    | 'TERRAGRUNT_PLAN'
    | 'TERRAGRUNT_APPLY'
    | 'TERRAGRUNT_DESTROY'
    | 'TERRAGRUNT_ROLLBACK'
    | 'SEI_MAX_NUMBER_OF_CONTRIBUTORS'
  restriction?: RestrictionDTO
  restrictionType?:
    | 'AVAILABILITY'
    | 'STATIC_LIMIT'
    | 'RATE_LIMIT'
    | 'CUSTOM'
    | 'DURATION'
    | 'LICENSE_RATE_LIMIT'
    | 'LICENSE_STATIC_LIMIT'
}

export interface FeatureRestrictionMetadataDTO {
  edition?: 'COMMUNITY' | 'FREE' | 'TEAM' | 'ENTERPRISE'
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  name?:
    | 'TEST1'
    | 'TEST2'
    | 'TEST3'
    | 'TEST4'
    | 'TEST5'
    | 'TEST6'
    | 'TEST7'
    | 'PERSPECTIVES'
    | 'CCM_K8S_CLUSTERS'
    | 'CCM_AUTOSTOPPING_RULES'
    | 'MULTIPLE_ORGANIZATIONS'
    | 'MULTIPLE_PROJECTS'
    | 'MULTIPLE_SECRETS'
    | 'MULTIPLE_USER_GROUPS'
    | 'MULTIPLE_USERS'
    | 'MULTIPLE_SERVICE_ACCOUNTS'
    | 'MULTIPLE_VARIABLES'
    | 'MULTIPLE_CONNECTORS'
    | 'MULTIPLE_API_KEYS'
    | 'MULTIPLE_API_TOKENS'
    | 'INTEGRATED_APPROVALS_WITH_HARNESS_UI'
    | 'INTEGRATED_APPROVALS_WITH_CUSTOM_SCRIPT'
    | 'INTEGRATED_APPROVALS_WITH_JIRA'
    | 'SECRET_MANAGERS'
    | 'DEPLOYMENTS'
    | 'INITIAL_DEPLOYMENTS'
    | 'DEPLOYMENTS_PER_MONTH'
    | 'SERVICES'
    | 'BUILDS'
    | 'SAML_SUPPORT'
    | 'OAUTH_SUPPORT'
    | 'LDAP_SUPPORT'
    | 'TWO_FACTOR_AUTH_SUPPORT'
    | 'CUSTOM_ROLES'
    | 'CUSTOM_RESOURCE_GROUPS'
    | 'MAX_TOTAL_BUILDS'
    | 'MAX_BUILDS_PER_MONTH'
    | 'MAX_BUILDS_PER_DAY'
    | 'ACTIVE_COMMITTERS'
    | 'TEST_INTELLIGENCE'
    | 'TEMPLATE_SERVICE'
    | 'CACHE_SIZE_ALLOWANCE'
    | 'SRM_SERVICES'
    | 'ANALYZE_DEPLOYMENT_STEP'
    | 'TERRAFORM_APPLY'
    | 'TERRAFORM_PLAN'
    | 'TERRAFORM_DESTROY'
    | 'TERRAFORM_ROLLBACK'
    | 'INTEGRATED_APPROVALS_WITH_SERVICE_NOW'
    | 'CREATE_STACK'
    | 'DELETE_STACK'
    | 'ROLLBACK_STACK'
    | 'COMMAND'
    | 'AZURE_SLOT_DEPLOYMENT'
    | 'AZURE_TRAFFIC_SHIFT'
    | 'AZURE_SWAP_SLOT'
    | 'AZURE_WEBAPP_ROLLBACK'
    | 'JENKINS_BUILD'
    | 'AZURE_CREATE_ARM_RESOURCE'
    | 'AZURE_CREATE_BP_RESOURCE'
    | 'AZURE_ROLLBACK_ARM_RESOURCE'
    | 'SHELL_SCRIPT_PROVISION'
    | 'TERRAFORM_CLOUD_RUN'
    | 'TERRAFORM_CLOUD_ROLLBACK'
    | 'SECURITY'
    | 'DEVELOPERS'
    | 'MONTHLY_ACTIVE_USERS'
    | 'STRATEGY_MAX_CONCURRENT'
    | 'MAX_PARALLEL_STEP_IN_A_PIPELINE'
    | 'PIPELINE_EXECUTION_DATA_RETENTION_DAYS'
    | 'MAX_PIPELINE_TIMEOUT_SECONDS'
    | 'MAX_STAGE_TIMEOUT_SECONDS'
    | 'MAX_STEP_TIMEOUT_SECONDS'
    | 'MAX_CONCURRENT_ACTIVE_PIPELINE_EXECUTIONS'
    | 'MAX_CHAOS_EXPERIMENT_RUNS_PER_MONTH'
    | 'MAX_CHAOS_INFRASTRUCTURES'
    | 'TERRAGRUNT_PLAN'
    | 'TERRAGRUNT_APPLY'
    | 'TERRAGRUNT_DESTROY'
    | 'TERRAGRUNT_ROLLBACK'
    | 'SEI_MAX_NUMBER_OF_CONTRIBUTORS'
  restrictionMetadata?: {
    [key: string]: RestrictionMetadataDTO
  }
}

export interface FeedbackFormDTO {
  accountId?: string
  email?: string
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  score?: number
  suggestion?: string
}

export interface FetchAllArtifacts {
  artifactsArrayPath?: ParameterFieldString
  attributes?: NGVariable[]
  spec: CustomArtifactScriptInfo
  versionPath?: ParameterFieldString
}

export type FetchInstanceScriptStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type FetchLinkedAppsStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export interface FieldValues {
  fieldValues?: {
    [key: string]: string[]
  }
}

export interface FileDTO {
  accountIdentifier: string
  createdBy?: EmbeddedUserDetailsDTO
  description?: string
  draft?: boolean
  fileUsage?: 'MANIFEST_FILE' | 'CONFIG' | 'SCRIPT'
  identifier: string
  lastModifiedAt?: number
  lastModifiedBy?: EmbeddedUserDetailsDTO
  mimeType?: string
  name: string
  orgIdentifier?: string
  parentIdentifier: string
  path?: string
  projectIdentifier?: string
  tags?: NGTag[]
  type: 'FILE' | 'FOLDER'
}

export type FileNodeDTO = FileStoreNodeDTO & {
  content?: string
  description?: string
  fileUsage: 'MANIFEST_FILE' | 'CONFIG' | 'SCRIPT'
  mimeType?: string
  size?: number
  tags?: NGTag[]
}

export interface FilePaths {
  buildDetails?: BuildDetails
}

export interface FileStoreNodeDTO {
  identifier: string
  lastModifiedAt?: number
  lastModifiedBy?: EmbeddedUserDetailsDTO
  name: string
  parentIdentifier?: string
  path?: string
  type: 'FILE' | 'FOLDER'
}

export interface FileStoreRequest {
  file: FileDTO
}

export type FilesFilterProperties = FilterProperties & {
  createdBy?: EmbeddedUserDetailsDTO
  fileUsage?: 'MANIFEST_FILE' | 'CONFIG' | 'SCRIPT'
  referencedBy?: ReferencedByDTO
}

export interface Filter {
  ids?: string[]
}

export type FilterCreatorErrorResponse = ErrorMetadataDTO & {
  errorMetadataList?: ErrorMetadata[]
}

export interface FilterDTO {
  filterProperties: FilterProperties
  filterVisibility?: 'EveryOne' | 'OnlyCreator'
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface FilterProperties {
  filterType?:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
    | 'Trigger'
    | 'EnvironmentGroup'
    | 'FileStore'
    | 'CCMRecommendation'
    | 'Anomaly'
    | 'Environment'
    | 'RuleExecution'
    | 'Override'
    | 'InputSet'
  labels?: {
    [key: string]: string
  }
  tags?: {
    [key: string]: string
  }
}

export interface FilterSpec {
  [key: string]: any
}

export interface FilterYaml {
  entities: ('infrastructures' | 'gitOpsClusters' | 'environments')[]
  identifier: string
  spec: FilterSpec
  type: 'tags' | 'all'
}

export interface FolderNodeDTO {
  children?: FileStoreNodeDTO[]
  identifier: string
  lastModifiedAt?: number
  lastModifiedBy?: EmbeddedUserDetailsDTO
  name: string
  parentIdentifier?: string
  path?: string
  type: 'FILE' | 'FOLDER'
}

export interface FreezeBannerDetails {
  accountId?: string
  accountName?: string
  freezeScope?: 'account' | 'org' | 'project' | 'unknown'
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  window?: CurrentOrUpcomingWindow
  windows?: FreezeWindow[]
}

export interface FreezeDetailedResponse {
  accountId?: string
  createdAt?: number
  currentOrUpcomingWindow?: CurrentOrUpcomingWindow
  description?: string
  freezeScope?: 'account' | 'org' | 'project' | 'unknown'
  identifier?: string
  lastUpdatedAt?: number
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  status?: 'Enabled' | 'Disabled'
  tags?: {
    [key: string]: string
  }
  type?: 'GLOBAL' | 'MANUAL'
  windows?: FreezeWindow[]
  yaml?: string
}

export interface FreezeErrorResponseDTO {
  errorMessage?: string
  id?: string
  name?: string
}

export interface FreezeExecutionInfo {
  freezeType?: string
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  yaml?: string
}

export interface FreezeExecutionSummary {
  freezeExecutionInfoList?: FreezeExecutionInfo[]
}

export interface FreezeFilterPropertiesDTO {
  endTime?: number
  freezeIdentifiers?: string[]
  freezeStatus?: 'Enabled' | 'Disabled'
  searchTerm?: string
  sort?: string[]
  startTime?: number
}

export interface FreezeReference {
  freezeScope?: 'account' | 'org' | 'project' | 'unknown'
  identifier?: string
  type?: 'GLOBAL' | 'MANUAL'
}

export interface FreezeResponse {
  accountId?: string
  createdAt?: number
  description?: string
  freezeScope?: 'account' | 'org' | 'project' | 'unknown'
  identifier?: string
  lastUpdatedAt?: number
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  status?: 'Enabled' | 'Disabled'
  tags?: {
    [key: string]: string
  }
  type?: 'GLOBAL' | 'MANUAL'
  windows?: FreezeWindow[]
  yaml?: string
}

export interface FreezeResponseWrapperDTO {
  freezeErrorResponseDTOList?: FreezeErrorResponseDTO[]
  noOfFailed?: number
  noOfSuccess?: number
  successfulFreezeResponseDTOList?: FreezeResponse[]
}

export interface FreezeSummaryResponse {
  accountId?: string
  createdAt?: number
  currentOrUpcomingWindow?: CurrentOrUpcomingWindow
  description?: string
  freezeScope?: 'account' | 'org' | 'project' | 'unknown'
  identifier?: string
  lastUpdatedAt?: number
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  status?: 'Enabled' | 'Disabled'
  tags?: {
    [key: string]: string
  }
  type?: 'GLOBAL' | 'MANUAL'
  windows?: FreezeWindow[]
  yaml?: string
}

export interface FreezeWindow {
  duration?: string
  endTime?: string
  recurrence?: Recurrence
  startTime: string
  timeZone: string
}

export interface FrozenExecutionDetail {
  freeze?: FreezeSummaryResponse
  url?: string
}

export interface FrozenExecutionDetails {
  freezeList?: FrozenExecutionDetail[]
}

export interface GARBuildDetailsDTO {
  metadata?: {
    [key: string]: string
  }
  version?: string
}

export interface GARResponseDTO {
  buildDetailsList?: GARBuildDetailsDTO[]
}

export type GARStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  buildArgs?: {
    [key: string]: string
  }
  cacheFrom?: string[]
  cacheTo?: string
  caching?: boolean
  connectorRef: string
  context?: string
  dockerfile?: string
  host: string
  imageName: string
  labels?: {
    [key: string]: string
  }
  optimize?: boolean
  projectID: string
  remoteCacheImage?: string
  resources?: ContainerResource
  runAsUser?: number
  tags: string[]
  target?: string
  version?: string
}

export type GCRStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  buildArgs?: {
    [key: string]: string
  }
  cacheFrom?: string[]
  cacheTo?: string
  caching?: boolean
  connectorRef: string
  context?: string
  dockerfile?: string
  host: string
  imageName: string
  labels?: {
    [key: string]: string
  }
  optimize?: boolean
  projectID: string
  remoteCacheImage?: string
  resources?: ContainerResource
  runAsUser?: number
  tags: string[]
  target?: string
  version?: string
}

export type GarArtifactSummary = ArtifactSummary & {
  package?: string
  project?: string
  region?: string
  repositoryName?: string
  version?: string
}

export interface GarRequestDTO {
  runtimeInputYaml?: string
  version?: string
  versionList?: string[]
  versionRegex?: string
}

export interface GatewayAccountRequestDTO {
  accountName?: string
  companyName?: string
  createdFromNG?: boolean
  defaultExperience?: 'NG' | 'CG'
  nextGenEnabled?: boolean
  uuid?: string
}

export interface GcpBillingExportSpec {
  datasetId: string
  tableId: string
}

export type GcpCloudCostConnector = ConnectorConfigDTO & {
  billingExportSpec?: GcpBillingExportSpec
  featuresEnabled?: (
    | 'BILLING'
    | 'OPTIMIZATION'
    | 'VISIBILITY'
    | 'GOVERNANCE'
    | 'COMMITMENT_ORCHESTRATOR'
    | 'CLUSTER_ORCHESTRATOR'
  )[]
  projectId: string
  serviceAccountEmail: string
}

export type GcpConnector = ConnectorConfigDTO & {
  credential: GcpConnectorCredential
  delegateSelectors?: string[]
  executeOnDelegate?: boolean
}

export interface GcpConnectorCredential {
  spec?: GcpCredentialSpec
  type: 'InheritFromDelegate' | 'ManualConfig' | 'OidcAuthentication'
}

export interface GcpCredentialSpec {
  [key: string]: any
}

export type GcpKmsConnectorDTO = ConnectorConfigDTO & {
  credentials: string
  default?: boolean
  delegateSelectors?: string[]
  keyName: string
  keyRing: string
  projectId: string
  region: string
}

export type GcpManualDetails = GcpCredentialSpec & {
  secretKeyRef: string
}

export interface GcpOidcAccessTokenRequestDTO {
  gcpOidcTokenRequestDTO: GcpOidcTokenRequestDTO
  oidcIdToken: string
}

export interface GcpOidcTokenRequestDTO {
  accountId: string
  gcpProjectId: string
  providerId: string
  serviceAccountEmail?: string
  workloadPoolId: string
}

export interface GcpProjectDetails {
  id?: string
  name?: string
}

export interface GcpProjectResponseDTO {
  projects?: GcpProjectDetails[]
}

export interface GcpResponseDTO {
  clusterNames?: string[]
}

export type GcpSecretManager = ConnectorConfigDTO & {
  assumeCredentialsOnDelegate?: boolean
  credentialsRef?: string
  default?: boolean
  delegateSelectors?: string[]
}

export type GcrArtifactConfig = ArtifactConfig & {
  connectorRef: string
  digest?: string
  imagePath: string
  registryHostname: string
  tag?: string
  tagRegex?: string
}

export type GcrArtifactSummary = ArtifactSummary & {
  imagePath?: string
  tag?: string
}

export interface GcrBuildDetailsDTO {
  buildUrl?: string
  imagePath?: string
  labels?: {
    [key: string]: string
  }
  metadata?: {
    [key: string]: string
  }
  tag?: string
}

export interface GcrRequestDTO {
  registryHostname?: string
  runtimeInputYaml?: string
  tag?: string
  tagRegex?: string
  tagsList?: string[]
}

export interface GcrResponseDTO {
  buildDetailsList?: GcrBuildDetailsDTO[]
}

export type GcsStoreConfig = StoreConfig & {
  bucketName?: string
  connectorRef?: string
  folderPath?: string
  metadata?: string
}

export type GenericEntityFilter = Filter & {
  filterType?: string
}

export interface GetFileResponseDTO {
  blobId?: string
  commitId?: string
  fileContent?: string
}

export interface GitAuthenticationDTO {
  [key: string]: any
}

export interface GitBranchDTO {
  branchName?: string
  branchSyncStatus?: 'SYNCED' | 'SYNCING' | 'UNSYNCED'
}

export interface GitBranchDetailsDTO {
  name?: string
}

export interface GitBranchListDTO {
  branches?: PageGitBranchDTO
  defaultBranch?: GitBranchDTO
}

export interface GitBranchesResponseDTO {
  branches?: GitBranchDetailsDTO[]
  defaultBranch?: GitBranchDetailsDTO
}

export type GitCloneStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  build: Build
  cloneDirectory?: string
  connectorRef: string
  depth?: number
  outputFilePathsContent?: string[]
  projectName?: string
  repoName?: string
  resources?: ContainerResource
  runAsUser?: number
  sslVerify?: boolean
  version?: string
}

export type GitConfigDTO = ConnectorConfigDTO & {
  branchName?: string
  connectionType: 'Account' | 'Repo' | 'Project'
  delegateSelectors?: string[]
  executeOnDelegate?: boolean
  spec: GitAuthenticationDTO
  type: 'Http' | 'Ssh'
  url: string
  validationRepo?: string
}

export interface GitDefaultBranchCacheKeyRequestDTO {
  accountIdentifier: string
  repo: string
  repoUrl: string
}

export interface GitDefaultBranchCacheListRequest {
  gitDefaultBranchCacheParamsRequestDTO?: GitDefaultBranchCacheParamsRequestDTO
}

export interface GitDefaultBranchCacheListResponse {
  defaultBranchCacheResponseList?: DefaultBranchCacheResponse[]
}

export interface GitDefaultBranchCacheParamsRequestDTO {
  accountIdentifier?: string
  repo?: string
  repoUrl?: string
}

export interface GitDefaultBranchClearCacheRequest {
  gitDefaultBranchCacheParamsRequestDTO?: GitDefaultBranchCacheParamsRequestDTO
}

export interface GitDefaultBranchClearCacheResponse {
  count?: number
}

export interface GitDefaultBranchGetCacheRequest {
  gitDefaultBranchCacheKeyRequestDTO?: GitDefaultBranchCacheKeyRequestDTO
}

export interface GitDefaultBranchGetCacheResponse {
  defaultBranchCacheResponse?: DefaultBranchCacheResponse
}

export interface GitDefaultBranchUpsertCacheRequest {
  defaultBranch?: string
  gitDefaultBranchCacheKeyRequestDTO?: GitDefaultBranchCacheKeyRequestDTO
}

export interface GitDefaultBranchUpsertCacheResponse {
  defaultBranchCacheResponse?: DefaultBranchCacheResponse
}

export interface GitEnabledDTO {
  connectivityMode?: 'MANAGER' | 'DELEGATE'
  gitSimplificationEnabled?: boolean
  gitSyncEnabled?: boolean
  gitSyncEnabledOnlyForFF?: boolean
}

export interface GitEntityBranchFilterSummaryProperties {
  entityTypes?: (
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  )[]
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  searchTerm?: string
}

export interface GitEntityFilterProperties {
  entityTypes?: (
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  )[]
  gitSyncConfigIdentifiers?: string[]
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  searchTerm?: string
}

export interface GitErrorMetadata {
  branch?: string
  filepath?: string
  repo?: string
  type?: string
}

export type GitErrorMetadataDTO = ErrorMetadataDTO & {
  branch?: string
  repo?: string
}

export interface GitFileCacheClearCacheRequest {
  accountIdentifier?: string
  filepath?: string
  gitProvider?: string
  ref?: string
  repoName?: string
}

export interface GitFileCacheClearCacheResponse {
  [key: string]: any
}

export interface GitFileCacheUpdateKey {
  accountIdentifier?: string
  filepath?: string
  gitProvider?: string
  ref?: string
  repoName?: string
}

export interface GitFileCacheUpdateRequest {
  key?: GitFileCacheUpdateKey
  values?: GitFileCacheUpdateValues
}

export interface GitFileCacheUpdateResponse {
  [key: string]: any
}

export interface GitFileCacheUpdateValues {
  updatedAt?: number
  validUntil?: number
}

export interface GitFileContent {
  content?: string
  objectId?: string
}

export interface GitFullSyncConfigDTO {
  accountIdentifier?: string
  baseBranch?: string
  branch?: string
  createPullRequest?: boolean
  newBranch?: boolean
  orgIdentifier?: string
  prTitle?: string
  projectIdentifier?: string
  repoIdentifier?: string
  rootFolder?: string
  targetBranch?: string
}

export interface GitFullSyncConfigRequestDTO {
  baseBranch?: string
  branch: string
  createPullRequest?: boolean
  newBranch?: boolean
  prTitle?: string
  repoIdentifier: string
  rootFolder: string
  targetBranch?: string
}

export interface GitFullSyncEntityInfoDTO {
  accountIdentifier?: string
  branch?: string
  entityType?:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  errorMessage?: string
  filePath?: string
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repoName?: string
  repoUrl?: string
  retryCount?: number
  rootFolder?: string
  syncStatus?: 'QUEUED' | 'SUCCESS' | 'FAILED' | 'OVERRIDDEN'
}

export interface GitFullSyncEntityInfoFilterKeys {
  entityTypes?: (
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  )[]
  syncStatus?: 'QUEUED' | 'SUCCESS' | 'FAILED' | 'OVERRIDDEN'
}

export type GitHTTPAuthenticationDTO = GitAuthenticationDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export interface GitInfo {
  commit?: string
  commitID?: string
  eventType?: string
  repoName?: string
  sourceBranch?: string
  targetBranch?: string
}

export type GitLabStore = StoreConfig & {
  branch?: string
  commitId?: string
  connectorRef: string
  folderPath?: string
  gitFetchType: 'Branch' | 'Commit'
  paths?: string[]
  repoName?: string
}

export interface GitListBranchesResponse {
  gitBranchesResponse?: GitBranchesResponseDTO
  paginationDetails?: PaginationDetails
}

export interface GitListRepositoryResponse {
  gitRepositoryResponseList?: GitRepositoryResponseDTO[]
  paginationDetails?: PaginationDetails
}

export interface GitOpsAppSummary {
  applications?: Application[]
}

export type GitOpsDeploymentRepoManifest = ManifestAttributes & {
  store?: StoreConfigWrapper
}

export interface GitOpsExecutionSummary {
  clusters?: Cluster[]
  environments?: Environment[]
}

export interface GitOpsInfoDTO {
  type?: 'CONNECTED_ARGO_PROVIDER' | 'MANAGED_ARGO_PROVIDER'
}

export type GitOpsInstanceInfoDTO = InstanceInfoDTO & {
  agentIdentifier?: string
  appIdentifier?: string
  clusterIdentifier?: string
  containerList: K8sContainer[]
  namespace: string
  podId?: string
  podName: string
}

export interface GitOpsInstanceRequest {
  accountIdentifier?: string
  agentIdentifier?: string
  applicationIdentifier?: string
  buildId?: string
  clusterIdentifier?: string
  creationTimestamp: number
  envIdentifier?: string
  instanceInfo: K8sBasicInfo
  lastDeployedAt: number
  lastDeployedById?: string
  lastDeployedByName?: string
  lastExecutedAt?: number
  orgIdentifier?: string
  pipelineExecutionId?: string
  pipelineName?: string
  projectIdentifier?: string
  serviceIdentifier?: string
}

export interface GitOpsProvider {
  description?: string
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  spec: GitOpsInfoDTO
  tags?: {
    [key: string]: string
  }
}

export interface GitPRCreateRequest {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  sourceBranch: string
  targetBranch: string
  title: string
  useUserFromToken?: boolean
  yamlGitConfigRef?: string
}

export interface GitRepositoryResponseDTO {
  name?: string
}

export type GitSSHAuthenticationDTO = GitAuthenticationDTO & {
  sshKeyRef: string
}

export type GitStore = StoreConfig & {
  branch?: string
  commitId?: string
  connectorRef: string
  folderPath?: string
  gitFetchType: 'Branch' | 'Commit'
  paths?: string[]
  repoName?: string
}

export interface GitSyncConfig {
  branch?: string
  gitConnectorRef?: string
  gitConnectorType: 'Github' | 'Gitlab' | 'Bitbucket'
  gitSyncFolderConfigDTOs?: GitSyncFolderConfigDTO[]
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repo?: string
}

export interface GitSyncEntityDTO {
  branch?: string
  entityGitPath?: string
  entityIdentifier?: string
  entityName?: string
  entityReference?: EntityReference
  entityType?:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  entityUrl?: string
  folderPath?: string
  gitConnectorId?: string
  repoUrl?: string
}

export interface GitSyncEntityListDTO {
  count?: number
  entityType?:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  gitSyncEntities?: GitSyncEntityDTO[]
}

export interface GitSyncErrorAggregateByCommitDTO {
  branchName?: string
  commitMessage?: string
  createdAt?: number
  errorsForSummaryView?: GitSyncErrorDTO[]
  failedCount?: number
  gitCommitId?: string
  repoId?: string
}

export interface GitSyncErrorCountDTO {
  connectivityErrorCount?: number
  gitToHarnessErrorCount?: number
}

export interface GitSyncErrorDTO {
  accountIdentifier?: string
  additionalErrorDetails?: GitSyncErrorDetailsDTO
  branchName?: string
  changeType?: 'ADD' | 'RENAME' | 'MODIFY' | 'DELETE' | 'NONE' | 'ADD_V2' | 'UPDATE_V2'
  completeFilePath?: string
  createdAt?: number
  entityType?:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  errorType?: 'GIT_TO_HARNESS' | 'CONNECTIVITY_ISSUE' | 'FULL_SYNC'
  failureReason?: string
  repoId?: string
  repoUrl?: string
  scopes?: Scope[]
  status?: 'ACTIVE' | 'DISCARDED' | 'EXPIRED' | 'RESOLVED' | 'OVERRIDDEN'
}

export interface GitSyncErrorDetailsDTO {
  [key: string]: any
}

export interface GitSyncFolderConfigDTO {
  isDefault?: boolean
  rootFolder?: string
}

export interface GitSyncRepoFiles {
  gitSyncConfigIdentifier?: string
  gitSyncEntityLists?: GitSyncEntityListDTO[]
}

export interface GitSyncRepoFilesList {
  gitSyncRepoFilesList?: GitSyncRepoFiles[]
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
}

export interface GitSyncSettingsDTO {
  accountIdentifier?: string
  enabledOnlyForFF?: boolean
  executeOnDelegate: boolean
  gitSimplificationEnabled?: boolean
  orgIdentifier: string
  projectIdentifier: string
}

export interface GithubApiAccess {
  spec?: GithubApiAccessSpecDTO
  type: 'GithubApp' | 'Token' | 'OAuth'
}

export interface GithubApiAccessSpecDTO {
  [key: string]: any
}

export type GithubApp = GithubHttpCredentialsSpecDTO & {
  applicationId?: string
  applicationIdRef?: string
  installationId?: string
  installationIdRef?: string
  privateKeyRef: string
}

export type GithubAppSpec = GithubApiAccessSpecDTO & {
  applicationId?: string
  applicationIdRef?: string
  installationId?: string
  installationIdRef?: string
  privateKeyRef: string
}

export interface GithubAuthentication {
  spec: GithubCredentialsDTO
  type: 'Http' | 'Ssh'
}

export interface GithubAuthenticationDTO {
  apiAccessDTO?: GithubApiAccess
}

export type GithubConnector = ConnectorConfigDTO & {
  apiAccess?: GithubApiAccess
  authentication: GithubAuthentication
  delegateSelectors?: string[]
  executeOnDelegate?: boolean
  type: 'Account' | 'Repo' | 'Project'
  url: string
  validationRepo?: string
}

export interface GithubCredentialsDTO {
  [key: string]: any
}

export type GithubHttpCredentials = GithubCredentialsDTO & {
  spec: GithubHttpCredentialsSpecDTO
  type: 'UsernamePassword' | 'UsernameToken' | 'OAuth' | 'GithubApp'
}

export interface GithubHttpCredentialsSpecDTO {
  [key: string]: any
}

export type GithubOauth = GithubHttpCredentialsSpecDTO & {
  tokenRef: string
}

export interface GithubPackageDTO {
  packageId?: string
  packageName?: string
  packageType?: string
  packageUrl?: string
  visibility?: string
}

export type GithubPackagesArtifactConfig = ArtifactConfig & {
  artifactId?: string
  connectorRef: string
  digest?: string
  extension?: string
  groupId?: string
  org?: string
  packageName: string
  packageType: 'npm' | 'maven' | 'rubygems' | 'nuget' | 'container'
  user?: string
  version?: string
  versionRegex?: string
}

export type GithubPackagesArtifactSummary = ArtifactSummary & {
  packageName?: string
  version?: string
}

export interface GithubPackagesResponseDTO {
  githubPackageResponse?: GithubPackageDTO[]
}

export type GithubSCMDTO = SourceCodeManagerDTO & {
  authentication?: GithubAuthentication
}

export type GithubSCMRequestDTO = UserSourceCodeManagerRequestDTO & {
  authentication?: GithubAuthenticationDTO
}

export type GithubSshCredentials = GithubCredentialsDTO & {
  sshKeyRef: string
}

export type GithubStore = StoreConfig & {
  branch?: string
  commitId?: string
  connectorRef: string
  folderPath?: string
  gitFetchType: 'Branch' | 'Commit'
  paths?: string[]
  repoName?: string
}

export type GithubTokenSpec = GithubApiAccessSpecDTO & {
  tokenRef: string
}

export type GithubUsernamePassword = GithubHttpCredentialsSpecDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type GithubUsernameToken = GithubHttpCredentialsSpecDTO & {
  tokenRef: string
  username?: string
  usernameRef?: string
}

export interface GitlabApiAccess {
  spec?: GitlabApiAccessSpecDTO
  type: 'Token' | 'OAuth'
}

export interface GitlabApiAccessSpecDTO {
  [key: string]: any
}

export interface GitlabAuthentication {
  spec: GitlabCredentialsDTO
  type: 'Http' | 'Ssh'
}

export interface GitlabAuthenticationDTO {
  apiAccessDTO?: GitlabApiAccess
}

export type GitlabConnector = ConnectorConfigDTO & {
  apiAccess?: GitlabApiAccess
  authentication: GitlabAuthentication
  delegateSelectors?: string[]
  executeOnDelegate?: boolean
  type: 'Account' | 'Repo' | 'Project'
  url: string
  validationRepo?: string
}

export interface GitlabCredentialsDTO {
  [key: string]: any
}

export type GitlabHttpCredentials = GitlabCredentialsDTO & {
  spec: GitlabHttpCredentialsSpecDTO
  type: 'UsernamePassword' | 'UsernameToken' | 'Kerberos' | 'OAuth'
}

export interface GitlabHttpCredentialsSpecDTO {
  [key: string]: any
}

export type GitlabKerberos = GitlabHttpCredentialsSpecDTO & {
  kerberosKeyRef: string
}

export type GitlabOauth = GitlabHttpCredentialsSpecDTO & {
  refreshTokenRef: string
  tokenRef: string
}

export type GitlabSCMDTO = SourceCodeManagerDTO & {
  authentication: GitlabAuthentication
}

export type GitlabSCMRequestDTO = UserSourceCodeManagerRequestDTO & {
  authentication?: GitlabAuthenticationDTO
}

export type GitlabSshCredentials = GitlabCredentialsDTO & {
  sshKeyRef: string
}

export type GitlabTokenSpec = GitlabApiAccessSpecDTO & {
  apiUrl?: string
  tokenRef: string
}

export type GitlabUsernamePassword = GitlabHttpCredentialsSpecDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type GitlabUsernameToken = GitlabHttpCredentialsSpecDTO & {
  tokenRef: string
  username?: string
  usernameRef?: string
}

export interface GitopsProviderResponse {
  description?: string
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  spec: GitOpsInfoDTO
  tags?: {
    [key: string]: string
  }
}

export interface GlobalFreezeBannerDetailsResponseDTO {
  activeOrUpcomingGlobalFreezes?: FreezeBannerDetails[]
}

export type GoogleArtifactRegistryConfig = ArtifactConfig & {
  connectorRef: string
  digest?: string
  metadata?: string
  package: string
  project: string
  region: string
  repositoryName: string
  repositoryType: 'docker'
  version?: string
  versionRegex?: string
}

export type GoogleCloudFunctionDefinitionManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export type GoogleCloudFunctionDeploymentMetaData = DeploymentMetaData & {
  environmentType?: string
  metadata?: string
}

export type GoogleCloudFunctionGenOneDefinitionManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export type GoogleCloudFunctionsServiceSpec = ServiceSpec & {
  environmentType?: string
}

export type GoogleCloudSourceArtifactConfig = ArtifactConfig & {
  branch?: string
  commitId?: string
  connectorRef: string
  fetchType: 'Branch' | 'Commit' | 'Tag'
  project: string
  repository: string
  sourceDirectory: string
  tag?: string
}

export type GoogleCloudStorageArtifactConfig = ArtifactConfig & {
  artifactPath: string
  bucket: string
  connectorRef: string
  project: string
}

export interface GoogleCloudStorageBucketDetails {
  id?: string
  name?: string
}

export interface GoogleCloudStorageBucketsResponseDTO {
  buckets?: GoogleCloudStorageBucketDetails[]
}

export type GoogleFunctionInfrastructureDetails = InfrastructureDetails & {
  project?: string
  region?: string
}

export type GoogleFunctionInstanceInfoDTO = InstanceInfoDTO & {
  functionName: string
  infraStructureKey?: string
  memorySize?: string
  project: string
  region: string
  revision: string
  runTime?: string
  source?: string
  updatedTime?: number
}

export type GoogleFunctionsDeployStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  updateFieldMask?: string
}

export type GoogleFunctionsDeployWithoutTrafficStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  updateFieldMask?: string
}

export type GoogleFunctionsGenOneDeployStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  updateFieldMask?: string
}

export type GoogleFunctionsGenOneRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type GoogleFunctionsInfrastructure = Infrastructure & {
  connectorRef: string
  metadata?: string
  project: string
  provisioner?: string
  region: string
}

export type GoogleFunctionsRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type GoogleFunctionsTrafficShiftStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  trafficPercent?: number
}

export interface GovernanceMetadata {
  [key: string]: any
}

export interface HarnessApiAccess {
  spec?: HarnessApiAccessSpecDTO
  type: 'Token' | 'Jwt_Token'
}

export interface HarnessApiAccessSpecDTO {
  [key: string]: any
}

export interface HarnessAuthentication {
  spec: HarnessHttpCredentials
  type: 'Http' | 'Ssh'
}

export type HarnessConnector = ConnectorConfigDTO & {
  apiAccess?: HarnessApiAccess
  authentication: HarnessAuthentication
  executeOnDelegate?: boolean
  type: 'Account' | 'Repo' | 'Project'
  url: string
  validationRepo?: string
}

export type HarnessFileStoreSource = ShellScriptBaseSource & {
  file?: string
}

export interface HarnessForConfig {
  end?: number
  items?: string[]
  maxConcurrency?: number
  partitionSize?: number
  start?: number
  times?: number
  unit?: 'Percentage' | 'Count'
}

export interface HarnessHttpCredentials {
  spec: HarnessHttpCredentialsSpecDTO
  type: 'UsernameToken'
}

export interface HarnessHttpCredentialsSpecDTO {
  [key: string]: any
}

export type HarnessJWTTokenSpec = HarnessApiAccessSpecDTO & {
  tokenRef: string
}

export interface HarnessRelease {
  name: string
}

export interface HarnessServiceInfoNG {
  envId?: string
  infraMappingId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId?: string
}

export type HarnessStore = StoreConfig & {
  files?: string[]
  secretFiles?: string[]
}

export type HarnessTokenSpec = HarnessApiAccessSpecDTO & {
  tokenRef: string
}

export type HarnessUsernameToken = HarnessHttpCredentialsSpecDTO & {
  tokenRef: string
  username?: string
}

export interface HealthDeploymentDashboard {
  healthDeploymentInfo?: HealthDeploymentInfo
}

export interface HealthDeploymentDashboardV2 {
  healthDeploymentInfo?: HealthDeploymentInfoV2
}

export interface HealthDeploymentInfo {
  active?: DeploymentInfo
  failure?: DeploymentInfo
  success?: DeploymentInfo
  total?: TotalDeploymentInfo
}

export interface HealthDeploymentInfoV2 {
  active?: DeploymentInfoV2
  failure?: DeploymentInfoV2
  success?: DeploymentInfoV2
  total?: TotalDeploymentInfoV2
}

export interface HelmChartInfo {
  name?: string
  repoUrl?: string
  subChartPath?: string
  version?: string
}

export type HelmChartManifest = ManifestAttributes & {
  chartName?: string
  chartVersion?: string
  commandFlags?: HelmManifestCommandFlag[]
  enableDeclarativeRollback?: ParameterFieldBoolean
  fetchHelmChartMetadata?: boolean
  helmVersion?: 'V2' | 'V3' | 'V380'
  metadata?: string
  skipResourceVersioning?: boolean
  store?: StoreConfigWrapper
  subChartPath?: string
  valuesPaths?: string[]
}

export interface HelmChartResponseDTO {
  helmChartVersions?: string[]
  lastTag?: string
}

export type HelmDeployStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  ignoreReleaseHistFailStatus?: boolean
  skipSteadyStateCheck?: ParameterFieldBoolean
}

export interface HelmFileParameters {
  name: string
  path: string
}

export interface HelmManifestCommandFlag {
  commandType:
    | 'Fetch'
    | 'Template'
    | 'Pull'
    | 'Install'
    | 'Upgrade'
    | 'Rollback'
    | 'History'
    | 'Delete'
    | 'Uninstall'
    | 'List'
    | 'Add'
    | 'Update'
    | 'Version'
  flag?: string
}

export interface HelmParameters {
  name: string
  value: string
}

export type HelmRepoOverrideManifest = ManifestAttributes & {
  connectorRef: string
  metadata?: string
  type: string
}

export type HelmRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  skipSteadyStateCheck?: ParameterFieldBoolean
}

export interface HelmValues {
  fileParameters?: HelmFileParameters[]
  parameters?: HelmParameters[]
  valueFiles?: string[]
}

export type HostAttributesFilter = HostFilterSpec & {
  value?: {
    [key: string]: string
  }
}

export interface HostDTO {
  hostAttributes?: {
    [key: string]: string
  }
  hostname: string
}

export interface HostFilter {
  spec?: HostFilterSpec
  type: 'All' | 'HostNames' | 'HostAttributes'
}

export interface HostFilterDTO {
  filter?: string
  type?: 'All' | 'HostNames' | 'HostAttributes'
}

export interface HostFilterSpec {
  type?: 'All' | 'HostNames' | 'HostAttributes'
}

export type HostNamesFilter = HostFilterSpec & {
  value?: string[]
}

export type HostPathYaml = CIVolume & {
  mountPath: string
  spec: HostPathYamlSpec
  type: 'EmptyDir' | 'PersistentVolumeClaim' | 'HostPath'
}

export interface HostPathYamlSpec {
  path: string
  type?: string
}

export interface HostValidationDTO {
  error?: ErrorDetail
  host?: string
  status?: 'SUCCESS' | 'FAILED'
}

export interface HostValidationParams {
  hosts: string[]
  tags?: string[]
}

export interface HttpHelmAuthCredentialsDTO {
  [key: string]: any
}

export interface HttpHelmAuthenticationDTO {
  spec?: HttpHelmAuthCredentialsDTO
  type: 'UsernamePassword' | 'Anonymous'
}

export type HttpHelmConnectorDTO = ConnectorConfigDTO & {
  auth?: HttpHelmAuthenticationDTO
  delegateSelectors?: string[]
  helmRepoUrl: string
}

export type HttpHelmUsernamePasswordDTO = HttpHelmAuthCredentialsDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type HttpStateExecutionData = DelegateResponseData & {
  assertionStatement?: string
  assertionStatus?: string
  delegateMetaInfo?: DelegateMetaInfo
  document?: Document
  element?: ContextElement
  endTs?: number
  errorMsg?: string
  executionDetails?: {
    [key: string]: ExecutionDataValue
  }
  executionSummary?: {
    [key: string]: ExecutionDataValue
  }
  header?: string
  headers?: KeyValuePair[]
  httpMethod?: string
  httpResponseBody?: string
  httpResponseCode?: number
  httpUrl?: string
  startTs?: number
  stateName?: string
  stateParams?: {
    [key: string]: { [key: string]: any }
  }
  stateType?: string
  status?:
    | 'ABORTED'
    | 'DISCONTINUING'
    | 'ERROR'
    | 'FAILED'
    | 'NEW'
    | 'PAUSED'
    | 'PAUSING'
    | 'QUEUED'
    | 'RESUMED'
    | 'RUNNING'
    | 'SCHEDULED'
    | 'STARTING'
    | 'SUCCESS'
    | 'WAITING'
    | 'SKIPPED'
    | 'ABORTING'
    | 'REJECTED'
    | 'EXPIRED'
    | 'PREPARING'
  templateVariable?: {
    [key: string]: { [key: string]: any }
  }
  useProxy?: boolean
  waitInterval?: number
  warningMessage?: string
}

export type HttpStoreConfig = StoreConfig & {
  connectorRef?: string
  metadata?: string
}

export type IACMLicenseSummaryDTO = LicensesWithSummaryDTO & {
  totalDevelopers?: number
}

export type IACMModuleLicenseDTO = ModuleLicenseDTO & {
  numberOfDevelopers?: number
}

export type IDPModuleLicenseDTO = ModuleLicenseDTO & {
  numberOfDevelopers?: number
}

export interface IconDTO {
  deploymentType?: string
  icon?: string
}

export type IdentifierRef = EntityReference & {
  fullyQualifiedScopeIdentifier?: string
  isDefault?: boolean
}

export type IgnoreFailureActionConfig = FailureStrategyActionConfig & {
  type: 'Ignore'
}

export interface InfraExecutionSummary {
  envGroupId?: string
  envGroupName?: string
  identifier?: string
  infrastructureIdentifier?: string
  infrastructureName?: string
  name?: string
  type?: string
}

export interface InfraOverrides {
  environment?: EnvironmentYaml
  infrastructureDefinition?: InfrastructureDef
}

export interface InfraStructureDefinitionYaml {
  identifier: string
  inputs?: JsonNode
  metadata?: string
}

export interface InfraUseFromStage {
  overrides?: InfraOverrides
  stage: string
}

export interface Infrastructure {
  [key: string]: any
}

export interface InfrastructureConfig {
  infrastructureDefinition?: InfrastructureDefinitionConfig
}

export interface InfrastructureDef {
  provisioner?: ExecutionElementConfig
  spec: Infrastructure
  type:
    | 'KubernetesDirect'
    | 'KubernetesGcp'
    | 'KubernetesAzure'
    | 'Pdc'
    | 'SshWinRmAzure'
    | 'ServerlessAwsLambda'
    | 'AzureWebApp'
    | 'SshWinRmAws'
    | 'CustomDeployment'
    | 'ECS'
    | 'Elastigroup'
    | 'TAS'
    | 'Asg'
    | 'GoogleCloudFunctions'
    | 'AWS_SAM'
    | 'AwsLambda'
    | 'KubernetesAws'
    | 'KubernetesRancher'
}

export interface InfrastructureDefinitionConfig {
  allowSimultaneousDeployments?: boolean
  deploymentType:
    | 'Kubernetes'
    | 'NativeHelm'
    | 'Ssh'
    | 'WinRm'
    | 'ServerlessAwsLambda'
    | 'AzureWebApp'
    | 'CustomDeployment'
    | 'ECS'
    | 'Elastigroup'
    | 'TAS'
    | 'Asg'
    | 'GoogleCloudFunctions'
    | 'AwsLambda'
    | 'AWS_SAM'
  description?: string
  environmentRef?: string
  identifier?: string
  metadata?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  scopedServices?: string[]
  spec: Infrastructure
  tags?: {
    [key: string]: string
  }
  type:
    | 'KubernetesDirect'
    | 'KubernetesGcp'
    | 'KubernetesAzure'
    | 'Pdc'
    | 'SshWinRmAzure'
    | 'ServerlessAwsLambda'
    | 'AzureWebApp'
    | 'SshWinRmAws'
    | 'CustomDeployment'
    | 'ECS'
    | 'Elastigroup'
    | 'TAS'
    | 'Asg'
    | 'GoogleCloudFunctions'
    | 'AWS_SAM'
    | 'AwsLambda'
    | 'KubernetesAws'
    | 'KubernetesRancher'
}

export interface InfrastructureDetails {
  [key: string]: any
}

export interface InfrastructureInfo {
  infrastructureIdentifier?: string
  infrastructureName?: string
}

export interface InfrastructureInputsMergedResponseDto {
  infrastructureYaml?: string
  mergedInfrastructureInputsYaml?: string
}

export interface InfrastructureRequestDTO {
  description?: string
  environmentRef?: string
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
  type?:
    | 'KubernetesDirect'
    | 'KubernetesGcp'
    | 'KubernetesAzure'
    | 'Pdc'
    | 'SshWinRmAzure'
    | 'ServerlessAwsLambda'
    | 'AzureWebApp'
    | 'SshWinRmAws'
    | 'CustomDeployment'
    | 'ECS'
    | 'Elastigroup'
    | 'TAS'
    | 'Asg'
    | 'GoogleCloudFunctions'
    | 'AWS_SAM'
    | 'AwsLambda'
    | 'KubernetesAws'
    | 'KubernetesRancher'
  yaml?: string
}

export interface InfrastructureResponse {
  createdAt?: number
  infrastructure?: InfrastructureResponseDTO
  lastModifiedAt?: number
}

export interface InfrastructureResponseDTO {
  accountId?: string
  cacheResponseMetadataDTO?: CacheResponseMetadata
  connectorRef?: string
  deploymentType?:
    | 'Kubernetes'
    | 'NativeHelm'
    | 'Ssh'
    | 'WinRm'
    | 'ServerlessAwsLambda'
    | 'AzureWebApp'
    | 'CustomDeployment'
    | 'ECS'
    | 'Elastigroup'
    | 'TAS'
    | 'Asg'
    | 'GoogleCloudFunctions'
    | 'AwsLambda'
    | 'AWS_SAM'
  description?: string
  entityGitDetails?: EntityGitDetails
  environmentRef?: string
  fallbackBranch?: string
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  storeType?: 'INLINE' | 'REMOTE'
  tags?: {
    [key: string]: string
  }
  type?:
    | 'KubernetesDirect'
    | 'KubernetesGcp'
    | 'KubernetesAzure'
    | 'Pdc'
    | 'SshWinRmAzure'
    | 'ServerlessAwsLambda'
    | 'AzureWebApp'
    | 'SshWinRmAws'
    | 'CustomDeployment'
    | 'ECS'
    | 'Elastigroup'
    | 'TAS'
    | 'Asg'
    | 'GoogleCloudFunctions'
    | 'AWS_SAM'
    | 'AwsLambda'
    | 'KubernetesAws'
    | 'KubernetesRancher'
  yaml?: string
}

export interface InfrastructureYamlMetadata {
  connectorRef?: string
  entityGitDetails?: EntityGitDetails
  fallbackBranch?: string
  infrastructureIdentifier: string
  infrastructureYaml?: string
  inputSetTemplateYaml?: string
  orgIdentifier?: string
  projectIdentifier?: string
  storeType?: 'INLINE' | 'REMOTE'
}

export interface InfrastructureYamlMetadataApiInput {
  infrastructureIdentifiers: string[]
}

export interface InfrastructureYamlMetadataApiInputV2 {
  environmentBranch?: string
  infrastructureIdentifiers: string[]
}

export interface InfrastructureYamlMetadataDTO {
  infrastructureYamlMetadataList?: InfrastructureYamlMetadata[]
}

export type InheritFromManifestStoreConfig = StoreConfig & {
  paths?: string[]
}

export type InheritedCloudformationDeleteStackStepConfiguration = CloudformationDeleteStackStepConfigurationSpec & {
  provisionerIdentifier: string
}

export type InlineCloudformationDeleteStackStepConfiguration = CloudformationDeleteStackStepConfigurationSpec & {
  connectorRef: string
  region: string
  roleArn?: string
  stackName: string
}

export type InlineCloudformationTagsFileSpec = CloudformationTagsFileSpec & {
  content: string
}

export type InlineCloudformationTemplateFileSpec = CloudformationTemplateFileSpec & {
  templateBody: string
}

export type InlineStoreConfig = StoreConfig & {
  content: string
}

export type InlineTerraformBackendConfigSpec = TerraformBackendConfigSpec & {
  content?: string
}

export type InlineTerraformVarFileSpec = TerraformVarFileSpec & {
  content?: string
}

export type InlineTerragruntBackendConfigSpec = TerragruntBackendConfigSpec & {
  content?: string
}

export type InlineTerragruntVarFileSpec = TerragruntVarFileSpec & {
  content?: string
}

export interface InputSetError {
  fieldName?: string
  identifierOfErrorSource?: string
  message?: string
}

export interface InputSetErrorResponse {
  errors?: InputSetError[]
}

export type InputSetErrorWrapper = ErrorMetadataDTO & {
  errorPipelineYaml?: string
  invalidInputSetReferences?: string[]
  uuidToErrorResponseMap?: {
    [key: string]: InputSetErrorResponse
  }
}

export type InputSetFilterProperties = FilterProperties & {
  inputSetIdsWithPipelineIds?: string[]
}

export type InputSetReference = EntityReference & {
  isDefault?: boolean
  pipelineIdentifier?: string
}

export interface InputSetValidator {
  parameters?: string
  validatorType?: 'ALLOWED_VALUES' | 'REGEX'
}

export interface InputsValidationResponse {
  childrenErrorNodes?: NodeErrorSummary[]
  valid?: boolean
}

export interface InstanceCountDetailsByEnvTypeAndServiceId {
  instanceCountDetailsByEnvTypeBaseMap?: {
    [key: string]: InstanceCountDetailsByEnvTypeBase
  }
}

export interface InstanceCountDetailsByEnvTypeBase {
  nonProdInstances?: number
  prodInstances?: number
  totalInstances?: number
}

export interface InstanceDetailGroupedByPipelineExecution {
  instances: InstanceDetailsDTO[]
  lastDeployedAt?: number
  pipelineId: string
  planExecutionId: string
  rollbackStatus?: 'UNAVAILABLE' | 'NOT_STARTED' | 'STARTED' | 'SUCCESS' | 'FAILURE'
  stageNodeExecutionId?: string
  stageSetupId?: string
  stageStatus?:
    | 'NO_OP'
    | 'RUNNING'
    | 'INTERVENTION_WAITING'
    | 'TIMED_WAITING'
    | 'ASYNC_WAITING'
    | 'TASK_WAITING'
    | 'DISCONTINUING'
    | 'PAUSING'
    | 'QUEUED'
    | 'SKIPPED'
    | 'PAUSED'
    | 'ABORTED'
    | 'ERRORED'
    | 'FAILED'
    | 'EXPIRED'
    | 'SUSPENDED'
    | 'SUCCEEDED'
    | 'IGNORE_FAILED'
    | 'APPROVAL_WAITING'
    | 'RESOURCE_WAITING'
    | 'APPROVAL_REJECTED'
    | 'INPUT_WAITING'
    | 'WAIT_STEP_RUNNING'
    | 'FREEZE_FAILED'
    | 'QUEUED_LICENSE_LIMIT_REACHED'
    | 'QUEUED_EXECUTION_CONCURRENCY_REACHED'
    | 'UNRECOGNIZED'
}

export interface InstanceDetailGroupedByPipelineExecutionList {
  instanceDetailGroupedByPipelineExecutionList: InstanceDetailGroupedByPipelineExecution[]
}

export interface InstanceDetailsByBuildId {
  buildId?: string
  instances?: InstanceDetailsDTO[]
}

export interface InstanceDetailsDTO {
  artifactName?: string
  connectorRef?: string
  deployedAt?: number
  deployedById?: string
  deployedByName?: string
  infrastructureDetails?: InfrastructureDetails
  infrastructureMappingId?: string
  instanceInfoDTO?: InstanceInfoDTO
  instanceKey?: string
  pipelineExecutionName?: string
  podName?: string
  rollbackStatus?: 'UNAVAILABLE' | 'NOT_STARTED' | 'STARTED' | 'SUCCESS' | 'FAILURE'
  terraformInstance?: string
}

export interface InstanceGroupByArtifact {
  artifact?: string
  instanceGroupedOnEnvironmentList?: InstanceGroupedOnEnvironment[]
  lastDeployedAt?: number
}

export interface InstanceGroupByChartVersion {
  chartVersion?: string
  instanceGroupByArtifactList: InstanceGroupByArtifact[]
  lastDeployedAt?: number
}

export interface InstanceGroupedByArtifact {
  artifact?: string
  instanceGroupedByChartVersionList: InstanceGroupedByChartVersion[]
  lastDeployedAt?: number
}

export interface InstanceGroupedByArtifactV2 {
  artifactPath?: string
  artifactVersion?: string
  instanceGroupedByEnvironmentList?: InstanceGroupedByEnvironmentV2[]
  lastDeployedAt?: number
  latest?: boolean
}

export interface InstanceGroupedByChartVersion {
  chartVersion?: string
  count?: number
  infrastructureMappingId?: string
  instanceKey?: string
  lastDeployedAt?: number
  lastPlanExecutionId?: string
  pipelineIdentifier?: string
  rollbackStatus?: 'UNAVAILABLE' | 'NOT_STARTED' | 'STARTED' | 'SUCCESS' | 'FAILURE'
  stageNodeExecutionId?: string
  stageSetupId?: string
}

export interface InstanceGroupedByEnvironment {
  envGroups?: string[]
  envId: string
  envName?: string
  instanceGroupedByEnvironmentTypeList: InstanceGroupedByEnvironmentType[]
  lastDeployedAt?: number
}

export interface InstanceGroupedByEnvironmentList {
  instanceGroupedByEnvironmentList: InstanceGroupedByEnvironment[]
}

export interface InstanceGroupedByEnvironmentType {
  environmentType?: 'PreProduction' | 'Production'
  instanceGroupedByInfrastructureList: InstanceGroupedByInfrastructure[]
  lastDeployedAt?: number
}

export interface InstanceGroupedByEnvironmentV2 {
  envId?: string
  envName?: string
  instanceGroupedByClusterList?: InstanceGroupedByInfrastructureV2[]
  instanceGroupedByInfraList?: InstanceGroupedByInfrastructureV2[]
  lastDeployedAt?: number
}

export interface InstanceGroupedByInfrastructure {
  agentId?: string
  clusterId?: string
  infrastructureId?: string
  infrastructureName?: string
  instanceGroupedByArtifactList: InstanceGroupedByArtifact[]
  lastDeployedAt?: number
}

export interface InstanceGroupedByInfrastructureV2 {
  agentIdentifier?: string
  clusterIdentifier?: string
  infraIdentifier?: string
  infraName?: string
  instanceGroupedByPipelineExecutionList?: InstanceGroupedByPipelineExecution[]
  lastDeployedAt?: number
}

export interface InstanceGroupedByPipelineExecution {
  count?: number
  lastDeployedAt?: number
  lastPipelineExecutionId?: string
  lastPipelineExecutionName?: string
}

export interface InstanceGroupedByService {
  instanceGroupedByArtifactList?: InstanceGroupedByArtifactV2[]
  lastDeployedAt?: number
  serviceId?: string
  serviceName?: string
}

export interface InstanceGroupedByServiceList {
  instanceGroupedByServiceList?: InstanceGroupedByService[]
}

export interface InstanceGroupedOnArtifact {
  artifact?: string
  instanceGroupedOnChartVersionList: InstanceGroupedOnChartVersion[]
  lastDeployedAt?: number
}

export interface InstanceGroupedOnArtifactList {
  instanceGroupedOnArtifactList: InstanceGroupedOnArtifact[]
}

export interface InstanceGroupedOnChartVersion {
  chartVersion?: string
  instanceGroupedOnEnvironmentList?: InstanceGroupedOnEnvironment[]
  lastDeployedAt?: number
}

export interface InstanceGroupedOnChartVersionList {
  instanceGroupByChartVersionList: InstanceGroupByChartVersion[]
}

export interface InstanceGroupedOnEnvironment {
  envId?: string
  envName?: string
  instanceGroupedOnEnvironmentTypeList?: InstanceGroupedOnEnvironmentType[]
  lastDeployedAt?: number
}

export interface InstanceGroupedOnEnvironmentType {
  environmentType?: 'PreProduction' | 'Production'
  instanceGroupedOnInfrastructureList?: InstanceGroupedOnInfrastructure[]
  lastDeployedAt?: number
}

export interface InstanceGroupedOnInfrastructure {
  agentId?: string
  clusterId?: string
  count?: number
  infrastructureId?: string
  infrastructureName?: string
  lastDeployedAt?: number
}

export interface InstanceInfoDTO {
  podName?: string
  type?: string
}

export interface InstanceSelectionBase {
  [key: string]: any
}

export interface InstanceSelectionWrapper {
  spec?: InstanceSelectionBase
  type?: 'Count' | 'Percentage'
}

export interface InstanceSyncResponseV2 {
  [key: string]: any
}

export interface InstanceSyncTaskDetails {
  details?: PageDeploymentReleaseDetails
  responseBatchConfig?: ResponseBatchConfig
}

export interface InstancesByBuildIdList {
  instancesByBuildIdList?: InstanceDetailsByBuildId[]
}

export type InvalidFieldsDTO = ErrorMetadataDTO & {}

export interface Invite {
  accountIdentifier: string
  approved?: boolean
  email: string
  id: string
  inviteType: 'USER_INITIATED_INVITE' | 'ADMIN_INITIATED_INVITE' | 'SCIM_INITIATED_INVITE'
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  roleBindings?: RoleBinding[]
  userGroups?: string[]
}

export interface InvoiceDetailDTO {
  amountDue?: number
  clientSecret?: string
  invoiceId?: string
  items?: ItemDTO[]
  nextPaymentAttempt?: number
  paymentIntent?: PaymentIntentDetailDTO
  periodEnd?: number
  periodStart?: number
  subscriptionId?: string
  totalAmount?: number
}

export interface ItemDTO {
  amount?: number
  description?: string
  price?: PriceDTO
  proration?: boolean
  quantity?: number
}

export type JUnitTestReport = UnitTestReportSpec & {
  paths?: string[]
}

export type JenkinsArtifactConfig = ArtifactConfig & {
  artifactPath?: string
  build?: string
  connectorRef: string
  jobName: string
}

export type JenkinsArtifactSummary = ArtifactSummary & {
  build?: string
  jobName?: string
  tag?: string
}

export interface JenkinsAuthCredentialsDTO {
  [key: string]: any
}

export interface JenkinsAuthenticationDTO {
  spec?: JenkinsAuthCredentialsDTO
  type: 'UsernamePassword' | 'Anonymous' | 'Bearer Token(HTTP Header)'
}

export type JenkinsBearerTokenDTO = JenkinsAuthCredentialsDTO & {
  tokenRef: string
}

export type JenkinsBuildStepInfo = StepSpecType & {
  connectorRef: string
  consoleLogPollFrequency?: string
  delegateSelectors?: string[]
  jobName: string
  jobParameter?: JenkinsParameterField[]
  metadata?: string
  unstableStatusAsSuccess?: boolean
  useConnectorUrlForJobExecution?: boolean
}

export type JenkinsConnectorDTO = ConnectorConfigDTO & {
  auth?: JenkinsAuthenticationDTO
  delegateSelectors?: string[]
  jenkinsUrl: string
}

export interface JenkinsJobDetailsDTO {
  jobDetails?: JobDetails[]
}

export interface JenkinsParameterField {
  metadata?: string
  name?: string
  type?: 'String' | 'Number'
  value: string
}

export type JenkinsUserNamePasswordDTO = JenkinsAuthCredentialsDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export interface JiraAuthCredentialsDTO {
  [key: string]: any
}

export interface JiraAuthenticationDTO {
  spec: JiraAuthCredentialsDTO
  type: 'UsernamePassword' | 'PersonalAccessToken'
}

export type JiraConnector = ConnectorConfigDTO & {
  auth: JiraAuthenticationDTO
  delegateSelectors?: string[]
  jiraUrl: string
  passwordRef?: string
  username?: string
  usernameRef?: string
}

export interface JiraFieldAllowedValueNG {
  id?: string
  name?: string
  value?: string
}

export interface JiraFieldNG {
  allowedValues: JiraFieldAllowedValueNG[]
  custom?: boolean
  key: string
  name: string
  required?: boolean
  schema: JiraFieldSchemaNG
}

export interface JiraFieldSchemaNG {
  array?: boolean
  customType?: string
  type: 'string' | 'number' | 'date' | 'datetime' | 'timetracking' | 'option' | 'user' | 'issuelink' | 'issuetype'
  typeStr: string
}

export interface JiraIssueCreateMetadataNG {
  projects?: {
    [key: string]: JiraProjectNG
  }
}

export interface JiraIssueTransitionNG {
  available?: boolean
  id: string
  name: string
  to: JiraStatusNG
}

export interface JiraIssueTypeNG {
  description?: string
  fields: {
    [key: string]: JiraFieldNG
  }
  id: string
  name: string
  statuses: JiraStatusNG[]
  subTask?: boolean
}

export interface JiraIssueUpdateMetadataNG {
  fields: {
    [key: string]: JiraFieldNG
  }
}

export type JiraPATDTO = JiraAuthCredentialsDTO & {
  patRef: string
}

export interface JiraProjectBasicNG {
  id: string
  key: string
  name: string
}

export interface JiraProjectNG {
  id: string
  issuetypes: {
    [key: string]: JiraIssueTypeNG
  }
  key: string
  name: string
}

export interface JiraStatusCategoryNG {
  id: number
  key: string
  name: string
}

export interface JiraStatusNG {
  id: string
  name: string
  statusCategory?: JiraStatusCategoryNG
}

export interface JiraUserData {
  accountId?: string
  active?: boolean
  displayName?: string
  emailAddress?: string
  name?: string
}

export type JiraUserNamePasswordDTO = JiraAuthCredentialsDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export interface JobDetails {
  folder?: boolean
  jobName?: string
  parameters?: JobParameter[]
  url?: string
}

export interface JobParameter {
  defaultValue?: string
  description?: string
  name?: string
  options?: string[]
}

export interface JsonNode {
  [key: string]: any
}

export interface JwksPublicKeyDTO {
  alg?: string
  e?: string
  kid?: string
  kty?: string
  n?: string
  use?: string
}

export interface JwksPublicKeysDTO {
  keys?: JwksPublicKeyDTO[]
}

export type K8SDirectInfrastructure = Infrastructure & {
  connectorRef: string
  namespace: string
  provisioner?: string
  releaseName: string
}

export type K8sApplyStepInfo = StepSpecType & {
  commandFlags?: K8sStepCommandFlag[]
  delegateSelectors?: string[]
  filePaths?: string[]
  manifestSource?: ManifestSourceWrapper
  overrides?: ManifestConfigWrapper[]
  skipDryRun?: boolean
  skipRendering?: boolean
  skipSteadyStateCheck?: boolean
}

export type K8sAwsInfrastructure = Infrastructure & {
  cluster: string
  connectorRef: string
  metadata?: string
  namespace: string
  provisioner?: string
  region?: string
  releaseName: string
}

export type K8sAzureInfrastructure = Infrastructure & {
  cluster: string
  connectorRef: string
  namespace: string
  provisioner?: string
  releaseName: string
  resourceGroup: string
  subscriptionId: string
  useClusterAdminCredentials?: boolean
}

export type K8sBGStageScaleDownStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type K8sBGSwapServicesStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export interface K8sBasicInfo {
  agentIdentifier?: string
  clusterIdentifier?: string
  containerList?: K8sContainer[]
  namespace: string
  podId: string
  podName: string
}

export type K8sBlueGreenStepInfo = StepSpecType & {
  commandFlags?: K8sStepCommandFlag[]
  delegateSelectors?: string[]
  pruningEnabled?: boolean
  skipDryRun?: boolean
  skipUnchangedManifest?: boolean
}

export type K8sCanaryDeleteStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type K8sCanaryStepInfo = StepSpecType & {
  commandFlags?: K8sStepCommandFlag[]
  delegateSelectors?: string[]
  instanceSelection: InstanceSelectionWrapper
  skipDryRun?: boolean
}

export interface K8sConfigDetails {
  k8sPermissionType?: 'CLUSTER_ADMIN' | 'CLUSTER_VIEWER' | 'NAMESPACE_ADMIN'
  namespace?: string
}

export interface K8sContainer {
  containerId?: string
  image?: string
  name?: string
}

export type K8sDeleteStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  deleteResources: DeleteResourcesWrapper
}

export type K8sDeploymentReleaseDetails = DeploymentDetails & {
  helmChartInfo?: HelmChartInfo
  k8sCloudClusterConfig?: KubernetesCloudClusterConfig
  namespaces?: string[]
  releaseName?: string
}

export type K8sDirectInfra = StepGroupInfra & {
  spec: ContainerInfraYamlSpec
  type: 'KubernetesDirect' | 'Delegate' | 'Noop'
}

export type K8sDryRunManifestStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type K8sGcpInfrastructure = Infrastructure & {
  cluster: string
  connectorRef: string
  metadata?: string
  namespace: string
  provisioner?: string
  releaseName: string
}

export type K8sInfrastructureDetails = InfrastructureDetails & {
  namespace?: string
  releaseName?: string
}

export type K8sInstanceInfoDTO = InstanceInfoDTO & {
  blueGreenColor?: string
  canary?: boolean
  containerList: K8sContainer[]
  helmChartInfo?: HelmChartInfo
  namespace: string
  podIP?: string
  podName: string
  releaseName: string
}

export type K8sManifest = ManifestAttributes & {
  enableDeclarativeRollback?: ParameterFieldBoolean
  metadata?: string
  skipResourceVersioning?: ParameterFieldBoolean
  store?: StoreConfigWrapper
  valuesPaths?: string[]
}

export type K8sRancherInfrastructure = Infrastructure & {
  cluster: string
  connectorRef: string
  metadata?: string
  namespace: string
  provisioner?: string
  releaseName: string
}

export type K8sRollingRollbackStepInfo = StepSpecType & {
  commandFlags?: K8sStepCommandFlag[]
  delegateSelectors?: string[]
  pruningEnabled?: boolean
}

export type K8sRollingStepInfo = StepSpecType & {
  commandFlags?: K8sStepCommandFlag[]
  delegateSelectors?: string[]
  pruningEnabled?: boolean
  skipDryRun?: boolean
}

export type K8sScaleStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  instanceSelection: InstanceSelectionWrapper
  skipSteadyStateCheck?: boolean
  workload: string
}

export interface K8sStepCommandFlag {
  commandType: 'Apply'
  flag?: string
}

export type K8sStepInstanceInfo = StepInstanceInfo & {
  podName?: string
}

export type KerberosConfigDTO = BaseSSHSpecDTO & {
  principal: string
  realm: string
  spec?: TGTGenerationSpecDTO
  tgtGenerationMethod?: 'KeyTabFilePath' | 'Password'
}

export type KerberosWinRmConfigDTO = BaseWinRmSpecDTO & {
  principal: string
  realm: string
  skipCertChecks?: boolean
  spec?: TGTGenerationSpecDTO
  tgtGenerationMethod?: 'KeyTabFilePath' | 'Password'
  useNoProfile?: boolean
  useSSL?: boolean
}

export interface KeyValuePair {
  key?: string
  value?: string
}

export interface KubernetesAuthCredentialDTO {
  [key: string]: any
}

export interface KubernetesAuthDTO {
  spec: KubernetesAuthCredentialDTO
  type: 'UsernamePassword' | 'ClientKeyCert' | 'ServiceAccount' | 'OpenIdConnect'
}

export type KubernetesClientKeyCertDTO = KubernetesAuthCredentialDTO & {
  caCertRef?: string
  clientCertRef: string
  clientKeyAlgo?: string
  clientKeyPassphraseRef?: string
  clientKeyRef: string
}

export interface KubernetesCloudClusterConfig {
  addRegionalParam?: boolean
  clusterName?: string
  region?: string
  resourceGroup?: string
  subscriptionId?: string
  useClusterAdminCredentials?: boolean
}

export type KubernetesClusterConfigDTO = ConnectorConfigDTO & {
  credential: KubernetesCredentialDTO
  delegateSelectors?: string[]
}

export type KubernetesClusterDetailsDTO = KubernetesCredentialSpecDTO & {
  auth: KubernetesAuthDTO
  masterUrl: string
}

export interface KubernetesCredentialDTO {
  spec?: KubernetesCredentialSpecDTO
  type: 'InheritFromDelegate' | 'ManualConfig'
}

export interface KubernetesCredentialSpecDTO {
  [key: string]: any
}

export type KubernetesDeploymentMetaData = DeploymentMetaData & { [key: string]: any }

export type KubernetesOpenIdConnectDTO = KubernetesAuthCredentialDTO & {
  oidcClientIdRef: string
  oidcIssuerUrl?: string
  oidcPasswordRef: string
  oidcScopes?: string
  oidcSecretRef?: string
  oidcUsername?: string
  oidcUsernameRef?: string
}

export type KubernetesServiceAccountDTO = KubernetesAuthCredentialDTO & {
  caCertRef?: string
  serviceAccountTokenRef: string
}

export type KubernetesServiceSpec = ServiceSpec & {
  hooks?: ServiceHookWrapper[]
  manifestConfigurations?: ManifestConfigurations
  release?: HarnessRelease
}

export type KubernetesUserNamePasswordDTO = KubernetesAuthCredentialDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type KustomizeManifest = ManifestAttributes & {
  commandFlags?: KustomizeManifestCommandFlag[]
  enableDeclarativeRollback?: ParameterFieldBoolean
  metadata?: string
  overlayConfiguration?: OverlayConfiguration
  patchesPaths?: string[]
  pluginPath?: string
  skipResourceVersioning?: ParameterFieldBoolean
  store?: StoreConfigWrapper
}

export interface KustomizeManifestCommandFlag {
  commandType: 'Build'
  flag?: string
}

export type KustomizePatchesManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export interface KustomizeReplicas {
  count: string
  name: string
}

export interface KustomizeValues {
  images?: string[]
  namespace?: string
  replicas?: KustomizeReplicas[]
}

export interface LDAPSettings {
  connectionSettings: LdapConnectionSettings
  cronExpression?: string
  disabled?: boolean
  displayName: string
  groupSettingsList?: LdapGroupSettings[]
  identifier: string
  nextIterations?: number[]
  settingsType?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
  userSettingsList?: LdapUserSettings[]
}

export interface LandingDashboardRequestCD {
  orgProjectIdentifiers: OrgProjectIdentifier[]
}

export interface LandingPageDeploymentCount {
  value?: number
}

export interface LastWorkloadInfo {
  authorInfo?: AuthorInfo
  deploymentType?: string
  endTime?: number
  startTime?: number
  status?: string
  triggerType?: string
}

export interface LdapConnectionSettings {
  accountId?: string
  bindDN?: string
  bindPassword?: string
  bindSecret?: string[]
  connectTimeout?: number
  delegateSelectors?: string[]
  host: string
  maxReferralHops?: number
  passwordType?: string
  port?: number
  referralsEnabled?: boolean
  responseTimeout?: number
  settingType?:
    | 'HOST_CONNECTION_ATTRIBUTES'
    | 'BASTION_HOST_CONNECTION_ATTRIBUTES'
    | 'SMTP'
    | 'SFTP'
    | 'JENKINS'
    | 'BAMBOO'
    | 'STRING'
    | 'SPLUNK'
    | 'ELK'
    | 'LOGZ'
    | 'SUMO'
    | 'DATA_DOG'
    | 'APM_VERIFICATION'
    | 'BUG_SNAG'
    | 'LOG_VERIFICATION'
    | 'APP_DYNAMICS'
    | 'NEW_RELIC'
    | 'DYNA_TRACE'
    | 'INSTANA'
    | 'DATA_DOG_LOG'
    | 'CLOUD_WATCH'
    | 'SCALYR'
    | 'ELB'
    | 'SLACK'
    | 'AWS'
    | 'GCS'
    | 'GCP'
    | 'AZURE'
    | 'PCF'
    | 'RANCHER'
    | 'DIRECT'
    | 'KUBERNETES_CLUSTER'
    | 'DOCKER'
    | 'ECR'
    | 'GCR'
    | 'ACR'
    | 'PHYSICAL_DATA_CENTER'
    | 'KUBERNETES'
    | 'NEXUS'
    | 'ARTIFACTORY'
    | 'SMB'
    | 'AMAZON_S3'
    | 'GIT'
    | 'SSH_SESSION_CONFIG'
    | 'SERVICE_VARIABLE'
    | 'CONFIG_FILE'
    | 'KMS'
    | 'GCP_KMS'
    | 'JIRA'
    | 'SERVICENOW'
    | 'SECRET_TEXT'
    | 'SECRET_FILE'
    | 'YAML_GIT_SYNC'
    | 'VAULT'
    | 'VAULT_SSH'
    | 'AWS_SECRETS_MANAGER'
    | 'WINRM_CONNECTION_ATTRIBUTES'
    | 'WINRM_SESSION_CONFIG'
    | 'PROMETHEUS'
    | 'INFRASTRUCTURE_MAPPING'
    | 'HTTP_HELM_REPO'
    | 'AMAZON_S3_HELM_REPO'
    | 'GCS_HELM_REPO'
    | 'SPOT_INST'
    | 'AZURE_ARTIFACTS_PAT'
    | 'CUSTOM'
    | 'CE_AWS'
    | 'CE_GCP'
    | 'CE_AZURE'
    | 'AZURE_VAULT'
    | 'KUBERNETES_CLUSTER_NG'
    | 'GIT_NG'
    | 'SSO_SAML'
    | 'LDAP'
    | 'GCP_SECRETS_MANAGER'
    | 'TRIGGER'
    | 'OCI_HELM_REPO'
  sslEnabled?: boolean
  useRecursiveGroupMembershipSearch?: boolean
}

export interface LdapGroupResponse {
  description?: string
  dn?: string
  message?: string
  name?: string
  selectable?: boolean
  totalMembers?: number
  users?: LdapUserResponse[]
}

export interface LdapGroupSettings {
  baseDN?: string
  descriptionAttr?: string
  nameAttr?: string
  referencedUserAttr?: string
  searchFilter?: string
  userMembershipAttr?: string
}

export interface LdapLinkGroupRequest {
  ldapGroupDN?: string
  ldapGroupName?: string
}

export interface LdapResponse {
  message?: string
  status?: 'SUCCESS' | 'FAILURE'
}

export type LdapSettings = SSOSettings & {
  connectionSettings: LdapConnectionSettings
  cronExpression?: string
  disabled?: boolean
  groupSettings?: LdapGroupSettings
  groupSettingsList?: LdapGroupSettings[]
  userSettings?: LdapUserSettings
  userSettingsList?: LdapUserSettings[]
}

export interface LdapTestResponse {
  message?: string
  status?: 'SUCCESS' | 'FAILURE'
}

export interface LdapUserResponse {
  dn?: string
  email?: string
  name?: string
  userId?: string
}

export interface LdapUserSettings {
  baseDN?: string
  displayNameAttr?: string
  emailAttr?: string
  groupMembershipAttr?: string
  samAccountNameAttr?: string
  searchFilter?: string
  uidAttr?: string
}

export interface LicenseDateUsageDTO {
  licenseType?: 'SERVICES' | 'SERVICE_INSTANCES'
  licenseUsage?: {
    [key: string]: number
  }
  reportType?: 'DAILY' | 'MONTHLY'
}

export interface LicenseDateUsageParams {
  fromDate?: string
  reportType?: 'DAILY' | 'MONTHLY'
  toDate?: string
}

export interface LicenseInfo {
  accountStatus?: string
  accountType?: string
  expiryTime?: number
  licenseUnits?: number
}

export type LicenseRateLimitRestrictionDTO = RestrictionDTO & {
  count?: number
  fieldName?: string
  limit?: number
  timeUnit?: TimeUnit
}

export type LicenseRateLimitRestrictionMetadataDTO = RestrictionMetadataDTO & {
  fieldName?: string
  limit?: number
  timeUnit?: TimeUnit
}

export type LicenseStaticLimitRestrictionDTO = RestrictionDTO & {
  count?: number
  fieldName?: string
  limit?: number
}

export type LicenseStaticLimitRestrictionMetadataDTO = RestrictionMetadataDTO & {
  fieldName?: string
  limit?: number
}

export interface LicenseUsageDTO {
  accountIdentifier?: string
  module?: string
  timestamp?: number
}

export interface LicensesWithSummaryDTO {
  edition?: 'COMMUNITY' | 'FREE' | 'TEAM' | 'ENTERPRISE'
  licenseType?: 'TRIAL' | 'PAID'
  maxExpiryTime?: number
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
}

export interface Limits {
  cpu?: string
  memory?: string
}

export interface LoadBalancer {
  spec?: LoadBalancerSpec
  type: 'AWSLoadBalancerConfig'
}

export interface LoadBalancerSpec {
  type?: 'AWSLoadBalancerConfig'
}

export type LocalConnectorDTO = ConnectorConfigDTO & {
  default?: boolean
}

export interface LoginSettings {
  accountId: string
  lastUpdatedAt?: number
  lastUpdatedBy?: EmbeddedUser
  passwordExpirationPolicy: PasswordExpirationPolicy
  passwordStrengthPolicy: PasswordStrengthPolicy
  userLockoutPolicy: UserLockoutPolicy
  uuid: string
}

export interface LoginTypeResponse {
  authenticationMechanism?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
  defaultExperience?: 'NG' | 'CG'
  oauthEnabled?: boolean
  showCaptcha?: boolean
  ssorequest?: SSORequest
}

export type ManagedArgoGitOpsInfoDTO = GitOpsInfoDTO & {
  namespace: string
}

export interface ManagementGroupData {
  displayName?: string
  id?: string
  name?: string
}

export interface ManifestAttributes {
  [key: string]: any
}

export interface ManifestConfig {
  identifier: string
  spec: ManifestAttributes
  type:
    | 'HelmChart'
    | 'HelmRepoOverride'
    | 'K8sManifest'
    | 'Kustomize'
    | 'KustomizePatches'
    | 'OpenshiftParam'
    | 'OpenshiftTemplate'
    | 'Values'
    | 'ServerlessAwsLambda'
    | 'ReleaseRepo'
    | 'DeploymentRepo'
    | 'EcsTaskDefinition'
    | 'EcsServiceDefinition'
    | 'EcsScalableTargetDefinition'
    | 'EcsScalingPolicyDefinition'
    | 'TasManifest'
    | 'TasVars'
    | 'TasAutoScaler'
    | 'AsgLaunchTemplate'
    | 'AsgConfiguration'
    | 'AsgScalingPolicy'
    | 'AsgScheduledUpdateGroupAction'
    | 'GoogleCloudFunctionDefinition'
    | 'AwsLambdaFunctionDefinition'
    | 'AwsLambdaFunctionAliasDefinition'
    | 'AwsSamDirectory'
    | 'GoogleCloudFunctionGenOneDefinition'
}

export interface ManifestConfigWrapper {
  manifest?: ManifestConfig
}

export interface ManifestConfigurations {
  primaryManifestRef?: string
}

export interface ManifestOverrideSetWrapper {
  overrideSet?: ManifestOverrideSets
}

export interface ManifestOverrideSets {
  identifier?: string
  manifests?: ManifestConfigWrapper[]
}

export interface ManifestSourceWrapper {
  spec: ManifestAttributes
  type: 'K8sManifest'
}

export interface ManifestStoreInfo {
  branch?: string
  bucketName?: string
  chartName?: string
  chartVersion?: string
  commitId?: string
  folderPath?: string
  helmVersion?: string
  paths?: string[]
  region?: string
  repoName?: string
  storeType?: string
  subChartPath?: string
}

export interface ManualFailureSpecConfig {
  onTimeout: OnTimeoutConfig
  timeout: string
}

export type ManualInterventionFailureActionConfig = FailureStrategyActionConfig & {
  spec: ManualFailureSpecConfig
  type: 'ManualIntervention'
}

export type MarkAsFailFailureActionConfig = FailureStrategyActionConfig & {
  type: 'MarkAsFailure'
}

export type MarkAsSuccessFailureActionConfig = FailureStrategyActionConfig & {
  type: 'MarkAsSuccess'
}

export interface MatrixConfigInterface {
  [key: string]: any
}

export interface Member {
  display?: string
  ref?: string
  value?: string
}

export type MergePRStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  deleteSourceBranch: boolean
  variables?: NGVariable[]
}

export type MicrosoftTeamsConfig = NotificationSettingConfig & {
  microsoftTeamsWebhookUrl?: string
}

export type MicrosoftTeamsConfigDTO = NotificationSettingConfigDTO & {
  microsoftTeamsWebhookUrl: string
}

export interface ModuleLicenseDTO {
  accountIdentifier?: string
  createdAt?: number
  developerLicenseCount?: number
  edition?: 'COMMUNITY' | 'FREE' | 'TEAM' | 'ENTERPRISE'
  expiryTime?: number
  id?: string
  lastModifiedAt?: number
  licenseType?: 'TRIAL' | 'PAID'
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  premiumSupport?: boolean
  selfService?: boolean
  startTime?: number
  status?: 'ACTIVE' | 'DELETED' | 'EXPIRED'
  trialExtended?: boolean
}

export interface ModuleSource {
  useConnectorCredentials: ParameterFieldBoolean
}

export interface NGAuthSettings {
  settingsType?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
}

export interface NGEntityList {
  entityTypeList?: (
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  )[]
}

export interface NGEntityTemplateResponseDTO {
  inputSetTemplateYaml?: string
}

export interface NGEnvironmentConfig {
  environment?: NGEnvironmentInfoConfig
}

export interface NGEnvironmentGlobalOverride {
  applicationSettings?: ApplicationSettingsConfiguration
  configFiles?: ConfigFileWrapper[]
  connectionStrings?: ConnectionStringsConfiguration
  manifests?: ManifestConfigWrapper[]
  metadata?: string
}

export interface NGEnvironmentInfoConfig {
  description?: string
  identifier: string
  metadata?: string
  name: string
  orgIdentifier?: string
  overrides?: NGEnvironmentGlobalOverride
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
  type: 'PreProduction' | 'Production'
  variables?: NGVariable[]
}

export interface NGServiceConfig {
  metadata?: string
  service?: NGServiceV2InfoConfig
}

export interface NGServiceOverrideConfig {
  serviceOverrides?: NGServiceOverrideInfoConfig
}

export interface NGServiceOverrideInfoConfig {
  applicationSettings?: ApplicationSettingsConfiguration
  configFiles?: ConfigFileWrapper[]
  connectionStrings?: ConnectionStringsConfiguration
  environmentRef: string
  manifests?: ManifestConfigWrapper[]
  serviceRef: string
  variables?: NGVariable[]
}

export interface NGServiceV2InfoConfig {
  description?: string
  gitOpsEnabled?: boolean
  identifier: string
  metadata?: string
  name: string
  serviceDefinition?: ServiceDefinition
  tags?: {
    [key: string]: string
  }
  useFromStage?: ServiceUseFromStageV2
}

export interface NGTag {
  key: string
  value?: string
}

export type NGTemplateReference = EntityReference & {
  isDefault?: boolean
  versionLabel?: string
}

export interface NGVariable {
  description?: string
  metadata?: string
  name?: string
  required?: boolean
  type?: 'String' | 'Number' | 'Secret'
}

export interface NGVariableOverrideSetWrapper {
  overrideSet?: NGVariableOverrideSets
}

export interface NGVariableOverrideSets {
  identifier?: string
  variables?: NGVariable[]
}

export type NTLMConfigDTO = BaseWinRmSpecDTO & {
  domain: string
  password: string
  skipCertChecks?: boolean
  useNoProfile?: boolean
  useSSL?: boolean
  username: string
}

export interface NameValuePairWithDefault {
  name?: string
  type: string
  useAsDefault?: boolean
  value: string
}

export interface NamedNodeMap {
  length?: number
}

export type NativeHelmDeploymentMetaData = DeploymentMetaData & { [key: string]: any }

export type NativeHelmDeploymentReleaseDetails = DeploymentDetails & {
  helmChartInfo?: HelmChartInfo
  helmVersion?: string
  k8sCloudClusterConfig?: KubernetesCloudClusterConfig
  namespaces?: string[]
  releaseName?: string
  workloadLabelSelectors?: {
    [key: string]: string[]
  }
}

export type NativeHelmInstanceInfoDTO = InstanceInfoDTO & {
  helmChartInfo?: HelmChartInfo
  helmVersion?: 'V2' | 'V3' | 'V380'
  ip?: string
  namespace?: string
  podName: string
  releaseName?: string
}

export type NativeHelmServiceSpec = ServiceSpec & {
  hooks?: ServiceHookWrapper[]
  manifestConfigurations?: ManifestConfigurations
  release?: HarnessRelease
}

export type NewRelicConnectorDTO = ConnectorConfigDTO & {
  apiKeyRef: string
  delegateSelectors?: string[]
  newRelicAccountId: string
  url: string
}

export interface NextActionDetailDTO {
  type?: string
  useStripeSdk?: {
    [key: string]: { [key: string]: any }
  }
}

export type Nexus2RegistryArtifactConfig = ArtifactConfig & {
  connectorRef: string
  metadata?: string
  repository: string
  repositoryFormat: 'maven' | 'npm' | 'nuget'
  spec?: NexusRegistryConfigSpec
  tag?: string
  tagRegex?: string
}

export type NexusArtifactSummary = ArtifactSummary & {
  artifactPath?: string
  tag?: string
}

export interface NexusAuthCredentials {
  [key: string]: any
}

export interface NexusAuthentication {
  spec?: NexusAuthCredentials
  type: 'UsernamePassword' | 'Anonymous'
}

export interface NexusBuildDetailsDTO {
  buildUrl?: string
  imagePath?: string
  labels?: {
    [key: string]: string
  }
  metadata?: {
    [key: string]: string
  }
  tag?: string
}

export type NexusConnector = ConnectorConfigDTO & {
  auth?: NexusAuthentication
  delegateSelectors?: string[]
  nexusServerUrl: string
  version: string
}

export type NexusRegistryArtifactConfig = ArtifactConfig & {
  artifactPath?: string
  connectorRef: string
  digest?: string
  metadata?: string
  repository: string
  repositoryFormat: 'docker' | 'maven' | 'npm' | 'nuget' | 'raw'
  repositoryPort?: string
  repositoryUrl?: string
  spec?: NexusRegistryConfigSpec
  tag?: string
  tagRegex?: string
}

export interface NexusRegistryConfigSpec {
  [key: string]: any
}

export type NexusRegistryDockerConfig = NexusRegistryConfigSpec & {
  artifactPath: string
  repositoryPort?: string
  repositoryUrl?: string
}

export type NexusRegistryMavenConfig = NexusRegistryConfigSpec & {
  artifactId: string
  classifier?: string
  extension?: string
  groupId: string
}

export type NexusRegistryNpmConfig = NexusRegistryConfigSpec & {
  packageName: string
}

export type NexusRegistryNugetConfig = NexusRegistryConfigSpec & {
  packageName: string
}

export type NexusRegistryRawConfig = NexusRegistryConfigSpec & {
  group: string
}

export interface NexusRepositories {
  repositoryId?: string
  repositoryName?: string
}

export interface NexusRequestDTO {
  runtimeInputYaml?: string
  tag?: string
  tagRegex?: string
}

export interface NexusResponseDTO {
  buildDetailsList?: NexusBuildDetailsDTO[]
}

export type NexusUsernamePasswordAuth = NexusAuthCredentials & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export interface NgManagerRefreshRequestDTO {
  resolvedTemplatesYaml?: string
  yaml: string
}

export interface NgSmtpDTO {
  accountId?: string
  name: string
  uuid?: string
  value: SmtpConfigDTO
}

export interface Node {
  attributes?: NamedNodeMap
  baseURI?: string
  childNodes?: NodeList
  firstChild?: Node
  lastChild?: Node
  localName?: string
  namespaceURI?: string
  nextSibling?: Node
  nodeName?: string
  nodeType?: number
  nodeValue?: string
  ownerDocument?: Document
  parentNode?: Node
  prefix?: string
  previousSibling?: Node
  textContent?: string
}

export interface NodeErrorInfo {
  fqn?: string
  identifier?: string
  name?: string
  type?: string
}

export interface NodeErrorSummary {
  childrenErrorNodes?: NodeErrorSummary[]
  nodeInfo?: NodeInfo
  type?: 'TEMPLATE' | 'SERVICE' | 'PIPELINE' | 'UNKNOWN'
}

export interface NodeInfo {
  identifier?: string
  localFqn?: string
  name?: string
}

export interface NodeList {
  length?: number
}

export interface NotificationSettingConfig {
  type: 'EMAIL' | 'SLACK' | 'PAGERDUTY' | 'MSTEAMS' | 'WEBHOOK'
}

export interface NotificationSettingConfigDTO {
  type?: 'EMAIL' | 'SLACK' | 'PAGERDUTY' | 'MSTEAMS' | 'WEBHOOK'
}

export interface NotificationSettings {
  emailAddresses: string[]
  microsoftTeamsWebhookUrl?: string
  pagerDutyIntegrationKey?: string
  sendMailToNewMembers?: boolean
  slackConfig: SlackNotificationSetting
  useIndividualEmails?: boolean
}

export type NumberNGVariable = NGVariable & {
  default?: number
  name?: string
  type?: 'Number'
  value: number
}

export interface OAuthSettings {
  allowedProviders?: ('AZURE' | 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'GOOGLE' | 'LINKEDIN')[]
  filter?: string
  settingsType?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
}

export interface OAuthSignupDTO {
  edition?: 'COMMUNITY' | 'FREE' | 'TEAM' | 'ENTERPRISE'
  email?: string
  gaClientId?: string
  intent?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  name?: string
  referer?: string
  signupAction?: 'REGULAR' | 'TRIAL' | 'SUBSCRIBE'
  utmInfo?: UtmInfo
  visitorToken?: string
}

export interface OauthAccessTokenDTO {
  accessToken?: string
  refreshToken?: string
  userDetailsDTO?: UserDetailsDTO
}

export interface OauthAccessTokenResponseDTO {
  accessTokenRef?: string
  refreshTokenRef?: string
}

export type OauthSettings = SSOSettings & {
  allowedProviders?: ('AZURE' | 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'GOOGLE' | 'LINKEDIN')[]
  filter?: string
}

export interface OciHelmAuthCredentialsDTO {
  [key: string]: any
}

export interface OciHelmAuthenticationDTO {
  spec?: OciHelmAuthCredentialsDTO
  type: 'UsernamePassword' | 'Anonymous'
}

export type OciHelmChartConfig = StoreConfig & {
  basePath?: string
  config?: OciHelmChartStoreConfigWrapper
  metadata?: string
}

export interface OciHelmChartStoreConfig {
  [key: string]: any
}

export interface OciHelmChartStoreConfigWrapper {
  metadata?: string
  spec: OciHelmChartStoreConfig
  type: 'Generic' | 'ECR'
}

export type OciHelmChartStoreEcrConfig = OciHelmChartStoreConfig & {
  connectorRef: string
  metadata?: string
  region: string
  registryId?: string
}

export type OciHelmChartStoreGenericConfig = OciHelmChartStoreConfig & {
  connectorRef?: ParameterFieldString
  metadata?: string
}

export type OciHelmConnectorDTO = ConnectorConfigDTO & {
  auth?: OciHelmAuthenticationDTO
  delegateSelectors?: string[]
  helmRepoUrl: string
}

export type OciHelmUsernamePasswordDTO = OciHelmAuthCredentialsDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export interface OidcConfiguration {
  claims_supported?: string[]
  id_token_signing_alg_values_supported?: string[]
  issuer?: string
  jwks_uri?: string
  response_types_supported?: string[]
  scopes_supported?: string[]
  subject_types_supported?: string[]
}

export interface OidcWorkloadAccessTokenResponse {
  access_token?: string
  expires_in?: number
  issued_token_type?: string
  token_type?: string
}

export type OktaAddOperation = PatchOperation & {
  value?: JsonNode
}

export type OktaRemoveOperation = PatchOperation & {
  value?: JsonNode
}

export type OktaReplaceOperation = PatchOperation & {
  value?: JsonNode
}

export interface OnFailureConfig {
  action: FailureStrategyActionConfig
  errors: (
    | 'Unknown'
    | 'AllErrors'
    | 'Authentication'
    | 'Connectivity'
    | 'Timeout'
    | 'Authorization'
    | 'Verification'
    | 'DelegateProvisioning'
    | 'PolicyEvaluationFailure'
    | 'InputTimeoutError'
    | 'ApprovalRejection'
    | 'DelegateRestart'
    | 'UserMarkedFailure'
  )[]
}

export interface OnRetryFailureConfig {
  action?: FailureStrategyActionConfig
}

export interface OnTimeoutConfig {
  action?: FailureStrategyActionConfig
}

export interface OpenTaskDetails {
  pipelineDeploymentDetails?: ServicePipelineWithRevertInfo[]
}

export type OpenshiftManifest = ManifestAttributes & {
  enableDeclarativeRollback?: ParameterFieldBoolean
  metadata?: string
  paramsPaths?: string[]
  skipResourceVersioning?: ParameterFieldBoolean
  store?: StoreConfigWrapper
}

export type OpenshiftParamManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export interface OrgDeployments {
  orgIdentifier?: string
  projectDeploymentsList?: ProjectDeployments[]
}

export interface OrgLevelOverrideMigrationResponseDTO {
  accountId?: string
  environmentsInfo?: SingleEnvMigrationResponse[]
  envsMigrationSuccessful?: boolean
  migratedEnvironmentCount?: number
  migratedEnvironmentsCount?: number
  migratedServiceOverridesCount?: number
  orgIdentifier?: string
  overridesMigrationSuccessFul?: boolean
  serviceOverridesInfo?: SingleServiceOverrideMigrationResponse[]
  totalEnvironmentsCount?: number
  totalServiceOverridesCount?: number
}

export interface OrgLevelOverrideV2SettingsUpdateResponseDTO {
  accountId?: string
  orgIdentifier?: string
  settingResponseDTO?: SettingResponseDTO[]
  settingsUpdateSuccessFul?: boolean
}

export interface OrgProjectIdentifier {
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface Organization {
  description?: string
  identifier: string
  name: string
  tags?: {
    [key: string]: string
  }
  uniqueId?: string
}

export interface OrganizationAggregateDTO {
  admins?: UserMetadataDTO[]
  collaborators?: UserMetadataDTO[]
  connectorsCount?: number
  delegatesCount?: number
  organizationResponse: OrganizationResponse
  projectsCount?: number
  secretsCount?: number
  templatesCount?: number
}

export interface OrganizationDTO {
  organizationId: string
  organizationName: string
}

export interface OrganizationRequest {
  organization: Organization
}

export interface OrganizationResponse {
  createdAt?: number
  harnessManaged?: boolean
  lastModifiedAt?: number
  organization: Organization
}

export interface OrganizationsDTO {
  organizations?: OrganizationDTO[]
}

export interface OutputNGVariable {
  description?: string
  name?: string
}

export interface OverlayConfiguration {
  kustomizeYamlFolderPath: string
}

export type OverlayInputSetErrorWrapper = ErrorMetadataDTO & {
  invalidReferences?: {
    [key: string]: string
  }
}

export interface OverrideFilterProperties {
  environmentRefs?: string[]
  filterType?:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
    | 'Trigger'
    | 'EnvironmentGroup'
    | 'FileStore'
    | 'CCMRecommendation'
    | 'Anomaly'
    | 'Environment'
    | 'RuleExecution'
    | 'Override'
    | 'InputSet'
  infraIdentifiers?: string[]
  labels?: {
    [key: string]: string
  }
  serviceRefs?: string[]
  tags?: {
    [key: string]: string
  }
}

export interface OverrideV2SettingsUpdateResponseDTO {
  accountId?: string
  accountLevelUpdateInfo?: AccountLevelOverrideV2SettingsUpdateResponseDTO
  orgLevelUpdateInfo?: OrgLevelOverrideV2SettingsUpdateResponseDTO[]
  projectLevelUpdateInfo?: ProjectLevelOverrideV2SettingsUpdateResponseDTO[]
  successful?: boolean
}

export type PRBuildSpec = BuildSpec & {
  number: string
}

export interface Page {
  content?: { [key: string]: any }[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageActiveServiceDTO {
  content?: ActiveServiceDTO[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface PageActivity {
  content?: Activity[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface PageActivitySummary {
  content?: ActivitySummary[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface PageApiKeyAggregateDTO {
  content?: ApiKeyAggregateDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageCcmK8sConnectorResponse {
  content?: CcmK8sConnectorResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageClusterFromGitops {
  content?: ClusterFromGitops[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageClusterResponse {
  content?: ClusterResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageConnectorResponse {
  content?: ConnectorResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageDeploymentReleaseDetails {
  content?: DeploymentReleaseDetails[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageEntitySetupUsageDTO {
  content?: EntitySetupUsageDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageEnvironmentGroupResponse {
  content?: EnvironmentGroupResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageEnvironmentResponse {
  content?: EnvironmentResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageEnvironmentResponseDTO {
  content?: EnvironmentResponseDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageFileDTO {
  content?: FileDTO[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface PageFilterDTO {
  content?: FilterDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageFreezeSummaryResponse {
  content?: FreezeSummaryResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageGitBranchDTO {
  content?: GitBranchDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageGitFullSyncEntityInfoDTO {
  content?: GitFullSyncEntityInfoDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageGitSyncEntityListDTO {
  content?: GitSyncEntityListDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageGitSyncErrorAggregateByCommitDTO {
  content?: GitSyncErrorAggregateByCommitDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageGitSyncErrorDTO {
  content?: GitSyncErrorDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageGitopsProviderResponse {
  content?: GitopsProviderResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageHostDTO {
  content?: HostDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageInfrastructureResponse {
  content?: InfrastructureResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageInvite {
  content?: Invite[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageOrganizationAggregateDTO {
  content?: OrganizationAggregateDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageOrganizationResponse {
  content?: OrganizationResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageProject {
  content?: Project[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageProjectAggregateDTO {
  content?: ProjectAggregateDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageProjectResponse {
  content?: ProjectResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageRoleAssignmentResponse {
  content?: RoleAssignmentResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageSecretResponseWrapper {
  content?: SecretResponseWrapper[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageServiceAccountAggregateDTO {
  content?: ServiceAccountAggregateDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageServiceNowTemplate {
  content?: ServiceNowTemplate[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageServiceOverrideResponseDTO {
  content?: ServiceOverrideResponseDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageServiceOverridesResponseDTOV2 {
  content?: ServiceOverridesResponseDTOV2[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageServiceResponse {
  content?: ServiceResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageServiceResponseDTO {
  content?: ServiceResponseDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageTokenAggregateDTO {
  content?: TokenAggregateDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageUserAggregate {
  content?: UserAggregate[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageUserGroupAggregateDTO {
  content?: UserGroupAggregateDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageUserGroupDTO {
  content?: UserGroupDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageUserMetadataDTO {
  content?: UserMetadataDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageVariableResponseDTO {
  content?: VariableResponseDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface Pageable {
  offset?: number
  pageNumber?: number
  pageSize?: number
  paged?: boolean
  sort?: Sort
  unpaged?: boolean
}

export type PagerDutyConfig = NotificationSettingConfig & {
  pagerDutyKey?: string
}

export type PagerDutyConfigDTO = NotificationSettingConfigDTO & {
  pagerDutyKey: string
}

export type PagerDutyConnectorDTO = ConnectorConfigDTO & {
  apiTokenRef: string
  delegateSelectors?: string[]
}

export interface PaginationDetails {
  nextPage?: number
  nextPageUrl?: string
}

export type ParallelStepElementConfig = ExecutionWrapperConfig[]

export interface ParameterField {
  defaultValue?: { [key: string]: any }
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: { [key: string]: any }
}

export interface ParameterFieldBoolean {
  defaultValue?: boolean
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: boolean
}

export interface ParameterFieldListString {
  defaultValue?: string[]
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: string[]
}

export interface ParameterFieldMapStringJsonNode {
  defaultValue?: {
    [key: string]: JsonNode
  }
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: {
    [key: string]: JsonNode
  }
}

export interface ParameterFieldMapStringString {
  defaultValue?: {
    [key: string]: string
  }
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: {
    [key: string]: string
  }
}

export interface ParameterFieldMatrixConfigInterface {
  defaultValue?: MatrixConfigInterface
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: MatrixConfigInterface
}

export interface ParameterFieldString {
  defaultValue?: string
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: string
}

export interface ParameterFieldTILanguage {
  defaultValue?: 'Java' | 'Kotlin' | 'Scala' | 'Csharp' | 'Python' | 'Ruby'
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: 'Java' | 'Kotlin' | 'Scala' | 'Csharp' | 'Python' | 'Ruby'
}

export interface PartialSchemaDTO {
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  namespace?: string
  nodeName?: string
  nodeType?: string
  schema?: JsonNode
  skipStageSchema?: boolean
}

export interface PasswordChangeDTO {
  currentPassword?: string
  newPassword?: string
}

export interface PasswordExpirationPolicy {
  daysBeforePasswordExpires?: number
  daysBeforeUserNotifiedOfPasswordExpiration?: number
  enabled?: boolean
}

export interface PasswordStrengthPolicy {
  enabled?: boolean
  minNumberOfCharacters?: number
  minNumberOfDigits?: number
  minNumberOfLowercaseCharacters?: number
  minNumberOfSpecialCharacters?: number
  minNumberOfUppercaseCharacters?: number
}

export interface PatchOperation {
  path?: string
}

export interface PatchRequest {
  Operations: PatchOperation[]
  externalId?: string
  id?: string
  meta?: JsonNode
  schemas: string[]
}

export interface PaymentIntentDetailDTO {
  clientSecret?: string
  id?: string
  nextAction?: NextActionDetailDTO
  status?: string
}

export interface PaymentMethodCollectionDTO {
  paymentMethods?: CardDTO[]
}

export type PdcInfrastructure = Infrastructure & {
  connectorRef?: string
  credentialsRef: string
  delegateSelectors?: string[]
  hostArrayPath?: string
  hostAttributes?: {
    [key: string]: string
  }
  hostFilter: HostFilter
  hosts?: string[]
  provisioner?: string
}

export type PdcInstanceInfoDTO = InstanceInfoDTO & {
  host: string
  infrastructureKey: string
  serviceType: string
}

export interface PendingUpdateDetailDTO {
  expiresAt?: number
}

export type PercentageCapacitySpec = CapacitySpec & {
  percentage: number
}

export type PercentageInstanceSelection = InstanceSelectionBase & {
  percentage?: ParameterFieldString
}

export interface PermissionCheck {
  permission?: string
  resourceAttributes?: {
    [key: string]: string
  }
  resourceIdentifier?: string
  resourceScope?: ResourceScope
  resourceType?: string
}

export type PersistentVolumeClaimYaml = CIVolume & {
  mountPath: string
  spec: PersistentVolumeClaimYamlSpec
  type: 'EmptyDir' | 'PersistentVolumeClaim' | 'HostPath'
}

export interface PersistentVolumeClaimYamlSpec {
  claimName: string
  readOnly?: boolean
}

export type PhysicalDataCenterConnectorDTO = ConnectorConfigDTO & {
  delegateSelectors?: string[]
  hosts?: HostDTO[]
}

export interface PipelineDetailsDto {
  orgIdentifier?: string
  pipelineIdentifier?: string
  projectIdentifier?: string
}

export interface PipelineExecutionCountInfo {
  executionCountGroupedOnServiceList?: CountGroupedOnService[]
}

export interface PipelineExecutionDashboardInfo {
  accountIdentifier?: string
  identifier?: string
  name?: string
  orgIdentifier?: string
  planExecutionId?: string
  projectIdentifier?: string
  startTs?: number
}

export type PipelineFilterProperties = FilterProperties & {
  description?: string
  moduleProperties?: {
    [key: string]: { [key: string]: any }
  }
  name?: string
  pipelineIdentifiers?: string[]
  pipelineTags?: NGTag[]
  repoName?: string
}

export interface PipelineInfrastructure {
  allowSimultaneousDeployments?: boolean
  environment?: EnvironmentYaml
  environmentRef?: string
  infrastructureDefinition?: InfrastructureDef
  infrastructureKey?: string
  useFromStage?: InfraUseFromStage
}

export type PipelineRollbackFailureActionConfig = FailureStrategyActionConfig & {
  type: 'PipelineRollback'
}

export interface PipelinesExecutionDashboardInfo {
  failed24HrsExecutions?: PipelineExecutionDashboardInfo[]
  pendingApprovalExecutions?: PipelineExecutionDashboardInfo[]
  pendingManualInterventionExecutions?: PipelineExecutionDashboardInfo[]
  runningExecutions?: PipelineExecutionDashboardInfo[]
}

export type PluginStepInfo = StepSpecType & {
  connectorRef?: string
  entrypoint?: string[]
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  privileged?: boolean
  reports?: UnitTestReport
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  uses?: string
  version?: string
}

export type PluginStepInfoV1 = StepSpecType & {
  envs?: {
    [key: string]: string
  }
  image?: string
  privileged?: boolean
  pull?: 'always' | 'never' | 'if-not-exists'
  resources?: ContainerResource
  user?: number
  uses?: string
  version?: string
  with?: ParameterFieldMapStringJsonNode
}

export interface PolicyConfig {
  policySets: string[]
}

export interface PostProdRollbackCheckDTO {
  message?: string
  rollbackAllowed?: boolean
  swimLaneInfo?: PostProdRollbackSwimLaneInfo
}

export interface PostProdRollbackRequestDTO {
  infrastructureMappingId: string
  instanceKey: string
}

export interface PostProdRollbackResponseDTO {
  infraMappingId?: string
  instanceKey?: string
  message?: string
  planExecutionId?: string
  rollbackTriggered?: boolean
}

export interface PostProdRollbackSwimLaneInfo {
  [key: string]: any
}

export interface PriceCollectionDTO {
  prices?: PriceDTO[]
}

export interface PriceDTO {
  active?: boolean
  currency?: string
  lookupKey?: string
  metaData?: {
    [key: string]: string
  }
  priceId?: string
  productId?: string
  tierMode?: 'volume' | 'graduated'
  tiersDTO?: TiersDTO[]
  unitAmount?: number
}

export interface PrimaryArtifact {
  primaryArtifactRef?: string
  sources?: ArtifactSource[]
  spec?: ArtifactConfig
  type?:
    | 'DockerRegistry'
    | 'Gcr'
    | 'Ecr'
    | 'Nexus3Registry'
    | 'Nexus2Registry'
    | 'ArtifactoryRegistry'
    | 'CustomArtifact'
    | 'Acr'
    | 'Jenkins'
    | 'AmazonS3'
    | 'GoogleArtifactRegistry'
    | 'GithubPackageRegistry'
    | 'AzureArtifacts'
    | 'AmazonMachineImage'
    | 'Bamboo'
    | 'GoogleCloudStorage'
    | 'GoogleCloudSource'
}

export interface Principal {
  jwtclaims?: {
    [key: string]: string
  }
  name?: string
  type: 'USER' | 'SERVICE' | 'API_KEY' | 'SERVICE_ACCOUNT'
}

export type ProceedWithDefaultValuesFailureActionConfig = FailureStrategyActionConfig & {
  type: 'ProceedWithDefaultValues'
}

export interface Project {
  color?: string
  description?: string
  identifier: string
  modules?: (
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  )[]
  name: string
  orgIdentifier?: string
  tags?: {
    [key: string]: string
  }
  uniqueId?: string
}

export interface ProjectAggregateDTO {
  admins?: UserMetadataDTO[]
  collaborators?: UserMetadataDTO[]
  harnessManagedOrg?: boolean
  organization?: Organization
  projectResponse: ProjectResponse
}

export interface ProjectDashBoardInfo {
  accountId?: string
  deploymentsCount?: number
  deploymentsCountChangeRate?: number
  failedDeploymentsCount?: number
  orgIdentifier?: string
  projectIdentifier?: string
  successDeploymentsCount?: number
}

export interface ProjectDeployments {
  deployments?: ExecutionStatusInfo[]
  projectIdentifier?: string
}

export interface ProjectLevelOverrideMigrationResponseDTO {
  accountId?: string
  envMigrationSuccessful?: boolean
  migratedEnvCount?: number
  migratedEnvironmentsInfo?: SingleEnvMigrationResponse[]
  migratedServiceOverridesCount?: number
  orgIdentifier?: string
  overridesMigrationSuccessFul?: boolean
  projectIdentifier?: string
  serviceOverridesInfos?: SingleServiceOverrideMigrationResponse[]
  totalEnvironmentsCount?: number
  totalServiceOverridesCount?: number
}

export interface ProjectLevelOverrideV2SettingsUpdateResponseDTO {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  settingResponseDTO?: SettingResponseDTO[]
  settingsUpdateSuccessFul?: boolean
}

export interface ProjectRequest {
  project: Project
}

export interface ProjectResponse {
  createdAt?: number
  isFavorite: boolean
  lastModifiedAt?: number
  project: Project
}

export interface ProjectsDashboardInfo {
  projectDashBoardInfoList?: ProjectDashBoardInfo[]
}

export type PrometheusConnectorDTO = ConnectorConfigDTO & {
  delegateSelectors?: string[]
  headers?: CustomHealthKeyAndValue[]
  passwordRef?: string
  url: string
  username?: string
}

export type RancherConnectorBearerTokenAuthenticationDTO = RancherConnectorConfigAuthenticationSpecDTO & {
  passwordRef: string
}

export interface RancherConnectorConfigAuthCredentialsDTO {
  spec?: RancherConnectorConfigAuthenticationSpecDTO
  type: 'BearerToken'
}

export interface RancherConnectorConfigAuthDTO {
  auth: RancherConnectorConfigAuthCredentialsDTO
  rancherUrl: string
}

export interface RancherConnectorConfigAuthenticationSpecDTO {
  [key: string]: any
}

export interface RancherConnectorConfigDTO {
  spec?: RancherConnectorConfigAuthDTO
  type: 'ManualConfig'
}

export type RancherConnectorDTO = ConnectorConfigDTO & {
  credential?: RancherConnectorConfigDTO
  delegateSelectors?: string[]
}

export interface RateLimitProtection {
  incorrectAttemptTimestamps?: number[]
  lastNotificationSentToSecOpsAt?: number
  lastNotificationSentToUserAt?: number
  totalIncorrectAttempts?: number
}

export type RateLimitRestrictionDTO = RestrictionDTO & {
  count?: number
  limit?: number
  timeUnit?: TimeUnit
}

export type RateLimitRestrictionMetadataDTO = RestrictionMetadataDTO & {
  allowedIfEqual?: boolean
  limit?: number
  timeUnit?: TimeUnit
}

export interface RecommendationRequest {
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  usageMap?: {
    [key: string]: number
  }
}

export interface Recurrence {
  spec?: RecurrenceSpec
  type: 'Daily' | 'Weekly' | 'Monthly' | 'Yearly'
}

export interface RecurrenceSpec {
  until?: string
  value?: number
}

export interface ReferenceDTO {
  accountIdentifier?: string
  count?: number
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ReferenceInstanceInfoDTO = InstanceInfoDTO & {
  namespace?: string
  releaseName?: string
}

export interface ReferencedByDTO {
  name?: string
  type?:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
}

export interface RefreshResponse {
  refreshedYaml?: string
}

export interface RegionGar {
  name?: string
  value?: string
}

export type ReleaseRepoManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export type RemoteCloudformationTagsFileSpec = CloudformationTagsFileSpec & {
  store: StoreConfigWrapper
}

export type RemoteCloudformationTemplateFileSpec = CloudformationTemplateFileSpec & {
  store: StoreConfigWrapper
}

export type RemoteTerraformBackendConfigSpec = TerraformBackendConfigSpec & {
  store: StoreConfigWrapper
}

export type RemoteTerraformVarFileSpec = TerraformVarFileSpec & {
  optional?: boolean
  store: StoreConfigWrapper
}

export type RemoteTerragruntBackendConfigSpec = TerragruntBackendConfigSpec & {
  store: StoreConfigWrapper
}

export type RemoteTerragruntVarFileSpec = TerragruntVarFileSpec & {
  store: StoreConfigWrapper
}

export type RemoveOperation = PatchOperation & {
  value?: JsonNode
}

export type ReplaceOperation = PatchOperation & {
  value?: JsonNode
}

export interface RepoListResponseDTO {
  repositories?: string[]
}

export interface RepoValidationResponse {
  isValid?: boolean
}

export interface ResourceDTO {
  identifier: string
  labels?: {
    [key: string]: string
  }
  type:
    | 'ORGANIZATION'
    | 'PROJECT'
    | 'USER_GROUP'
    | 'SECRET'
    | 'RESOURCE_GROUP'
    | 'USER'
    | 'ROLE'
    | 'PIPELINE'
    | 'TRIGGER'
    | 'TEMPLATE'
    | 'INPUT_SET'
    | 'DELEGATE_CONFIGURATION'
    | 'DELEGATE_GROUPS'
    | 'SERVICE'
    | 'ENVIRONMENT'
    | 'ENVIRONMENT_GROUP'
    | 'DELEGATE'
    | 'SERVICE_ACCOUNT'
    | 'CONNECTOR'
    | 'API_KEY'
    | 'TOKEN'
    | 'DELEGATE_TOKEN'
    | 'GOVERNANCE_POLICY'
    | 'GOVERNANCE_POLICY_SET'
    | 'VARIABLE'
    | 'CHAOS_HUB'
    | 'MONITORED_SERVICE'
    | 'CHAOS_INFRASTRUCTURE'
    | 'CHAOS_EXPERIMENT'
    | 'CHAOS_GAMEDAY'
    | 'STO_TARGET'
    | 'STO_EXEMPTION'
    | 'SERVICE_LEVEL_OBJECTIVE'
    | 'PERSPECTIVE'
    | 'PERSPECTIVE_BUDGET'
    | 'PERSPECTIVE_REPORT'
    | 'COST_CATEGORY'
    | 'SMTP'
    | 'PERSPECTIVE_FOLDER'
    | 'AUTOSTOPPING_RULE'
    | 'AUTOSTOPPING_LB'
    | 'AUTOSTOPPING_STARTSTOP'
    | 'SETTING'
    | 'NG_LOGIN_SETTINGS'
    | 'DEPLOYMENT_FREEZE'
    | 'CLOUD_ASSET_GOVERNANCE_RULE'
    | 'CLOUD_ASSET_GOVERNANCE_RULE_SET'
    | 'CLOUD_ASSET_GOVERNANCE_RULE_ENFORCEMENT'
    | 'TARGET_GROUP'
    | 'FEATURE_FLAG'
    | 'NG_ACCOUNT_DETAILS'
    | 'BUDGET_GROUP'
    | 'IP_ALLOWLIST_CONFIG'
    | 'NETWORK_MAP'
    | 'CET_AGENT_TOKEN'
    | 'CET_CRITICAL_EVENT'
    | 'CHAOS_SECURITY_GOVERNANCE'
    | 'END_USER_LICENSE_AGREEMENT'
    | 'WORKSPACE'
    | 'SEI_CONFIGURATION_SETTINGS'
    | 'SEI_COLLECTIONS'
    | 'SEI_INSIGHTS'
    | 'CET_SAVED_FILTER'
    | 'GITOPS_AGENT'
    | 'GITOPS_REPOSITORY'
    | 'GITOPS_CLUSTER'
    | 'GITOPS_CREDENTIAL_TEMPLATE'
    | 'GITOPS_REPOSITORY_CERTIFICATE'
    | 'GITOPS_GNUPG_KEY'
    | 'GITOPS_PROJECT_MAPPING'
    | 'GITOPS_APPLICATION'
    | 'CODE_REPOSITORY'
  uniqueId?: string
}

export interface ResourceGroup {
  identifier?: string
  name?: string
}

export interface ResourceScope {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface ResourceScopeDTO {
  accountIdentifier?: string
  labels?: {
    [key: string]: string
  }
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface Response {
  correlationId?: string
  data?: { [key: string]: any }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAccountCreditCardValidationResponse {
  correlationId?: string
  data?: AccountCreditCardValidationResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAccountDTO {
  correlationId?: string
  data?: AccountDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAccountLicenseDTO {
  correlationId?: string
  data?: AccountLicenseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAccountResourcesDTO {
  correlationId?: string
  data?: AccountResourcesDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAccountSettingResponse {
  correlationId?: string
  data?: AccountSettingResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAccountSummaryResponseDto {
  correlationId?: string
  data?: AccountSummaryResponseDto
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAcrBuildDetailsDTO {
  correlationId?: string
  data?: AcrBuildDetailsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAcrRegistriesDTO {
  correlationId?: string
  data?: AcrRegistriesDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAcrRepositoriesDTO {
  correlationId?: string
  data?: AcrRepositoriesDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAcrResponseDTO {
  correlationId?: string
  data?: AcrResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseActiveProjectsCountDTO {
  correlationId?: string
  data?: ActiveProjectsCountDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseActiveServiceInstanceSummary {
  correlationId?: string
  data?: ActiveServiceInstanceSummary
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseActiveServiceInstanceSummaryV2 {
  correlationId?: string
  data?: ActiveServiceInstanceSummaryV2
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAddUsersResponse {
  correlationId?: string
  data?: AddUsersResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseApiKeyAggregateDTO {
  correlationId?: string
  data?: ApiKeyAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseApiKeyDTO {
  correlationId?: string
  data?: ApiKeyDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseArtifactInstanceDetails {
  correlationId?: string
  data?: ArtifactInstanceDetails
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseArtifactSourceConfig {
  correlationId?: string
  data?: ArtifactSourceConfig
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseArtifactSourcesResponseDTO {
  correlationId?: string
  data?: ArtifactSourcesResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseArtifactSummary {
  correlationId?: string
  data?: ArtifactSummary
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseArtifactoryBuildDetailsDTO {
  correlationId?: string
  data?: ArtifactoryBuildDetailsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseArtifactoryImagePathsDTO {
  correlationId?: string
  data?: ArtifactoryImagePathsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseArtifactoryRepoDetailsDTO {
  correlationId?: string
  data?: ArtifactoryRepoDetailsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseArtifactoryResponseDTO {
  correlationId?: string
  data?: ArtifactoryResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAzureClustersDTO {
  correlationId?: string
  data?: AzureClustersDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAzureDeploymentSlotsDTO {
  correlationId?: string
  data?: AzureDeploymentSlotsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAzureImageGalleriesDTO {
  correlationId?: string
  data?: AzureImageGalleriesDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAzureLocationsDTO {
  correlationId?: string
  data?: AzureLocationsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAzureManagementGroupsDTO {
  correlationId?: string
  data?: AzureManagementGroupsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAzureResourceGroupsDTO {
  correlationId?: string
  data?: AzureResourceGroupsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAzureSubscriptionsDTO {
  correlationId?: string
  data?: AzureSubscriptionsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAzureTagsDTO {
  correlationId?: string
  data?: AzureTagsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAzureWebAppNamesDTO {
  correlationId?: string
  data?: AzureWebAppNamesDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseBambooPlanKeysDTO {
  correlationId?: string
  data?: BambooPlanKeysDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseBatchConfig {
  instanceCount?: number
  releaseCount?: number
}

export interface ResponseBoolean {
  correlationId?: string
  data?: boolean
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseBuildDetails {
  correlationId?: string
  data?: BuildDetails
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCDPipelineModuleInfo {
  correlationId?: string
  data?: CDPipelineModuleInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCDStageMetaDataDTO {
  correlationId?: string
  data?: CDStageMetaDataDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCDStageModuleInfo {
  correlationId?: string
  data?: CDStageModuleInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCannyBoardsResponseDTO {
  correlationId?: string
  data?: CannyBoardsResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCannyPostResponseDTO {
  correlationId?: string
  data?: CannyPostResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCardDTO {
  correlationId?: string
  data?: CardDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseChartVersionInstanceDetails {
  correlationId?: string
  data?: ChartVersionInstanceDetails
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseClusterBatchResponse {
  correlationId?: string
  data?: ClusterBatchResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseClusterResponse {
  correlationId?: string
  data?: ClusterResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseConnectivityCheckSummary {
  correlationId?: string
  data?: ConnectivityCheckSummary
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseConnectorCatalogueResponse {
  correlationId?: string
  data?: ConnectorCatalogueResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseConnectorResponse {
  correlationId?: string
  data?: ConnectorResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseConnectorStatistics {
  correlationId?: string
  data?: ConnectorStatistics
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseConnectorValidationResult {
  correlationId?: string
  data?: ConnectorValidationResult
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCreatePRDTO {
  correlationId?: string
  data?: CreatePRDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCreatePRResponse {
  correlationId?: string
  data?: CreatePRResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCreditCardResponse {
  correlationId?: string
  data?: CreditCardResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCreditCardValidationResponse {
  correlationId?: string
  data?: CreditCardValidationResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCreditDTO {
  correlationId?: string
  data?: CreditDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCustomDeploymentInfraResponse {
  correlationId?: string
  data?: CustomDeploymentInfraResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCustomDeploymentRefreshYaml {
  correlationId?: string
  data?: CustomDeploymentRefreshYaml
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCustomDeploymentVariableResponse {
  correlationId?: string
  data?: CustomDeploymentVariableResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCustomSequenceDTO {
  correlationId?: string
  data?: CustomSequenceDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCustomerDetailDTO {
  correlationId?: string
  data?: CustomerDetailDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDashboardExecutionStatusInfo {
  correlationId?: string
  data?: DashboardExecutionStatusInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDashboardWorkloadDeployment {
  correlationId?: string
  data?: DashboardWorkloadDeployment
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDashboardWorkloadDeploymentV2 {
  correlationId?: string
  data?: DashboardWorkloadDeploymentV2
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDelegateStatus {
  correlationId?: string
  data?: 'SUCCESS' | 'IN_PROGRESS' | 'FAILURE'
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDeleteInstancesRequest {
  correlationId?: string
  data?: DeleteInstancesRequest
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDeploymentStatsSummary {
  correlationId?: string
  data?: DeploymentStatsSummary
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDeploymentsInfo {
  correlationId?: string
  data?: DeploymentsInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDeveloperMappingDTO {
  correlationId?: string
  data?: DeveloperMappingDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDockerBuildDetailsDTO {
  correlationId?: string
  data?: DockerBuildDetailsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDockerResponseDTO {
  correlationId?: string
  data?: DockerResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEOLBannerResponseDTO {
  correlationId?: string
  data?: EOLBannerResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEcrBuildDetailsDTO {
  correlationId?: string
  data?: EcrBuildDetailsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEcrListImagesDTO {
  correlationId?: string
  data?: EcrListImagesDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEcrResponseDTO {
  correlationId?: string
  data?: EcrResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEnumMapUsageKeyLong {
  correlationId?: string
  data?: {
    [key: string]: number
  }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEnvBuildIdAndInstanceCountInfoList {
  correlationId?: string
  data?: EnvBuildIdAndInstanceCountInfoList
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEnvCount {
  correlationId?: string
  data?: EnvCount
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEnvSwaggerObjectWrapper {
  correlationId?: string
  data?: EnvSwaggerObjectWrapper
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEnvironmentDeploymentInfo {
  correlationId?: string
  data?: EnvironmentDeploymentInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEnvironmentGroupDeleteResponse {
  correlationId?: string
  data?: EnvironmentGroupDeleteResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEnvironmentGroupInstanceDetails {
  correlationId?: string
  data?: EnvironmentGroupInstanceDetails
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEnvironmentGroupResponse {
  correlationId?: string
  data?: EnvironmentGroupResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEnvironmentInputsMergedResponseDto {
  correlationId?: string
  data?: EnvironmentInputsMergedResponseDto
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEnvironmentResponse {
  correlationId?: string
  data?: EnvironmentResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEnvironmentResponseDTO {
  correlationId?: string
  data?: EnvironmentResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEnvironmentYamlMetadataDTO {
  correlationId?: string
  data?: EnvironmentYamlMetadataDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseExecutionDeploymentInfo {
  correlationId?: string
  data?: ExecutionDeploymentInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFeatureRestrictionDetailsDTO {
  correlationId?: string
  data?: FeatureRestrictionDetailsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFeatureRestrictionMetadataDTO {
  correlationId?: string
  data?: FeatureRestrictionMetadataDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFieldValues {
  correlationId?: string
  data?: FieldValues
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFileDTO {
  correlationId?: string
  data?: FileDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFilterDTO {
  correlationId?: string
  data?: FilterDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFolderNodeDTO {
  correlationId?: string
  data?: FolderNodeDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFreezeDetailedResponse {
  correlationId?: string
  data?: FreezeDetailedResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFreezeResponse {
  correlationId?: string
  data?: FreezeResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFreezeResponseWrapperDTO {
  correlationId?: string
  data?: FreezeResponseWrapperDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFrozenExecutionDetails {
  correlationId?: string
  data?: FrozenExecutionDetails
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGARBuildDetailsDTO {
  correlationId?: string
  data?: GARBuildDetailsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGARResponseDTO {
  correlationId?: string
  data?: GARResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGcpProjectResponseDTO {
  correlationId?: string
  data?: GcpProjectResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGcpResponseDTO {
  correlationId?: string
  data?: GcpResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGcrBuildDetailsDTO {
  correlationId?: string
  data?: GcrBuildDetailsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGcrResponseDTO {
  correlationId?: string
  data?: GcrResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGetFileResponseDTO {
  correlationId?: string
  data?: GetFileResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitBranchListDTO {
  correlationId?: string
  data?: GitBranchListDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitBranchesResponseDTO {
  correlationId?: string
  data?: GitBranchesResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitDefaultBranchCacheListResponse {
  correlationId?: string
  data?: GitDefaultBranchCacheListResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitDefaultBranchClearCacheResponse {
  correlationId?: string
  data?: GitDefaultBranchClearCacheResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitDefaultBranchGetCacheResponse {
  correlationId?: string
  data?: GitDefaultBranchGetCacheResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitDefaultBranchUpsertCacheResponse {
  correlationId?: string
  data?: GitDefaultBranchUpsertCacheResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitFileCacheClearCacheResponse {
  correlationId?: string
  data?: GitFileCacheClearCacheResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitFileCacheUpdateResponse {
  correlationId?: string
  data?: GitFileCacheUpdateResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitFileContent {
  correlationId?: string
  data?: GitFileContent
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitFullSyncConfigDTO {
  correlationId?: string
  data?: GitFullSyncConfigDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitListBranchesResponse {
  correlationId?: string
  data?: GitListBranchesResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitListRepositoryResponse {
  correlationId?: string
  data?: GitListRepositoryResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitSyncErrorCountDTO {
  correlationId?: string
  data?: GitSyncErrorCountDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitSyncRepoFilesList {
  correlationId?: string
  data?: GitSyncRepoFilesList
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitSyncSettingsDTO {
  correlationId?: string
  data?: GitSyncSettingsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGithubPackagesResponseDTO {
  correlationId?: string
  data?: GithubPackagesResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitopsProviderResponse {
  correlationId?: string
  data?: GitopsProviderResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGlobalFreezeBannerDetailsResponseDTO {
  correlationId?: string
  data?: GlobalFreezeBannerDetailsResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGoogleCloudStorageBucketsResponseDTO {
  correlationId?: string
  data?: GoogleCloudStorageBucketsResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseHealthDeploymentDashboard {
  correlationId?: string
  data?: HealthDeploymentDashboard
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseHealthDeploymentDashboardV2 {
  correlationId?: string
  data?: HealthDeploymentDashboardV2
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseHelmChartResponseDTO {
  correlationId?: string
  data?: HelmChartResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInfrastructureConfig {
  correlationId?: string
  data?: InfrastructureConfig
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInfrastructureInputsMergedResponseDto {
  correlationId?: string
  data?: InfrastructureInputsMergedResponseDto
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInfrastructureResponse {
  correlationId?: string
  data?: InfrastructureResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInfrastructureYamlMetadataDTO {
  correlationId?: string
  data?: InfrastructureYamlMetadataDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInputsValidationResponse {
  correlationId?: string
  data?: InputsValidationResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInstanceCountDetailsByEnvTypeAndServiceId {
  correlationId?: string
  data?: InstanceCountDetailsByEnvTypeAndServiceId
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInstanceDetailGroupedByPipelineExecutionList {
  correlationId?: string
  data?: InstanceDetailGroupedByPipelineExecutionList
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInstanceDetailsByBuildId {
  correlationId?: string
  data?: InstanceDetailsByBuildId
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInstanceGroupedByEnvironmentList {
  correlationId?: string
  data?: InstanceGroupedByEnvironmentList
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInstanceGroupedByService {
  correlationId?: string
  data?: InstanceGroupedByService
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInstanceGroupedByServiceList {
  correlationId?: string
  data?: InstanceGroupedByServiceList
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInstanceGroupedOnArtifactList {
  correlationId?: string
  data?: InstanceGroupedOnArtifactList
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInstanceGroupedOnChartVersionList {
  correlationId?: string
  data?: InstanceGroupedOnChartVersionList
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInstanceSyncTaskDetails {
  correlationId?: string
  data?: InstanceSyncTaskDetails
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInstancesByBuildIdList {
  correlationId?: string
  data?: InstancesByBuildIdList
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInvite {
  correlationId?: string
  data?: Invite
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInvoiceDetailDTO {
  correlationId?: string
  data?: InvoiceDetailDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseJenkinsJobDetailsDTO {
  correlationId?: string
  data?: JenkinsJobDetailsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseJiraIssueCreateMetadataNG {
  correlationId?: string
  data?: JiraIssueCreateMetadataNG
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseJiraIssueUpdateMetadataNG {
  correlationId?: string
  data?: JiraIssueUpdateMetadataNG
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseJsonNode {
  correlationId?: string
  data?: JsonNode
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseLandingPageDeploymentCount {
  correlationId?: string
  data?: LandingPageDeploymentCount
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseLicenseDateUsageDTO {
  correlationId?: string
  data?: LicenseDateUsageDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseLicenseUsageDTO {
  correlationId?: string
  data?: LicenseUsageDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseLicensesWithSummaryDTO {
  correlationId?: string
  data?: LicensesWithSummaryDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListAMITagObject {
  correlationId?: string
  data?: AMITagObject[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListAccountSettings {
  correlationId?: string
  data?: AccountSettings[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListApiKeyDTO {
  correlationId?: string
  data?: ApiKeyDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListArtifactoryArtifactBuildDetailsDTO {
  correlationId?: string
  data?: ArtifactoryArtifactBuildDetailsDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListAwsCFTemplateParamsData {
  correlationId?: string
  data?: AwsCFTemplateParamsData[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListAwsVPC {
  correlationId?: string
  data?: AwsVPC[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListAzureArtifactsFeed {
  correlationId?: string
  data?: AzureArtifactsFeed[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListAzureArtifactsPackage {
  correlationId?: string
  data?: AzureArtifactsPackage[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListAzureDevopsProject {
  correlationId?: string
  data?: AzureDevopsProject[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListBucketResponse {
  correlationId?: string
  data?: BucketResponse[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListBuildDetails {
  correlationId?: string
  data?: BuildDetails[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListConnectorResponse {
  correlationId?: string
  data?: ConnectorResponse[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListCreditDTO {
  correlationId?: string
  data?: CreditDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListDeveloperMappingDTO {
  correlationId?: string
  data?: DeveloperMappingDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListEntityDetailProtoDTO {
  correlationId?: string
  data?: EntityDetailProtoDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListEntityType {
  correlationId?: string
  data?: (
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  )[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListEnvironmentResponse {
  correlationId?: string
  data?: EnvironmentResponse[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListExecutionStatus {
  correlationId?: string
  data?: (
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'WaitStepRunning'
    | 'QueuedLicenseLimitReached'
    | 'QueuedExecutionConcurrencyReached'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'InputWaiting'
    | 'AbortedByFreeze'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
  )[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListFeatureRestrictionDetailsDTO {
  correlationId?: string
  data?: FeatureRestrictionDetailsDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListFeatureRestrictionMetadataDTO {
  correlationId?: string
  data?: FeatureRestrictionMetadataDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListFilePaths {
  correlationId?: string
  data?: FilePaths[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListGitRepositoryResponseDTO {
  correlationId?: string
  data?: GitRepositoryResponseDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListGitSyncEntityListDTO {
  correlationId?: string
  data?: GitSyncEntityListDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListHostValidationDTO {
  correlationId?: string
  data?: HostValidationDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListInfrastructureResponse {
  correlationId?: string
  data?: InfrastructureResponse[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListJiraIssueTransitionNG {
  correlationId?: string
  data?: JiraIssueTransitionNG[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListJiraProjectBasicNG {
  correlationId?: string
  data?: JiraProjectBasicNG[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListJiraStatusNG {
  correlationId?: string
  data?: JiraStatusNG[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListJiraUserData {
  correlationId?: string
  data?: JiraUserData[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListJobParameter {
  correlationId?: string
  data?: JobParameter[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListModuleLicenseDTO {
  correlationId?: string
  data?: ModuleLicenseDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListNexusRepositories {
  correlationId?: string
  data?: NexusRepositories[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListPartialSchemaDTO {
  correlationId?: string
  data?: PartialSchemaDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListProject {
  correlationId?: string
  data?: Project[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListRegionGar {
  correlationId?: string
  data?: RegionGar[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListRoleAssignmentResponse {
  correlationId?: string
  data?: RoleAssignmentResponse[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListScopeName {
  correlationId?: string
  data?: ScopeName[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListServiceAccountDTO {
  correlationId?: string
  data?: ServiceAccountDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListServiceDefinitionType {
  correlationId?: string
  data?: (
    | 'Kubernetes'
    | 'NativeHelm'
    | 'Ssh'
    | 'WinRm'
    | 'ServerlessAwsLambda'
    | 'AzureWebApp'
    | 'CustomDeployment'
    | 'ECS'
    | 'Elastigroup'
    | 'TAS'
    | 'Asg'
    | 'GoogleCloudFunctions'
    | 'AwsLambda'
    | 'AWS_SAM'
  )[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListServiceNowFieldNG {
  correlationId?: string
  data?: ServiceNowFieldNG[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListServiceNowStagingTable {
  correlationId?: string
  data?: ServiceNowStagingTable[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListServiceNowTemplate {
  correlationId?: string
  data?: ServiceNowTemplate[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListServiceNowTicketTypeDTO {
  correlationId?: string
  data?: ServiceNowTicketTypeDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListServiceOverrideMigrationResponseDTO {
  correlationId?: string
  data?: ServiceOverrideMigrationResponseDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListServiceResponse {
  correlationId?: string
  data?: ServiceResponse[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListSettingResponseDTO {
  correlationId?: string
  data?: SettingResponseDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListSettingUpdateResponseDTO {
  correlationId?: string
  data?: SettingUpdateResponseDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListSourceCodeManagerDTO {
  correlationId?: string
  data?: SourceCodeManagerDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListStepExecutionInstanceInfo {
  correlationId?: string
  data?: StepExecutionInstanceInfo[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListString {
  correlationId?: string
  data?: string[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListSubscriptionDetailDTO {
  correlationId?: string
  data?: SubscriptionDetailDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListUserGroupDTO {
  correlationId?: string
  data?: UserGroupDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListUserRepoResponse {
  correlationId?: string
  data?: UserRepoResponse[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMapEditionSetEditionActionDTO {
  correlationId?: string
  data?: {
    [key: string]: EditionActionDTO[]
  }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMapModuleTypeLong {
  correlationId?: string
  data?: {
    [key: string]: number
  }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMapServiceDefinitionTypeListExecutionStrategyType {
  correlationId?: string
  data?: {
    [key: string]: ('Basic' | 'Canary' | 'BlueGreen' | 'Rolling' | 'Default' | 'GitOps')[]
  }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMapStringCDStageSummaryResponseDTO {
  correlationId?: string
  data?: {
    [key: string]: CDStageSummaryResponseDTO
  }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMapStringString {
  correlationId?: string
  data?: {
    [key: string]: string
  }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMapUsageKeyLong {
  correlationId?: string
  data?: {
    [key: string]: number
  }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMessage {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'ACCOUNT_MIGRATED_TO_NEXT_GEN'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'SCM_REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_INTERRUPT_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SPOTNIST_REST_EXCEPTION'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'MISSING_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
    | 'ABORT_ALL_ALREADY_NG'
  exception?: Throwable
  failureTypes?: (
    | 'EXPIRED'
    | 'DELEGATE_PROVISIONING'
    | 'CONNECTIVITY'
    | 'AUTHENTICATION'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'TIMEOUT_ERROR'
    | 'POLICY_EVALUATION_FAILURE'
    | 'INPUT_TIMEOUT_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'DELEGATE_RESTART'
    | 'USER_MARKED_FAILURE'
  )[]
  level?: 'INFO' | 'ERROR'
  message?: string
}

export interface ResponseModuleLicenseDTO {
  correlationId?: string
  data?: ModuleLicenseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseNGEntityList {
  correlationId?: string
  data?: NGEntityList
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseNGEntityTemplateResponseDTO {
  correlationId?: string
  data?: NGEntityTemplateResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseNGEnvironmentConfig {
  correlationId?: string
  data?: NGEnvironmentConfig
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseNGServiceConfig {
  correlationId?: string
  data?: NGServiceConfig
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseNexusBuildDetailsDTO {
  correlationId?: string
  data?: NexusBuildDetailsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseNexusResponseDTO {
  correlationId?: string
  data?: NexusResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseNgSmtpDTO {
  correlationId?: string
  data?: NgSmtpDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseOidcWorkloadAccessTokenResponse {
  correlationId?: string
  data?: OidcWorkloadAccessTokenResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseOpenTaskDetails {
  correlationId?: string
  data?: OpenTaskDetails
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseOptionalHarnessServiceInfoNG {
  correlationId?: string
  data?: HarnessServiceInfoNG
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseOptionalInvite {
  correlationId?: string
  data?: Invite
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseOrganizationAggregateDTO {
  correlationId?: string
  data?: OrganizationAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseOrganizationResponse {
  correlationId?: string
  data?: OrganizationResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseOrganizationsDTO {
  correlationId?: string
  data?: OrganizationsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseOverrideV2SettingsUpdateResponseDTO {
  correlationId?: string
  data?: OverrideV2SettingsUpdateResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageActiveServiceDTO {
  correlationId?: string
  data?: PageActiveServiceDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageActivity {
  correlationId?: string
  data?: PageActivity
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageActivitySummary {
  correlationId?: string
  data?: PageActivitySummary
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageApiKeyAggregateDTO {
  correlationId?: string
  data?: PageApiKeyAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageCcmK8sConnectorResponse {
  correlationId?: string
  data?: PageCcmK8sConnectorResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageClusterFromGitops {
  correlationId?: string
  data?: PageClusterFromGitops
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageClusterResponse {
  correlationId?: string
  data?: PageClusterResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageConnectorResponse {
  correlationId?: string
  data?: PageConnectorResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageEntitySetupUsageDTO {
  correlationId?: string
  data?: PageEntitySetupUsageDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageEnvironmentGroupResponse {
  correlationId?: string
  data?: PageEnvironmentGroupResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageEnvironmentResponse {
  correlationId?: string
  data?: PageEnvironmentResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageEnvironmentResponseDTO {
  correlationId?: string
  data?: PageEnvironmentResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageFileDTO {
  correlationId?: string
  data?: PageFileDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageFilterDTO {
  correlationId?: string
  data?: PageFilterDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageFreezeSummaryResponse {
  correlationId?: string
  data?: PageFreezeSummaryResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageGitFullSyncEntityInfoDTO {
  correlationId?: string
  data?: PageGitFullSyncEntityInfoDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageGitSyncEntityListDTO {
  correlationId?: string
  data?: PageGitSyncEntityListDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageGitSyncErrorAggregateByCommitDTO {
  correlationId?: string
  data?: PageGitSyncErrorAggregateByCommitDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageGitSyncErrorDTO {
  correlationId?: string
  data?: PageGitSyncErrorDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageGitopsProviderResponse {
  correlationId?: string
  data?: PageGitopsProviderResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageHostDTO {
  correlationId?: string
  data?: PageHostDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageInfrastructureResponse {
  correlationId?: string
  data?: PageInfrastructureResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageInvite {
  correlationId?: string
  data?: PageInvite
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageOrganizationAggregateDTO {
  correlationId?: string
  data?: PageOrganizationAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageOrganizationResponse {
  correlationId?: string
  data?: PageOrganizationResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageProject {
  correlationId?: string
  data?: PageProject
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageProjectAggregateDTO {
  correlationId?: string
  data?: PageProjectAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageProjectResponse {
  correlationId?: string
  data?: PageProjectResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageRoleAssignmentResponse {
  correlationId?: string
  data?: PageRoleAssignmentResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageSecretResponseWrapper {
  correlationId?: string
  data?: PageSecretResponseWrapper
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageServiceAccountAggregateDTO {
  correlationId?: string
  data?: PageServiceAccountAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageServiceNowTemplate {
  correlationId?: string
  data?: PageServiceNowTemplate
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageServiceOverrideResponseDTO {
  correlationId?: string
  data?: PageServiceOverrideResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageServiceOverridesResponseDTOV2 {
  correlationId?: string
  data?: PageServiceOverridesResponseDTOV2
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageServiceResponse {
  correlationId?: string
  data?: PageServiceResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageServiceResponseDTO {
  correlationId?: string
  data?: PageServiceResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageTokenAggregateDTO {
  correlationId?: string
  data?: PageTokenAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageUserAggregate {
  correlationId?: string
  data?: PageUserAggregate
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageUserGroupAggregateDTO {
  correlationId?: string
  data?: PageUserGroupAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageUserGroupDTO {
  correlationId?: string
  data?: PageUserGroupDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageUserMetadataDTO {
  correlationId?: string
  data?: PageUserMetadataDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageVariableResponseDTO {
  correlationId?: string
  data?: PageVariableResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePasswordChangeResponse {
  correlationId?: string
  data?: 'PASSWORD_CHANGED' | 'INCORRECT_CURRENT_PASSWORD' | 'PASSWORD_STRENGTH_VIOLATED'
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePaymentMethodCollectionDTO {
  correlationId?: string
  data?: PaymentMethodCollectionDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelineExecutionCountInfo {
  correlationId?: string
  data?: PipelineExecutionCountInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelinesExecutionDashboardInfo {
  correlationId?: string
  data?: PipelinesExecutionDashboardInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePostProdRollbackCheckDTO {
  correlationId?: string
  data?: PostProdRollbackCheckDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePostProdRollbackResponseDTO {
  correlationId?: string
  data?: PostProdRollbackResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePriceCollectionDTO {
  correlationId?: string
  data?: PriceCollectionDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseProjectAggregateDTO {
  correlationId?: string
  data?: ProjectAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseProjectResponse {
  correlationId?: string
  data?: ProjectResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseProjectsDashboardInfo {
  correlationId?: string
  data?: ProjectsDashboardInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseRefreshResponse {
  correlationId?: string
  data?: RefreshResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseRepoListResponseDTO {
  correlationId?: string
  data?: RepoListResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseRepoValidationResponse {
  correlationId?: string
  data?: RepoValidationResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseRoleAssignmentAggregateResponse {
  correlationId?: string
  data?: RoleAssignmentAggregateResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseRoleAssignmentResponse {
  correlationId?: string
  data?: RoleAssignmentResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSaasGitDTO {
  correlationId?: string
  data?: SaasGitDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseScmBatchGetFileResponseDTO {
  correlationId?: string
  data?: ScmBatchGetFileResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseScmConnectorResponse {
  correlationId?: string
  data?: ScmConnectorResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseScmListFilesResponseDTO {
  correlationId?: string
  data?: ScmListFilesResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSecretManagerMetadataDTO {
  correlationId?: string
  data?: SecretManagerMetadataDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSecretResponseWrapper {
  correlationId?: string
  data?: SecretResponseWrapper
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSecretValidationResultDTO {
  correlationId?: string
  data?: SecretValidationResultDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSequenceToggleDTO {
  correlationId?: string
  data?: SequenceToggleDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceAccountAggregateDTO {
  correlationId?: string
  data?: ServiceAccountAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceAccountDTO {
  correlationId?: string
  data?: ServiceAccountDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceDeploymentInfoDTO {
  correlationId?: string
  data?: ServiceDeploymentInfoDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceDeploymentListInfo {
  correlationId?: string
  data?: ServiceDeploymentListInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceDeploymentListInfoV2 {
  correlationId?: string
  data?: ServiceDeploymentListInfoV2
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceDeployments {
  correlationId?: string
  data?: ServiceDeployments
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceDetailsInfoDTO {
  correlationId?: string
  data?: ServiceDetailsInfoDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceDetailsInfoDTOV2 {
  correlationId?: string
  data?: ServiceDetailsInfoDTOV2
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceHeaderInfo {
  correlationId?: string
  data?: ServiceHeaderInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceInputsMergedResponseDto {
  correlationId?: string
  data?: ServiceInputsMergedResponseDto
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceInstanceUsageDTO {
  correlationId?: string
  data?: ServiceInstanceUsageDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceMoveConfigResponse {
  correlationId?: string
  data?: ServiceMoveConfigResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceNowTicketNG {
  correlationId?: string
  data?: ServiceNowTicketNG
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceOverrideMigrationResponseDTO {
  correlationId?: string
  data?: ServiceOverrideMigrationResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceOverrideResponseDTO {
  correlationId?: string
  data?: ServiceOverrideResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceOverridesResponseDTOV2 {
  correlationId?: string
  data?: ServiceOverridesResponseDTOV2
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceResponse {
  correlationId?: string
  data?: ServiceResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceResponseDTO {
  correlationId?: string
  data?: ServiceResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceSequence {
  correlationId?: string
  data?: ServiceSequence
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceUsageDTO {
  correlationId?: string
  data?: ServiceUsageDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServicesCount {
  correlationId?: string
  data?: ServicesCount
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServicesDashboardInfo {
  correlationId?: string
  data?: ServicesDashboardInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServicesV2YamlMetadataDTO {
  correlationId?: string
  data?: ServicesV2YamlMetadataDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSetEmbeddedUserDetailsDTO {
  correlationId?: string
  data?: EmbeddedUserDetailsDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSetHelmCommandFlagType {
  correlationId?: string
  data?: (
    | 'Fetch'
    | 'Template'
    | 'Pull'
    | 'Install'
    | 'Upgrade'
    | 'Rollback'
    | 'History'
    | 'Delete'
    | 'Uninstall'
    | 'List'
    | 'Add'
    | 'Update'
    | 'Version'
  )[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSetK8sCommandFlagType {
  correlationId?: string
  data?: 'Apply'[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSetKustomizeCommandFlagType {
  correlationId?: string
  data?: 'Build'[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSetServiceHookAction {
  correlationId?: string
  data?: ('FetchFiles' | 'TemplateManifest' | 'SteadyStateCheck')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSetString {
  correlationId?: string
  data?: string[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSetTerraformCommandFlagType {
  correlationId?: string
  data?: ('INIT' | 'WORKSPACE' | 'REFRESH' | 'PLAN' | 'APPLY' | 'DESTROY')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSetTerragruntCommandFlagType {
  correlationId?: string
  data?: ('INIT' | 'WORKSPACE' | 'PLAN' | 'APPLY' | 'DESTROY' | 'OUTPUT')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSettingValueResponseDTO {
  correlationId?: string
  data?: SettingValueResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSetupStatus {
  correlationId?: string
  data?:
    | 'SUCCESS'
    | 'DELEGATE_PROVISION_FAILURE'
    | 'K8S_CONNECTOR_PROVISION_FAILURE'
    | 'DOCKER_CONNECTOR_PROVISION_FAILURE'
    | 'PROVISIONING_DISABLED'
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseShouldDisableDeploymentFreezeResponseDTO {
  correlationId?: string
  data?: ShouldDisableDeploymentFreezeResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSourceCodeManagerDTO {
  correlationId?: string
  data?: SourceCodeManagerDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseStageElementConfig {
  correlationId?: string
  data?: StageElementConfig
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseStepCategory {
  correlationId?: string
  data?: StepCategory
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseStepElementConfig {
  correlationId?: string
  data?: StepElementConfig
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseString {
  correlationId?: string
  data?: string
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSubscriptionDetailDTO {
  correlationId?: string
  data?: SubscriptionDetailDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSvcEnvMigrationProjectWrapperResponseDto {
  correlationId?: string
  data?: SvcEnvMigrationProjectWrapperResponseDto
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSvcEnvMigrationResponseDto {
  correlationId?: string
  data?: SvcEnvMigrationResponseDto
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTimeValuePairListDTOEnvIdCountPair {
  correlationId?: string
  data?: TimeValuePairListDTOEnvIdCountPair
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTimeValuePairListDTOInteger {
  correlationId?: string
  data?: TimeValuePairListDTOInteger
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTokenDTO {
  correlationId?: string
  data?: TokenDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTriggerFullSyncResponseDTO {
  correlationId?: string
  data?: TriggerFullSyncResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTwoFactorAuthSettingsInfo {
  correlationId?: string
  data?: TwoFactorAuthSettingsInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseUserAggregate {
  correlationId?: string
  data?: UserAggregate
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseUserGroupAggregateDTO {
  correlationId?: string
  data?: UserGroupAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseUserGroupDTO {
  correlationId?: string
  data?: UserGroupDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseUserGroupResponseV2DTO {
  correlationId?: string
  data?: UserGroupResponseV2DTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseUserInfo {
  correlationId?: string
  data?: UserInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseUserMetadata {
  correlationId?: string
  data?: UserMetadata
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseUserSourceCodeManagerResponseDTO {
  correlationId?: string
  data?: UserSourceCodeManagerResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseUserSourceCodeManagerResponseDTOList {
  correlationId?: string
  data?: UserSourceCodeManagerResponseDTOList
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseValidateTemplateInputsResponseDTO {
  correlationId?: string
  data?: ValidateTemplateInputsResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseValidationResultDTO {
  correlationId?: string
  data?: ValidationResultDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseVariableResponseDTO {
  correlationId?: string
  data?: VariableResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseVoid {
  correlationId?: string
  data?: Void
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseWorkspacesDTO {
  correlationId?: string
  data?: WorkspacesDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseYamlSchemaDetailsWrapper {
  correlationId?: string
  data?: YamlSchemaDetailsWrapper
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseYamlSnippets {
  correlationId?: string
  data?: YamlSnippets
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface RestResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: { [key: string]: any }
  responseMessages?: ResponseMessage[]
}

export interface RestResponseAgentMtlsEndpointDetails {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: AgentMtlsEndpointDetails
  responseMessages?: ResponseMessage[]
}

export interface RestResponseAuthenticationSettingsResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: AuthenticationSettingsResponse
  responseMessages?: ResponseMessage[]
}

export interface RestResponseBoolean {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: boolean
  responseMessages?: ResponseMessage[]
}

export interface RestResponseCollectionLdapGroupResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: LdapGroupResponse[]
  responseMessages?: ResponseMessage[]
}

export interface RestResponseDelegateDeleteResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: DelegateDeleteResponse
  responseMessages?: ResponseMessage[]
}

export interface RestResponseDelegateGroup {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: DelegateGroup
  responseMessages?: ResponseMessage[]
}

export interface RestResponseDelegateGroupDTO {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: DelegateGroupDTO
  responseMessages?: ResponseMessage[]
}

export interface RestResponseDelegateGroupListing {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: DelegateGroupListing
  responseMessages?: ResponseMessage[]
}

export interface RestResponseDelegateProfileDetailsNg {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: DelegateProfileDetailsNg
  responseMessages?: ResponseMessage[]
}

export interface RestResponseDelegateTokenDetails {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: DelegateTokenDetails
  responseMessages?: ResponseMessage[]
}

export interface RestResponseLDAPSettings {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: LDAPSettings
  responseMessages?: ResponseMessage[]
}

export interface RestResponseLdapResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: LdapResponse
  responseMessages?: ResponseMessage[]
}

export interface RestResponseLdapTestResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: LdapTestResponse
  responseMessages?: ResponseMessage[]
}

export interface RestResponseListDelegateGroupDTO {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: DelegateGroupDTO[]
  responseMessages?: ResponseMessage[]
}

export interface RestResponseListDelegateListResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: DelegateListResponse[]
  responseMessages?: ResponseMessage[]
}

export interface RestResponseListDelegateTokenDetails {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: DelegateTokenDetails[]
  responseMessages?: ResponseMessage[]
}

export interface RestResponseLoginSettings {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: LoginSettings
  responseMessages?: ResponseMessage[]
}

export interface RestResponseLoginTypeResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: LoginTypeResponse
  responseMessages?: ResponseMessage[]
}

export interface RestResponseOauthAccessTokenResponseDTO {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: OauthAccessTokenResponseDTO
  responseMessages?: ResponseMessage[]
}

export interface RestResponsePageResponseDelegateProfileDetailsNg {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: DelegateProfileDetailsNg[]
  responseMessages?: ResponseMessage[]
}

export interface RestResponsePasswordStrengthPolicy {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: PasswordStrengthPolicy
  responseMessages?: ResponseMessage[]
}

export interface RestResponseSSOConfig {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: SSOConfig
  responseMessages?: ResponseMessage[]
}

export interface RestResponseString {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: string
  responseMessages?: ResponseMessage[]
}

export interface RestResponseSupportedDelegateVersion {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: SupportedDelegateVersion
  responseMessages?: ResponseMessage[]
}

export interface RestResponseUserGroup {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: UserGroup
  responseMessages?: ResponseMessage[]
}

export interface RestResponseUserInfo {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: UserInfo
  responseMessages?: ResponseMessage[]
}

export interface RestResponseVerifyTokenResponseDTO {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: VerifyTokenResponseDTO
  responseMessages?: ResponseMessage[]
}

export interface RestResponseVoid {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: Void
  responseMessages?: ResponseMessage[]
}

export type RestoreCacheGCSStepInfo = StepSpecType & {
  archiveFormat?: 'Tar' | 'Gzip'
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  failIfKeyNotFound?: boolean
  key: string
  resources?: ContainerResource
  runAsUser?: number
  version?: string
}

export type RestoreCacheS3StepInfo = StepSpecType & {
  archiveFormat?: 'Tar' | 'Gzip'
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  endpoint?: string
  failIfKeyNotFound?: boolean
  key: string
  pathStyle?: boolean
  region?: string
  resources?: ContainerResource
  runAsUser?: number
  version?: string
}

export interface RestrictionDTO {
  [key: string]: any
}

export interface RestrictionMetadataDTO {
  restrictionType?:
    | 'AVAILABILITY'
    | 'STATIC_LIMIT'
    | 'RATE_LIMIT'
    | 'CUSTOM'
    | 'DURATION'
    | 'LICENSE_RATE_LIMIT'
    | 'LICENSE_STATIC_LIMIT'
}

export type RetryFailureActionConfig = FailureStrategyActionConfig & {
  spec: RetryFailureSpecConfig
  type: 'Retry'
}

export interface RetryFailureSpecConfig {
  onRetryFailure: OnRetryFailureConfig
  retryCount: number
  retryIntervals: string[]
}

export type RetrySGFailureActionConfig = FailureStrategyActionConfig & {
  spec: RetryStepGroupFailureSpecConfig
  type: 'RetryStepGroup'
}

export interface RetryStepGroupFailureSpecConfig {
  retryCount: number
  retryIntervals: string[]
}

export type RevertPRStepInfo = StepSpecType & {
  commitId: string
  delegateSelectors?: string[]
  prTitle?: string
}

export interface Role {
  allowedScopeLevels?: ('ACCOUNT' | 'ORGANIZATION' | 'PROJECT')[]
  description?: string
  identifier: string
  name: string
  permissions?: string[]
  tags?: {
    [key: string]: string
  }
}

export interface RoleAssignment {
  disabled?: boolean
  identifier?: string
  internal?: boolean
  managed?: boolean
  principal: Principal
  resourceGroupIdentifier: string
  roleIdentifier: string
}

export interface RoleAssignmentAggregateResponse {
  resourceGroups?: ResourceGroup[]
  roleAssignments?: RoleAssignment[]
  roles?: RoleResponse[]
  scope?: Scope
}

export interface RoleAssignmentCreateRequest {
  roleAssignments?: RoleAssignment[]
}

export interface RoleAssignmentFilter {
  disabledFilter?: boolean[]
  harnessManagedFilter?: boolean[]
  principalFilter?: Principal[]
  principalScopeLevelFilter?: string[]
  principalTypeFilter?: ('USER' | 'USER_GROUP' | 'SERVICE' | 'API_KEY' | 'SERVICE_ACCOUNT')[]
  resourceGroupFilter?: string[]
  roleFilter?: string[]
}

export interface RoleAssignmentMetadataDTO {
  identifier: string
  managedRole: boolean
  managedRoleAssignment: boolean
  resourceGroupIdentifier: string
  resourceGroupName: string
  roleIdentifier: string
  roleName: string
}

export interface RoleAssignmentResponse {
  createdAt?: number
  harnessManaged?: boolean
  lastModifiedAt?: number
  roleAssignment: RoleAssignment
  scope: Scope
}

export interface RoleBinding {
  managedRole: boolean
  resourceGroupIdentifier?: string
  resourceGroupName?: string
  roleIdentifier: string
  roleName: string
}

export interface RoleResponse {
  createdAt?: number
  harnessManaged?: boolean
  lastModifiedAt?: number
  role: Role
  scope: Scope
}

export type RunStepInfo = StepSpecType & {
  command: string
  connectorRef?: string
  envVariables?: {
    [key: string]: string
  }
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  reports?: UnitTestReport
  resources?: ContainerResource
  runAsUser?: number
  shell?: 'Sh' | 'Bash' | 'Powershell' | 'Pwsh' | 'Python'
  version?: string
}

export type RunTestsStepInfo = StepSpecType & {
  args?: string
  buildEnvironment?: 'Core' | 'Framework'
  buildTool: 'Maven' | 'Bazel' | 'Gradle' | 'Dotnet' | 'Nunitconsole' | 'SBT' | 'Pytest' | 'Unittest' | 'Rspec'
  connectorRef?: string
  enableTestSplitting?: boolean
  envVariables?: {
    [key: string]: string
  }
  frameworkVersion?: '5.0' | '6.0'
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  language: 'Java' | 'Kotlin' | 'Scala' | 'Csharp' | 'Python' | 'Ruby'
  namespaces?: string
  outputVariables?: OutputNGVariable[]
  packages?: string
  postCommand?: string
  preCommand?: string
  privileged?: boolean
  pythonVersion?: '3' | '2'
  reports?: UnitTestReport
  resources?: ContainerResource
  runAsUser?: number
  runOnlySelectedTests?: boolean
  shell?: 'Sh' | 'Bash' | 'Powershell' | 'Pwsh' | 'Python'
  testAnnotations?: string
  testGlobs?: string
  testRoot?: string
  testSplitStrategy?: 'ClassTiming' | 'TestCount'
  version?: string
}

export interface RuntimeEntity {
  environmentRef?: string
  serviceRef?: string
}

export type S3ArtifactSummary = ArtifactSummary & {
  bucketName?: string
  filePath?: string
  tag?: string
}

export type S3StoreConfig = StoreConfig & {
  bucketName?: string
  connectorRef?: string
  folderPath?: string
  metadata?: string
  paths?: string[]
  region?: string
}

export type S3UrlCloudformationTemplateFileSpec = CloudformationTemplateFileSpec & {
  templateUrl: string
}

export type S3UrlStoreConfig = StoreConfig & {
  connectorRef: string
  metadata?: string
  region: string
  urls: string[]
}

export type SAMLSettings = NGAuthSettings & {
  authenticationEnabled?: boolean
  authorizationEnabled?: boolean
  clientId?: string
  clientSecret?: string
  displayName?: string
  entityIdentifier?: string
  friendlySamlName?: string
  groupMembershipAttr?: string
  identifier: string
  jitEnabled?: boolean
  jitValidationKey?: string
  jitValidationValue?: string
  logoutUrl?: string
  origin: string
  samlProviderType?: string
}

export type SEIModuleLicenseDTO = ModuleLicenseDTO & {
  numberOfContributors?: number
}

export type SRMModuleLicenseDTO = ModuleLicenseDTO & {
  numberOfServices?: number
}

export interface SSHAuthDTO {
  spec: BaseSSHSpecDTO
  type: 'SSH' | 'Kerberos'
  useSshClient?: boolean
  useSshj?: boolean
}

export type SSHConfigDTO = BaseSSHSpecDTO & {
  credentialType: 'Password' | 'KeyPath' | 'KeyReference'
  spec: SSHCredentialSpecDTO
}

export interface SSHCredentialSpecDTO {
  [key: string]: any
}

export type SSHKeyPathCredentialDTO = SSHCredentialSpecDTO & {
  encryptedPassphrase?: string
  keyPath: string
  userName: string
}

export type SSHKeyReferenceCredentialDTO = SSHCredentialSpecDTO & {
  encryptedPassphrase?: string
  key: string
  userName: string
}

export type SSHKeySpecDTO = SecretSpecDTO & {
  auth: SSHAuthDTO
  port?: number
}

export type SSHKeyValidationMetadata = SecretValidationMetaData & {
  host: string
}

export type SSHPasswordCredentialDTO = SSHCredentialSpecDTO & {
  password: string
  userName: string
}

export interface SSOConfig {
  accountId?: string
  authenticationMechanism?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
  ssoSettings?: SSOSettings[]
}

export interface SSORequest {
  friendlySamlName?: string
  idpRedirectUrl?: string
  oauthProviderType?: 'AZURE' | 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'GOOGLE' | 'LINKEDIN'
  oauthProviderTypes?: ('AZURE' | 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'GOOGLE' | 'LINKEDIN')[]
  samlProviderType?: 'AZURE' | 'OKTA' | 'ONELOGIN' | 'OTHER'
  ssoId?: string
}

export interface SSOSettings {
  accountId?: string
  appId: string
  createdAt?: number
  createdBy?: EmbeddedUser
  displayName?: string
  lastUpdatedAt: number
  lastUpdatedBy?: EmbeddedUser
  nextIteration?: number
  nextIterations?: number[]
  type: 'SAML' | 'LDAP' | 'OAUTH'
  url?: string
  uuid: string
}

export type STOLicenseSummaryDTO = LicensesWithSummaryDTO & {
  totalDevelopers?: number
}

export type STOModuleLicenseDTO = ModuleLicenseDTO & {
  numberOfDevelopers?: number
}

export interface SaasGitDTO {
  saasGit?: boolean
}

export interface SamlLinkGroupRequest {
  samlGroupName?: string
}

export type SamlSettings = SSOSettings & {
  accountId: string
  authenticationEnabled?: boolean
  authorizationEnabled?: boolean
  clientId?: string
  clientSecret?: string[]
  configuredFromNG?: boolean
  encryptedClientSecret?: string
  entityIdentifier?: string
  friendlySamlName?: string
  groupMembershipAttr?: string
  jitEnabled?: boolean
  jitValidationKey?: string
  jitValidationValue?: string
  logoutUrl?: string
  origin: string
  samlProviderType?: 'AZURE' | 'OKTA' | 'ONELOGIN' | 'OTHER'
  settingType?:
    | 'HOST_CONNECTION_ATTRIBUTES'
    | 'BASTION_HOST_CONNECTION_ATTRIBUTES'
    | 'SMTP'
    | 'SFTP'
    | 'JENKINS'
    | 'BAMBOO'
    | 'STRING'
    | 'SPLUNK'
    | 'ELK'
    | 'LOGZ'
    | 'SUMO'
    | 'DATA_DOG'
    | 'APM_VERIFICATION'
    | 'BUG_SNAG'
    | 'LOG_VERIFICATION'
    | 'APP_DYNAMICS'
    | 'NEW_RELIC'
    | 'DYNA_TRACE'
    | 'INSTANA'
    | 'DATA_DOG_LOG'
    | 'CLOUD_WATCH'
    | 'SCALYR'
    | 'ELB'
    | 'SLACK'
    | 'AWS'
    | 'GCS'
    | 'GCP'
    | 'AZURE'
    | 'PCF'
    | 'RANCHER'
    | 'DIRECT'
    | 'KUBERNETES_CLUSTER'
    | 'DOCKER'
    | 'ECR'
    | 'GCR'
    | 'ACR'
    | 'PHYSICAL_DATA_CENTER'
    | 'KUBERNETES'
    | 'NEXUS'
    | 'ARTIFACTORY'
    | 'SMB'
    | 'AMAZON_S3'
    | 'GIT'
    | 'SSH_SESSION_CONFIG'
    | 'SERVICE_VARIABLE'
    | 'CONFIG_FILE'
    | 'KMS'
    | 'GCP_KMS'
    | 'JIRA'
    | 'SERVICENOW'
    | 'SECRET_TEXT'
    | 'SECRET_FILE'
    | 'YAML_GIT_SYNC'
    | 'VAULT'
    | 'VAULT_SSH'
    | 'AWS_SECRETS_MANAGER'
    | 'WINRM_CONNECTION_ATTRIBUTES'
    | 'WINRM_SESSION_CONFIG'
    | 'PROMETHEUS'
    | 'INFRASTRUCTURE_MAPPING'
    | 'HTTP_HELM_REPO'
    | 'AMAZON_S3_HELM_REPO'
    | 'GCS_HELM_REPO'
    | 'SPOT_INST'
    | 'AZURE_ARTIFACTS_PAT'
    | 'CUSTOM'
    | 'CE_AWS'
    | 'CE_GCP'
    | 'CE_AZURE'
    | 'AZURE_VAULT'
    | 'KUBERNETES_CLUSTER_NG'
    | 'GIT_NG'
    | 'SSO_SAML'
    | 'LDAP'
    | 'GCP_SECRETS_MANAGER'
    | 'TRIGGER'
    | 'OCI_HELM_REPO'
  userIdAttr?: string
}

export type SampleErrorMetadataDTO = ErrorMetadataDTO & {
  sampleMap?: {
    [key: string]: string
  }
}

export type SaveCacheGCSStepInfo = StepSpecType & {
  archiveFormat?: 'Tar' | 'Gzip'
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  key: string
  override?: boolean
  resources?: ContainerResource
  runAsUser?: number
  sourcePaths: string[]
  version?: string
}

export type SaveCacheS3StepInfo = StepSpecType & {
  archiveFormat?: 'Tar' | 'Gzip'
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  endpoint?: string
  key: string
  override?: boolean
  pathStyle?: boolean
  region?: string
  resources?: ContainerResource
  runAsUser?: number
  sourcePaths: string[]
  version?: string
}

export interface ScimGroup {
  displayName?: string
  externalId?: string
  harnessScopes?: string
  id?: string
  members?: Member[]
  meta?: JsonNode
  schemas?: string[]
}

export interface ScimUser {
  active?: boolean
  displayName?: string
  emails?: JsonNode
  externalId?: string
  groups?: JsonNode
  id?: string
  meta?: JsonNode
  name?: JsonNode
  password?: JsonNode
  roles?: JsonNode
  schemas?: string[]
  userName?: string
}

export interface ScmBatchGetFileRequestDTO {
  scmGetFileRequestDTOMap?: {
    [key: string]: ScmGetFileRequestDTO
  }
}

export interface ScmBatchGetFileResponseDTO {
  scmGetFileResponseV2DTOMap?: {
    [key: string]: ScmGetFileResponseV2DTO
  }
}

export interface ScmCacheDetails {
  cacheExpiryTTL?: number
  lastUpdatedAt?: number
  scmCacheState?: 'VALID_CACHE' | 'STALE_CACHE'
  syncEnabled?: boolean
  validUntilTTL?: number
}

export interface ScmConnectorDTO {
  connector?: ConnectorInfoDTO
  secret?: SecretDTOV2
}

export interface ScmConnectorResponse {
  connectorResponseDTO?: ConnectorResponse
  connectorValidationResult?: ConnectorValidationResult
  secretResponseWrapper?: SecretResponseWrapper
}

export interface ScmErrorDetails {
  error?: string
  explanation?: string
  gitErrorMetadata?: GitErrorMetadata
  hint?: string
  statusCode?: number
}

export type ScmErrorMetadataDTO = ErrorMetadataDTO & {
  conflictCommitId?: string
}

export interface ScmFileGitDetailsDTO {
  blobId?: string
  commitId?: string
  contentType?: 'INVALID_CONTENT_TYPE' | 'UNKNOWN_CONTENT' | 'FILE' | 'DIRECTORY' | 'SYMLINK' | 'GITLINK'
  path?: string
}

export interface ScmGetFileRequestDTO {
  accountIdentifier?: string
  branch?: string
  commitId?: string
  connectorRef?: string
  filepath?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repoName?: string
  useCache?: boolean
}

export interface ScmGetFileResponseV2DTO {
  blobId?: string
  branchName?: string
  cacheDetails?: ScmCacheDetails
  commitId?: string
  errorResponse?: boolean
  fileContent?: string
  gitDefaultBranch?: boolean
  scmErrorDetails?: ScmErrorDetails
}

export interface ScmListFilesResponseDTO {
  fileGitDetailsDTOList?: ScmFileGitDetailsDTO[]
}

export interface Scope {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface ScopeName {
  accountIdentifier?: string
  orgIdentifier?: string
  orgName?: string
  projectIdentifier?: string
  projectName?: string
}

export interface ScopeSelector {
  accountIdentifier?: string
  filter: 'EXCLUDING_CHILD_SCOPES' | 'INCLUDING_CHILD_SCOPES'
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface ScopingRuleDetailsNg {
  description?: string
  environmentIds?: string[]
  environmentTypeId?: string
}

export type ScriptCommandUnitSpec = CommandUnitBaseSpec & {
  shell: 'Bash' | 'PowerShell'
  source: ShellScriptSourceWrapper
  tailFiles?: TailFilePattern[]
  workingDirectory?: string
}

export type ScriptStateExecutionData = DelegateResponseData & {
  activityId?: string
  delegateMetaInfo?: DelegateMetaInfo
  element?: ContextElement
  endTs?: number
  errorMsg?: string
  executionDetails?: {
    [key: string]: ExecutionDataValue
  }
  executionSummary?: {
    [key: string]: ExecutionDataValue
  }
  name?: string
  secretOutputVars?: string[]
  startTs?: number
  stateName?: string
  stateParams?: {
    [key: string]: { [key: string]: any }
  }
  stateType?: string
  status?:
    | 'ABORTED'
    | 'DISCONTINUING'
    | 'ERROR'
    | 'FAILED'
    | 'NEW'
    | 'PAUSED'
    | 'PAUSING'
    | 'QUEUED'
    | 'RESUMED'
    | 'RUNNING'
    | 'SCHEDULED'
    | 'STARTING'
    | 'SUCCESS'
    | 'WAITING'
    | 'SKIPPED'
    | 'ABORTING'
    | 'REJECTED'
    | 'EXPIRED'
    | 'PREPARING'
  sweepingOutputEnvVariables?: {
    [key: string]: string
  }
  templateVariable?: {
    [key: string]: { [key: string]: any }
  }
  waitInterval?: number
}

export type ScriptStepInfo = StepSpecType & {
  envs?: {
    [key: string]: string
  }
  image?: string
  outputs?: string[]
  privileged?: boolean
  pull?: 'always' | 'never' | 'if-not-exists'
  resources?: ContainerResource
  run: string
  shell?: 'sh' | 'bash' | 'powershell' | 'pwsh' | 'python'
  user?: number
  version?: string
}

export interface SecretDTOV2 {
  description?: string
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  spec: SecretSpecDTO
  tags?: {
    [key: string]: string
  }
  type: 'SecretFile' | 'SecretText' | 'SSHKey' | 'WinRmCredentials'
}

export type SecretFileSpecDTO = SecretSpecDTO & {
  additionalMetadata?: AdditionalMetadata
  secretManagerIdentifier: string
}

export interface SecretManagerMetadataDTO {
  encryptionType?:
    | 'LOCAL'
    | 'KMS'
    | 'GCP_KMS'
    | 'AWS_SECRETS_MANAGER'
    | 'AZURE_VAULT'
    | 'VAULT'
    | 'GCP_SECRETS_MANAGER'
    | 'CUSTOM'
    | 'VAULT_SSH'
    | 'CUSTOM_NG'
  spec?: SecretManagerMetadataSpecDTO
}

export interface SecretManagerMetadataRequestDTO {
  encryptionType:
    | 'LOCAL'
    | 'KMS'
    | 'GCP_KMS'
    | 'AWS_SECRETS_MANAGER'
    | 'AZURE_VAULT'
    | 'VAULT'
    | 'GCP_SECRETS_MANAGER'
    | 'CUSTOM'
    | 'VAULT_SSH'
    | 'CUSTOM_NG'
  identifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  spec: SecretManagerMetadataRequestSpecDTO
}

export interface SecretManagerMetadataRequestSpecDTO {
  [key: string]: any
}

export interface SecretManagerMetadataSpecDTO {
  [key: string]: any
}

export type SecretNGVariable = NGVariable & {
  default?: string
  name?: string
  type?: 'Secret'
  value: string
}

export interface SecretRefData {
  decryptedValue?: string[]
  identifier?: string
  null?: boolean
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export type SecretReferredByConnectorSetupUsageDetail = SetupUsageDetail & {
  fieldName?: string
}

export interface SecretRequestWrapper {
  secret: SecretDTOV2
}

export interface SecretResourceFilterDTO {
  identifiers?: string[]
  includeAllSecretsAccessibleAtScope?: boolean
  includeSecretsFromEverySubScope?: boolean
  searchTerm?: string
  secretTypes?: ('SecretFile' | 'SecretText' | 'SSHKey' | 'WinRmCredentials')[]
  sourceCategory?:
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
}

export interface SecretResponseWrapper {
  createdAt?: number
  draft?: boolean
  governanceMetadata?: GovernanceMetadata
  secret: SecretDTOV2
  updatedAt?: number
}

export interface SecretSpecDTO {
  errorMessageForInvalidYaml?: string
}

export type SecretTextSpecDTO = SecretSpecDTO & {
  additionalMetadata?: AdditionalMetadata
  secretManagerIdentifier: string
  value?: string
  valueType: 'Inline' | 'Reference' | 'CustomSecretManagerValues'
}

export interface SecretValidationMetaData {
  type: 'SecretFile' | 'SecretText' | 'SSHKey' | 'WinRmCredentials'
}

export interface SecretValidationResultDTO {
  message?: string
  success?: boolean
}

export interface SecurityContext {
  allowPrivilegeEscalation?: boolean
  capabilities?: Capabilities
  privileged?: boolean
  procMount?: string
  readOnlyRootFilesystem?: boolean
  runAsGroup?: number
  runAsNonRoot?: boolean
  runAsUser?: number
}

export type SecurityStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  version?: string
}

export interface SequenceToggleDTO {
  nullCustomSequence?: boolean
  shouldUseCustomSequence?: boolean
}

export type ServerlessAwsLambdaDeployStepInfo = StepSpecType & {
  commandOptions?: string
  delegateSelectors?: string[]
}

export type ServerlessAwsLambdaDeployV2StepInfo = StepSpecType & {
  connectorRef?: string
  delegateSelectors?: string[]
  deployCommandOptions?: string[]
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  serverlessVersion?: string
}

export type ServerlessAwsLambdaDeploymentMetaData = DeploymentMetaData & { [key: string]: any }

export type ServerlessAwsLambdaInfrastructure = Infrastructure & {
  connectorRef: string
  metadata?: string
  provisioner?: string
  region: string
  stage: string
}

export type ServerlessAwsLambdaInfrastructureDetails = InfrastructureDetails & {
  region?: string
  stage?: string
}

export type ServerlessAwsLambdaInstanceInfoDTO = InstanceInfoDTO & {
  functionName: string
  handler?: string
  infraStructureKey?: string
  memorySize?: string
  region: string
  runTime?: string
  serviceName: string
  stage: string
  timeout?: number
}

export type ServerlessAwsLambdaManifest = ManifestAttributes & {
  configOverridePath?: string
  metadata?: string
  store?: StoreConfigWrapper
}

export type ServerlessAwsLambdaPackageV2StepInfo = StepSpecType & {
  connectorRef?: string
  delegateSelectors?: string[]
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  packageCommandOptions?: string[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  serverlessVersion?: string
}

export type ServerlessAwsLambdaPrepareRollbackV2StepInfo = StepSpecType & {
  connectorRef?: string
  delegateSelectors?: string[]
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  serverlessVersion?: string
}

export type ServerlessAwsLambdaRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type ServerlessAwsLambdaRollbackV2StepInfo = StepSpecType & {
  connectorRef?: string
  delegateSelectors?: string[]
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  serverlessVersion?: string
}

export type ServerlessAwsLambdaServiceSpec = ServiceSpec & {}

export interface ServiceAccountAggregateDTO {
  createdAt: number
  lastModifiedAt: number
  roleAssignmentsMetadataDTO?: RoleAssignmentMetadataDTO[]
  serviceAccount: ServiceAccountDTO
  tokensCount?: number
}

export interface ServiceAccountConfig {
  apiKeyLimit?: number
  tokenLimit?: number
}

export interface ServiceAccountDTO {
  accountIdentifier: string
  description?: string
  email: string
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
}

export type ServiceAccountPrincipal = Principal & {
  accountId?: string
  email?: string
  username?: string
}

export interface ServiceConfig {
  service?: ServiceYaml
  serviceDefinition?: ServiceDefinition
  serviceRef?: string
  stageOverrides?: StageOverridesConfig
  useFromStage?: ServiceUseFromStage
}

export interface ServiceDashboardInfo {
  accountIdentifier?: string
  failureDeploymentsCount?: number
  identifier?: string
  instancesCount?: number
  instancesCountChangeRate?: number
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  successDeploymentsCount?: number
  totalDeploymentsChangeRate?: number
  totalDeploymentsCount?: number
}

export interface ServiceDefinition {
  spec: ServiceSpec
  type:
    | 'Kubernetes'
    | 'NativeHelm'
    | 'Ssh'
    | 'WinRm'
    | 'ServerlessAwsLambda'
    | 'AzureWebApp'
    | 'CustomDeployment'
    | 'ECS'
    | 'Elastigroup'
    | 'TAS'
    | 'Asg'
    | 'GoogleCloudFunctions'
    | 'AwsLambda'
    | 'AWS_SAM'
}

export interface ServiceDeployment {
  deployments?: DeploymentCount
  rate?: DeploymentChangeRates
  time?: number
}

export interface ServiceDeploymentInfo {
  image?: string
  serviceId?: string
  serviceName?: string
  serviceTag?: string
}

export interface ServiceDeploymentInfoDTO {
  serviceDeploymentList?: ServiceDeployment[]
}

export interface ServiceDeploymentListInfo {
  endTime?: number
  failureRate?: number
  failureRateChangeRate?: number
  frequency?: number
  frequencyChangeRate?: number
  serviceDeploymentList?: ServiceDeployment[]
  startTime?: number
  totalDeployments?: number
  totalDeploymentsChangeRate?: number
}

export interface ServiceDeploymentListInfoV2 {
  endTime?: number
  failureRate?: number
  failureRateChangeRate?: ChangeRate
  frequency?: number
  frequencyChangeRate?: ChangeRate
  serviceDeploymentList?: ServiceDeploymentV2[]
  startTime?: number
  totalDeployments?: number
  totalDeploymentsChangeRate?: ChangeRate
}

export interface ServiceDeploymentV2 {
  deployments?: DeploymentCount
  rate?: DeploymentChangeRatesV2
  time?: number
}

export interface ServiceDeployments {
  orgDeploymentsList?: OrgDeployments[]
}

export interface ServiceDetailsDTO {
  deploymentTypeList?: string[]
  description?: string
  failureRate?: number
  failureRateChangeRate?: number
  frequency?: number
  frequencyChangeRate?: number
  instanceCountDetails?: InstanceCountDetailsByEnvTypeBase
  lastPipelineExecuted?: ServicePipelineInfo
  serviceIdentifier?: string
  serviceName?: string
  successRate?: number
  successRateChangeRate?: number
  tags?: {
    [key: string]: string
  }
  totalDeploymentChangeRate?: number
  totalDeployments?: number
}

export interface ServiceDetailsDTOV2 {
  connectorRef?: string
  deploymentIconList?: IconDTO[]
  deploymentTypeList?: string[]
  description?: string
  entityGitDetails?: EntityGitDetails
  failureRate?: number
  failureRateChangeRate?: ChangeRate
  fallbackBranch?: string
  frequency?: number
  frequencyChangeRate?: ChangeRate
  instanceCountDetails?: InstanceCountDetailsByEnvTypeBase
  lastPipelineExecuted?: ServicePipelineInfo
  serviceIdentifier?: string
  serviceName?: string
  storeType?: 'INLINE' | 'REMOTE'
  successRate?: number
  successRateChangeRate?: ChangeRate
  tags?: {
    [key: string]: string
  }
  totalDeploymentChangeRate?: ChangeRate
  totalDeployments?: number
}

export interface ServiceDetailsInfoDTO {
  serviceDeploymentDetailsList?: ServiceDetailsDTO[]
}

export interface ServiceDetailsInfoDTOV2 {
  serviceDeploymentDetailsList?: ServiceDetailsDTOV2[]
}

export interface ServiceEnvRef {
  environmentRef?: string
  serviceRef?: string
}

export interface ServiceExecutionSummary {
  artifacts?: ArtifactsSummary
  deploymentType?: string
  displayName?: string
  gitOpsEnabled?: boolean
  identifier?: string
  manifestInfo?: ManifestStoreInfo
}

export interface ServiceHeaderInfo {
  createdAt?: number
  deploymentIconList?: IconDTO[]
  deploymentTypes?: string[]
  description?: string
  identifier?: string
  lastModifiedAt?: number
  name?: string
}

export interface ServiceHook {
  actions?: ('FetchFiles' | 'TemplateManifest' | 'SteadyStateCheck')[]
  identifier: string
  store: StoreConfig
  storeType: 'Inline'
}

export interface ServiceHookWrapper {
  postHook?: ServiceHook
  preHook?: ServiceHook
}

export interface ServiceInputsMergedResponseDto {
  mergedServiceInputsYaml?: string
  serviceYaml?: string
}

export interface ServiceInstanceUsageDTO {
  accountIdentifier?: string
  activeServiceInstances?: UsageDataDTO
  activeServices?: UsageDataDTO
  cdLicenseType?: 'SERVICES' | 'SERVICE_INSTANCES'
  module?: string
  timestamp?: number
}

export interface ServiceMoveConfigResponse {
  serviceIdentifier?: string
}

export type ServiceNowADFSDTO = ServiceNowAuthCredentialsDTO & {
  adfsUrl: string
  certificateRef: string
  clientIdRef: string
  privateKeyRef: string
  resourceIdRef: string
}

export interface ServiceNowAuthCredentialsDTO {
  [key: string]: any
}

export interface ServiceNowAuthenticationDTO {
  spec: ServiceNowAuthCredentialsDTO
  type: 'UsernamePassword' | 'AdfsClientCredentialsWithCertificate' | 'RefreshTokenGrantType'
}

export type ServiceNowConnector = ConnectorConfigDTO & {
  auth: ServiceNowAuthenticationDTO
  delegateSelectors?: string[]
  passwordRef?: string
  serviceNowUrl: string
  username?: string
  usernameRef?: string
}

export interface ServiceNowFieldAllowedValueNG {
  id?: string
  name?: string
  value?: string
}

export interface ServiceNowFieldNG {
  allowedValues: ServiceNowFieldAllowedValueNG[]
  custom?: boolean
  internalType?: string
  key: string
  name: string
  readOnly?: boolean
  required?: boolean
  schema: ServiceNowFieldSchemaNG
}

export interface ServiceNowFieldSchemaNG {
  array?: boolean
  customType?: string
  multilineText?: boolean
  type: 'glide_date_time' | 'integer' | 'boolean' | 'string' | 'option' | 'unknown'
  typeStr: string
}

export interface ServiceNowFieldValueNG {
  displayValue?: string
  value?: string
}

export type ServiceNowRefreshTokenDTO = ServiceNowAuthCredentialsDTO & {
  clientIdRef: string
  clientSecretRef?: string
  refreshTokenRef: string
  scope?: string
  tokenUrl: string
}

export interface ServiceNowStagingTable {
  label: string
  name: string
}

export interface ServiceNowTemplate {
  fields: {
    [key: string]: ServiceNowFieldValueNG
  }
  name: string
  sys_id: string
}

export interface ServiceNowTicketNG {
  fields: {
    [key: string]: ServiceNowFieldValueNG
  }
  number: string
  url: string
}

export interface ServiceNowTicketTypeDTO {
  key: string
  name: string
}

export type ServiceNowUserNamePasswordDTO = ServiceNowAuthCredentialsDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export interface ServiceOverrideBatchMigrationDTO {
  accountIds?: string[]
}

export interface ServiceOverrideInputsYaml {
  serviceOverrideInputs?: JsonNode
  serviceRef: string
}

export interface ServiceOverrideMigrationResponseDTO {
  accountId?: string
  accountLevelMigrationInfo?: AccountLevelOverrideMigrationResponseDTO
  orgLevelMigrationInfo?: OrgLevelOverrideMigrationResponseDTO[]
  overrideV2SettingsUpdateResponseDTO?: OverrideV2SettingsUpdateResponseDTO
  projectLevelMigrationInfo?: ProjectLevelOverrideMigrationResponseDTO[]
  successful?: boolean
}

export interface ServiceOverrideRequestDTO {
  environmentIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceIdentifier?: string
  yaml?: string
}

export interface ServiceOverrideRequestDTOV2 {
  clusterIdentifier?: string
  environmentRef: string
  infraIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceRef?: string
  spec?: ServiceOverridesSpec
  type:
    | 'ENV_GLOBAL_OVERRIDE'
    | 'ENV_SERVICE_OVERRIDE'
    | 'INFRA_GLOBAL_OVERRIDE'
    | 'INFRA_SERVICE_OVERRIDE'
    | 'CLUSTER_GLOBAL_OVERRIDE'
    | 'CLUSTER_SERVICE_OVERRIDE'
  v1Api?: boolean
  yamlInternal?: string
}

export interface ServiceOverrideResponseDTO {
  accountId?: string
  environmentRef?: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceRef?: string
  yaml?: string
}

export interface ServiceOverrides {
  description?: string
  name?: string
}

export interface ServiceOverridesMetadata {
  serviceOverridesYaml?: string
  serviceRef?: string
  serviceRuntimeInputYaml?: string
  serviceYaml?: string
}

export interface ServiceOverridesResponseDTOV2 {
  accountId?: string
  clusterIdentifier?: string
  environmentRef?: string
  identifier?: string
  infraIdentifier?: string
  newlyCreated?: boolean
  orgIdentifier?: string
  projectIdentifier?: string
  serviceRef?: string
  spec?: ServiceOverridesSpec
  type?:
    | 'ENV_GLOBAL_OVERRIDE'
    | 'ENV_SERVICE_OVERRIDE'
    | 'INFRA_GLOBAL_OVERRIDE'
    | 'INFRA_SERVICE_OVERRIDE'
    | 'CLUSTER_GLOBAL_OVERRIDE'
    | 'CLUSTER_SERVICE_OVERRIDE'
  yamlInternal?: string
}

export interface ServiceOverridesSpec {
  applicationSettings?: ApplicationSettingsConfiguration
  configFiles?: ConfigFileWrapper[]
  connectionStrings?: ConnectionStringsConfiguration
  manifests?: ManifestConfigWrapper[]
  metadata?: string
  variables?: NGVariable[]
}

export interface ServicePipelineInfo {
  deployedById?: string
  deployedByName?: string
  identifier?: string
  lastExecutedAt?: number
  name?: string
  pipelineExecutionId?: string
  planExecutionId?: string
  status?: string
}

export interface ServicePipelineWithRevertInfo {
  deployedById?: string
  deployedByName?: string
  failureDetail?: string
  identifier?: string
  lastExecutedAt?: number
  name?: string
  pipelineExecutionId?: string
  planExecutionId?: string
  revertExecution?: boolean
  status?: string
}

export type ServicePrincipal = Principal & {}

export interface ServiceRequestDTO {
  description?: string
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
  yaml?: string
}

export interface ServiceResponse {
  createdAt?: number
  lastModifiedAt?: number
  service?: ServiceResponseDTO
}

export interface ServiceResponseDTO {
  accountId?: string
  cacheResponseMetadataDTO?: CacheResponseMetadata
  connectorRef?: string
  deleted?: boolean
  description?: string
  entityGitDetails?: EntityGitDetails
  fallbackBranch?: string
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  storeType?: 'INLINE' | 'REMOTE'
  tags?: {
    [key: string]: string
  }
  v2Service?: boolean
  yaml?: string
}

export interface ServiceSequence {
  accountId?: string
  createdAt?: number
  customSequence?: CustomSequenceDTO
  lastModifiedAt?: number
  orgIdentifier?: string
  projectIdentifier?: string
  serviceIdentifier?: string
  shouldUseCustomSequence?: boolean
  uuid?: string
}

export interface ServiceSpec {
  artifacts?: ArtifactListConfig
  configFiles?: ConfigFileWrapper[]
  manifests?: ManifestConfigWrapper[]
  variables?: NGVariable[]
}

export interface ServiceUsageDTO {
  accountIdentifier?: string
  activeServiceInstances?: UsageDataDTO
  activeServices?: UsageDataDTO
  cdLicenseType?: 'SERVICES' | 'SERVICE_INSTANCES'
  module?: string
  serviceLicenses?: UsageDataDTO
  timestamp?: number
}

export interface ServiceUseFromStage {
  metadata?: string
  overrides?: ServiceOverrides
  stage: string
}

export interface ServiceUseFromStageV2 {
  metadata?: string
  stage: string
}

export interface ServiceV2YamlMetadata {
  connectorRef?: string
  entityGitDetails?: EntityGitDetails
  fallbackBranch?: string
  inputSetTemplateYaml?: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceIdentifier: string
  serviceYaml?: string
  storeType?: 'INLINE' | 'REMOTE'
}

export interface ServiceYaml {
  description?: string
  identifier: string
  name: string
  tags?: {
    [key: string]: string
  }
}

export interface ServiceYamlV2 {
  gitBranch?: string
  serviceInputs?: JsonNode
  serviceRef?: string
  useFromStage?: ServiceUseFromStageV2
}

export interface ServicesCount {
  newCount?: number
  totalCount?: number
}

export interface ServicesDashboardInfo {
  serviceDashboardInfoList?: ServiceDashboardInfo[]
}

export interface ServicesMetadata {
  parallel?: boolean
}

export interface ServicesV2YamlMetadataDTO {
  serviceV2YamlMetadataList?: ServiceV2YamlMetadata[]
}

export interface ServicesYaml {
  metadata?: ServicesMetadata
  useFromStage?: ServiceUseFromStageV2
  values?: ServiceYamlV2[]
}

export interface ServicesYamlMetadataApiInput {
  serviceIdentifiers: string[]
}

export interface ServicesYamlMetadataApiInputV2 {
  serviceWithGitInfoList?: EntityWithGitInfo[]
}

export interface SessionTimeoutSettings {
  sessionTimeOutInMinutes: number
}

export interface SettingDTO {
  allowOverrides: boolean
  allowedScopes: ('ACCOUNT' | 'ORGANIZATION' | 'PROJECT')[]
  allowedValues?: string[]
  category:
    | 'CD'
    | 'CI'
    | 'CE'
    | 'CV'
    | 'CF'
    | 'STO'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'GOVERNANCE'
    | 'CHAOS'
    | 'SCIM'
    | 'GIT_EXPERIENCE'
    | 'CONNECTORS'
    | 'EULA'
    | 'NOTIFICATIONS'
  defaultValue?: string
  groupIdentifier: string
  identifier: string
  isSettingEditable: boolean
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  settingSource?: 'ACCOUNT' | 'ORG' | 'PROJECT' | 'DEFAULT'
  value?: string
  valueType: 'String' | 'Boolean' | 'Number'
}

export interface SettingRequestDTO {
  allowOverrides: boolean
  identifier?: string
  updateType: 'UPDATE' | 'RESTORE'
  value?: string
}

export interface SettingResponseDTO {
  lastModifiedAt?: number
  setting: SettingDTO
}

export interface SettingUpdateResponseDTO {
  errorMessage?: string
  identifier?: string
  lastModifiedAt?: number
  setting: SettingDTO
  updateStatus?: boolean
}

export interface SettingValueResponseDTO {
  value: string
  valueType: 'String' | 'Boolean' | 'Number'
}

export interface SetupUsageDetail {
  [key: string]: any
}

export interface ShellScriptBaseSource {
  type?: string
}

export type ShellScriptInlineSource = ShellScriptBaseSource & {
  script?: string
}

export type ShellScriptProvisionStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  environmentVariables?: NGVariable[]
  source: ShellScriptSourceWrapper
}

export interface ShellScriptSourceWrapper {
  spec: ShellScriptBaseSource
  type: string
}

export interface ShouldDisableDeploymentFreezeResponseDTO {
  freezeReferences?: FreezeReference[]
  shouldDisable?: boolean
}

export interface SidecarArtifact {
  identifier: string
  name?: string
  spec?: ArtifactConfig
  template?: TemplateLinkConfig
  type?:
    | 'DockerRegistry'
    | 'Gcr'
    | 'Ecr'
    | 'Nexus3Registry'
    | 'Nexus2Registry'
    | 'ArtifactoryRegistry'
    | 'CustomArtifact'
    | 'Acr'
    | 'Jenkins'
    | 'AmazonS3'
    | 'GoogleArtifactRegistry'
    | 'GithubPackageRegistry'
    | 'AzureArtifacts'
    | 'AmazonMachineImage'
    | 'Bamboo'
    | 'GoogleCloudStorage'
    | 'GoogleCloudSource'
}

export interface SidecarArtifactWrapper {
  sidecar?: SidecarArtifact
}

export type SignalFXConnectorDTO = ConnectorConfigDTO & {
  apiTokenRef: string
  delegateSelectors?: string[]
  url: string
}

export interface SignupDTO {
  billingFrequency?: 'MONTHLY' | 'YEARLY'
  companyName?: string
  edition?: 'COMMUNITY' | 'FREE' | 'TEAM' | 'ENTERPRISE'
  email?: string
  intent?: string
  name?: string
  password?: string
  signupAction?: 'REGULAR' | 'TRIAL' | 'SUBSCRIBE'
  utmInfo?: UtmInfo
}

export interface SingleEnvMigrationResponse {
  accountId?: string
  envIdentifier?: string
  orgId?: string
  projectId?: string
  successful?: boolean
}

export interface SingleServiceOverrideMigrationResponse {
  accountId?: string
  envRef?: string
  orgId?: string
  projectId?: string
  serviceRef?: string
  successful?: boolean
}

export type SlackConfig = NotificationSettingConfig & {
  slackWebhookUrl?: string
}

export type SlackConfigDTO = NotificationSettingConfigDTO & {
  slackWebhookUrl: string
}

export interface SlackNotificationSetting {
  name?: string
  outgoingWebhookUrl: string
}

export interface SmtpConfigDTO {
  delegateSelectors?: string[]
  fromAddress?: string
  host: string
  password?: string[]
  port: number
  startTLS?: boolean
  useSSL?: boolean
  username?: string
}

export interface Sort {
  empty?: boolean
  sorted?: boolean
  unsorted?: boolean
}

export interface SourceCodeManagerAuthentication {
  [key: string]: any
}

export interface SourceCodeManagerDTO {
  accountIdentifier?: string
  authentication?: SourceCodeManagerAuthentication
  createdAt?: number
  id?: string
  lastModifiedAt?: number
  name: string
  type?: 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'AWS_CODE_COMMIT' | 'AZURE_REPO'
  userIdentifier?: string
}

export interface Splitting {
  concurrency?: number
  enabled?: boolean
  strategy?: 'class_timing' | 'test_count'
}

export type SplunkConnectorDTO = ConnectorConfigDTO & {
  accountId: string
  delegateSelectors?: string[]
  passwordRef?: string
  splunkUrl: string
  tokenRef?: string
  type?: 'UsernamePassword' | 'Anonymous' | 'Bearer Token(HTTP Header)'
  username?: string
}

export type SpotConnector = ConnectorConfigDTO & {
  credential: SpotCredential
  delegateSelectors?: string[]
  executeOnDelegate?: boolean
}

export interface SpotCredential {
  spec?: SpotCredentialSpec
  type: 'PermanentTokenConfig'
}

export interface SpotCredentialSpec {
  [key: string]: any
}

export type SpotInfrastructureDetails = InfrastructureDetails & {
  ec2InstanceId?: string
  elastigroupId?: string
}

export type SpotInstanceInfoDTO = InstanceInfoDTO & {
  ec2InstanceId: string
  elastigroupId: string
  infrastructureKey: string
}

export type SpotPermanentTokenConfigSpec = SpotCredentialSpec & {
  apiTokenRef: string
  spotAccountId?: string
  spotAccountIdRef?: string
}

export type SshDeploymentMetaData = DeploymentMetaData & { [key: string]: any }

export type SshServiceSpec = ServiceSpec & {}

export type SshWinRmAwsInfrastructure = Infrastructure & {
  awsInstanceFilter: AwsInstanceFilter
  connectorRef: string
  credentialsRef: string
  hostConnectionType: 'PublicIP' | 'PrivateIP'
  provisioner?: string
  region: string
}

export type SshWinRmAzureInfrastructure = Infrastructure & {
  connectorRef: string
  credentialsRef: string
  hostConnectionType: 'Hostname' | 'PrivateIP' | 'PublicIP'
  provisioner?: string
  resourceGroup: string
  subscriptionId: string
  tags?: {
    [key: string]: string
  }
}

export type SshWinrmInfrastructureDetails = InfrastructureDetails & {
  host?: string
}

export interface StackTraceElement {
  classLoaderName?: string
  className?: string
  fileName?: string
  lineNumber?: number
  methodName?: string
  moduleName?: string
  moduleVersion?: string
  nativeMethod?: boolean
}

export interface StageElementConfig {
  delegateSelectors?: string[]
  description?: string
  failureStrategies?: FailureStrategyConfig[]
  identifier: string
  name: string
  skipInstances?: boolean
  spec?: StageInfoConfig
  strategy?: StrategyConfig
  tags?: {
    [key: string]: string
  }
  template?: TemplateLinkConfig
  timeout?: string
  type?: string
  variables?: NGVariable[]
  when?: StageWhenCondition
}

export interface StageInfoConfig {
  execution?: ExecutionElementConfig
}

export interface StageMigrationFailureResponse {
  failureReason?: string
  orgIdentifier?: string
  pipelineIdentifier?: string
  projectIdentifier?: string
  stageIdentifier?: string
}

export interface StageOverridesConfig {
  artifacts?: ArtifactListConfig
  configFiles?: ConfigFileWrapper[]
  manifests?: ManifestConfigWrapper[]
  variables?: NGVariable[]
}

export type StageRollbackFailureActionConfig = FailureStrategyActionConfig & {
  type: 'StageRollback'
}

export interface StageWhenCondition {
  condition?: string
  pipelineStatus: 'Success' | 'Failure' | 'All'
}

export interface StartTrialDTO {
  edition: 'COMMUNITY' | 'FREE' | 'TEAM' | 'ENTERPRISE'
  moduleType:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
}

export interface StartupCommandConfiguration {
  metadata?: string
  store: StoreConfigWrapper
}

export interface StartupScriptConfiguration {
  metadata?: string
  store: StoreConfigWrapper
}

export type StaticLimitRestrictionDTO = RestrictionDTO & {
  count?: number
  limit?: number
}

export type StaticLimitRestrictionMetadataDTO = RestrictionMetadataDTO & {
  allowedIfEqual?: boolean
  limit?: number
}

export interface StepCategory {
  name?: string
  stepCategories?: StepCategory[]
  stepsData?: StepData[]
}

export interface StepData {
  name?: string
  type?:
    | 'MergePR'
    | 'RevertPR'
    | 'GitOpsSync'
    | 'UpdateGitOpsApp'
    | 'APPLY'
    | 'SCALE'
    | 'STAGE_DEPLOYMENT'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'K8sBGSwapServices'
    | 'K8sDelete'
    | 'K8sCanaryDelete'
    | 'K8sCanaryDeploy'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'CreateStack'
    | 'DeleteStack'
    | 'RollbackStack'
    | 'SHELL_SCRIPT_PROVISIONER'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'JIRA'
    | 'SERVICENOW'
    | 'EMAIL'
    | 'BARRIERS'
    | 'NEW_RELIC_DEPLOYMENT_MAKER'
    | 'TEMPLATIZED_SECRET_MANAGER'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'EcsRunTask'
    | 'Command'
    | 'JenkinsBuild'
    | 'AzureCreateARMResource'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'ElastigroupSetup'
    | 'TerragruntPlan'
    | 'TerragruntApply'
    | 'TerragruntDestroy'
    | 'TerragruntRollback'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'BasicAppSetup'
    | 'BGAppSetup'
    | 'CanaryAppSetup'
    | 'TanzuCommand'
    | 'SwapRollback'
    | 'SwapRoutes'
    | 'AppResize'
    | 'AppRollback'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'DownloadManifests'
    | 'AwsSamBuild'
    | 'AwsSamRollback'
    | 'AwsLambdaRollback'
    | 'BambooBuild'
    | 'RouteMapping'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'ServerlessAwsLambdaDeployV2'
    | 'ServerlessAwsLambdaPackageV2'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'AwsCdkRollback'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'AsgShiftTraffic'
}

export interface StepElementConfig {
  description?: string
  enforce?: PolicyConfig
  failureStrategies?: FailureStrategyConfig[]
  identifier: string
  name: string
  spec?: StepSpecType
  strategy?: StrategyConfig
  timeout?: string
  type: string
  when?: StepWhenCondition
}

export interface StepExecutionInstanceInfo {
  deployedServiceInstances: StepInstanceInfo[]
  serviceInstancesAfter: StepInstanceInfo[]
  serviceInstancesBefore: StepInstanceInfo[]
}

export interface StepGroupElementConfig {
  delegateSelectors?: string[]
  failureStrategies?: FailureStrategyConfig[]
  identifier: string
  name: string
  sharedPaths?: string[]
  stepGroupInfra?: StepGroupInfra
  steps?: ExecutionWrapperConfig[]
  strategy?: StrategyConfig
  template?: TemplateLinkConfig
  variables?: NGVariable[]
  when?: StepWhenCondition
}

export type StepGroupFailureActionConfig = FailureStrategyActionConfig & {
  type: 'StepGroupRollback'
}

export interface StepGroupInfra {
  type?: 'KubernetesDirect' | 'Delegate' | 'Noop'
}

export interface StepInstanceInfo {
  instanceName?: string
}

export interface StepSpecType {
  [key: string]: any
}

export interface StepTemplateRef {
  templateRef: string
  versionLabel?: string
}

export interface StepWhenCondition {
  condition?: string
  stageStatus: 'Success' | 'Failure' | 'All'
}

export interface StoreConfig {
  [key: string]: any
}

export interface StoreConfigWrapper {
  metadata?: string
  spec: StoreConfig
  type:
    | 'CustomRemote'
    | 'Git'
    | 'Github'
    | 'Bitbucket'
    | 'GitLab'
    | 'Http'
    | 'S3'
    | 'Gcs'
    | 'Inline'
    | 'Artifactory'
    | 'S3Url'
    | 'InheritFromManifest'
    | 'Harness'
    | 'OciHelmChart'
    | 'AzureRepo'
    | 'ArtifactBundle'
}

export interface StoreConfigWrapperParameters {
  spec?: StoreConfig
  type?: string
}

export interface StrategyConfig {
  matrix?: ParameterFieldMatrixConfigInterface
  parallelism?: number
  repeat?: HarnessForConfig
}

export interface StrategyParameters {
  artifactType?:
    | 'JAR'
    | 'WAR'
    | 'TAR'
    | 'ZIP'
    | 'NUGET'
    | 'DOCKER'
    | 'RPM'
    | 'AWS_LAMBDA'
    | 'AWS_CODEDEPLOY'
    | 'PCF'
    | 'AMI'
    | 'AZURE_MACHINE_IMAGE'
    | 'AZURE_WEBAPP'
    | 'IIS'
    | 'OTHER'
    | 'IIS_APP'
    | 'IIS_VirtualDirectory'
  instances?: number
  phases?: number[]
  unitType?: 'COUNT' | 'PERCENTAGE'
}

export type StringNGVariable = NGVariable & {
  default?: string
  name?: string
  type?: 'String'
  value: string
}

export type StringVariableConfigDTO = VariableConfigDTO & {
  allowedValues?: string[]
  defaultValue?: string
  fixedValue?: string
}

export interface StripeBillingDTO {
  city?: string
  country?: string
  creditCardId?: string
  line1?: string
  line2?: string
  state?: string
  zipCode?: string
}

export interface StripeItemRequest {
  priceId?: string
  quantity?: number
}

export interface SubscriptionDTO {
  customer?: CustomerDTO
  items?: StripeItemRequest[]
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  paymentFrequency?: 'MONTHLY' | 'YEARLY'
  paymentMethodId?: string
}

export interface SubscriptionDetailDTO {
  accountIdentifier?: string
  cancelAt?: number
  canceledAt?: number
  clientSecret?: string
  customerId?: string
  items?: ItemDTO[]
  latestInvoice?: string
  latestInvoiceDetail?: InvoiceDetailDTO
  pendingUpdate?: PendingUpdateDetailDTO
  status?: string
  subscriptionId?: string
}

export interface SubscriptionItemRequest {
  quantity?: number
  quantityIncludedInPrice?: boolean
  type?: string
}

export interface SubscriptionRequest {
  accountIdentifier?: string
  customer?: CustomerDTO
  edition?: string
  items?: SubscriptionItemRequest[]
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  paymentFrequency?: string
  premiumSupport?: boolean
}

export type SumoLogicConnectorDTO = ConnectorConfigDTO & {
  accessIdRef: string
  accessKeyRef: string
  delegateSelectors?: string[]
  url: string
}

export interface SupportedDelegateVersion {
  latestSupportedMinimalVersion?: string
  latestSupportedVersion?: string
}

export interface SvcEnvMigrationProjectWrapperRequestDto {
  branch?: string
  infraIdentifierFormat: string
  newBranch?: boolean
  orgIdentifier: string
  projectIdentifier: string
  skipInfras?: string[]
  skipPipelines?: string[]
  skipServices?: string[]
  templateMap?: {
    [key: string]: TemplateObject
  }
  updatePipeline?: boolean
}

export interface SvcEnvMigrationProjectWrapperResponseDto {
  failures?: StageMigrationFailureResponse[]
  migratedPipelines?: string[]
}

export interface SvcEnvMigrationRequestDto {
  branch?: string
  expressionMap?: {
    [key: string]: string
  }
  infraIdentifierFormat: string
  newBranch?: boolean
  orgIdentifier: string
  pipelineIdentifier: string
  populateInfrastructureInputs?: boolean
  populateServiceInputs?: boolean
  projectIdentifier: string
  skipInfras?: string[]
  skipServices?: string[]
  stageMap?: {
    [key: string]: RuntimeEntity
  }
  templateMap?: {
    [key: string]: TemplateObject
  }
  updatePipeline?: boolean
}

export interface SvcEnvMigrationResponseDto {
  failures?: StageMigrationFailureResponse[]
  migrated?: boolean
  pipelineYaml?: string
}

export interface SyncOptions {
  applyOutOfSyncOnly: boolean
  autoCreateNamespace: boolean
  prunePropagationPolicy: 'foreground' | 'background' | 'orphan'
  pruneResourcesAtLast: boolean
  replaceResources: boolean
  skipSchemaValidation: boolean
}

export interface SyncRetryStrategy {
  baseBackoffDuration?: string
  increaseBackoffByFactor?: number
  limit?: number
  maxBackoffDuration?: string
}

export type SyncStepInfo = StepSpecType & {
  applicationsList?: AgentApplicationTargets[]
  applyOnly: boolean
  delegateSelectors?: string[]
  dryRun: boolean
  forceApply: boolean
  prune: boolean
  retryStrategy?: SyncRetryStrategy
  syncOptions: SyncOptions
}

export interface TGTGenerationSpecDTO {
  [key: string]: any
}

export type TGTKeyTabFilePathSpecDTO = TGTGenerationSpecDTO & {
  keyPath?: string
}

export type TGTPasswordSpecDTO = TGTGenerationSpecDTO & {
  password?: string
}

export interface Tag {
  key?: string
  value?: string
}

export type TagBuildSpec = BuildSpec & {
  tag: string
}

export type TagsFilter = FilterSpec & {
  matchType: 'all' | 'any'
  tags: {
    [key: string]: string
  }
}

export interface TailFilePattern {
  tailFile?: ParameterFieldString
  tailPattern?: ParameterFieldString
}

export type TanzuApplicationServiceInfrastructure = Infrastructure & {
  connectorRef: string
  metadata?: string
  organization: string
  provisioner?: string
  space: string
}

export type TanzuApplicationServiceSpec = ServiceSpec & {}

export type TasAppResizeStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  ignoreInstanceCountManifest?: boolean
  newAppInstances: TasInstanceSelectionWrapper
  oldAppInstances?: TasInstanceSelectionWrapper
}

export type TasBGAppSetupStepInfo = StepSpecType & {
  additionalRoutes?: string[]
  delegateSelectors?: string[]
  existingVersionToKeep: number
  tasInstanceCountType: 'FromManifest' | 'MatchRunningInstances'
  tempRoutes?: string[]
}

export type TasBasicAppSetupStepInfo = StepSpecType & {
  additionalRoutes?: string[]
  delegateSelectors?: string[]
  existingVersionToKeep: number
  tasInstanceCountType: 'FromManifest' | 'MatchRunningInstances'
}

export type TasCanaryAppSetupStepInfo = StepSpecType & {
  additionalRoutes?: string[]
  delegateSelectors?: string[]
  existingVersionToKeep: number
  resizeStrategy: 'UpScaleNewFirst' | 'DownScaleOldFirst'
  tasInstanceCountType: 'FromManifest' | 'MatchRunningInstances'
}

export interface TasCommandScript {
  store: StoreConfigWrapper
}

export type TasCommandStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  inputVariables?: NGVariable[]
  outputVariables?: NGVariable[]
  script: TasCommandScript
}

export type TasConnector = ConnectorConfigDTO & {
  credential: TasCredential
  delegateSelectors?: string[]
  executeOnDelegate?: boolean
}

export type TasCountInstanceSelection = TasInstanceSelectionBase & {
  value: ParameterFieldString
}

export interface TasCredential {
  spec?: TasCredentialSpec
  type: 'ManualConfig'
}

export interface TasCredentialSpec {
  [key: string]: any
}

export type TasDeploymentMetaData = DeploymentMetaData & { [key: string]: any }

export type TasInfrastructureDetails = InfrastructureDetails & {
  organization?: string
  space?: string
  tasApplicationName?: string
}

export type TasInstanceInfoDTO = InstanceInfoDTO & {
  id: string
  instanceIndex?: string
  organization: string
  space: string
  tasApplicationGuid?: string
  tasApplicationName: string
}

export interface TasInstanceSelectionBase {
  [key: string]: any
}

export interface TasInstanceSelectionWrapper {
  spec?: TasInstanceSelectionBase
  type?: 'Percentage' | 'Count'
}

export type TasManifest = ManifestAttributes & {
  autoScalerPath?: string[]
  cfCliVersion?: 'V7'
  metadata?: string
  store?: StoreConfigWrapper
  varsPaths?: string[]
}

export type TasManualDetails = TasCredentialSpec & {
  endpointUrl: string
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type TasPercentageInstanceSelection = TasInstanceSelectionBase & {
  value: ParameterFieldString
}

export type TasRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type TasRollingDeployStepInfo = StepSpecType & {
  additionalRoutes?: string[]
  delegateSelectors?: string[]
}

export type TasRollingRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export type TasRouteMappingStepInfo = StepSpecType & {
  appName: string
  delegateSelectors?: string[]
  routeType: 'Map' | 'UnMap'
  routes: string[]
}

export type TasSwapRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  upsizeInActiveApp: boolean
}

export type TasSwapRoutesStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  downSizeOldApplication: boolean
}

export interface TaskSelectorYaml {
  delegateSelectors?: string
  origin?: string
}

export interface TechStack {
  category?: string
  technology?: string
}

export type TemplateFilterProperties = FilterProperties & {
  childTypes?: string[]
  description?: string
  listingScope?: TemplateScope
  repoName?: string
  templateEntityTypes?: (
    | 'Step'
    | 'Stage'
    | 'Pipeline'
    | 'CustomDeployment'
    | 'MonitoredService'
    | 'SecretManager'
    | 'ArtifactSource'
    | 'StepGroup'
  )[]
  templateIdentifiers?: string[]
  templateNames?: string[]
}

export interface TemplateInfo {
  templateEntityType?:
    | 'Step'
    | 'Stage'
    | 'Pipeline'
    | 'CustomDeployment'
    | 'MonitoredService'
    | 'SecretManager'
    | 'ArtifactSource'
    | 'StepGroup'
  templateIdentifier?: string
  versionLabel?: string
}

export interface TemplateInputsErrorDTO {
  fieldName?: string
  identifierOfErrorSource?: string
  message?: string
}

export type TemplateInputsErrorMetadataDTO = ErrorMetadataDTO & {
  errorMap?: {
    [key: string]: TemplateInputsErrorDTO
  }
  errorYaml?: string
}

export interface TemplateLinkConfig {
  gitBranch?: string
  templateInputs?: JsonNode
  templateRef: string
  templateVariables?: JsonNode
  versionLabel?: string
}

export interface TemplateLinkConfigForCustomSecretManager {
  templateInputs?: {
    [key: string]: NameValuePairWithDefault[]
  }
  templateRef: string
  versionLabel: string
}

export interface TemplateObject {
  templateRef: string
  versionLabel: string
}

export interface TemplateResponse {
  accountId: string
  cacheResponseMetadata?: CacheResponseMetadata
  childType?: string
  connectorRef?: string
  description?: string
  entityValidityDetails?: EntityValidityDetails
  gitDetails?: EntityGitDetails
  icon?: string
  identifier: string
  lastUpdatedAt?: number
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  stableTemplate?: boolean
  storeType?: 'INLINE' | 'REMOTE'
  tags?: {
    [key: string]: string
  }
  templateEntityType?:
    | 'Step'
    | 'Stage'
    | 'Pipeline'
    | 'CustomDeployment'
    | 'MonitoredService'
    | 'SecretManager'
    | 'ArtifactSource'
    | 'StepGroup'
  templateScope?: 'account' | 'org' | 'project' | 'unknown'
  version?: number
  versionLabel?: string
  yaml?: string
  yamlVersion?: string
}

export interface TemplateScope {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type TerraformApplyStepInfo = StepSpecType & {
  cloudCliConfiguration?: TerraformCloudCliStepConfiguration
  configuration?: TerraformStepConfiguration
  delegateSelectors?: string[]
  metadata?: string
  provisionerIdentifier: string
}

export interface TerraformBackendConfig {
  spec?: TerraformBackendConfigSpec
  type?: string
}

export interface TerraformBackendConfigSpec {
  [key: string]: any
}

export interface TerraformCliOptionFlag {
  commandType: 'INIT' | 'WORKSPACE' | 'REFRESH' | 'PLAN' | 'APPLY' | 'DESTROY'
  flag: string
}

export type TerraformCloudApplySpec = TerraformCloudRunExecutionSpec & {
  provisionerIdentifier: string
}

export interface TerraformCloudCliExecutionData {
  backendConfig?: TerraformBackendConfig
  configFiles: TerraformConfigFilesWrapper
  environmentVariables?: NGVariable[]
  targets?: string[]
  varFiles?: TerraformVarFileWrapper[]
}

export interface TerraformCloudCliPlanExecutionData {
  backendConfig?: TerraformBackendConfig
  command: 'Apply' | 'Destroy'
  commandFlags?: TerraformCliOptionFlag[]
  configFiles: TerraformConfigFilesWrapper
  environmentVariables?: NGVariable[]
  skipStateStorage?: boolean
  targets?: string[]
  varFiles?: TerraformVarFileWrapper[]
}

export interface TerraformCloudCliStepConfiguration {
  commandFlags?: TerraformCliOptionFlag[]
  encryptOutput?: TerraformEncryptOutput
  skipStateStorage?: boolean
  spec?: TerraformCloudCliExecutionData
}

export type TerraformCloudConnector = ConnectorConfigDTO & {
  credential: TerraformCloudCredential
  delegateSelectors?: string[]
  executeOnDelegate?: boolean
  terraformCloudUrl: string
}

export interface TerraformCloudCredential {
  spec?: TerraformCloudCredentialSpec
  type: 'ApiToken'
}

export interface TerraformCloudCredentialSpec {
  [key: string]: any
}

export type TerraformCloudPlanAndApplySpec = TerraformCloudRunExecutionSpec & {
  connectorRef: string
  discardPendingRuns?: boolean
  organization: string
  overridePolicies?: boolean
  provisionerIdentifier: string
  targets?: string[]
  variables?: NGVariable[]
  workspace: string
}

export type TerraformCloudPlanAndDestroySpec = TerraformCloudRunExecutionSpec & {
  connectorRef: string
  discardPendingRuns?: boolean
  organization: string
  overridePolicies?: boolean
  provisionerIdentifier: string
  targets?: string[]
  variables?: NGVariable[]
  workspace: string
}

export type TerraformCloudPlanOnlySpec = TerraformCloudRunExecutionSpec & {
  connectorRef: string
  discardPendingRuns: boolean
  exportTerraformPlanJson?: boolean
  organization: string
  planType?: 'Apply' | 'Destroy'
  provisionerIdentifier: string
  targets?: string[]
  terraformVersion?: string
  variables?: NGVariable[]
  workspace: string
}

export type TerraformCloudPlanSpec = TerraformCloudRunExecutionSpec & {
  connectorRef: string
  discardPendingRuns: boolean
  exportTerraformPlanJson?: boolean
  organization: string
  planType?: 'Apply' | 'Destroy'
  provisionerIdentifier: string
  targets?: string[]
  variables?: NGVariable[]
  workspace: string
}

export type TerraformCloudRefreshSpec = TerraformCloudRunExecutionSpec & {
  connectorRef: string
  discardPendingRuns?: boolean
  organization: string
  variables?: NGVariable[]
  workspace: string
}

export type TerraformCloudRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  discardPendingRuns?: boolean
  overridePolicies?: boolean
  provisionerIdentifier: string
  runMessage?: string
}

export interface TerraformCloudRunExecutionSpec {
  [key: string]: any
}

export type TerraformCloudRunStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  runMessage?: string
  runType: 'RefreshState' | 'PlanOnly' | 'PlanAndApply' | 'PlanAndDestroy' | 'Plan' | 'Apply'
  spec: TerraformCloudRunExecutionSpec
}

export type TerraformCloudTokenCredentials = TerraformCloudCredentialSpec & {
  apiToken: string
}

export interface TerraformConfigFilesWrapper {
  moduleSource?: ModuleSource
  store: StoreConfigWrapper
}

export type TerraformDestroyStepInfo = StepSpecType & {
  cloudCliConfiguration?: TerraformCloudCliStepConfiguration
  configuration?: TerraformStepConfiguration
  delegateSelectors?: string[]
  metadata?: string
  provisionerIdentifier: string
}

export interface TerraformEncryptOutput {
  outputSecretManagerRef: string
}

export interface TerraformExecutionData {
  backendConfig?: TerraformBackendConfig
  configFiles: TerraformConfigFilesWrapper
  environmentVariables?: NGVariable[]
  providerCredential?: TerraformProviderCredential
  targets?: string[]
  varFiles?: TerraformVarFileWrapper[]
  workspace?: string
}

export interface TerraformPlanExecutionData {
  backendConfig?: TerraformBackendConfig
  command: 'Apply' | 'Destroy'
  commandFlags?: TerraformCliOptionFlag[]
  configFiles: TerraformConfigFilesWrapper
  environmentVariables?: NGVariable[]
  exportTerraformHumanReadablePlan?: boolean
  exportTerraformPlanJson?: boolean
  providerCredential?: TerraformProviderCredential
  secretManagerRef: string
  skipRefreshCommand?: boolean
  skipStateStorage?: boolean
  targets?: string[]
  varFiles?: TerraformVarFileWrapper[]
  workspace?: string
}

export type TerraformPlanStepInfo = StepSpecType & {
  cloudCliConfiguration?: TerraformCloudCliPlanExecutionData
  configuration?: TerraformPlanExecutionData
  delegateSelectors?: string[]
  provisionerIdentifier: string
}

export interface TerraformProviderCredential {
  spec: TerraformProviderCredentialSpec
  type: 'Aws'
}

export interface TerraformProviderCredentialSpec {
  [key: string]: any
}

export type TerraformRollbackStepInfo = StepSpecType & {
  commandFlags?: TerraformCliOptionFlag[]
  delegateSelectors?: string[]
  provisionerIdentifier: string
  skipRefreshCommand?: boolean
}

export interface TerraformStepConfiguration {
  commandFlags?: TerraformCliOptionFlag[]
  encryptOutput?: TerraformEncryptOutput
  skipRefreshCommand?: boolean
  skipStateStorage?: boolean
  spec?: TerraformExecutionData
  type: 'Inline' | 'InheritFromPlan' | 'InheritFromApply'
}

export interface TerraformVarFile {
  identifier: string
  spec: TerraformVarFileSpec
  type: string
}

export interface TerraformVarFileSpec {
  type?: string
}

export interface TerraformVarFileWrapper {
  varFile: TerraformVarFile
}

export type TerragruntApplyStepInfo = StepSpecType & {
  configuration: TerragruntStepConfiguration
  delegateSelectors?: string[]
  metadata?: string
  provisionerIdentifier: string
}

export interface TerragruntBackendConfig {
  spec?: TerragruntBackendConfigSpec
  type?: string
}

export interface TerragruntBackendConfigSpec {
  [key: string]: any
}

export interface TerragruntCliOptionFlag {
  commandType: 'INIT' | 'WORKSPACE' | 'PLAN' | 'APPLY' | 'DESTROY' | 'OUTPUT'
  flag: string
}

export interface TerragruntConfigFilesWrapper {
  moduleSource?: ModuleSource
  store: StoreConfigWrapper
}

export type TerragruntDestroyStepInfo = StepSpecType & {
  configuration: TerragruntStepConfiguration
  delegateSelectors?: string[]
  metadata?: string
  provisionerIdentifier: string
}

export interface TerragruntExecutionData {
  backendConfig?: TerragruntBackendConfig
  configFiles: TerragruntConfigFilesWrapper
  environmentVariables?: NGVariable[]
  moduleConfig: TerragruntModuleConfig
  targets?: string[]
  varFiles?: TerragruntVarFileWrapper[]
  workspace?: string
}

export interface TerragruntModuleConfig {
  path: string
  terragruntRunType: 'RunAll' | 'RunModule'
}

export interface TerragruntPlanExecutionData {
  backendConfig?: TerragruntBackendConfig
  command: 'Apply' | 'Destroy'
  commandFlags?: TerragruntCliOptionFlag[]
  configFiles: TerragruntConfigFilesWrapper
  environmentVariables?: NGVariable[]
  exportTerragruntPlanJson?: boolean
  moduleConfig: TerragruntModuleConfig
  secretManagerRef: string
  targets?: string[]
  varFiles?: TerragruntVarFileWrapper[]
  workspace?: string
}

export type TerragruntPlanStepInfo = StepSpecType & {
  configuration: TerragruntPlanExecutionData
  delegateSelectors?: string[]
  provisionerIdentifier: string
}

export type TerragruntRollbackStepInfo = StepSpecType & {
  commandFlags?: TerragruntCliOptionFlag[]
  delegateSelectors?: string[]
  provisionerIdentifier: string
}

export interface TerragruntStepConfiguration {
  commandFlags?: TerragruntCliOptionFlag[]
  spec?: TerragruntExecutionData
  type: 'Inline' | 'InheritFromPlan' | 'InheritFromApply'
}

export interface TerragruntVarFile {
  identifier: string
  spec: TerragruntVarFileSpec
  type: string
}

export interface TerragruntVarFileSpec {
  type?: string
}

export interface TerragruntVarFileWrapper {
  varFile: TerragruntVarFile
}

export type TestStepInfo = StepSpecType & {
  envs?: {
    [key: string]: string
  }
  image?: string
  language?: ParameterFieldTILanguage
  outputs?: string[]
  privileged?: boolean
  pull?: 'always' | 'never' | 'if-not-exists'
  resources?: ContainerResource
  shell?: 'sh' | 'bash' | 'powershell' | 'pwsh' | 'python'
  splitting?: Splitting
  user?: number
  uses?: 'maven' | 'bazel' | 'gradle' | 'dotnet' | 'nunit_console' | 'sbt' | 'pytest' | 'unittest' | 'rspec'
  version?: string
  with?: {
    [key: string]: JsonNode
  }
}

export interface Throwable {
  cause?: Throwable
  localizedMessage?: string
  message?: string
  stackTrace?: StackTraceElement[]
  suppressed?: Throwable[]
}

export interface TiersDTO {
  unitAmount?: number
  upTo?: number
}

export interface TimeBasedDeploymentInfo {
  epochTime?: number
  failedCount?: number
  failureRate?: number
  successCount?: number
  totalCount?: number
}

export interface TimeUnit {
  numberOfUnits?: number
  unit?:
    | 'NANOS'
    | 'MICROS'
    | 'MILLIS'
    | 'SECONDS'
    | 'MINUTES'
    | 'HOURS'
    | 'HALF_DAYS'
    | 'DAYS'
    | 'WEEKS'
    | 'MONTHS'
    | 'YEARS'
    | 'DECADES'
    | 'CENTURIES'
    | 'MILLENNIA'
    | 'ERAS'
    | 'FOREVER'
}

export interface TimeValuePair {
  timestamp?: number
  value?: { [key: string]: any }
}

export interface TimeValuePairEnvIdCountPair {
  timestamp?: number
  value?: EnvIdCountPair
}

export interface TimeValuePairInteger {
  timestamp?: number
  value?: number
}

export interface TimeValuePairListDTO {
  timeValuePairList?: TimeValuePairObject[]
}

export interface TimeValuePairListDTOEnvIdCountPair {
  timeValuePairList?: TimeValuePairEnvIdCountPair[]
}

export interface TimeValuePairListDTOInteger {
  timeValuePairList?: TimeValuePairInteger[]
}

export interface TimeValuePairObject {
  timestamp?: number
  value?: { [key: string]: any }
}

export interface TokenAggregateDTO {
  createdAt: number
  expiryAt: number
  lastModifiedAt: number
  token: TokenDTO
}

export interface TokenDTO {
  accountIdentifier: string
  apiKeyIdentifier: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  description?: string
  email?: string
  encodedPassword?: string
  identifier: string
  name: string
  orgIdentifier?: string
  parentIdentifier: string
  projectIdentifier?: string
  scheduledExpireTime?: number
  tags?: {
    [key: string]: string
  }
  username?: string
  valid?: boolean
  validFrom?: number
  validTo?: number
}

export interface Toleration {
  effect?: string
  key?: string
  operator?: string
  tolerationSeconds?: number
  value?: string
}

export interface TotalDeploymentInfo {
  count?: number
  countList?: DeploymentDateAndCount[]
  nonProduction?: number
  production?: number
  rate?: number
}

export interface TotalDeploymentInfoV2 {
  count?: number
  countList?: DeploymentDateAndCount[]
  nonProduction?: number
  production?: number
  rate?: ChangeRate
}

export interface TrialSignupOptions {
  assistedOption?: boolean
  productsSelected?: ('CD' | 'CE' | 'CI')[]
}

export interface TriggerFullSyncResponseDTO {
  isFullSyncTriggered?: boolean
}

export type TriggerReference = EntityReference & {
  isDefault?: boolean
  pipelineIdentifier?: string
}

export interface TwoFactorAdminOverrideSettings {
  adminOverrideTwoFactorEnabled?: boolean
}

export interface TwoFactorAuthSettingsInfo {
  email?: string
  mechanism?: 'TOTP'
  totpSecretKey?: string
  totpqrurl?: string
  twoFactorAuthenticationEnabled?: boolean
  userId?: string
}

export interface TypeInfo {
  typeName?: string
  typeNamespace?: string
}

export interface UnitTestReport {
  spec?: UnitTestReportSpec
  type?: 'JUnit'
}

export interface UnitTestReportSpec {
  [key: string]: any
}

export type UpdateGitOpsAppStepInfo = StepSpecType & {
  agentId: string
  applicationName: string
  helm?: HelmValues
  kustomize?: KustomizeValues
  targetRevision?: string
}

export type UpdateReleaseRepoStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  prTitle?: string
  stringMap?: ParameterFieldMapStringString
  variables?: NGVariable[]
}

export type UploadToArtifactoryStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  connectorRef: string
  resources?: ContainerResource
  runAsUser?: number
  sourcePath: string
  target: string
  version?: string
}

export type UploadToGCSStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  resources?: ContainerResource
  runAsUser?: number
  sourcePath: string
  target?: string
  version?: string
}

export type UploadToS3StepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  endpoint?: string
  region: string
  resources?: ContainerResource
  runAsUser?: number
  sourcePath: string
  stripPrefix?: string
  target?: string
  version?: string
}

export interface UsageDataDTO {
  count?: number
  displayName?: string
  references?: ReferenceDTO[]
}

export interface User {
  accountIds?: string[]
  accountName?: string
  accounts?: Account[]
  appId: string
  companyName?: string
  createdAt?: number
  createdBy?: EmbeddedUser
  defaultAccountId?: string
  disabled?: boolean
  email?: string
  emailVerified?: boolean
  externalUserId?: string
  familyName?: string
  firstLogin?: boolean
  givenName?: string
  imported?: boolean
  lastAccountId?: string
  lastAppId?: string
  lastLogin?: number
  lastUpdatedAt: number
  lastUpdatedBy?: EmbeddedUser
  name?: string
  oauthProvider?: string
  password?: string[]
  passwordExpired?: boolean
  pendingAccounts?: Account[]
  rateLimitProtection?: RateLimitProtection
  reportedSegmentTracks?: string[]
  statsFetchedOn?: number
  supportAccounts?: Account[]
  token?: string
  twoFactorAuthenticationEnabled?: boolean
  twoFactorAuthenticationMechanism?: 'TOTP'
  twoFactorJwtToken?: string
  userAccountLevelDataMap?: {
    [key: string]: UserAccountLevelData
  }
  userGroups?: UserGroup[]
  userLocked?: boolean
  userLockoutInfo?: UserLockoutInfo
  utmInfo?: UtmInfo
  uuid: string
}

export interface UserAccountLevelData {
  sourceOfProvisioning?: {
    [key: string]: 'MANUAL' | 'LDAP' | 'SCIM' | 'JIT'
  }
  userProvisionedTo?: ('CG' | 'NG')[]
}

export interface UserAggregate {
  roleAssignmentMetadata: RoleAssignmentMetadataDTO[]
  user: UserMetadataDTO
}

export interface UserDataConfiguration {
  metadata?: string
  store: StoreConfigWrapper
}

export interface UserDetailsDTO {
  userEmail?: string
}

export interface UserFilter {
  emails?: string[]
  identifiers?: string[]
  parentFilter?: 'NO_PARENT_SCOPES' | 'INCLUDE_PARENT_SCOPES' | 'STRICTLY_PARENT_SCOPES'
  searchTerm?: string
}

export interface UserGroup {
  accountIdentifier: string
  createdAt?: number
  deleted?: boolean
  description: string
  externallyManaged?: boolean
  harnessManaged?: boolean
  id?: string
  identifier?: string
  isSsoLinked?: boolean
  lastModifiedAt?: number
  linkedSsoDisplayName?: string
  linkedSsoId?: string
  linkedSsoType?: 'SAML' | 'LDAP' | 'OAUTH'
  name?: string
  notificationConfigs: NotificationSettingConfig[]
  orgIdentifier?: string
  projectIdentifier?: string
  ssoGroupId?: string
  ssoGroupName?: string
  tags: NGTag[]
  users: string[]
  version?: number
}

export interface UserGroupAggregateDTO {
  lastModifiedAt?: number
  roleAssignmentsMetadataDTO?: RoleAssignmentMetadataDTO[]
  userGroupDTO: UserGroupDTO
  users?: UserMetadataDTO[]
}

export interface UserGroupAggregateFilter {
  scopeFilter?: ScopeSelector[]
}

export interface UserGroupDTO {
  accountIdentifier?: string
  description?: string
  externallyManaged?: boolean
  harnessManaged?: boolean
  identifier: string
  linkedSsoDisplayName?: string
  linkedSsoId?: string
  linkedSsoType?: string
  name: string
  notificationConfigs?: NotificationSettingConfigDTO[]
  orgIdentifier?: string
  projectIdentifier?: string
  ssoGroupId?: string
  ssoGroupName?: string
  ssoLinked?: boolean
  tags?: {
    [key: string]: string
  }
  users?: string[]
}

export interface UserGroupEntityReference {
  accountId?: string
  appId?: string
  entityType?: string
  id?: string
}

export interface UserGroupFilterDTO {
  accountIdentifier?: string
  databaseIdFilter?: string[]
  filterType?: 'INCLUDE_INHERITED_GROUPS' | 'EXCLUDE_INHERITED_GROUPS' | 'INCLUDE_CHILD_SCOPE_GROUPS'
  identifierFilter?: string[]
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  userIdentifierFilter?: string[]
}

export interface UserGroupRequestV2DTO {
  accountIdentifier?: string
  description?: string
  externallyManaged?: boolean
  harnessManaged?: boolean
  identifier: string
  linkedSsoDisplayName?: string
  linkedSsoId?: string
  linkedSsoType?: string
  name: string
  notificationConfigs?: NotificationSettingConfigDTO[]
  orgIdentifier?: string
  projectIdentifier?: string
  ssoGroupId?: string
  ssoGroupName?: string
  ssoLinked?: boolean
  tags?: {
    [key: string]: string
  }
  users?: string[]
}

export interface UserGroupResponseV2DTO {
  accountIdentifier?: string
  description?: string
  externallyManaged?: boolean
  harnessManaged?: boolean
  identifier: string
  linkedSsoDisplayName?: string
  linkedSsoId?: string
  linkedSsoType?: string
  name: string
  notificationConfigs?: NotificationSettingConfigDTO[]
  orgIdentifier?: string
  projectIdentifier?: string
  ssoGroupId?: string
  ssoGroupName?: string
  ssoLinked?: boolean
  tags?: {
    [key: string]: string
  }
  users?: UserInfo[]
}

export interface UserInfo {
  accounts?: GatewayAccountRequestDTO[]
  admin?: boolean
  billingFrequency?: string
  createdAt?: number
  defaultAccountId?: string
  disabled?: boolean
  edition?: string
  email?: string
  emailVerified?: boolean
  externalId?: string
  externallyManaged?: boolean
  familyName?: string
  givenName?: string
  intent?: string
  lastUpdatedAt?: number
  locked?: boolean
  name?: string
  signupAction?: string
  token?: string
  twoFactorAuthenticationEnabled?: boolean
  utmInfo?: UtmInfo
  uuid: string
}

export interface UserInfoUpdateDTO {
  email?: string
  familyName?: string
  givenName?: string
  name?: string
}

export interface UserLockoutInfo {
  numberOfFailedLoginAttempts?: number
  userLockedAt?: number
}

export interface UserLockoutPolicy {
  enableLockoutPolicy?: boolean
  lockOutPeriod?: number
  notifyUser?: boolean
  numberOfFailedAttemptsBeforeLockout?: number
  userGroupsToNotify?: UserGroup[]
}

export interface UserMetadata {
  createdAt?: number
  disabled?: boolean
  email?: string
  externallyManaged?: boolean
  lastModifiedAt?: number
  locked?: boolean
  name?: string
  twoFactorAuthenticationEnabled?: boolean
  userId?: string
  version?: number
}

export interface UserMetadataDTO {
  disabled?: boolean
  email: string
  externallyManaged?: boolean
  locked?: boolean
  name?: string
  twoFactorAuthenticationEnabled?: boolean
  uuid: string
}

export type UserPrincipal = Principal & {
  accountId?: string
  email?: string
  username?: string
}

export interface UserRepoResponse {
  name?: string
  namespace?: string
}

export interface UserSourceCodeManagerAuthentication {
  [key: string]: any
}

export interface UserSourceCodeManagerRequestDTO {
  accountIdentifier?: string
  authentication?: UserSourceCodeManagerAuthentication
  type?: 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'AWS_CODE_COMMIT' | 'AZURE_REPO'
  userIdentifier?: string
}

export interface UserSourceCodeManagerResponseDTO {
  accountIdentifier?: string
  type?: 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'AWS_CODE_COMMIT' | 'AZURE_REPO'
  userEmail?: string
  userIdentifier?: string
  userName?: string
}

export interface UserSourceCodeManagerResponseDTOList {
  userSourceCodeManagerResponseDTOList?: UserSourceCodeManagerResponseDTO[]
}

export type UsernamePasswordSettings = NGAuthSettings & {
  loginSettings: LoginSettings
}

export interface UtmInfo {
  utmCampaign?: string
  utmContent?: string
  utmMedium?: string
  utmSource?: string
  utmTerm?: string
}

export type ValidateTemplateInputsResponseDTO = ErrorMetadataDTO & {
  errorNodeSummary?: ErrorNodeSummary
  validYaml?: boolean
}

export interface ValidationError {
  error?: string
  fieldId?: string
}

export interface ValidationResultDTO {
  errorMessage?: string
  valid?: boolean
}

export type ValuesManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export interface VariableConfigDTO {
  value?: { [key: string]: any }
  valueType: 'FIXED' | 'FIXED_SET' | 'REGEX'
}

export interface VariableDTO {
  description?: string
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  spec: VariableConfigDTO
  type: 'String'
}

export interface VariableRequestDTO {
  variable?: VariableDTO
}

export interface VariableResponseDTO {
  createdAt?: number
  lastModifiedAt?: number
  variable: VariableDTO
}

export type VarsManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export type VaultAgentCredentialDTO = VaultCredentialDTO & {
  sinkPath?: string
}

export type VaultAppRoleCredentialDTO = VaultCredentialDTO & {
  appRoleId?: string
  secretId?: string
}

export type VaultAuthTokenCredentialDTO = VaultCredentialDTO & {
  authToken?: string
}

export type VaultAwsIamRoleCredentialDTO = VaultCredentialDTO & {
  awsRegion?: string
  vaultAwsIamRole?: string
  xvaultAwsIamServerId?: SecretRefData
}

export type VaultConnectorDTO = ConnectorConfigDTO & {
  accessType?: 'APP_ROLE' | 'TOKEN' | 'VAULT_AGENT' | 'AWS_IAM' | 'K8s_AUTH'
  appRoleId?: string
  authToken?: string
  awsRegion?: string
  basePath?: string
  default?: boolean
  delegateSelectors?: string[]
  enableCache?: boolean
  k8sAuthEndpoint?: string
  namespace?: string
  readOnly?: boolean
  renewAppRoleToken?: boolean
  renewalIntervalMinutes: number
  secretEngineManuallyConfigured?: boolean
  secretEngineName?: string
  secretEngineVersion?: number
  secretId?: string
  serviceAccountTokenPath?: string
  sinkPath?: string
  useAwsIam?: boolean
  useK8sAuth?: boolean
  useVaultAgent?: boolean
  vaultAwsIamRole?: string
  vaultK8sAuthRole?: string
  vaultUrl: string
  xvaultAwsIamServerId?: string
}

export interface VaultCredentialDTO {
  [key: string]: any
}

export type VaultK8sCredentialDTO = VaultCredentialDTO & {
  k8sAuthEndpoint?: string
  serviceAccountTokenPath?: string
  vaultK8sAuthRole?: string
}

export type VaultMetadataRequestSpecDTO = SecretManagerMetadataRequestSpecDTO & {
  accessType: 'APP_ROLE' | 'TOKEN' | 'VAULT_AGENT' | 'AWS_IAM' | 'K8s_AUTH'
  delegateSelectors?: string[]
  namespace?: string
  spec?: VaultCredentialDTO
  url: string
}

export type VaultMetadataSpecDTO = SecretManagerMetadataSpecDTO & {
  secretEngines?: VaultSecretEngineDTO[]
}

export interface VaultSecretEngineDTO {
  description?: string
  name?: string
  type?: string
  version?: number
}

export interface VerifyTokenResponseDTO {
  accountIdentifier?: string
}

export interface Void {
  [key: string]: any
}

export type WebhookConfig = NotificationSettingConfig & {
  webhookUrl?: string
}

export interface WinRmAuthDTO {
  spec: BaseWinRmSpecDTO
  type: 'NTLM' | 'Kerberos'
}

export interface WinRmCommandParameter {
  parameter?: string
  value?: string
}

export type WinRmCredentialsSpecDTO = SecretSpecDTO & {
  auth: WinRmAuthDTO
  parameters?: WinRmCommandParameter[]
  port?: number
}

export type WinRmCredentialsValidationMetadata = SecretValidationMetaData & {
  host: string
}

export type WinRmServiceSpec = ServiceSpec & {
  artifactOverrideSets?: ArtifactOverrideSetWrapper[]
  configFileOverrideSets?: ConfigFileOverrideSetWrapper[]
  manifestOverrideSets?: ManifestOverrideSetWrapper[]
  variableOverrideSets?: NGVariableOverrideSetWrapper[]
}

export type WinrmDeploymentMetaData = DeploymentMetaData & { [key: string]: any }

export type WorkflowFilter = Filter & {
  filterTypes?: string[]
}

export interface WorkloadCountInfo {
  count?: number
}

export interface WorkloadDateCountInfo {
  date?: number
  execution?: WorkloadCountInfo
}

export interface WorkloadDeploymentInfo {
  deploymentTypeList?: string[]
  failureRate?: number
  failureRateChangeRate?: number
  frequency?: number
  frequencyChangeRate?: number
  lastExecuted?: LastWorkloadInfo
  lastPipelineExecutionId?: string
  percentSuccess?: number
  rateSuccess?: number
  serviceId?: string
  serviceName?: string
  totalDeploymentChangeRate?: number
  totalDeployments?: number
  workload?: WorkloadDateCountInfo[]
}

export interface WorkloadDeploymentInfoV2 {
  deploymentTypeList?: string[]
  failureRate?: number
  failureRateChangeRate?: ChangeRate
  frequency?: number
  frequencyChangeRate?: ChangeRate
  lastExecuted?: LastWorkloadInfo
  lastPipelineExecutionId?: string
  percentSuccess?: number
  rateSuccess?: ChangeRate
  serviceId?: string
  serviceName?: string
  totalDeploymentChangeRate?: ChangeRate
  totalDeployments?: number
  workload?: WorkloadDateCountInfo[]
}

export interface WorkspaceDTO {
  workspaceId: string
  workspaceName: string
}

export interface WorkspacesDTO {
  workspaces?: WorkspaceDTO[]
}

export interface YamlGroup {
  group?: string
}

export interface YamlSchemaDetailsWrapper {
  yamlSchemaWithDetailsList?: YamlSchemaWithDetails[]
}

export interface YamlSchemaErrorDTO {
  fqn?: string
  hintMessage?: string
  message?: string
  messageWithFQN?: string
  stageInfo?: NodeErrorInfo
  stepInfo?: NodeErrorInfo
}

export type YamlSchemaErrorWrapperDTO = ErrorMetadataDTO & {
  schemaErrors?: YamlSchemaErrorDTO[]
}

export interface YamlSchemaMetadata {
  featureFlags?: string[]
  featureRestrictions?: string[]
  modulesSupported?: (
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  )[]
  namespace?: string
  yamlGroup: YamlGroup
}

export interface YamlSchemaWithDetails {
  availableAtAccountLevel?: boolean
  availableAtOrgLevel?: boolean
  availableAtProjectLevel?: boolean
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  schema?: JsonNode
  schemaClassName?: string
  yamlSchemaMetadata?: YamlSchemaMetadata
}

export interface YamlSnippetMetaData {
  description?: string
  iconTag?: string
  identifier?: string
  name?: string
  tags?: string[]
  version?: string
}

export interface YamlSnippets {
  yamlSnippets?: YamlSnippetMetaData[]
}

export type AccountDTORequestBody = AccountDTO

export type AccountSettingsRequestBody = AccountSettings

export type AcrRequestDTORequestBody = AcrRequestDTO

export type ApiKeyDTORequestBody = ApiKeyDTO

export type ArtifactoryRequestDTORequestBody = ArtifactoryRequestDTO

export type CFParametersForAwsBodyRequestBody = string

export type ClusterBatchRequestRequestBody = ClusterBatchRequest

export type ConnectorRequestBody = Connector

export type ConnectorFilterPropertiesRequestBody = ConnectorFilterProperties

export type CreditDTORequestBody = CreditDTO

export type CustomDeploymentYamlRequestRequestBody = CustomDeploymentYamlRequest

export type CustomerDTORequestBody = CustomerDTO

export type DelegateDownloadRequestRequestBody = DelegateDownloadRequest

export type DelegateGroupTagsRequestBody = DelegateGroupTags

export type DelegateProfileDetailsNgRequestBody = DelegateProfileDetailsNg

export type DelegateResponseDataRequestBody = DelegateResponseData

export type DockerRequestDTORequestBody = DockerRequestDTO

export type EOLBannerRequestDTORequestBody = EOLBannerRequestDTO

export type EcrRequestDTORequestBody = EcrRequestDTO

export type EnvironmentFilterPropertiesRequestBody = EnvironmentFilterProperties

export type EnvironmentGroupRequestDTORequestBody = EnvironmentGroupRequestDTO

export type EnvironmentRequestDTORequestBody = EnvironmentRequestDTO

export type FileStoreRequestRequestBody = void

export type FilterDTORequestBody = FilterDTO

export type GarRequestDTORequestBody = GarRequestDTO

export type GcrRequestDTORequestBody = GcrRequestDTO

export type GitFullSyncConfigRequestDTORequestBody = GitFullSyncConfigRequestDTO

export type GitOpsInstanceRequestArrayRequestBody = GitOpsInstanceRequest[]

export type GitOpsProviderRequestBody = GitOpsProvider

export type GitSyncConfigRequestBody = GitSyncConfig

export type GitSyncSettingsDTORequestBody = GitSyncSettingsDTO

export type HostValidationParamsRequestBody = HostValidationParams

export type InfrastructureRequestDTORequestBody = InfrastructureRequestDTO

export type LDAPSettingsRequestBody = LDAPSettings

export type LandingDashboardRequestCDRequestBody = LandingDashboardRequestCD

export type LdapSettingsRequestBody = LdapSettings

export type NexusRequestDTORequestBody = NexusRequestDTO

export type NgManagerRefreshRequestDTORequestBody = NgManagerRefreshRequestDTO

export type NgSmtpDTORequestBody = NgSmtpDTO

export type OrganizationRequestRequestBody = OrganizationRequest

export type PatchRequestRequestBody = PatchRequest

export type PostProdRollbackRequestDTORequestBody = PostProdRollbackRequestDTO

export type ProjectRequestRequestBody = ProjectRequest

export type RoleAssignmentFilterRequestBody = RoleAssignmentFilter

export type ScimGroupRequestBody = ScimGroup

export type ScimUserRequestBody = ScimUser

export type ScopingRuleDetailsNgArrayRequestBody = ScopingRuleDetailsNg[]

export type SecretRequestWrapperRequestBody = void

export type ServiceAccountDTORequestBody = ServiceAccountDTO

export type ServiceOverrideRequestDTOV2RequestBody = ServiceOverrideRequestDTOV2

export type ServiceRequestDTORequestBody = ServiceRequestDTO

export type ServiceRequestDTOArrayRequestBody = ServiceRequestDTO[]

export type SignupDTORequestBody = SignupDTO

export type SourceCodeManagerDTORequestBody = SourceCodeManagerDTO

export type StartTrialDTORequestBody = StartTrialDTO

export type SubscriptionDTORequestBody = SubscriptionDTO

export type TokenDTORequestBody = TokenDTO

export type UserFilterRequestBody = UserFilter

export type UserGroupDTORequestBody = UserGroupDTO

export type UserGroupFilterDTORequestBody = UserGroupFilterDTO

export type UserGroupRequestV2DTORequestBody = UserGroupRequestV2DTO

export type UserSourceCodeManagerRequestDTORequestBody = UserSourceCodeManagerRequestDTO

export type VariableRequestDTORequestBody = VariableRequestDTO

export type YamlSchemaDetailsWrapperRequestBody = YamlSchemaDetailsWrapper

export type DeleteManyFreezesBodyRequestBody = string[]

export type GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody = string

export type ListTagsForAMIArtifactBodyRequestBody = string

export type UpdateHarnessSupportAccessNGBodyRequestBody = boolean

export type UpdateSamlMetaDataForSamlSSOIdRequestBody = void

export type UpdateWhitelistedDomainsBodyRequestBody = string[]

export interface GetAccountSettingQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type: 'Connector'
}

export type GetAccountSettingProps = Omit<
  GetProps<ResponseAccountSettingResponse, Failure | Error, GetAccountSettingQueryParams, void>,
  'path'
>

/**
 * Gets account setting
 */
export const GetAccountSetting = (props: GetAccountSettingProps) => (
  <Get<ResponseAccountSettingResponse, Failure | Error, GetAccountSettingQueryParams, void>
    path={`/account-setting`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAccountSettingProps = Omit<
  UseGetProps<ResponseAccountSettingResponse, Failure | Error, GetAccountSettingQueryParams, void>,
  'path'
>

/**
 * Gets account setting
 */
export const useGetAccountSetting = (props: UseGetAccountSettingProps) =>
  useGet<ResponseAccountSettingResponse, Failure | Error, GetAccountSettingQueryParams, void>(`/account-setting`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets account setting
 */
export const getAccountSettingPromise = (
  props: GetUsingFetchProps<ResponseAccountSettingResponse, Failure | Error, GetAccountSettingQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAccountSettingResponse, Failure | Error, GetAccountSettingQueryParams, void>(
    getConfig('ng/api'),
    `/account-setting`,
    props,
    signal
  )

export interface CreateAccountSettingQueryParams {
  accountIdentifier: string
}

export type CreateAccountSettingProps = Omit<
  MutateProps<
    ResponseAccountSettingResponse,
    Failure | Error,
    CreateAccountSettingQueryParams,
    AccountSettingsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a account setting
 */
export const CreateAccountSetting = (props: CreateAccountSettingProps) => (
  <Mutate<
    ResponseAccountSettingResponse,
    Failure | Error,
    CreateAccountSettingQueryParams,
    AccountSettingsRequestBody,
    void
  >
    verb="POST"
    path={`/account-setting`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateAccountSettingProps = Omit<
  UseMutateProps<
    ResponseAccountSettingResponse,
    Failure | Error,
    CreateAccountSettingQueryParams,
    AccountSettingsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a account setting
 */
export const useCreateAccountSetting = (props: UseCreateAccountSettingProps) =>
  useMutate<
    ResponseAccountSettingResponse,
    Failure | Error,
    CreateAccountSettingQueryParams,
    AccountSettingsRequestBody,
    void
  >('POST', `/account-setting`, { base: getConfig('ng/api'), ...props })

/**
 * Create a account setting
 */
export const createAccountSettingPromise = (
  props: MutateUsingFetchProps<
    ResponseAccountSettingResponse,
    Failure | Error,
    CreateAccountSettingQueryParams,
    AccountSettingsRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseAccountSettingResponse,
    Failure | Error,
    CreateAccountSettingQueryParams,
    AccountSettingsRequestBody,
    void
  >('POST', getConfig('ng/api'), `/account-setting`, props, signal)

export interface UpdateAccountSettingQueryParams {
  accountIdentifier: string
}

export type UpdateAccountSettingProps = Omit<
  MutateProps<
    ResponseAccountSettingResponse,
    Failure | Error,
    UpdateAccountSettingQueryParams,
    AccountSettingsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a account setting
 */
export const UpdateAccountSetting = (props: UpdateAccountSettingProps) => (
  <Mutate<
    ResponseAccountSettingResponse,
    Failure | Error,
    UpdateAccountSettingQueryParams,
    AccountSettingsRequestBody,
    void
  >
    verb="PUT"
    path={`/account-setting`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateAccountSettingProps = Omit<
  UseMutateProps<
    ResponseAccountSettingResponse,
    Failure | Error,
    UpdateAccountSettingQueryParams,
    AccountSettingsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a account setting
 */
export const useUpdateAccountSetting = (props: UseUpdateAccountSettingProps) =>
  useMutate<
    ResponseAccountSettingResponse,
    Failure | Error,
    UpdateAccountSettingQueryParams,
    AccountSettingsRequestBody,
    void
  >('PUT', `/account-setting`, { base: getConfig('ng/api'), ...props })

/**
 * Update a account setting
 */
export const updateAccountSettingPromise = (
  props: MutateUsingFetchProps<
    ResponseAccountSettingResponse,
    Failure | Error,
    UpdateAccountSettingQueryParams,
    AccountSettingsRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseAccountSettingResponse,
    Failure | Error,
    UpdateAccountSettingQueryParams,
    AccountSettingsRequestBody,
    void
  >('PUT', getConfig('ng/api'), `/account-setting`, props, signal)

export interface ListAccountSettingQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type?: 'Connector'
}

export type ListAccountSettingProps = Omit<
  GetProps<ResponseListAccountSettings, Failure | Error, ListAccountSettingQueryParams, void>,
  'path'
>

/**
 * List account setting
 */
export const ListAccountSetting = (props: ListAccountSettingProps) => (
  <Get<ResponseListAccountSettings, Failure | Error, ListAccountSettingQueryParams, void>
    path={`/account-setting/list`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListAccountSettingProps = Omit<
  UseGetProps<ResponseListAccountSettings, Failure | Error, ListAccountSettingQueryParams, void>,
  'path'
>

/**
 * List account setting
 */
export const useListAccountSetting = (props: UseListAccountSettingProps) =>
  useGet<ResponseListAccountSettings, Failure | Error, ListAccountSettingQueryParams, void>(`/account-setting/list`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * List account setting
 */
export const listAccountSettingPromise = (
  props: GetUsingFetchProps<ResponseListAccountSettings, Failure | Error, ListAccountSettingQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListAccountSettings, Failure | Error, ListAccountSettingQueryParams, void>(
    getConfig('ng/api'),
    `/account-setting/list`,
    props,
    signal
  )

export interface GetAccountNGPathParams {
  accountIdentifier: string
}

export type GetAccountNGProps = Omit<
  GetProps<ResponseAccountDTO, Failure | Error, void, GetAccountNGPathParams>,
  'path'
> &
  GetAccountNGPathParams

/**
 * Get Account
 */
export const GetAccountNG = ({ accountIdentifier, ...props }: GetAccountNGProps) => (
  <Get<ResponseAccountDTO, Failure | Error, void, GetAccountNGPathParams>
    path={`/accounts/${accountIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAccountNGProps = Omit<
  UseGetProps<ResponseAccountDTO, Failure | Error, void, GetAccountNGPathParams>,
  'path'
> &
  GetAccountNGPathParams

/**
 * Get Account
 */
export const useGetAccountNG = ({ accountIdentifier, ...props }: UseGetAccountNGProps) =>
  useGet<ResponseAccountDTO, Failure | Error, void, GetAccountNGPathParams>(
    (paramsInPath: GetAccountNGPathParams) => `/accounts/${paramsInPath.accountIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Get Account
 */
export const getAccountNGPromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseAccountDTO, Failure | Error, void, GetAccountNGPathParams> & {
    accountIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAccountDTO, Failure | Error, void, GetAccountNGPathParams>(
    getConfig('ng/api'),
    `/accounts/${accountIdentifier}`,
    props,
    signal
  )

export interface UpdateAccountCrossGenerationAccessEnabledNGPathParams {
  accountIdentifier: string
}

export type UpdateAccountCrossGenerationAccessEnabledNGProps = Omit<
  MutateProps<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountCrossGenerationAccessEnabledNGPathParams
  >,
  'path' | 'verb'
> &
  UpdateAccountCrossGenerationAccessEnabledNGPathParams

/**
 * Update Cross Generation Access Enabled
 */
export const UpdateAccountCrossGenerationAccessEnabledNG = ({
  accountIdentifier,
  ...props
}: UpdateAccountCrossGenerationAccessEnabledNGProps) => (
  <Mutate<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountCrossGenerationAccessEnabledNGPathParams
  >
    verb="PUT"
    path={`/accounts/${accountIdentifier}/cross-generation-access`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateAccountCrossGenerationAccessEnabledNGProps = Omit<
  UseMutateProps<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountCrossGenerationAccessEnabledNGPathParams
  >,
  'path' | 'verb'
> &
  UpdateAccountCrossGenerationAccessEnabledNGPathParams

/**
 * Update Cross Generation Access Enabled
 */
export const useUpdateAccountCrossGenerationAccessEnabledNG = ({
  accountIdentifier,
  ...props
}: UseUpdateAccountCrossGenerationAccessEnabledNGProps) =>
  useMutate<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountCrossGenerationAccessEnabledNGPathParams
  >(
    'PUT',
    (paramsInPath: UpdateAccountCrossGenerationAccessEnabledNGPathParams) =>
      `/accounts/${paramsInPath.accountIdentifier}/cross-generation-access`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Update Cross Generation Access Enabled
 */
export const updateAccountCrossGenerationAccessEnabledNGPromise = (
  {
    accountIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountCrossGenerationAccessEnabledNGPathParams
  > & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountCrossGenerationAccessEnabledNGPathParams
  >('PUT', getConfig('ng/api'), `/accounts/${accountIdentifier}/cross-generation-access`, props, signal)

export interface UpdateAccountDefaultExperienceNGPathParams {
  accountIdentifier: string
}

export type UpdateAccountDefaultExperienceNGProps = Omit<
  MutateProps<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountDefaultExperienceNGPathParams
  >,
  'path' | 'verb'
> &
  UpdateAccountDefaultExperienceNGPathParams

/**
 * Update Default Experience
 */
export const UpdateAccountDefaultExperienceNG = ({
  accountIdentifier,
  ...props
}: UpdateAccountDefaultExperienceNGProps) => (
  <Mutate<ResponseAccountDTO, Failure | Error, void, AccountDTORequestBody, UpdateAccountDefaultExperienceNGPathParams>
    verb="PUT"
    path={`/accounts/${accountIdentifier}/default-experience`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateAccountDefaultExperienceNGProps = Omit<
  UseMutateProps<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountDefaultExperienceNGPathParams
  >,
  'path' | 'verb'
> &
  UpdateAccountDefaultExperienceNGPathParams

/**
 * Update Default Experience
 */
export const useUpdateAccountDefaultExperienceNG = ({
  accountIdentifier,
  ...props
}: UseUpdateAccountDefaultExperienceNGProps) =>
  useMutate<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountDefaultExperienceNGPathParams
  >(
    'PUT',
    (paramsInPath: UpdateAccountDefaultExperienceNGPathParams) =>
      `/accounts/${paramsInPath.accountIdentifier}/default-experience`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Update Default Experience
 */
export const updateAccountDefaultExperienceNGPromise = (
  {
    accountIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountDefaultExperienceNGPathParams
  > & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountDefaultExperienceNGPathParams
  >('PUT', getConfig('ng/api'), `/accounts/${accountIdentifier}/default-experience`, props, signal)

export interface UpdateHarnessSupportAccessNGPathParams {
  accountIdentifier: string
}

export type UpdateHarnessSupportAccessNGProps = Omit<
  MutateProps<
    RestResponseBoolean,
    Failure | Error,
    void,
    UpdateHarnessSupportAccessNGBodyRequestBody,
    UpdateHarnessSupportAccessNGPathParams
  >,
  'path' | 'verb'
> &
  UpdateHarnessSupportAccessNGPathParams

/**
 * Enable/Disable Harness Support Access
 */
export const UpdateHarnessSupportAccessNG = ({ accountIdentifier, ...props }: UpdateHarnessSupportAccessNGProps) => (
  <Mutate<
    RestResponseBoolean,
    Failure | Error,
    void,
    UpdateHarnessSupportAccessNGBodyRequestBody,
    UpdateHarnessSupportAccessNGPathParams
  >
    verb="PUT"
    path={`/accounts/${accountIdentifier}/harness-support-access`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateHarnessSupportAccessNGProps = Omit<
  UseMutateProps<
    RestResponseBoolean,
    Failure | Error,
    void,
    UpdateHarnessSupportAccessNGBodyRequestBody,
    UpdateHarnessSupportAccessNGPathParams
  >,
  'path' | 'verb'
> &
  UpdateHarnessSupportAccessNGPathParams

/**
 * Enable/Disable Harness Support Access
 */
export const useUpdateHarnessSupportAccessNG = ({
  accountIdentifier,
  ...props
}: UseUpdateHarnessSupportAccessNGProps) =>
  useMutate<
    RestResponseBoolean,
    Failure | Error,
    void,
    UpdateHarnessSupportAccessNGBodyRequestBody,
    UpdateHarnessSupportAccessNGPathParams
  >(
    'PUT',
    (paramsInPath: UpdateHarnessSupportAccessNGPathParams) =>
      `/accounts/${paramsInPath.accountIdentifier}/harness-support-access`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Enable/Disable Harness Support Access
 */
export const updateHarnessSupportAccessNGPromise = (
  {
    accountIdentifier,
    ...props
  }: MutateUsingFetchProps<
    RestResponseBoolean,
    Failure | Error,
    void,
    UpdateHarnessSupportAccessNGBodyRequestBody,
    UpdateHarnessSupportAccessNGPathParams
  > & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseBoolean,
    Failure | Error,
    void,
    UpdateHarnessSupportAccessNGBodyRequestBody,
    UpdateHarnessSupportAccessNGPathParams
  >('PUT', getConfig('ng/api'), `/accounts/${accountIdentifier}/harness-support-access`, props, signal)

export interface IsImmutableDelegateEnabledPathParams {
  accountIdentifier: string
}

export type IsImmutableDelegateEnabledProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, void, IsImmutableDelegateEnabledPathParams>,
  'path'
> &
  IsImmutableDelegateEnabledPathParams

/**
 * Get Immutable delegate enabled flag
 */
export const IsImmutableDelegateEnabled = ({ accountIdentifier, ...props }: IsImmutableDelegateEnabledProps) => (
  <Get<ResponseBoolean, Failure | Error, void, IsImmutableDelegateEnabledPathParams>
    path={`/accounts/${accountIdentifier}/immutable-delegate-enabled`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseIsImmutableDelegateEnabledProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, void, IsImmutableDelegateEnabledPathParams>,
  'path'
> &
  IsImmutableDelegateEnabledPathParams

/**
 * Get Immutable delegate enabled flag
 */
export const useIsImmutableDelegateEnabled = ({ accountIdentifier, ...props }: UseIsImmutableDelegateEnabledProps) =>
  useGet<ResponseBoolean, Failure | Error, void, IsImmutableDelegateEnabledPathParams>(
    (paramsInPath: IsImmutableDelegateEnabledPathParams) =>
      `/accounts/${paramsInPath.accountIdentifier}/immutable-delegate-enabled`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Get Immutable delegate enabled flag
 */
export const isImmutableDelegateEnabledPromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseBoolean, Failure | Error, void, IsImmutableDelegateEnabledPathParams> & {
    accountIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, void, IsImmutableDelegateEnabledPathParams>(
    getConfig('ng/api'),
    `/accounts/${accountIdentifier}/immutable-delegate-enabled`,
    props,
    signal
  )

export interface UpdateAccountNameNGPathParams {
  accountIdentifier: string
}

export type UpdateAccountNameNGProps = Omit<
  MutateProps<ResponseAccountDTO, Failure | Error, void, AccountDTORequestBody, UpdateAccountNameNGPathParams>,
  'path' | 'verb'
> &
  UpdateAccountNameNGPathParams

/**
 * Update Account Name
 */
export const UpdateAccountNameNG = ({ accountIdentifier, ...props }: UpdateAccountNameNGProps) => (
  <Mutate<ResponseAccountDTO, Failure | Error, void, AccountDTORequestBody, UpdateAccountNameNGPathParams>
    verb="PUT"
    path={`/accounts/${accountIdentifier}/name`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateAccountNameNGProps = Omit<
  UseMutateProps<ResponseAccountDTO, Failure | Error, void, AccountDTORequestBody, UpdateAccountNameNGPathParams>,
  'path' | 'verb'
> &
  UpdateAccountNameNGPathParams

/**
 * Update Account Name
 */
export const useUpdateAccountNameNG = ({ accountIdentifier, ...props }: UseUpdateAccountNameNGProps) =>
  useMutate<ResponseAccountDTO, Failure | Error, void, AccountDTORequestBody, UpdateAccountNameNGPathParams>(
    'PUT',
    (paramsInPath: UpdateAccountNameNGPathParams) => `/accounts/${paramsInPath.accountIdentifier}/name`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Update Account Name
 */
export const updateAccountNameNGPromise = (
  {
    accountIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountNameNGPathParams
  > & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseAccountDTO, Failure | Error, void, AccountDTORequestBody, UpdateAccountNameNGPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/accounts/${accountIdentifier}/name`,
    props,
    signal
  )

export interface ListActivitiesQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  startTime: number
  endTime: number
  status?: 'SUCCESS' | 'FAILED'
  referredEntityType:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  referredByEntityType?: (
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  )[]
  activityTypes?: ('CONNECTIVITY_CHECK' | 'ENTITY_USAGE' | 'ENTITY_CREATION' | 'ENTITY_UPDATE')[]
  searchTerm?: string
  scopeFilter?: ('account' | 'org' | 'project' | 'unknown')[]
}

export type ListActivitiesProps = Omit<GetProps<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>, 'path'>

/**
 * Get Activities where this resource was used
 */
export const ListActivities = (props: ListActivitiesProps) => (
  <Get<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>
    path={`/activityHistory`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListActivitiesProps = Omit<
  UseGetProps<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>,
  'path'
>

/**
 * Get Activities where this resource was used
 */
export const useListActivities = (props: UseListActivitiesProps) =>
  useGet<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>(`/activityHistory`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Activities where this resource was used
 */
export const listActivitiesPromise = (
  props: GetUsingFetchProps<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>(
    getConfig('ng/api'),
    `/activityHistory`,
    props,
    signal
  )

export interface GetConnectivitySummaryQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  startTime: number
  endTime: number
}

export type GetConnectivitySummaryProps = Omit<
  GetProps<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>,
  'path'
>

/**
 * Get ConnectivityCheck Summary
 */
export const GetConnectivitySummary = (props: GetConnectivitySummaryProps) => (
  <Get<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>
    path={`/activityHistory/connectivityCheckSummary`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectivitySummaryProps = Omit<
  UseGetProps<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>,
  'path'
>

/**
 * Get ConnectivityCheck Summary
 */
export const useGetConnectivitySummary = (props: UseGetConnectivitySummaryProps) =>
  useGet<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>(
    `/activityHistory/connectivityCheckSummary`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get ConnectivityCheck Summary
 */
export const getConnectivitySummaryPromise = (
  props: GetUsingFetchProps<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>(
    getConfig('ng/api'),
    `/activityHistory/connectivityCheckSummary`,
    props,
    signal
  )

export interface GetUniqueReferredByEntitiesQueryParams {
  accountIdentifier?: string
  referredEntityType:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  activityTypes?: ('CONNECTIVITY_CHECK' | 'ENTITY_USAGE' | 'ENTITY_CREATION' | 'ENTITY_UPDATE')[]
}

export type GetUniqueReferredByEntitiesProps = Omit<
  GetProps<ResponseNGEntityList, unknown, GetUniqueReferredByEntitiesQueryParams, void>,
  'path'
>

/**
 * Get List Of Referred By Entity Types
 */
export const GetUniqueReferredByEntities = (props: GetUniqueReferredByEntitiesProps) => (
  <Get<ResponseNGEntityList, unknown, GetUniqueReferredByEntitiesQueryParams, void>
    path={`/activityHistory/referred-by-entity-types`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUniqueReferredByEntitiesProps = Omit<
  UseGetProps<ResponseNGEntityList, unknown, GetUniqueReferredByEntitiesQueryParams, void>,
  'path'
>

/**
 * Get List Of Referred By Entity Types
 */
export const useGetUniqueReferredByEntities = (props: UseGetUniqueReferredByEntitiesProps) =>
  useGet<ResponseNGEntityList, unknown, GetUniqueReferredByEntitiesQueryParams, void>(
    `/activityHistory/referred-by-entity-types`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get List Of Referred By Entity Types
 */
export const getUniqueReferredByEntitiesPromise = (
  props: GetUsingFetchProps<ResponseNGEntityList, unknown, GetUniqueReferredByEntitiesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNGEntityList, unknown, GetUniqueReferredByEntitiesQueryParams, void>(
    getConfig('ng/api'),
    `/activityHistory/referred-by-entity-types`,
    props,
    signal
  )

export interface GetActivitiesSummaryQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  startTime: number
  endTime: number
  timeGroupType: 'HOUR' | 'DAY' | 'WEEK'
  referredEntityType:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  referredByEntityType?:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
}

export type GetActivitiesSummaryProps = Omit<
  GetProps<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>,
  'path'
>

/**
 * Get Activities Summary
 */
export const GetActivitiesSummary = (props: GetActivitiesSummaryProps) => (
  <Get<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>
    path={`/activityHistory/summary`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActivitiesSummaryProps = Omit<
  UseGetProps<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>,
  'path'
>

/**
 * Get Activities Summary
 */
export const useGetActivitiesSummary = (props: UseGetActivitiesSummaryProps) =>
  useGet<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>(`/activityHistory/summary`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Activities Summary
 */
export const getActivitiesSummaryPromise = (
  props: GetUsingFetchProps<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>(
    getConfig('ng/api'),
    `/activityHistory/summary`,
    props,
    signal
  )

export interface AdminCreateCreditQueryParams {
  accountIdentifier: string
}

export type AdminCreateCreditProps = Omit<
  MutateProps<ResponseCreditDTO, Failure | Error, AdminCreateCreditQueryParams, CreditDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Admin Level purchase credit for an account
 */
export const AdminCreateCredit = (props: AdminCreateCreditProps) => (
  <Mutate<ResponseCreditDTO, Failure | Error, AdminCreateCreditQueryParams, CreditDTORequestBody, void>
    verb="POST"
    path={`/admin/credits/create`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAdminCreateCreditProps = Omit<
  UseMutateProps<ResponseCreditDTO, Failure | Error, AdminCreateCreditQueryParams, CreditDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Admin Level purchase credit for an account
 */
export const useAdminCreateCredit = (props: UseAdminCreateCreditProps) =>
  useMutate<ResponseCreditDTO, Failure | Error, AdminCreateCreditQueryParams, CreditDTORequestBody, void>(
    'POST',
    `/admin/credits/create`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Admin Level purchase credit for an account
 */
export const adminCreateCreditPromise = (
  props: MutateUsingFetchProps<
    ResponseCreditDTO,
    Failure | Error,
    AdminCreateCreditQueryParams,
    CreditDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseCreditDTO, Failure | Error, AdminCreateCreditQueryParams, CreditDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/admin/credits/create`,
    props,
    signal
  )

export interface AdminGetCreditsByAccountPathParams {
  accountIdentifier: string
}

export type AdminGetCreditsByAccountProps = Omit<
  GetProps<ResponseListCreditDTO, Failure | Error, void, AdminGetCreditsByAccountPathParams>,
  'path'
> &
  AdminGetCreditsByAccountPathParams

/**
 * Admin level get purchase history of credits for an Account in an ascending order of the expiry time
 */
export const AdminGetCreditsByAccount = ({ accountIdentifier, ...props }: AdminGetCreditsByAccountProps) => (
  <Get<ResponseListCreditDTO, Failure | Error, void, AdminGetCreditsByAccountPathParams>
    path={`/admin/credits/${accountIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAdminGetCreditsByAccountProps = Omit<
  UseGetProps<ResponseListCreditDTO, Failure | Error, void, AdminGetCreditsByAccountPathParams>,
  'path'
> &
  AdminGetCreditsByAccountPathParams

/**
 * Admin level get purchase history of credits for an Account in an ascending order of the expiry time
 */
export const useAdminGetCreditsByAccount = ({ accountIdentifier, ...props }: UseAdminGetCreditsByAccountProps) =>
  useGet<ResponseListCreditDTO, Failure | Error, void, AdminGetCreditsByAccountPathParams>(
    (paramsInPath: AdminGetCreditsByAccountPathParams) => `/admin/credits/${paramsInPath.accountIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Admin level get purchase history of credits for an Account in an ascending order of the expiry time
 */
export const adminGetCreditsByAccountPromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseListCreditDTO, Failure | Error, void, AdminGetCreditsByAccountPathParams> & {
    accountIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListCreditDTO, Failure | Error, void, AdminGetCreditsByAccountPathParams>(
    getConfig('ng/api'),
    `/admin/credits/${accountIdentifier}`,
    props,
    signal
  )

export interface AdminUpdatesCustomerCreditPathParams {
  accountIdentifier: string
}

export type AdminUpdatesCustomerCreditProps = Omit<
  MutateProps<ResponseCreditDTO, Failure | Error, void, CreditDTORequestBody, AdminUpdatesCustomerCreditPathParams>,
  'path' | 'verb'
> &
  AdminUpdatesCustomerCreditPathParams

/**
 * Enables Harness Support user to update an existing Credit for a customer account
 */
export const AdminUpdatesCustomerCredit = ({ accountIdentifier, ...props }: AdminUpdatesCustomerCreditProps) => (
  <Mutate<ResponseCreditDTO, Failure | Error, void, CreditDTORequestBody, AdminUpdatesCustomerCreditPathParams>
    verb="PUT"
    path={`/admin/credits/${accountIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAdminUpdatesCustomerCreditProps = Omit<
  UseMutateProps<ResponseCreditDTO, Failure | Error, void, CreditDTORequestBody, AdminUpdatesCustomerCreditPathParams>,
  'path' | 'verb'
> &
  AdminUpdatesCustomerCreditPathParams

/**
 * Enables Harness Support user to update an existing Credit for a customer account
 */
export const useAdminUpdatesCustomerCredit = ({ accountIdentifier, ...props }: UseAdminUpdatesCustomerCreditProps) =>
  useMutate<ResponseCreditDTO, Failure | Error, void, CreditDTORequestBody, AdminUpdatesCustomerCreditPathParams>(
    'PUT',
    (paramsInPath: AdminUpdatesCustomerCreditPathParams) => `/admin/credits/${paramsInPath.accountIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Enables Harness Support user to update an existing Credit for a customer account
 */
export const adminUpdatesCustomerCreditPromise = (
  {
    accountIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseCreditDTO,
    Failure | Error,
    void,
    CreditDTORequestBody,
    AdminUpdatesCustomerCreditPathParams
  > & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseCreditDTO,
    Failure | Error,
    void,
    CreditDTORequestBody,
    AdminUpdatesCustomerCreditPathParams
  >('PUT', getConfig('ng/api'), `/admin/credits/${accountIdentifier}`, props, signal)

export interface AdminDeleteCustomerCreditQueryParams {
  accountIdentifier?: string
}

export type AdminDeleteCustomerCreditProps = Omit<
  MutateProps<ResponseVoid, Failure | Error, AdminDeleteCustomerCreditQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Enables Harness Support User to delete an existing Credit for a customer account
 */
export const AdminDeleteCustomerCredit = (props: AdminDeleteCustomerCreditProps) => (
  <Mutate<ResponseVoid, Failure | Error, AdminDeleteCustomerCreditQueryParams, string, void>
    verb="DELETE"
    path={`/admin/credits`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAdminDeleteCustomerCreditProps = Omit<
  UseMutateProps<ResponseVoid, Failure | Error, AdminDeleteCustomerCreditQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Enables Harness Support User to delete an existing Credit for a customer account
 */
export const useAdminDeleteCustomerCredit = (props: UseAdminDeleteCustomerCreditProps) =>
  useMutate<ResponseVoid, Failure | Error, AdminDeleteCustomerCreditQueryParams, string, void>(
    'DELETE',
    `/admin/credits`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Enables Harness Support User to delete an existing Credit for a customer account
 */
export const adminDeleteCustomerCreditPromise = (
  props: MutateUsingFetchProps<ResponseVoid, Failure | Error, AdminDeleteCustomerCreditQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseVoid, Failure | Error, AdminDeleteCustomerCreditQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/admin/credits`,
    props,
    signal
  )

export interface GetAccountLevelDeveloperMappingPathParams {
  accountIdentifier: string
}

export type GetAccountLevelDeveloperMappingProps = Omit<
  GetProps<ResponseListDeveloperMappingDTO, Failure | Error, void, GetAccountLevelDeveloperMappingPathParams>,
  'path'
> &
  GetAccountLevelDeveloperMappingPathParams

export const GetAccountLevelDeveloperMapping = ({
  accountIdentifier,
  ...props
}: GetAccountLevelDeveloperMappingProps) => (
  <Get<ResponseListDeveloperMappingDTO, Failure | Error, void, GetAccountLevelDeveloperMappingPathParams>
    path={`/admin/developer-license-mapping/${accountIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAccountLevelDeveloperMappingProps = Omit<
  UseGetProps<ResponseListDeveloperMappingDTO, Failure | Error, void, GetAccountLevelDeveloperMappingPathParams>,
  'path'
> &
  GetAccountLevelDeveloperMappingPathParams

export const useGetAccountLevelDeveloperMapping = ({
  accountIdentifier,
  ...props
}: UseGetAccountLevelDeveloperMappingProps) =>
  useGet<ResponseListDeveloperMappingDTO, Failure | Error, void, GetAccountLevelDeveloperMappingPathParams>(
    (paramsInPath: GetAccountLevelDeveloperMappingPathParams) =>
      `/admin/developer-license-mapping/${paramsInPath.accountIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

export const getAccountLevelDeveloperMappingPromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseListDeveloperMappingDTO,
    Failure | Error,
    void,
    GetAccountLevelDeveloperMappingPathParams
  > & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListDeveloperMappingDTO, Failure | Error, void, GetAccountLevelDeveloperMappingPathParams>(
    getConfig('ng/api'),
    `/admin/developer-license-mapping/${accountIdentifier}`,
    props,
    signal
  )

export interface CreateAccountLevelDeveloperMappingPathParams {
  accountIdentifier: string
}

export type CreateAccountLevelDeveloperMappingProps = Omit<
  MutateProps<
    ResponseDeveloperMappingDTO,
    Failure | Error,
    void,
    DeveloperMappingDTO,
    CreateAccountLevelDeveloperMappingPathParams
  >,
  'path' | 'verb'
> &
  CreateAccountLevelDeveloperMappingPathParams

export const CreateAccountLevelDeveloperMapping = ({
  accountIdentifier,
  ...props
}: CreateAccountLevelDeveloperMappingProps) => (
  <Mutate<
    ResponseDeveloperMappingDTO,
    Failure | Error,
    void,
    DeveloperMappingDTO,
    CreateAccountLevelDeveloperMappingPathParams
  >
    verb="POST"
    path={`/admin/developer-license-mapping/${accountIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateAccountLevelDeveloperMappingProps = Omit<
  UseMutateProps<
    ResponseDeveloperMappingDTO,
    Failure | Error,
    void,
    DeveloperMappingDTO,
    CreateAccountLevelDeveloperMappingPathParams
  >,
  'path' | 'verb'
> &
  CreateAccountLevelDeveloperMappingPathParams

export const useCreateAccountLevelDeveloperMapping = ({
  accountIdentifier,
  ...props
}: UseCreateAccountLevelDeveloperMappingProps) =>
  useMutate<
    ResponseDeveloperMappingDTO,
    Failure | Error,
    void,
    DeveloperMappingDTO,
    CreateAccountLevelDeveloperMappingPathParams
  >(
    'POST',
    (paramsInPath: CreateAccountLevelDeveloperMappingPathParams) =>
      `/admin/developer-license-mapping/${paramsInPath.accountIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

export const createAccountLevelDeveloperMappingPromise = (
  {
    accountIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseDeveloperMappingDTO,
    Failure | Error,
    void,
    DeveloperMappingDTO,
    CreateAccountLevelDeveloperMappingPathParams
  > & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDeveloperMappingDTO,
    Failure | Error,
    void,
    DeveloperMappingDTO,
    CreateAccountLevelDeveloperMappingPathParams
  >('POST', getConfig('ng/api'), `/admin/developer-license-mapping/${accountIdentifier}`, props, signal)

export interface CheckAgentMtlsEndpointDomainPrefixAvailabilityQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier: string
  /**
   * The domain prefix to check.
   */
  domainPrefix: string
}

export type CheckAgentMtlsEndpointDomainPrefixAvailabilityProps = Omit<
  GetProps<RestResponseBoolean, unknown, CheckAgentMtlsEndpointDomainPrefixAvailabilityQueryParams, void>,
  'path'
>

/**
 * Checks whether a given agent mTLS endpoint domain prefix is available.
 */
export const CheckAgentMtlsEndpointDomainPrefixAvailability = (
  props: CheckAgentMtlsEndpointDomainPrefixAvailabilityProps
) => (
  <Get<RestResponseBoolean, unknown, CheckAgentMtlsEndpointDomainPrefixAvailabilityQueryParams, void>
    path={`/agent/mtls/check-availability`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCheckAgentMtlsEndpointDomainPrefixAvailabilityProps = Omit<
  UseGetProps<RestResponseBoolean, unknown, CheckAgentMtlsEndpointDomainPrefixAvailabilityQueryParams, void>,
  'path'
>

/**
 * Checks whether a given agent mTLS endpoint domain prefix is available.
 */
export const useCheckAgentMtlsEndpointDomainPrefixAvailability = (
  props: UseCheckAgentMtlsEndpointDomainPrefixAvailabilityProps
) =>
  useGet<RestResponseBoolean, unknown, CheckAgentMtlsEndpointDomainPrefixAvailabilityQueryParams, void>(
    `/agent/mtls/check-availability`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Checks whether a given agent mTLS endpoint domain prefix is available.
 */
export const checkAgentMtlsEndpointDomainPrefixAvailabilityPromise = (
  props: GetUsingFetchProps<
    RestResponseBoolean,
    unknown,
    CheckAgentMtlsEndpointDomainPrefixAvailabilityQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseBoolean, unknown, CheckAgentMtlsEndpointDomainPrefixAvailabilityQueryParams, void>(
    getConfig('ng/api'),
    `/agent/mtls/check-availability`,
    props,
    signal
  )

export interface DeleteAgentMtlsEndpointForAccountQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier: string
}

export type DeleteAgentMtlsEndpointForAccountProps = Omit<
  MutateProps<RestResponseBoolean, unknown, DeleteAgentMtlsEndpointForAccountQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Removes the agent mTLS endpoint for an account.
 */
export const DeleteAgentMtlsEndpointForAccount = (props: DeleteAgentMtlsEndpointForAccountProps) => (
  <Mutate<RestResponseBoolean, unknown, DeleteAgentMtlsEndpointForAccountQueryParams, void, void>
    verb="DELETE"
    path={`/agent/mtls/endpoint`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteAgentMtlsEndpointForAccountProps = Omit<
  UseMutateProps<RestResponseBoolean, unknown, DeleteAgentMtlsEndpointForAccountQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Removes the agent mTLS endpoint for an account.
 */
export const useDeleteAgentMtlsEndpointForAccount = (props: UseDeleteAgentMtlsEndpointForAccountProps) =>
  useMutate<RestResponseBoolean, unknown, DeleteAgentMtlsEndpointForAccountQueryParams, void, void>(
    'DELETE',
    `/agent/mtls/endpoint`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Removes the agent mTLS endpoint for an account.
 */
export const deleteAgentMtlsEndpointForAccountPromise = (
  props: MutateUsingFetchProps<RestResponseBoolean, unknown, DeleteAgentMtlsEndpointForAccountQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseBoolean, unknown, DeleteAgentMtlsEndpointForAccountQueryParams, void, void>(
    'DELETE',
    getConfig('ng/api'),
    `/agent/mtls/endpoint`,
    props,
    signal
  )

export interface GetAgentMtlsEndpointForAccountQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier: string
}

export type GetAgentMtlsEndpointForAccountProps = Omit<
  GetProps<RestResponseAgentMtlsEndpointDetails, unknown, GetAgentMtlsEndpointForAccountQueryParams, void>,
  'path'
>

/**
 * Gets the agent mTLS endpoint for an account.
 */
export const GetAgentMtlsEndpointForAccount = (props: GetAgentMtlsEndpointForAccountProps) => (
  <Get<RestResponseAgentMtlsEndpointDetails, unknown, GetAgentMtlsEndpointForAccountQueryParams, void>
    path={`/agent/mtls/endpoint`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAgentMtlsEndpointForAccountProps = Omit<
  UseGetProps<RestResponseAgentMtlsEndpointDetails, unknown, GetAgentMtlsEndpointForAccountQueryParams, void>,
  'path'
>

/**
 * Gets the agent mTLS endpoint for an account.
 */
export const useGetAgentMtlsEndpointForAccount = (props: UseGetAgentMtlsEndpointForAccountProps) =>
  useGet<RestResponseAgentMtlsEndpointDetails, unknown, GetAgentMtlsEndpointForAccountQueryParams, void>(
    `/agent/mtls/endpoint`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets the agent mTLS endpoint for an account.
 */
export const getAgentMtlsEndpointForAccountPromise = (
  props: GetUsingFetchProps<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    GetAgentMtlsEndpointForAccountQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseAgentMtlsEndpointDetails, unknown, GetAgentMtlsEndpointForAccountQueryParams, void>(
    getConfig('ng/api'),
    `/agent/mtls/endpoint`,
    props,
    signal
  )

export interface PatchAgentMtlsEndpointForAccountQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier: string
}

export type PatchAgentMtlsEndpointForAccountProps = Omit<
  MutateProps<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    PatchAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Updates selected properties of the existing agent mTLS endpoint for an account.
 */
export const PatchAgentMtlsEndpointForAccount = (props: PatchAgentMtlsEndpointForAccountProps) => (
  <Mutate<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    PatchAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >
    verb="PATCH"
    path={`/agent/mtls/endpoint`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePatchAgentMtlsEndpointForAccountProps = Omit<
  UseMutateProps<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    PatchAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Updates selected properties of the existing agent mTLS endpoint for an account.
 */
export const usePatchAgentMtlsEndpointForAccount = (props: UsePatchAgentMtlsEndpointForAccountProps) =>
  useMutate<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    PatchAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >('PATCH', `/agent/mtls/endpoint`, { base: getConfig('ng/api'), ...props })

/**
 * Updates selected properties of the existing agent mTLS endpoint for an account.
 */
export const patchAgentMtlsEndpointForAccountPromise = (
  props: MutateUsingFetchProps<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    PatchAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    PatchAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >('PATCH', getConfig('ng/api'), `/agent/mtls/endpoint`, props, signal)

export interface CreateAgentMtlsEndpointForAccountQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier: string
}

export type CreateAgentMtlsEndpointForAccountProps = Omit<
  MutateProps<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    CreateAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates the agent mTLS endpoint for an account.
 */
export const CreateAgentMtlsEndpointForAccount = (props: CreateAgentMtlsEndpointForAccountProps) => (
  <Mutate<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    CreateAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >
    verb="POST"
    path={`/agent/mtls/endpoint`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateAgentMtlsEndpointForAccountProps = Omit<
  UseMutateProps<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    CreateAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates the agent mTLS endpoint for an account.
 */
export const useCreateAgentMtlsEndpointForAccount = (props: UseCreateAgentMtlsEndpointForAccountProps) =>
  useMutate<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    CreateAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >('POST', `/agent/mtls/endpoint`, { base: getConfig('ng/api'), ...props })

/**
 * Creates the agent mTLS endpoint for an account.
 */
export const createAgentMtlsEndpointForAccountPromise = (
  props: MutateUsingFetchProps<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    CreateAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    CreateAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >('POST', getConfig('ng/api'), `/agent/mtls/endpoint`, props, signal)

export interface UpdateAgentMtlsEndpointForAccountQueryParams {
  /**
   * Account Identifier for the Entity.
   */
  accountIdentifier: string
}

export type UpdateAgentMtlsEndpointForAccountProps = Omit<
  MutateProps<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    UpdateAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Updates the existing agent mTLS endpoint for an account.
 */
export const UpdateAgentMtlsEndpointForAccount = (props: UpdateAgentMtlsEndpointForAccountProps) => (
  <Mutate<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    UpdateAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >
    verb="PUT"
    path={`/agent/mtls/endpoint`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateAgentMtlsEndpointForAccountProps = Omit<
  UseMutateProps<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    UpdateAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Updates the existing agent mTLS endpoint for an account.
 */
export const useUpdateAgentMtlsEndpointForAccount = (props: UseUpdateAgentMtlsEndpointForAccountProps) =>
  useMutate<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    UpdateAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >('PUT', `/agent/mtls/endpoint`, { base: getConfig('ng/api'), ...props })

/**
 * Updates the existing agent mTLS endpoint for an account.
 */
export const updateAgentMtlsEndpointForAccountPromise = (
  props: MutateUsingFetchProps<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    UpdateAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseAgentMtlsEndpointDetails,
    unknown,
    UpdateAgentMtlsEndpointForAccountQueryParams,
    AgentMtlsEndpointRequest,
    void
  >('PUT', getConfig('ng/api'), `/agent/mtls/endpoint`, props, signal)

export interface GetAccountResourcesCountQueryParams {
  accountIdentifier: string
}

export type GetAccountResourcesCountProps = Omit<
  GetProps<ResponseAccountResourcesDTO, Failure | Error, GetAccountResourcesCountQueryParams, void>,
  'path'
>

/**
 * Gets count of account resources
 */
export const GetAccountResourcesCount = (props: GetAccountResourcesCountProps) => (
  <Get<ResponseAccountResourcesDTO, Failure | Error, GetAccountResourcesCountQueryParams, void>
    path={`/aggregate/account-resources`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAccountResourcesCountProps = Omit<
  UseGetProps<ResponseAccountResourcesDTO, Failure | Error, GetAccountResourcesCountQueryParams, void>,
  'path'
>

/**
 * Gets count of account resources
 */
export const useGetAccountResourcesCount = (props: UseGetAccountResourcesCountProps) =>
  useGet<ResponseAccountResourcesDTO, Failure | Error, GetAccountResourcesCountQueryParams, void>(
    `/aggregate/account-resources`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets count of account resources
 */
export const getAccountResourcesCountPromise = (
  props: GetUsingFetchProps<ResponseAccountResourcesDTO, Failure | Error, GetAccountResourcesCountQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAccountResourcesDTO, Failure | Error, GetAccountResourcesCountQueryParams, void>(
    getConfig('ng/api'),
    `/aggregate/account-resources`,
    props,
    signal
  )

export interface GetUserGroupAggregateListByUserQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
  searchTerm?: string
  userSize?: number
}

export interface GetUserGroupAggregateListByUserPathParams {
  userId: string
}

export type GetUserGroupAggregateListByUserProps = Omit<
  MutateProps<
    ResponsePageUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListByUserQueryParams,
    UserGroupAggregateFilter,
    GetUserGroupAggregateListByUserPathParams
  >,
  'path' | 'verb'
> &
  GetUserGroupAggregateListByUserPathParams

/**
 * Get User Groups by User Id
 */
export const GetUserGroupAggregateListByUser = ({ userId, ...props }: GetUserGroupAggregateListByUserProps) => (
  <Mutate<
    ResponsePageUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListByUserQueryParams,
    UserGroupAggregateFilter,
    GetUserGroupAggregateListByUserPathParams
  >
    verb="POST"
    path={`/aggregate/acl/user/${userId}/usergroups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserGroupAggregateListByUserProps = Omit<
  UseMutateProps<
    ResponsePageUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListByUserQueryParams,
    UserGroupAggregateFilter,
    GetUserGroupAggregateListByUserPathParams
  >,
  'path' | 'verb'
> &
  GetUserGroupAggregateListByUserPathParams

/**
 * Get User Groups by User Id
 */
export const useGetUserGroupAggregateListByUser = ({ userId, ...props }: UseGetUserGroupAggregateListByUserProps) =>
  useMutate<
    ResponsePageUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListByUserQueryParams,
    UserGroupAggregateFilter,
    GetUserGroupAggregateListByUserPathParams
  >(
    'POST',
    (paramsInPath: GetUserGroupAggregateListByUserPathParams) =>
      `/aggregate/acl/user/${paramsInPath.userId}/usergroups`,
    { base: getConfig('ng/api'), pathParams: { userId }, ...props }
  )

/**
 * Get User Groups by User Id
 */
export const getUserGroupAggregateListByUserPromise = (
  {
    userId,
    ...props
  }: MutateUsingFetchProps<
    ResponsePageUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListByUserQueryParams,
    UserGroupAggregateFilter,
    GetUserGroupAggregateListByUserPathParams
  > & { userId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListByUserQueryParams,
    UserGroupAggregateFilter,
    GetUserGroupAggregateListByUserPathParams
  >('POST', getConfig('ng/api'), `/aggregate/acl/user/${userId}/usergroups`, props, signal)

export interface GetUserGroupAggregateListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
  searchTerm?: string
  filterType?: 'INCLUDE_INHERITED_GROUPS' | 'EXCLUDE_INHERITED_GROUPS' | 'INCLUDE_CHILD_SCOPE_GROUPS'
  userSize?: number
}

export type GetUserGroupAggregateListProps = Omit<
  GetProps<ResponsePageUserGroupAggregateDTO, Failure | Error, GetUserGroupAggregateListQueryParams, void>,
  'path'
>

/**
 * Get Aggregated User Group list
 */
export const GetUserGroupAggregateList = (props: GetUserGroupAggregateListProps) => (
  <Get<ResponsePageUserGroupAggregateDTO, Failure | Error, GetUserGroupAggregateListQueryParams, void>
    path={`/aggregate/acl/usergroups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserGroupAggregateListProps = Omit<
  UseGetProps<ResponsePageUserGroupAggregateDTO, Failure | Error, GetUserGroupAggregateListQueryParams, void>,
  'path'
>

/**
 * Get Aggregated User Group list
 */
export const useGetUserGroupAggregateList = (props: UseGetUserGroupAggregateListProps) =>
  useGet<ResponsePageUserGroupAggregateDTO, Failure | Error, GetUserGroupAggregateListQueryParams, void>(
    `/aggregate/acl/usergroups`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Aggregated User Group list
 */
export const getUserGroupAggregateListPromise = (
  props: GetUsingFetchProps<
    ResponsePageUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageUserGroupAggregateDTO, Failure | Error, GetUserGroupAggregateListQueryParams, void>(
    getConfig('ng/api'),
    `/aggregate/acl/usergroups`,
    props,
    signal
  )

export interface GetUserGroupAggregateQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  roleAssignmentScopeOrgIdentifier?: string
  roleAssignmentScopeProjectIdentifier?: string
}

export interface GetUserGroupAggregatePathParams {
  identifier: string
}

export type GetUserGroupAggregateProps = Omit<
  GetProps<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  >,
  'path'
> &
  GetUserGroupAggregatePathParams

/**
 * Get Aggregated User Group
 */
export const GetUserGroupAggregate = ({ identifier, ...props }: GetUserGroupAggregateProps) => (
  <Get<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  >
    path={`/aggregate/acl/usergroups/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserGroupAggregateProps = Omit<
  UseGetProps<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  >,
  'path'
> &
  GetUserGroupAggregatePathParams

/**
 * Get Aggregated User Group
 */
export const useGetUserGroupAggregate = ({ identifier, ...props }: UseGetUserGroupAggregateProps) =>
  useGet<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  >((paramsInPath: GetUserGroupAggregatePathParams) => `/aggregate/acl/usergroups/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Get Aggregated User Group
 */
export const getUserGroupAggregatePromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  >(getConfig('ng/api'), `/aggregate/acl/usergroups/${identifier}`, props, signal)

export interface GetOrganizationAggregateDTOListQueryParams {
  accountIdentifier: string
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type GetOrganizationAggregateDTOListProps = Omit<
  GetProps<ResponsePageOrganizationAggregateDTO, Failure | Error, GetOrganizationAggregateDTOListQueryParams, void>,
  'path'
>

/**
 * Get OrganizationAggregateDTO list
 */
export const GetOrganizationAggregateDTOList = (props: GetOrganizationAggregateDTOListProps) => (
  <Get<ResponsePageOrganizationAggregateDTO, Failure | Error, GetOrganizationAggregateDTOListQueryParams, void>
    path={`/aggregate/organizations`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationAggregateDTOListProps = Omit<
  UseGetProps<ResponsePageOrganizationAggregateDTO, Failure | Error, GetOrganizationAggregateDTOListQueryParams, void>,
  'path'
>

/**
 * Get OrganizationAggregateDTO list
 */
export const useGetOrganizationAggregateDTOList = (props: UseGetOrganizationAggregateDTOListProps) =>
  useGet<ResponsePageOrganizationAggregateDTO, Failure | Error, GetOrganizationAggregateDTOListQueryParams, void>(
    `/aggregate/organizations`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get OrganizationAggregateDTO list
 */
export const getOrganizationAggregateDTOListPromise = (
  props: GetUsingFetchProps<
    ResponsePageOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOListQueryParams,
    void
  >(getConfig('ng/api'), `/aggregate/organizations`, props, signal)

export interface GetOrganizationAggregateDTOQueryParams {
  accountIdentifier: string
}

export interface GetOrganizationAggregateDTOPathParams {
  identifier: string
}

export type GetOrganizationAggregateDTOProps = Omit<
  GetProps<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >,
  'path'
> &
  GetOrganizationAggregateDTOPathParams

/**
 * Gets an OrganizationAggregateDTO by identifier
 */
export const GetOrganizationAggregateDTO = ({ identifier, ...props }: GetOrganizationAggregateDTOProps) => (
  <Get<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >
    path={`/aggregate/organizations/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationAggregateDTOProps = Omit<
  UseGetProps<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >,
  'path'
> &
  GetOrganizationAggregateDTOPathParams

/**
 * Gets an OrganizationAggregateDTO by identifier
 */
export const useGetOrganizationAggregateDTO = ({ identifier, ...props }: UseGetOrganizationAggregateDTOProps) =>
  useGet<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >((paramsInPath: GetOrganizationAggregateDTOPathParams) => `/aggregate/organizations/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Gets an OrganizationAggregateDTO by identifier
 */
export const getOrganizationAggregateDTOPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >(getConfig('ng/api'), `/aggregate/organizations/${identifier}`, props, signal)

export interface GetProjectAggregateDTOListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  hasModule?: boolean
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  searchTerm?: string
  onlyFavorites?: boolean
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type GetProjectAggregateDTOListProps = Omit<
  GetProps<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>,
  'path'
>

/**
 * Get ProjectAggregateDTO list
 */
export const GetProjectAggregateDTOList = (props: GetProjectAggregateDTOListProps) => (
  <Get<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>
    path={`/aggregate/projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectAggregateDTOListProps = Omit<
  UseGetProps<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>,
  'path'
>

/**
 * Get ProjectAggregateDTO list
 */
export const useGetProjectAggregateDTOList = (props: UseGetProjectAggregateDTOListProps) =>
  useGet<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>(
    `/aggregate/projects`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get ProjectAggregateDTO list
 */
export const getProjectAggregateDTOListPromise = (
  props: GetUsingFetchProps<
    ResponsePageProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>(
    getConfig('ng/api'),
    `/aggregate/projects`,
    props,
    signal
  )

export interface GetProjectAggregateDTOQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export interface GetProjectAggregateDTOPathParams {
  identifier: string
}

export type GetProjectAggregateDTOProps = Omit<
  GetProps<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >,
  'path'
> &
  GetProjectAggregateDTOPathParams

/**
 * Gets a ProjectAggregateDTO by identifier
 */
export const GetProjectAggregateDTO = ({ identifier, ...props }: GetProjectAggregateDTOProps) => (
  <Get<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >
    path={`/aggregate/projects/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectAggregateDTOProps = Omit<
  UseGetProps<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >,
  'path'
> &
  GetProjectAggregateDTOPathParams

/**
 * Gets a ProjectAggregateDTO by identifier
 */
export const useGetProjectAggregateDTO = ({ identifier, ...props }: UseGetProjectAggregateDTOProps) =>
  useGet<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >((paramsInPath: GetProjectAggregateDTOPathParams) => `/aggregate/projects/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Gets a ProjectAggregateDTO by identifier
 */
export const getProjectAggregateDTOPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >(getConfig('ng/api'), `/aggregate/projects/${identifier}`, props, signal)

export interface ListApiKeysQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  parentIdentifier: string
  identifiers?: string[]
}

export type ListApiKeysProps = Omit<
  GetProps<ResponseListApiKeyDTO, Failure | Error, ListApiKeysQueryParams, void>,
  'path'
>

/**
 * List api keys
 */
export const ListApiKeys = (props: ListApiKeysProps) => (
  <Get<ResponseListApiKeyDTO, Failure | Error, ListApiKeysQueryParams, void>
    path={`/apikey`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListApiKeysProps = Omit<
  UseGetProps<ResponseListApiKeyDTO, Failure | Error, ListApiKeysQueryParams, void>,
  'path'
>

/**
 * List api keys
 */
export const useListApiKeys = (props: UseListApiKeysProps) =>
  useGet<ResponseListApiKeyDTO, Failure | Error, ListApiKeysQueryParams, void>(`/apikey`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * List api keys
 */
export const listApiKeysPromise = (
  props: GetUsingFetchProps<ResponseListApiKeyDTO, Failure | Error, ListApiKeysQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListApiKeyDTO, Failure | Error, ListApiKeysQueryParams, void>(
    getConfig('ng/api'),
    `/apikey`,
    props,
    signal
  )

export interface CreateApiKeyQueryParams {
  accountIdentifier: string
}

export type CreateApiKeyProps = Omit<
  MutateProps<ResponseApiKeyDTO, Failure | Error, CreateApiKeyQueryParams, ApiKeyDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create API key
 */
export const CreateApiKey = (props: CreateApiKeyProps) => (
  <Mutate<ResponseApiKeyDTO, Failure | Error, CreateApiKeyQueryParams, ApiKeyDTORequestBody, void>
    verb="POST"
    path={`/apikey`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateApiKeyProps = Omit<
  UseMutateProps<ResponseApiKeyDTO, Failure | Error, CreateApiKeyQueryParams, ApiKeyDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create API key
 */
export const useCreateApiKey = (props: UseCreateApiKeyProps) =>
  useMutate<ResponseApiKeyDTO, Failure | Error, CreateApiKeyQueryParams, ApiKeyDTORequestBody, void>(
    'POST',
    `/apikey`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create API key
 */
export const createApiKeyPromise = (
  props: MutateUsingFetchProps<ResponseApiKeyDTO, Failure | Error, CreateApiKeyQueryParams, ApiKeyDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseApiKeyDTO, Failure | Error, CreateApiKeyQueryParams, ApiKeyDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/apikey`,
    props,
    signal
  )

export interface ListAggregatedApiKeysQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  parentIdentifier: string
  identifiers?: string[]
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
  searchTerm?: string
}

export type ListAggregatedApiKeysProps = Omit<
  GetProps<ResponsePageApiKeyAggregateDTO, Failure | Error, ListAggregatedApiKeysQueryParams, void>,
  'path'
>

/**
 * List api key
 */
export const ListAggregatedApiKeys = (props: ListAggregatedApiKeysProps) => (
  <Get<ResponsePageApiKeyAggregateDTO, Failure | Error, ListAggregatedApiKeysQueryParams, void>
    path={`/apikey/aggregate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListAggregatedApiKeysProps = Omit<
  UseGetProps<ResponsePageApiKeyAggregateDTO, Failure | Error, ListAggregatedApiKeysQueryParams, void>,
  'path'
>

/**
 * List api key
 */
export const useListAggregatedApiKeys = (props: UseListAggregatedApiKeysProps) =>
  useGet<ResponsePageApiKeyAggregateDTO, Failure | Error, ListAggregatedApiKeysQueryParams, void>(`/apikey/aggregate`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * List api key
 */
export const listAggregatedApiKeysPromise = (
  props: GetUsingFetchProps<ResponsePageApiKeyAggregateDTO, Failure | Error, ListAggregatedApiKeysQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageApiKeyAggregateDTO, Failure | Error, ListAggregatedApiKeysQueryParams, void>(
    getConfig('ng/api'),
    `/apikey/aggregate`,
    props,
    signal
  )

export interface GetAggregatedApiKeyQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  parentIdentifier: string
}

export interface GetAggregatedApiKeyPathParams {
  identifier: string
}

export type GetAggregatedApiKeyProps = Omit<
  GetProps<ResponseApiKeyAggregateDTO, Failure | Error, GetAggregatedApiKeyQueryParams, GetAggregatedApiKeyPathParams>,
  'path'
> &
  GetAggregatedApiKeyPathParams

/**
 * Get API key
 */
export const GetAggregatedApiKey = ({ identifier, ...props }: GetAggregatedApiKeyProps) => (
  <Get<ResponseApiKeyAggregateDTO, Failure | Error, GetAggregatedApiKeyQueryParams, GetAggregatedApiKeyPathParams>
    path={`/apikey/aggregate/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAggregatedApiKeyProps = Omit<
  UseGetProps<
    ResponseApiKeyAggregateDTO,
    Failure | Error,
    GetAggregatedApiKeyQueryParams,
    GetAggregatedApiKeyPathParams
  >,
  'path'
> &
  GetAggregatedApiKeyPathParams

/**
 * Get API key
 */
export const useGetAggregatedApiKey = ({ identifier, ...props }: UseGetAggregatedApiKeyProps) =>
  useGet<ResponseApiKeyAggregateDTO, Failure | Error, GetAggregatedApiKeyQueryParams, GetAggregatedApiKeyPathParams>(
    (paramsInPath: GetAggregatedApiKeyPathParams) => `/apikey/aggregate/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get API key
 */
export const getAggregatedApiKeyPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseApiKeyAggregateDTO,
    Failure | Error,
    GetAggregatedApiKeyQueryParams,
    GetAggregatedApiKeyPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseApiKeyAggregateDTO,
    Failure | Error,
    GetAggregatedApiKeyQueryParams,
    GetAggregatedApiKeyPathParams
  >(getConfig('ng/api'), `/apikey/aggregate/${identifier}`, props, signal)

export interface DeleteApiKeyQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  parentIdentifier: string
}

export type DeleteApiKeyProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteApiKeyQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete API key
 */
export const DeleteApiKey = (props: DeleteApiKeyProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteApiKeyQueryParams, string, void>
    verb="DELETE"
    path={`/apikey`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteApiKeyProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteApiKeyQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete API key
 */
export const useDeleteApiKey = (props: UseDeleteApiKeyProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteApiKeyQueryParams, string, void>('DELETE', `/apikey`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete API key
 */
export const deleteApiKeyPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteApiKeyQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteApiKeyQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/apikey`,
    props,
    signal
  )

export interface UpdateApiKeyPathParams {
  identifier: string
}

export type UpdateApiKeyProps = Omit<
  MutateProps<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, UpdateApiKeyPathParams>,
  'path' | 'verb'
> &
  UpdateApiKeyPathParams

/**
 * Update API key
 */
export const UpdateApiKey = ({ identifier, ...props }: UpdateApiKeyProps) => (
  <Mutate<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, UpdateApiKeyPathParams>
    verb="PUT"
    path={`/apikey/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateApiKeyProps = Omit<
  UseMutateProps<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, UpdateApiKeyPathParams>,
  'path' | 'verb'
> &
  UpdateApiKeyPathParams

/**
 * Update API key
 */
export const useUpdateApiKey = ({ identifier, ...props }: UseUpdateApiKeyProps) =>
  useMutate<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, UpdateApiKeyPathParams>(
    'PUT',
    (paramsInPath: UpdateApiKeyPathParams) => `/apikey/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update API key
 */
export const updateApiKeyPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, UpdateApiKeyPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, UpdateApiKeyPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/apikey/${identifier}`,
    props,
    signal
  )

export interface GetACRRegistriesBySubscriptionQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  subscriptionId: string
}

export type GetACRRegistriesBySubscriptionProps = Omit<
  GetProps<ResponseAcrRegistriesDTO, Failure | Error, GetACRRegistriesBySubscriptionQueryParams, void>,
  'path'
>

/**
 * Gets ACR registries by subscription
 */
export const GetACRRegistriesBySubscription = (props: GetACRRegistriesBySubscriptionProps) => (
  <Get<ResponseAcrRegistriesDTO, Failure | Error, GetACRRegistriesBySubscriptionQueryParams, void>
    path={`/artifacts/acr/container-registries`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetACRRegistriesBySubscriptionProps = Omit<
  UseGetProps<ResponseAcrRegistriesDTO, Failure | Error, GetACRRegistriesBySubscriptionQueryParams, void>,
  'path'
>

/**
 * Gets ACR registries by subscription
 */
export const useGetACRRegistriesBySubscription = (props: UseGetACRRegistriesBySubscriptionProps) =>
  useGet<ResponseAcrRegistriesDTO, Failure | Error, GetACRRegistriesBySubscriptionQueryParams, void>(
    `/artifacts/acr/container-registries`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets ACR registries by subscription
 */
export const getACRRegistriesBySubscriptionPromise = (
  props: GetUsingFetchProps<ResponseAcrRegistriesDTO, Failure | Error, GetACRRegistriesBySubscriptionQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAcrRegistriesDTO, Failure | Error, GetACRRegistriesBySubscriptionQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/acr/container-registries`,
    props,
    signal
  )

export interface GetACRRepositoriesQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  subscriptionId: string
}

export interface GetACRRepositoriesPathParams {
  registry: string
}

export type GetACRRepositoriesProps = Omit<
  GetProps<ResponseAcrRepositoriesDTO, Failure | Error, GetACRRepositoriesQueryParams, GetACRRepositoriesPathParams>,
  'path'
> &
  GetACRRepositoriesPathParams

/**
 * Gets ACR repositories by subscription and container registry name
 */
export const GetACRRepositories = ({ registry, ...props }: GetACRRepositoriesProps) => (
  <Get<ResponseAcrRepositoriesDTO, Failure | Error, GetACRRepositoriesQueryParams, GetACRRepositoriesPathParams>
    path={`/artifacts/acr/container-registries/${registry}/repositories`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetACRRepositoriesProps = Omit<
  UseGetProps<ResponseAcrRepositoriesDTO, Failure | Error, GetACRRepositoriesQueryParams, GetACRRepositoriesPathParams>,
  'path'
> &
  GetACRRepositoriesPathParams

/**
 * Gets ACR repositories by subscription and container registry name
 */
export const useGetACRRepositories = ({ registry, ...props }: UseGetACRRepositoriesProps) =>
  useGet<ResponseAcrRepositoriesDTO, Failure | Error, GetACRRepositoriesQueryParams, GetACRRepositoriesPathParams>(
    (paramsInPath: GetACRRepositoriesPathParams) =>
      `/artifacts/acr/container-registries/${paramsInPath.registry}/repositories`,
    { base: getConfig('ng/api'), pathParams: { registry }, ...props }
  )

/**
 * Gets ACR repositories by subscription and container registry name
 */
export const getACRRepositoriesPromise = (
  {
    registry,
    ...props
  }: GetUsingFetchProps<
    ResponseAcrRepositoriesDTO,
    Failure | Error,
    GetACRRepositoriesQueryParams,
    GetACRRepositoriesPathParams
  > & { registry: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseAcrRepositoriesDTO,
    Failure | Error,
    GetACRRepositoriesQueryParams,
    GetACRRepositoriesPathParams
  >(getConfig('ng/api'), `/artifacts/acr/container-registries/${registry}/repositories`, props, signal)

export interface GetBuildDetailsForACRRepositoryQueryParams {
  subscriptionId?: string
  registry?: string
  repository?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetBuildDetailsForACRRepositoryProps = Omit<
  GetProps<ResponseAcrResponseDTO, Failure | Error, GetBuildDetailsForACRRepositoryQueryParams, void>,
  'path'
>

/**
 * Gets ACR repository build details
 */
export const GetBuildDetailsForACRRepository = (props: GetBuildDetailsForACRRepositoryProps) => (
  <Get<ResponseAcrResponseDTO, Failure | Error, GetBuildDetailsForACRRepositoryQueryParams, void>
    path={`/artifacts/acr/getBuildDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForACRRepositoryProps = Omit<
  UseGetProps<ResponseAcrResponseDTO, Failure | Error, GetBuildDetailsForACRRepositoryQueryParams, void>,
  'path'
>

/**
 * Gets ACR repository build details
 */
export const useGetBuildDetailsForACRRepository = (props: UseGetBuildDetailsForACRRepositoryProps) =>
  useGet<ResponseAcrResponseDTO, Failure | Error, GetBuildDetailsForACRRepositoryQueryParams, void>(
    `/artifacts/acr/getBuildDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets ACR repository build details
 */
export const getBuildDetailsForACRRepositoryPromise = (
  props: GetUsingFetchProps<ResponseAcrResponseDTO, Failure | Error, GetBuildDetailsForACRRepositoryQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAcrResponseDTO, Failure | Error, GetBuildDetailsForACRRepositoryQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/acr/getBuildDetails`,
    props,
    signal
  )

export interface GetBuildDetailsForAcrArtifactWithYamlQueryParams {
  subscriptionId?: string
  registry?: string
  repository?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  serviceId?: string
}

export type GetBuildDetailsForAcrArtifactWithYamlProps = Omit<
  MutateProps<
    ResponseAcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForAcrArtifactWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ACR build details with yaml input for expression resolution
 */
export const GetBuildDetailsForAcrArtifactWithYaml = (props: GetBuildDetailsForAcrArtifactWithYamlProps) => (
  <Mutate<
    ResponseAcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForAcrArtifactWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/acr/getBuildDetailsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForAcrArtifactWithYamlProps = Omit<
  UseMutateProps<
    ResponseAcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForAcrArtifactWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ACR build details with yaml input for expression resolution
 */
export const useGetBuildDetailsForAcrArtifactWithYaml = (props: UseGetBuildDetailsForAcrArtifactWithYamlProps) =>
  useMutate<
    ResponseAcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForAcrArtifactWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', `/artifacts/acr/getBuildDetailsV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets ACR build details with yaml input for expression resolution
 */
export const getBuildDetailsForAcrArtifactWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseAcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForAcrArtifactWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseAcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForAcrArtifactWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/acr/getBuildDetailsV2`, props, signal)

export interface GetLastSuccessfulBuildForACRRepositoryQueryParams {
  subscriptionId?: string
  registry?: string
  repository?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetLastSuccessfulBuildForACRRepositoryProps = Omit<
  MutateProps<
    ResponseAcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForACRRepositoryQueryParams,
    AcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ACR repository last successful build
 */
export const GetLastSuccessfulBuildForACRRepository = (props: GetLastSuccessfulBuildForACRRepositoryProps) => (
  <Mutate<
    ResponseAcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForACRRepositoryQueryParams,
    AcrRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/acr/getLastSuccessfulBuild`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForACRRepositoryProps = Omit<
  UseMutateProps<
    ResponseAcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForACRRepositoryQueryParams,
    AcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ACR repository last successful build
 */
export const useGetLastSuccessfulBuildForACRRepository = (props: UseGetLastSuccessfulBuildForACRRepositoryProps) =>
  useMutate<
    ResponseAcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForACRRepositoryQueryParams,
    AcrRequestDTORequestBody,
    void
  >('POST', `/artifacts/acr/getLastSuccessfulBuild`, { base: getConfig('ng/api'), ...props })

/**
 * Gets ACR repository last successful build
 */
export const getLastSuccessfulBuildForACRRepositoryPromise = (
  props: MutateUsingFetchProps<
    ResponseAcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForACRRepositoryQueryParams,
    AcrRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseAcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForACRRepositoryQueryParams,
    AcrRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/acr/getLastSuccessfulBuild`, props, signal)

export interface GetLastSuccessfulBuildForAcrArtifactWithYamlQueryParams {
  subscriptionId?: string
  registry?: string
  repository?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  fqnPath: string
  serviceId?: string
  pipelineIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetLastSuccessfulBuildForAcrArtifactWithYamlProps = Omit<
  MutateProps<
    ResponseAcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForAcrArtifactWithYamlQueryParams,
    AcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ACR last successful build with yaml input for expression resolution
 */
export const GetLastSuccessfulBuildForAcrArtifactWithYaml = (
  props: GetLastSuccessfulBuildForAcrArtifactWithYamlProps
) => (
  <Mutate<
    ResponseAcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForAcrArtifactWithYamlQueryParams,
    AcrRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/acr/getLastSuccessfulBuildV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForAcrArtifactWithYamlProps = Omit<
  UseMutateProps<
    ResponseAcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForAcrArtifactWithYamlQueryParams,
    AcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ACR last successful build with yaml input for expression resolution
 */
export const useGetLastSuccessfulBuildForAcrArtifactWithYaml = (
  props: UseGetLastSuccessfulBuildForAcrArtifactWithYamlProps
) =>
  useMutate<
    ResponseAcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForAcrArtifactWithYamlQueryParams,
    AcrRequestDTORequestBody,
    void
  >('POST', `/artifacts/acr/getLastSuccessfulBuildV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets ACR last successful build with yaml input for expression resolution
 */
export const getLastSuccessfulBuildForAcrArtifactWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseAcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForAcrArtifactWithYamlQueryParams,
    AcrRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseAcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForAcrArtifactWithYamlQueryParams,
    AcrRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/acr/getLastSuccessfulBuildV2`, props, signal)

export interface GetAzureSubscriptionsForAcrArtifactQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  fqnPath: string
  serviceId?: string
}

export type GetAzureSubscriptionsForAcrArtifactProps = Omit<
  GetProps<ResponseAzureSubscriptionsDTO, Failure | Error, GetAzureSubscriptionsForAcrArtifactQueryParams, void>,
  'path'
>

/**
 * Gets azure subscriptions for ACR artifact
 */
export const GetAzureSubscriptionsForAcrArtifact = (props: GetAzureSubscriptionsForAcrArtifactProps) => (
  <Get<ResponseAzureSubscriptionsDTO, Failure | Error, GetAzureSubscriptionsForAcrArtifactQueryParams, void>
    path={`/artifacts/acr/subscriptions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAzureSubscriptionsForAcrArtifactProps = Omit<
  UseGetProps<ResponseAzureSubscriptionsDTO, Failure | Error, GetAzureSubscriptionsForAcrArtifactQueryParams, void>,
  'path'
>

/**
 * Gets azure subscriptions for ACR artifact
 */
export const useGetAzureSubscriptionsForAcrArtifact = (props: UseGetAzureSubscriptionsForAcrArtifactProps) =>
  useGet<ResponseAzureSubscriptionsDTO, Failure | Error, GetAzureSubscriptionsForAcrArtifactQueryParams, void>(
    `/artifacts/acr/subscriptions`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets azure subscriptions for ACR artifact
 */
export const getAzureSubscriptionsForAcrArtifactPromise = (
  props: GetUsingFetchProps<
    ResponseAzureSubscriptionsDTO,
    Failure | Error,
    GetAzureSubscriptionsForAcrArtifactQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAzureSubscriptionsDTO, Failure | Error, GetAzureSubscriptionsForAcrArtifactQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/acr/subscriptions`,
    props,
    signal
  )

export interface GetACRRegistriesForServiceQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  subscriptionId?: string
  fqnPath: string
  serviceId?: string
}

export type GetACRRegistriesForServiceProps = Omit<
  GetProps<ResponseAcrRegistriesDTO, Failure | Error, GetACRRegistriesForServiceQueryParams, void>,
  'path'
>

/**
 * Gets ACR registries
 */
export const GetACRRegistriesForService = (props: GetACRRegistriesForServiceProps) => (
  <Get<ResponseAcrRegistriesDTO, Failure | Error, GetACRRegistriesForServiceQueryParams, void>
    path={`/artifacts/acr/v2/container-registries`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetACRRegistriesForServiceProps = Omit<
  UseGetProps<ResponseAcrRegistriesDTO, Failure | Error, GetACRRegistriesForServiceQueryParams, void>,
  'path'
>

/**
 * Gets ACR registries
 */
export const useGetACRRegistriesForService = (props: UseGetACRRegistriesForServiceProps) =>
  useGet<ResponseAcrRegistriesDTO, Failure | Error, GetACRRegistriesForServiceQueryParams, void>(
    `/artifacts/acr/v2/container-registries`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets ACR registries
 */
export const getACRRegistriesForServicePromise = (
  props: GetUsingFetchProps<ResponseAcrRegistriesDTO, Failure | Error, GetACRRegistriesForServiceQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAcrRegistriesDTO, Failure | Error, GetACRRegistriesForServiceQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/acr/v2/container-registries`,
    props,
    signal
  )

export interface GetACRRepositoriesForServiceQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  subscriptionId?: string
  registry?: string
  fqnPath: string
  serviceId?: string
}

export type GetACRRepositoriesForServiceProps = Omit<
  GetProps<ResponseAcrRepositoriesDTO, Failure | Error, GetACRRepositoriesForServiceQueryParams, void>,
  'path'
>

/**
 * Gets ACR repositories
 */
export const GetACRRepositoriesForService = (props: GetACRRepositoriesForServiceProps) => (
  <Get<ResponseAcrRepositoriesDTO, Failure | Error, GetACRRepositoriesForServiceQueryParams, void>
    path={`/artifacts/acr/v2/repositories`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetACRRepositoriesForServiceProps = Omit<
  UseGetProps<ResponseAcrRepositoriesDTO, Failure | Error, GetACRRepositoriesForServiceQueryParams, void>,
  'path'
>

/**
 * Gets ACR repositories
 */
export const useGetACRRepositoriesForService = (props: UseGetACRRepositoriesForServiceProps) =>
  useGet<ResponseAcrRepositoriesDTO, Failure | Error, GetACRRepositoriesForServiceQueryParams, void>(
    `/artifacts/acr/v2/repositories`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets ACR repositories
 */
export const getACRRepositoriesForServicePromise = (
  props: GetUsingFetchProps<ResponseAcrRepositoriesDTO, Failure | Error, GetACRRepositoriesForServiceQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAcrRepositoriesDTO, Failure | Error, GetACRRepositoriesForServiceQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/acr/v2/repositories`,
    props,
    signal
  )

export interface GetAzureSubscriptionsForAcrArtifactWithYamlQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  serviceId?: string
}

export type GetAzureSubscriptionsForAcrArtifactWithYamlProps = Omit<
  MutateProps<
    ResponseAzureSubscriptionsDTO,
    Failure | Error,
    GetAzureSubscriptionsForAcrArtifactWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets azure subscriptions for ACR artifact with yaml input for expression resolution
 */
export const GetAzureSubscriptionsForAcrArtifactWithYaml = (
  props: GetAzureSubscriptionsForAcrArtifactWithYamlProps
) => (
  <Mutate<
    ResponseAzureSubscriptionsDTO,
    Failure | Error,
    GetAzureSubscriptionsForAcrArtifactWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/acr/v2/subscriptions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAzureSubscriptionsForAcrArtifactWithYamlProps = Omit<
  UseMutateProps<
    ResponseAzureSubscriptionsDTO,
    Failure | Error,
    GetAzureSubscriptionsForAcrArtifactWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets azure subscriptions for ACR artifact with yaml input for expression resolution
 */
export const useGetAzureSubscriptionsForAcrArtifactWithYaml = (
  props: UseGetAzureSubscriptionsForAcrArtifactWithYamlProps
) =>
  useMutate<
    ResponseAzureSubscriptionsDTO,
    Failure | Error,
    GetAzureSubscriptionsForAcrArtifactWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', `/artifacts/acr/v2/subscriptions`, { base: getConfig('ng/api'), ...props })

/**
 * Gets azure subscriptions for ACR artifact with yaml input for expression resolution
 */
export const getAzureSubscriptionsForAcrArtifactWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseAzureSubscriptionsDTO,
    Failure | Error,
    GetAzureSubscriptionsForAcrArtifactWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseAzureSubscriptionsDTO,
    Failure | Error,
    GetAzureSubscriptionsForAcrArtifactWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/acr/v2/subscriptions`, props, signal)

export interface GetACRRegistriesForServiceWithYamlQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  subscriptionId?: string
  fqnPath: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  serviceId?: string
}

export type GetACRRegistriesForServiceWithYamlProps = Omit<
  MutateProps<
    ResponseAcrRegistriesDTO,
    Failure | Error,
    GetACRRegistriesForServiceWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ACR registries with yaml input for expression resolution
 */
export const GetACRRegistriesForServiceWithYaml = (props: GetACRRegistriesForServiceWithYamlProps) => (
  <Mutate<
    ResponseAcrRegistriesDTO,
    Failure | Error,
    GetACRRegistriesForServiceWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/acr/v3/container-registries`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetACRRegistriesForServiceWithYamlProps = Omit<
  UseMutateProps<
    ResponseAcrRegistriesDTO,
    Failure | Error,
    GetACRRegistriesForServiceWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ACR registries with yaml input for expression resolution
 */
export const useGetACRRegistriesForServiceWithYaml = (props: UseGetACRRegistriesForServiceWithYamlProps) =>
  useMutate<
    ResponseAcrRegistriesDTO,
    Failure | Error,
    GetACRRegistriesForServiceWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', `/artifacts/acr/v3/container-registries`, { base: getConfig('ng/api'), ...props })

/**
 * Gets ACR registries with yaml input for expression resolution
 */
export const getACRRegistriesForServiceWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseAcrRegistriesDTO,
    Failure | Error,
    GetACRRegistriesForServiceWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseAcrRegistriesDTO,
    Failure | Error,
    GetACRRegistriesForServiceWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/acr/v3/container-registries`, props, signal)

export interface GetACRRepositoriesForServiceWithYamlQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  subscriptionId?: string
  registry?: string
  fqnPath: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  serviceId?: string
}

export type GetACRRepositoriesForServiceWithYamlProps = Omit<
  MutateProps<
    ResponseAcrRepositoriesDTO,
    Failure | Error,
    GetACRRepositoriesForServiceWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ACR repositories with yaml input for expression resolution
 */
export const GetACRRepositoriesForServiceWithYaml = (props: GetACRRepositoriesForServiceWithYamlProps) => (
  <Mutate<
    ResponseAcrRepositoriesDTO,
    Failure | Error,
    GetACRRepositoriesForServiceWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/acr/v3/repositories`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetACRRepositoriesForServiceWithYamlProps = Omit<
  UseMutateProps<
    ResponseAcrRepositoriesDTO,
    Failure | Error,
    GetACRRepositoriesForServiceWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ACR repositories with yaml input for expression resolution
 */
export const useGetACRRepositoriesForServiceWithYaml = (props: UseGetACRRepositoriesForServiceWithYamlProps) =>
  useMutate<
    ResponseAcrRepositoriesDTO,
    Failure | Error,
    GetACRRepositoriesForServiceWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', `/artifacts/acr/v3/repositories`, { base: getConfig('ng/api'), ...props })

/**
 * Gets ACR repositories with yaml input for expression resolution
 */
export const getACRRepositoriesForServiceWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseAcrRepositoriesDTO,
    Failure | Error,
    GetACRRepositoriesForServiceWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseAcrRepositoriesDTO,
    Failure | Error,
    GetACRRepositoriesForServiceWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/acr/v3/repositories`, props, signal)

export interface ListTagsForAMIArtifactQueryParams {
  connectorRef?: string
  region?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath?: string
  serviceId?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type ListTagsForAMIArtifactProps = Omit<
  MutateProps<
    ResponseListAMITagObject,
    Failure | Error,
    ListTagsForAMIArtifactQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * List Tags for AMI Artifacts
 */
export const ListTagsForAMIArtifact = (props: ListTagsForAMIArtifactProps) => (
  <Mutate<
    ResponseListAMITagObject,
    Failure | Error,
    ListTagsForAMIArtifactQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/ami/tags`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListTagsForAMIArtifactProps = Omit<
  UseMutateProps<
    ResponseListAMITagObject,
    Failure | Error,
    ListTagsForAMIArtifactQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * List Tags for AMI Artifacts
 */
export const useListTagsForAMIArtifact = (props: UseListTagsForAMIArtifactProps) =>
  useMutate<
    ResponseListAMITagObject,
    Failure | Error,
    ListTagsForAMIArtifactQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/ami/tags`, { base: getConfig('ng/api'), ...props })

/**
 * List Tags for AMI Artifacts
 */
export const listTagsForAMIArtifactPromise = (
  props: MutateUsingFetchProps<
    ResponseListAMITagObject,
    Failure | Error,
    ListTagsForAMIArtifactQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListAMITagObject,
    Failure | Error,
    ListTagsForAMIArtifactQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/ami/tags`, props, signal)

export interface ListVersionsForAMIArtifactQueryParams {
  connectorRef?: string
  region?: string
  versionRegex?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath?: string
  serviceId?: string
}

export type ListVersionsForAMIArtifactProps = Omit<
  MutateProps<ResponseListBuildDetails, Failure | Error, ListVersionsForAMIArtifactQueryParams, AMIRequestBody, void>,
  'path' | 'verb'
>

/**
 * List Versions for AMI Artifacts
 */
export const ListVersionsForAMIArtifact = (props: ListVersionsForAMIArtifactProps) => (
  <Mutate<ResponseListBuildDetails, Failure | Error, ListVersionsForAMIArtifactQueryParams, AMIRequestBody, void>
    verb="POST"
    path={`/artifacts/ami/versions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListVersionsForAMIArtifactProps = Omit<
  UseMutateProps<
    ResponseListBuildDetails,
    Failure | Error,
    ListVersionsForAMIArtifactQueryParams,
    AMIRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * List Versions for AMI Artifacts
 */
export const useListVersionsForAMIArtifact = (props: UseListVersionsForAMIArtifactProps) =>
  useMutate<ResponseListBuildDetails, Failure | Error, ListVersionsForAMIArtifactQueryParams, AMIRequestBody, void>(
    'POST',
    `/artifacts/ami/versions`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * List Versions for AMI Artifacts
 */
export const listVersionsForAMIArtifactPromise = (
  props: MutateUsingFetchProps<
    ResponseListBuildDetails,
    Failure | Error,
    ListVersionsForAMIArtifactQueryParams,
    AMIRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListBuildDetails,
    Failure | Error,
    ListVersionsForAMIArtifactQueryParams,
    AMIRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/ami/versions`, props, signal)

export interface GetArtifactsBuildsDetailsForArtifactoryQueryParams {
  connectorRef: string
  repositoryName: string
  filePath?: string
  maxVersions: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetArtifactsBuildsDetailsForArtifactoryProps = Omit<
  GetProps<
    ResponseListArtifactoryArtifactBuildDetailsDTO,
    Failure | Error,
    GetArtifactsBuildsDetailsForArtifactoryQueryParams,
    void
  >,
  'path'
>

/**
 * Gets artifacts builds details
 */
export const GetArtifactsBuildsDetailsForArtifactory = (props: GetArtifactsBuildsDetailsForArtifactoryProps) => (
  <Get<
    ResponseListArtifactoryArtifactBuildDetailsDTO,
    Failure | Error,
    GetArtifactsBuildsDetailsForArtifactoryQueryParams,
    void
  >
    path={`/artifacts/artifactory/artifactBuildsDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetArtifactsBuildsDetailsForArtifactoryProps = Omit<
  UseGetProps<
    ResponseListArtifactoryArtifactBuildDetailsDTO,
    Failure | Error,
    GetArtifactsBuildsDetailsForArtifactoryQueryParams,
    void
  >,
  'path'
>

/**
 * Gets artifacts builds details
 */
export const useGetArtifactsBuildsDetailsForArtifactory = (props: UseGetArtifactsBuildsDetailsForArtifactoryProps) =>
  useGet<
    ResponseListArtifactoryArtifactBuildDetailsDTO,
    Failure | Error,
    GetArtifactsBuildsDetailsForArtifactoryQueryParams,
    void
  >(`/artifacts/artifactory/artifactBuildsDetails`, { base: getConfig('ng/api'), ...props })

/**
 * Gets artifacts builds details
 */
export const getArtifactsBuildsDetailsForArtifactoryPromise = (
  props: GetUsingFetchProps<
    ResponseListArtifactoryArtifactBuildDetailsDTO,
    Failure | Error,
    GetArtifactsBuildsDetailsForArtifactoryQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseListArtifactoryArtifactBuildDetailsDTO,
    Failure | Error,
    GetArtifactsBuildsDetailsForArtifactoryQueryParams,
    void
  >(getConfig('ng/api'), `/artifacts/artifactory/artifactBuildsDetails`, props, signal)

export interface GetBuildDetailsForArtifactoryArtifactQueryParams {
  repository?: string
  artifactPath?: string
  repositoryFormat?: string
  repositoryUrl?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  artifactFilter?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetBuildDetailsForArtifactoryArtifactProps = Omit<
  GetProps<ResponseArtifactoryResponseDTO, Failure | Error, GetBuildDetailsForArtifactoryArtifactQueryParams, void>,
  'path'
>

/**
 * Gets artifactory artifact build details
 */
export const GetBuildDetailsForArtifactoryArtifact = (props: GetBuildDetailsForArtifactoryArtifactProps) => (
  <Get<ResponseArtifactoryResponseDTO, Failure | Error, GetBuildDetailsForArtifactoryArtifactQueryParams, void>
    path={`/artifacts/artifactory/getBuildDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForArtifactoryArtifactProps = Omit<
  UseGetProps<ResponseArtifactoryResponseDTO, Failure | Error, GetBuildDetailsForArtifactoryArtifactQueryParams, void>,
  'path'
>

/**
 * Gets artifactory artifact build details
 */
export const useGetBuildDetailsForArtifactoryArtifact = (props: UseGetBuildDetailsForArtifactoryArtifactProps) =>
  useGet<ResponseArtifactoryResponseDTO, Failure | Error, GetBuildDetailsForArtifactoryArtifactQueryParams, void>(
    `/artifacts/artifactory/getBuildDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets artifactory artifact build details
 */
export const getBuildDetailsForArtifactoryArtifactPromise = (
  props: GetUsingFetchProps<
    ResponseArtifactoryResponseDTO,
    Failure | Error,
    GetBuildDetailsForArtifactoryArtifactQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseArtifactoryResponseDTO,
    Failure | Error,
    GetBuildDetailsForArtifactoryArtifactQueryParams,
    void
  >(getConfig('ng/api'), `/artifacts/artifactory/getBuildDetails`, props, signal)

export interface GetBuildDetailsForArtifactoryArtifactWithYamlQueryParams {
  repository?: string
  artifactPath?: string
  repositoryFormat?: string
  repositoryUrl?: string
  connectorRef?: string
  artifactFilter?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  tagInput?: string
  fqnPath: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  serviceId?: string
}

export type GetBuildDetailsForArtifactoryArtifactWithYamlProps = Omit<
  MutateProps<
    ResponseArtifactoryResponseDTO,
    Failure | Error,
    GetBuildDetailsForArtifactoryArtifactWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets artifactory artifact build details with yaml input for expression resolution
 */
export const GetBuildDetailsForArtifactoryArtifactWithYaml = (
  props: GetBuildDetailsForArtifactoryArtifactWithYamlProps
) => (
  <Mutate<
    ResponseArtifactoryResponseDTO,
    Failure | Error,
    GetBuildDetailsForArtifactoryArtifactWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/artifactory/getBuildDetailsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForArtifactoryArtifactWithYamlProps = Omit<
  UseMutateProps<
    ResponseArtifactoryResponseDTO,
    Failure | Error,
    GetBuildDetailsForArtifactoryArtifactWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets artifactory artifact build details with yaml input for expression resolution
 */
export const useGetBuildDetailsForArtifactoryArtifactWithYaml = (
  props: UseGetBuildDetailsForArtifactoryArtifactWithYamlProps
) =>
  useMutate<
    ResponseArtifactoryResponseDTO,
    Failure | Error,
    GetBuildDetailsForArtifactoryArtifactWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/artifactory/getBuildDetailsV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets artifactory artifact build details with yaml input for expression resolution
 */
export const getBuildDetailsForArtifactoryArtifactWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseArtifactoryResponseDTO,
    Failure | Error,
    GetBuildDetailsForArtifactoryArtifactWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseArtifactoryResponseDTO,
    Failure | Error,
    GetBuildDetailsForArtifactoryArtifactWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/artifactory/getBuildDetailsV2`, props, signal)

export interface GetLastSuccessfulBuildForArtifactoryArtifactQueryParams {
  repository?: string
  artifactPath?: string
  repositoryFormat?: string
  repositoryUrl?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetLastSuccessfulBuildForArtifactoryArtifactProps = Omit<
  MutateProps<
    ResponseArtifactoryBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForArtifactoryArtifactQueryParams,
    ArtifactoryRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets artifactory artifact last successful build
 */
export const GetLastSuccessfulBuildForArtifactoryArtifact = (
  props: GetLastSuccessfulBuildForArtifactoryArtifactProps
) => (
  <Mutate<
    ResponseArtifactoryBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForArtifactoryArtifactQueryParams,
    ArtifactoryRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/artifactory/getLastSuccessfulBuild`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForArtifactoryArtifactProps = Omit<
  UseMutateProps<
    ResponseArtifactoryBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForArtifactoryArtifactQueryParams,
    ArtifactoryRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets artifactory artifact last successful build
 */
export const useGetLastSuccessfulBuildForArtifactoryArtifact = (
  props: UseGetLastSuccessfulBuildForArtifactoryArtifactProps
) =>
  useMutate<
    ResponseArtifactoryBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForArtifactoryArtifactQueryParams,
    ArtifactoryRequestDTORequestBody,
    void
  >('POST', `/artifacts/artifactory/getLastSuccessfulBuild`, { base: getConfig('ng/api'), ...props })

/**
 * Gets artifactory artifact last successful build
 */
export const getLastSuccessfulBuildForArtifactoryArtifactPromise = (
  props: MutateUsingFetchProps<
    ResponseArtifactoryBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForArtifactoryArtifactQueryParams,
    ArtifactoryRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseArtifactoryBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForArtifactoryArtifactQueryParams,
    ArtifactoryRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/artifactory/getLastSuccessfulBuild`, props, signal)

export interface GetLastSuccessfulBuildArtifactoryArtifactWithYamlQueryParams {
  repository?: string
  artifactPath?: string
  repositoryFormat?: string
  repositoryUrl?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  serviceId?: string
}

export type GetLastSuccessfulBuildArtifactoryArtifactWithYamlProps = Omit<
  MutateProps<
    ResponseArtifactoryBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildArtifactoryArtifactWithYamlQueryParams,
    ArtifactoryRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets artifactory artifact last successful build with yaml input for expression resolution
 */
export const GetLastSuccessfulBuildArtifactoryArtifactWithYaml = (
  props: GetLastSuccessfulBuildArtifactoryArtifactWithYamlProps
) => (
  <Mutate<
    ResponseArtifactoryBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildArtifactoryArtifactWithYamlQueryParams,
    ArtifactoryRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/artifactory/getLastSuccessfulBuildV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildArtifactoryArtifactWithYamlProps = Omit<
  UseMutateProps<
    ResponseArtifactoryBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildArtifactoryArtifactWithYamlQueryParams,
    ArtifactoryRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets artifactory artifact last successful build with yaml input for expression resolution
 */
export const useGetLastSuccessfulBuildArtifactoryArtifactWithYaml = (
  props: UseGetLastSuccessfulBuildArtifactoryArtifactWithYamlProps
) =>
  useMutate<
    ResponseArtifactoryBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildArtifactoryArtifactWithYamlQueryParams,
    ArtifactoryRequestDTORequestBody,
    void
  >('POST', `/artifacts/artifactory/getLastSuccessfulBuildV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets artifactory artifact last successful build with yaml input for expression resolution
 */
export const getLastSuccessfulBuildArtifactoryArtifactWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseArtifactoryBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildArtifactoryArtifactWithYamlQueryParams,
    ArtifactoryRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseArtifactoryBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildArtifactoryArtifactWithYamlQueryParams,
    ArtifactoryRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/artifactory/getLastSuccessfulBuildV2`, props, signal)

export interface GetImagePathsForArtifactoryQueryParams {
  connectorRef?: string
  repositoryType?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  repository: string
  fqnPath?: string
  serviceId?: string
}

export type GetImagePathsForArtifactoryProps = Omit<
  GetProps<ResponseArtifactoryImagePathsDTO, Failure | Error, GetImagePathsForArtifactoryQueryParams, void>,
  'path'
>

/**
 * Gets Image Paths details
 */
export const GetImagePathsForArtifactory = (props: GetImagePathsForArtifactoryProps) => (
  <Get<ResponseArtifactoryImagePathsDTO, Failure | Error, GetImagePathsForArtifactoryQueryParams, void>
    path={`/artifacts/artifactory/imagePaths`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetImagePathsForArtifactoryProps = Omit<
  UseGetProps<ResponseArtifactoryImagePathsDTO, Failure | Error, GetImagePathsForArtifactoryQueryParams, void>,
  'path'
>

/**
 * Gets Image Paths details
 */
export const useGetImagePathsForArtifactory = (props: UseGetImagePathsForArtifactoryProps) =>
  useGet<ResponseArtifactoryImagePathsDTO, Failure | Error, GetImagePathsForArtifactoryQueryParams, void>(
    `/artifacts/artifactory/imagePaths`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Image Paths details
 */
export const getImagePathsForArtifactoryPromise = (
  props: GetUsingFetchProps<
    ResponseArtifactoryImagePathsDTO,
    Failure | Error,
    GetImagePathsForArtifactoryQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseArtifactoryImagePathsDTO, Failure | Error, GetImagePathsForArtifactoryQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/artifactory/imagePaths`,
    props,
    signal
  )

export interface GetImagePathsForArtifactoryV2QueryParams {
  connectorRef?: string
  repositoryType?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  repository?: string
  fqnPath?: string
  serviceId?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetImagePathsForArtifactoryV2Props = Omit<
  MutateProps<
    ResponseArtifactoryImagePathsDTO,
    Failure | Error,
    GetImagePathsForArtifactoryV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Image Paths details
 */
export const GetImagePathsForArtifactoryV2 = (props: GetImagePathsForArtifactoryV2Props) => (
  <Mutate<
    ResponseArtifactoryImagePathsDTO,
    Failure | Error,
    GetImagePathsForArtifactoryV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/artifactory/imagePathsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetImagePathsForArtifactoryV2Props = Omit<
  UseMutateProps<
    ResponseArtifactoryImagePathsDTO,
    Failure | Error,
    GetImagePathsForArtifactoryV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Image Paths details
 */
export const useGetImagePathsForArtifactoryV2 = (props: UseGetImagePathsForArtifactoryV2Props) =>
  useMutate<
    ResponseArtifactoryImagePathsDTO,
    Failure | Error,
    GetImagePathsForArtifactoryV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/artifactory/imagePathsV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Image Paths details
 */
export const getImagePathsForArtifactoryV2Promise = (
  props: MutateUsingFetchProps<
    ResponseArtifactoryImagePathsDTO,
    Failure | Error,
    GetImagePathsForArtifactoryV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseArtifactoryImagePathsDTO,
    Failure | Error,
    GetImagePathsForArtifactoryV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/artifactory/imagePathsV2`, props, signal)

export interface GetRepositoriesDetailsForArtifactoryQueryParams {
  connectorRef?: string
  repositoryType?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  fqnPath?: string
  serviceId?: string
}

export type GetRepositoriesDetailsForArtifactoryProps = Omit<
  GetProps<ResponseArtifactoryRepoDetailsDTO, Failure | Error, GetRepositoriesDetailsForArtifactoryQueryParams, void>,
  'path'
>

/**
 * Gets repository details
 */
export const GetRepositoriesDetailsForArtifactory = (props: GetRepositoriesDetailsForArtifactoryProps) => (
  <Get<ResponseArtifactoryRepoDetailsDTO, Failure | Error, GetRepositoriesDetailsForArtifactoryQueryParams, void>
    path={`/artifacts/artifactory/repositoriesDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetRepositoriesDetailsForArtifactoryProps = Omit<
  UseGetProps<
    ResponseArtifactoryRepoDetailsDTO,
    Failure | Error,
    GetRepositoriesDetailsForArtifactoryQueryParams,
    void
  >,
  'path'
>

/**
 * Gets repository details
 */
export const useGetRepositoriesDetailsForArtifactory = (props: UseGetRepositoriesDetailsForArtifactoryProps) =>
  useGet<ResponseArtifactoryRepoDetailsDTO, Failure | Error, GetRepositoriesDetailsForArtifactoryQueryParams, void>(
    `/artifacts/artifactory/repositoriesDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets repository details
 */
export const getRepositoriesDetailsForArtifactoryPromise = (
  props: GetUsingFetchProps<
    ResponseArtifactoryRepoDetailsDTO,
    Failure | Error,
    GetRepositoriesDetailsForArtifactoryQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseArtifactoryRepoDetailsDTO,
    Failure | Error,
    GetRepositoriesDetailsForArtifactoryQueryParams,
    void
  >(getConfig('ng/api'), `/artifacts/artifactory/repositoriesDetails`, props, signal)

export interface GetRepositoriesDetailsV2ForArtifactoryQueryParams {
  connectorRef?: string
  repositoryType?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath?: string
  serviceId?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetRepositoriesDetailsV2ForArtifactoryProps = Omit<
  MutateProps<
    ResponseArtifactoryRepoDetailsDTO,
    Failure | Error,
    GetRepositoriesDetailsV2ForArtifactoryQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets repository details
 */
export const GetRepositoriesDetailsV2ForArtifactory = (props: GetRepositoriesDetailsV2ForArtifactoryProps) => (
  <Mutate<
    ResponseArtifactoryRepoDetailsDTO,
    Failure | Error,
    GetRepositoriesDetailsV2ForArtifactoryQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/artifactory/repositoriesDetailsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetRepositoriesDetailsV2ForArtifactoryProps = Omit<
  UseMutateProps<
    ResponseArtifactoryRepoDetailsDTO,
    Failure | Error,
    GetRepositoriesDetailsV2ForArtifactoryQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets repository details
 */
export const useGetRepositoriesDetailsV2ForArtifactory = (props: UseGetRepositoriesDetailsV2ForArtifactoryProps) =>
  useMutate<
    ResponseArtifactoryRepoDetailsDTO,
    Failure | Error,
    GetRepositoriesDetailsV2ForArtifactoryQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/artifactory/repositoriesDetailsV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets repository details
 */
export const getRepositoriesDetailsV2ForArtifactoryPromise = (
  props: MutateUsingFetchProps<
    ResponseArtifactoryRepoDetailsDTO,
    Failure | Error,
    GetRepositoriesDetailsV2ForArtifactoryQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseArtifactoryRepoDetailsDTO,
    Failure | Error,
    GetRepositoriesDetailsV2ForArtifactoryQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/artifactory/repositoriesDetailsV2`, props, signal)

export interface ValidateArtifactServerForArtifactoryQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateArtifactServerForArtifactoryProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForArtifactoryQueryParams, void>,
  'path'
>

/**
 * Validate artifactory artifact server
 */
export const ValidateArtifactServerForArtifactory = (props: ValidateArtifactServerForArtifactoryProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactServerForArtifactoryQueryParams, void>
    path={`/artifacts/artifactory/validateArtifactServer`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactServerForArtifactoryProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForArtifactoryQueryParams, void>,
  'path'
>

/**
 * Validate artifactory artifact server
 */
export const useValidateArtifactServerForArtifactory = (props: UseValidateArtifactServerForArtifactoryProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactServerForArtifactoryQueryParams, void>(
    `/artifacts/artifactory/validateArtifactServer`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate artifactory artifact server
 */
export const validateArtifactServerForArtifactoryPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForArtifactoryQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactServerForArtifactoryQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/artifactory/validateArtifactServer`,
    props,
    signal
  )

export interface ListFeedsForAzureArtifactsQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  org?: string
  project?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type ListFeedsForAzureArtifactsProps = Omit<
  GetProps<ResponseListAzureArtifactsFeed, Failure | Error, ListFeedsForAzureArtifactsQueryParams, void>,
  'path'
>

/**
 * Lists Feeds for Azure Artifacts Org or Project
 */
export const ListFeedsForAzureArtifacts = (props: ListFeedsForAzureArtifactsProps) => (
  <Get<ResponseListAzureArtifactsFeed, Failure | Error, ListFeedsForAzureArtifactsQueryParams, void>
    path={`/artifacts/azureartifacts/feeds`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListFeedsForAzureArtifactsProps = Omit<
  UseGetProps<ResponseListAzureArtifactsFeed, Failure | Error, ListFeedsForAzureArtifactsQueryParams, void>,
  'path'
>

/**
 * Lists Feeds for Azure Artifacts Org or Project
 */
export const useListFeedsForAzureArtifacts = (props: UseListFeedsForAzureArtifactsProps) =>
  useGet<ResponseListAzureArtifactsFeed, Failure | Error, ListFeedsForAzureArtifactsQueryParams, void>(
    `/artifacts/azureartifacts/feeds`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Lists Feeds for Azure Artifacts Org or Project
 */
export const listFeedsForAzureArtifactsPromise = (
  props: GetUsingFetchProps<
    ResponseListAzureArtifactsFeed,
    Failure | Error,
    ListFeedsForAzureArtifactsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListAzureArtifactsFeed, Failure | Error, ListFeedsForAzureArtifactsQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/azureartifacts/feeds`,
    props,
    signal
  )

export interface ListPackagesForAzureArtifactsQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  org?: string
  project?: string
  packageType: string
  feed: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type ListPackagesForAzureArtifactsProps = Omit<
  GetProps<ResponseListAzureArtifactsPackage, Failure | Error, ListPackagesForAzureArtifactsQueryParams, void>,
  'path'
>

/**
 * List Packages for Azure Artifacts
 */
export const ListPackagesForAzureArtifacts = (props: ListPackagesForAzureArtifactsProps) => (
  <Get<ResponseListAzureArtifactsPackage, Failure | Error, ListPackagesForAzureArtifactsQueryParams, void>
    path={`/artifacts/azureartifacts/packages`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListPackagesForAzureArtifactsProps = Omit<
  UseGetProps<ResponseListAzureArtifactsPackage, Failure | Error, ListPackagesForAzureArtifactsQueryParams, void>,
  'path'
>

/**
 * List Packages for Azure Artifacts
 */
export const useListPackagesForAzureArtifacts = (props: UseListPackagesForAzureArtifactsProps) =>
  useGet<ResponseListAzureArtifactsPackage, Failure | Error, ListPackagesForAzureArtifactsQueryParams, void>(
    `/artifacts/azureartifacts/packages`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * List Packages for Azure Artifacts
 */
export const listPackagesForAzureArtifactsPromise = (
  props: GetUsingFetchProps<
    ResponseListAzureArtifactsPackage,
    Failure | Error,
    ListPackagesForAzureArtifactsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListAzureArtifactsPackage, Failure | Error, ListPackagesForAzureArtifactsQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/azureartifacts/packages`,
    props,
    signal
  )

export interface ListProjectsForAzureArtifactsQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  org?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type ListProjectsForAzureArtifactsProps = Omit<
  GetProps<ResponseListAzureDevopsProject, Failure | Error, ListProjectsForAzureArtifactsQueryParams, void>,
  'path'
>

/**
 * List Projects for Azure Artifacts
 */
export const ListProjectsForAzureArtifacts = (props: ListProjectsForAzureArtifactsProps) => (
  <Get<ResponseListAzureDevopsProject, Failure | Error, ListProjectsForAzureArtifactsQueryParams, void>
    path={`/artifacts/azureartifacts/projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListProjectsForAzureArtifactsProps = Omit<
  UseGetProps<ResponseListAzureDevopsProject, Failure | Error, ListProjectsForAzureArtifactsQueryParams, void>,
  'path'
>

/**
 * List Projects for Azure Artifacts
 */
export const useListProjectsForAzureArtifacts = (props: UseListProjectsForAzureArtifactsProps) =>
  useGet<ResponseListAzureDevopsProject, Failure | Error, ListProjectsForAzureArtifactsQueryParams, void>(
    `/artifacts/azureartifacts/projects`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * List Projects for Azure Artifacts
 */
export const listProjectsForAzureArtifactsPromise = (
  props: GetUsingFetchProps<
    ResponseListAzureDevopsProject,
    Failure | Error,
    ListProjectsForAzureArtifactsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListAzureDevopsProject, Failure | Error, ListProjectsForAzureArtifactsQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/azureartifacts/projects`,
    props,
    signal
  )

export interface ListFeedsForAzureArtifactsWithServiceV2QueryParams {
  connectorRef?: string
  project?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath: string
  serviceId?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type ListFeedsForAzureArtifactsWithServiceV2Props = Omit<
  MutateProps<
    ResponseListAzureArtifactsFeed,
    Failure | Error,
    ListFeedsForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Lists Feeds for Azure Artifacts Org or Project
 */
export const ListFeedsForAzureArtifactsWithServiceV2 = (props: ListFeedsForAzureArtifactsWithServiceV2Props) => (
  <Mutate<
    ResponseListAzureArtifactsFeed,
    Failure | Error,
    ListFeedsForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/azureartifacts/v2/feeds`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListFeedsForAzureArtifactsWithServiceV2Props = Omit<
  UseMutateProps<
    ResponseListAzureArtifactsFeed,
    Failure | Error,
    ListFeedsForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Lists Feeds for Azure Artifacts Org or Project
 */
export const useListFeedsForAzureArtifactsWithServiceV2 = (props: UseListFeedsForAzureArtifactsWithServiceV2Props) =>
  useMutate<
    ResponseListAzureArtifactsFeed,
    Failure | Error,
    ListFeedsForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/azureartifacts/v2/feeds`, { base: getConfig('ng/api'), ...props })

/**
 * Lists Feeds for Azure Artifacts Org or Project
 */
export const listFeedsForAzureArtifactsWithServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseListAzureArtifactsFeed,
    Failure | Error,
    ListFeedsForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListAzureArtifactsFeed,
    Failure | Error,
    ListFeedsForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/azureartifacts/v2/feeds`, props, signal)

export interface ListPackagesForAzureArtifactsWithServiceV2QueryParams {
  connectorRef?: string
  project?: string
  packageType?: string
  feed?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath: string
  serviceId?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type ListPackagesForAzureArtifactsWithServiceV2Props = Omit<
  MutateProps<
    ResponseListAzureArtifactsPackage,
    Failure | Error,
    ListPackagesForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * List Packages for Azure Artifacts
 */
export const ListPackagesForAzureArtifactsWithServiceV2 = (props: ListPackagesForAzureArtifactsWithServiceV2Props) => (
  <Mutate<
    ResponseListAzureArtifactsPackage,
    Failure | Error,
    ListPackagesForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/azureartifacts/v2/packages`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListPackagesForAzureArtifactsWithServiceV2Props = Omit<
  UseMutateProps<
    ResponseListAzureArtifactsPackage,
    Failure | Error,
    ListPackagesForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * List Packages for Azure Artifacts
 */
export const useListPackagesForAzureArtifactsWithServiceV2 = (
  props: UseListPackagesForAzureArtifactsWithServiceV2Props
) =>
  useMutate<
    ResponseListAzureArtifactsPackage,
    Failure | Error,
    ListPackagesForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/azureartifacts/v2/packages`, { base: getConfig('ng/api'), ...props })

/**
 * List Packages for Azure Artifacts
 */
export const listPackagesForAzureArtifactsWithServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseListAzureArtifactsPackage,
    Failure | Error,
    ListPackagesForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListAzureArtifactsPackage,
    Failure | Error,
    ListPackagesForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/azureartifacts/v2/packages`, props, signal)

export interface ListProjectsForAzureArtifactsWithServiceV2QueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath: string
  serviceId?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type ListProjectsForAzureArtifactsWithServiceV2Props = Omit<
  MutateProps<
    ResponseListAzureDevopsProject,
    Failure | Error,
    ListProjectsForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * List Projects for Azure Artifacts
 */
export const ListProjectsForAzureArtifactsWithServiceV2 = (props: ListProjectsForAzureArtifactsWithServiceV2Props) => (
  <Mutate<
    ResponseListAzureDevopsProject,
    Failure | Error,
    ListProjectsForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/azureartifacts/v2/projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListProjectsForAzureArtifactsWithServiceV2Props = Omit<
  UseMutateProps<
    ResponseListAzureDevopsProject,
    Failure | Error,
    ListProjectsForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * List Projects for Azure Artifacts
 */
export const useListProjectsForAzureArtifactsWithServiceV2 = (
  props: UseListProjectsForAzureArtifactsWithServiceV2Props
) =>
  useMutate<
    ResponseListAzureDevopsProject,
    Failure | Error,
    ListProjectsForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/azureartifacts/v2/projects`, { base: getConfig('ng/api'), ...props })

/**
 * List Projects for Azure Artifacts
 */
export const listProjectsForAzureArtifactsWithServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseListAzureDevopsProject,
    Failure | Error,
    ListProjectsForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListAzureDevopsProject,
    Failure | Error,
    ListProjectsForAzureArtifactsWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/azureartifacts/v2/projects`, props, signal)

export interface GetVersionFromPackageWithServiceV2QueryParams {
  connectorRef?: string
  project?: string
  package?: string
  packageType?: string
  version?: string
  versionRegex?: string
  feed?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath: string
  serviceId?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetVersionFromPackageWithServiceV2Props = Omit<
  MutateProps<
    ResponseBuildDetails,
    Failure | Error,
    GetVersionFromPackageWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Version from Packages
 */
export const GetVersionFromPackageWithServiceV2 = (props: GetVersionFromPackageWithServiceV2Props) => (
  <Mutate<
    ResponseBuildDetails,
    Failure | Error,
    GetVersionFromPackageWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/azureartifacts/v2/version`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetVersionFromPackageWithServiceV2Props = Omit<
  UseMutateProps<
    ResponseBuildDetails,
    Failure | Error,
    GetVersionFromPackageWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Version from Packages
 */
export const useGetVersionFromPackageWithServiceV2 = (props: UseGetVersionFromPackageWithServiceV2Props) =>
  useMutate<
    ResponseBuildDetails,
    Failure | Error,
    GetVersionFromPackageWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/azureartifacts/v2/version`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Version from Packages
 */
export const getVersionFromPackageWithServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseBuildDetails,
    Failure | Error,
    GetVersionFromPackageWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBuildDetails,
    Failure | Error,
    GetVersionFromPackageWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/azureartifacts/v2/version`, props, signal)

export interface ListVersionsFromPackageWithServiceV2QueryParams {
  connectorRef?: string
  project?: string
  package?: string
  packageType?: string
  versionRegex?: string
  feed?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath: string
  serviceId?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type ListVersionsFromPackageWithServiceV2Props = Omit<
  MutateProps<
    ResponseListBuildDetails,
    Failure | Error,
    ListVersionsFromPackageWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * List Versions from Package
 */
export const ListVersionsFromPackageWithServiceV2 = (props: ListVersionsFromPackageWithServiceV2Props) => (
  <Mutate<
    ResponseListBuildDetails,
    Failure | Error,
    ListVersionsFromPackageWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/azureartifacts/v2/versions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListVersionsFromPackageWithServiceV2Props = Omit<
  UseMutateProps<
    ResponseListBuildDetails,
    Failure | Error,
    ListVersionsFromPackageWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * List Versions from Package
 */
export const useListVersionsFromPackageWithServiceV2 = (props: UseListVersionsFromPackageWithServiceV2Props) =>
  useMutate<
    ResponseListBuildDetails,
    Failure | Error,
    ListVersionsFromPackageWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/azureartifacts/v2/versions`, { base: getConfig('ng/api'), ...props })

/**
 * List Versions from Package
 */
export const listVersionsFromPackageWithServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseListBuildDetails,
    Failure | Error,
    ListVersionsFromPackageWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListBuildDetails,
    Failure | Error,
    ListVersionsFromPackageWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/azureartifacts/v2/versions`, props, signal)

export interface GetVersionFromPackageQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  org?: string
  project?: string
  package: string
  packageType: string
  version?: string
  versionRegex?: string
  feed: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetVersionFromPackageProps = Omit<
  GetProps<ResponseBuildDetails, Failure | Error, GetVersionFromPackageQueryParams, void>,
  'path'
>

/**
 * Gets Version from Packages
 */
export const GetVersionFromPackage = (props: GetVersionFromPackageProps) => (
  <Get<ResponseBuildDetails, Failure | Error, GetVersionFromPackageQueryParams, void>
    path={`/artifacts/azureartifacts/version`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetVersionFromPackageProps = Omit<
  UseGetProps<ResponseBuildDetails, Failure | Error, GetVersionFromPackageQueryParams, void>,
  'path'
>

/**
 * Gets Version from Packages
 */
export const useGetVersionFromPackage = (props: UseGetVersionFromPackageProps) =>
  useGet<ResponseBuildDetails, Failure | Error, GetVersionFromPackageQueryParams, void>(
    `/artifacts/azureartifacts/version`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Version from Packages
 */
export const getVersionFromPackagePromise = (
  props: GetUsingFetchProps<ResponseBuildDetails, Failure | Error, GetVersionFromPackageQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBuildDetails, Failure | Error, GetVersionFromPackageQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/azureartifacts/version`,
    props,
    signal
  )

export interface ListVersionsFromPackageQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  org?: string
  project?: string
  package: string
  packageType: string
  versionRegex?: string
  feed: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type ListVersionsFromPackageProps = Omit<
  GetProps<ResponseListBuildDetails, Failure | Error, ListVersionsFromPackageQueryParams, void>,
  'path'
>

/**
 * List Versions from Package
 */
export const ListVersionsFromPackage = (props: ListVersionsFromPackageProps) => (
  <Get<ResponseListBuildDetails, Failure | Error, ListVersionsFromPackageQueryParams, void>
    path={`/artifacts/azureartifacts/versions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListVersionsFromPackageProps = Omit<
  UseGetProps<ResponseListBuildDetails, Failure | Error, ListVersionsFromPackageQueryParams, void>,
  'path'
>

/**
 * List Versions from Package
 */
export const useListVersionsFromPackage = (props: UseListVersionsFromPackageProps) =>
  useGet<ResponseListBuildDetails, Failure | Error, ListVersionsFromPackageQueryParams, void>(
    `/artifacts/azureartifacts/versions`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * List Versions from Package
 */
export const listVersionsFromPackagePromise = (
  props: GetUsingFetchProps<ResponseListBuildDetails, Failure | Error, ListVersionsFromPackageQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListBuildDetails, Failure | Error, ListVersionsFromPackageQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/azureartifacts/versions`,
    props,
    signal
  )

export interface GetBuildsForBambooQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  planName?: string
  artifactPath?: string[]
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  fqnPath?: string
  serviceId?: string
}

export type GetBuildsForBambooProps = Omit<
  MutateProps<
    ResponseListBuildDetails,
    Failure | Error,
    GetBuildsForBambooQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Builds details for Bamboo
 */
export const GetBuildsForBamboo = (props: GetBuildsForBambooProps) => (
  <Mutate<
    ResponseListBuildDetails,
    Failure | Error,
    GetBuildsForBambooQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/bamboo/builds`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildsForBambooProps = Omit<
  UseMutateProps<
    ResponseListBuildDetails,
    Failure | Error,
    GetBuildsForBambooQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Builds details for Bamboo
 */
export const useGetBuildsForBamboo = (props: UseGetBuildsForBambooProps) =>
  useMutate<
    ResponseListBuildDetails,
    Failure | Error,
    GetBuildsForBambooQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/bamboo/builds`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Builds details for Bamboo
 */
export const getBuildsForBambooPromise = (
  props: MutateUsingFetchProps<
    ResponseListBuildDetails,
    Failure | Error,
    GetBuildsForBambooQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListBuildDetails,
    Failure | Error,
    GetBuildsForBambooQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/bamboo/builds`, props, signal)

export interface GetArtifactPathsForBambooQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  planName?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  fqnPath?: string
  serviceId?: string
}

export type GetArtifactPathsForBambooProps = Omit<
  MutateProps<
    ResponseListString,
    Failure | Error,
    GetArtifactPathsForBambooQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Artifact Paths for Bamboo
 */
export const GetArtifactPathsForBamboo = (props: GetArtifactPathsForBambooProps) => (
  <Mutate<
    ResponseListString,
    Failure | Error,
    GetArtifactPathsForBambooQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/bamboo/paths`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetArtifactPathsForBambooProps = Omit<
  UseMutateProps<
    ResponseListString,
    Failure | Error,
    GetArtifactPathsForBambooQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Artifact Paths for Bamboo
 */
export const useGetArtifactPathsForBamboo = (props: UseGetArtifactPathsForBambooProps) =>
  useMutate<
    ResponseListString,
    Failure | Error,
    GetArtifactPathsForBambooQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/bamboo/paths`, { base: getConfig('ng/api'), ...props })

/**
 * Get Artifact Paths for Bamboo
 */
export const getArtifactPathsForBambooPromise = (
  props: MutateUsingFetchProps<
    ResponseListString,
    Failure | Error,
    GetArtifactPathsForBambooQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListString,
    Failure | Error,
    GetArtifactPathsForBambooQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/bamboo/paths`, props, signal)

export interface GetPlansKeyQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  fqnPath?: string
  serviceId?: string
}

export type GetPlansKeyProps = Omit<
  MutateProps<
    ResponseBambooPlanKeysDTO,
    Failure | Error,
    GetPlansKeyQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Plan Keys for Bamboo
 */
export const GetPlansKey = (props: GetPlansKeyProps) => (
  <Mutate<
    ResponseBambooPlanKeysDTO,
    Failure | Error,
    GetPlansKeyQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/bamboo/plans`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPlansKeyProps = Omit<
  UseMutateProps<
    ResponseBambooPlanKeysDTO,
    Failure | Error,
    GetPlansKeyQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Plan Keys for Bamboo
 */
export const useGetPlansKey = (props: UseGetPlansKeyProps) =>
  useMutate<
    ResponseBambooPlanKeysDTO,
    Failure | Error,
    GetPlansKeyQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/bamboo/plans`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Plan Keys for Bamboo
 */
export const getPlansKeyPromise = (
  props: MutateUsingFetchProps<
    ResponseBambooPlanKeysDTO,
    Failure | Error,
    GetPlansKeyQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBambooPlanKeysDTO,
    Failure | Error,
    GetPlansKeyQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/bamboo/plans`, props, signal)

export interface GetJobDetailsForCustomQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  versionPath: string
  arrayPath: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  fqnPath?: string
  serviceId?: string
}

export type GetJobDetailsForCustomProps = Omit<
  MutateProps<ResponseListBuildDetails, Failure | Error, GetJobDetailsForCustomQueryParams, CustomScriptInfo, void>,
  'path' | 'verb'
>

/**
 * Gets Job details for Custom Artifact
 */
export const GetJobDetailsForCustom = (props: GetJobDetailsForCustomProps) => (
  <Mutate<ResponseListBuildDetails, Failure | Error, GetJobDetailsForCustomQueryParams, CustomScriptInfo, void>
    verb="POST"
    path={`/artifacts/custom/builds`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJobDetailsForCustomProps = Omit<
  UseMutateProps<ResponseListBuildDetails, Failure | Error, GetJobDetailsForCustomQueryParams, CustomScriptInfo, void>,
  'path' | 'verb'
>

/**
 * Gets Job details for Custom Artifact
 */
export const useGetJobDetailsForCustom = (props: UseGetJobDetailsForCustomProps) =>
  useMutate<ResponseListBuildDetails, Failure | Error, GetJobDetailsForCustomQueryParams, CustomScriptInfo, void>(
    'POST',
    `/artifacts/custom/builds`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Job details for Custom Artifact
 */
export const getJobDetailsForCustomPromise = (
  props: MutateUsingFetchProps<
    ResponseListBuildDetails,
    Failure | Error,
    GetJobDetailsForCustomQueryParams,
    CustomScriptInfo,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListBuildDetails,
    Failure | Error,
    GetJobDetailsForCustomQueryParams,
    CustomScriptInfo,
    void
  >('POST', getConfig('ng/api'), `/artifacts/custom/builds`, props, signal)

export interface GetBuildDetailsForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetBuildDetailsForDockerProps = Omit<
  GetProps<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>,
  'path'
>

/**
 * Gets docker build details
 */
export const GetBuildDetailsForDocker = (props: GetBuildDetailsForDockerProps) => (
  <Get<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>
    path={`/artifacts/docker/getBuildDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForDockerProps = Omit<
  UseGetProps<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>,
  'path'
>

/**
 * Gets docker build details
 */
export const useGetBuildDetailsForDocker = (props: UseGetBuildDetailsForDockerProps) =>
  useGet<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>(
    `/artifacts/docker/getBuildDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets docker build details
 */
export const getBuildDetailsForDockerPromise = (
  props: GetUsingFetchProps<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/docker/getBuildDetails`,
    props,
    signal
  )

export interface GetBuildDetailsForDockerWithYamlQueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  tagInput?: string
  fqnPath: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  serviceId?: string
}

export type GetBuildDetailsForDockerWithYamlProps = Omit<
  MutateProps<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetBuildDetailsForDockerWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker build details with yaml input for expression resolution
 */
export const GetBuildDetailsForDockerWithYaml = (props: GetBuildDetailsForDockerWithYamlProps) => (
  <Mutate<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetBuildDetailsForDockerWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/docker/getBuildDetailsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForDockerWithYamlProps = Omit<
  UseMutateProps<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetBuildDetailsForDockerWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker build details with yaml input for expression resolution
 */
export const useGetBuildDetailsForDockerWithYaml = (props: UseGetBuildDetailsForDockerWithYamlProps) =>
  useMutate<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetBuildDetailsForDockerWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/docker/getBuildDetailsV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets docker build details with yaml input for expression resolution
 */
export const getBuildDetailsForDockerWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetBuildDetailsForDockerWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetBuildDetailsForDockerWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/docker/getBuildDetailsV2`, props, signal)

export interface GetLabelsForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetLabelsForDockerProps = Omit<
  MutateProps<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker labels
 */
export const GetLabelsForDocker = (props: GetLabelsForDockerProps) => (
  <Mutate<ResponseDockerResponseDTO, Failure | Error, GetLabelsForDockerQueryParams, DockerRequestDTORequestBody, void>
    verb="POST"
    path={`/artifacts/docker/getLabels`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLabelsForDockerProps = Omit<
  UseMutateProps<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker labels
 */
export const useGetLabelsForDocker = (props: UseGetLabelsForDockerProps) =>
  useMutate<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', `/artifacts/docker/getLabels`, { base: getConfig('ng/api'), ...props })

/**
 * Gets docker labels
 */
export const getLabelsForDockerPromise = (
  props: MutateUsingFetchProps<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/docker/getLabels`, props, signal)

export interface GetLastSuccessfulBuildForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetLastSuccessfulBuildForDockerProps = Omit<
  MutateProps<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker last successful build
 */
export const GetLastSuccessfulBuildForDocker = (props: GetLastSuccessfulBuildForDockerProps) => (
  <Mutate<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/docker/getLastSuccessfulBuild`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForDockerProps = Omit<
  UseMutateProps<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker last successful build
 */
export const useGetLastSuccessfulBuildForDocker = (props: UseGetLastSuccessfulBuildForDockerProps) =>
  useMutate<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', `/artifacts/docker/getLastSuccessfulBuild`, { base: getConfig('ng/api'), ...props })

/**
 * Gets docker last successful build
 */
export const getLastSuccessfulBuildForDockerPromise = (
  props: MutateUsingFetchProps<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/docker/getLastSuccessfulBuild`, props, signal)

export interface GetLastSuccessfulBuildForDockerWithYamlQueryParams {
  imagePath?: string
  connectorRef?: string
  tag?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  serviceId?: string
}

export type GetLastSuccessfulBuildForDockerWithYamlProps = Omit<
  MutateProps<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerWithYamlQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker last successful build with yaml input for expression resolution
 */
export const GetLastSuccessfulBuildForDockerWithYaml = (props: GetLastSuccessfulBuildForDockerWithYamlProps) => (
  <Mutate<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerWithYamlQueryParams,
    DockerRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/docker/getLastSuccessfulBuildV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForDockerWithYamlProps = Omit<
  UseMutateProps<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerWithYamlQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker last successful build with yaml input for expression resolution
 */
export const useGetLastSuccessfulBuildForDockerWithYaml = (props: UseGetLastSuccessfulBuildForDockerWithYamlProps) =>
  useMutate<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerWithYamlQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', `/artifacts/docker/getLastSuccessfulBuildV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets docker last successful build with yaml input for expression resolution
 */
export const getLastSuccessfulBuildForDockerWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerWithYamlQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerWithYamlQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/docker/getLastSuccessfulBuildV2`, props, signal)

export interface ValidateArtifactForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateArtifactForDockerProps = Omit<
  MutateProps<
    ResponseBoolean,
    Failure | Error,
    ValidateArtifactForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate docker artifact with tag/tagregx if given
 */
export const ValidateArtifactForDocker = (props: ValidateArtifactForDockerProps) => (
  <Mutate<ResponseBoolean, Failure | Error, ValidateArtifactForDockerQueryParams, DockerRequestDTORequestBody, void>
    verb="POST"
    path={`/artifacts/docker/validateArtifact`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactForDockerProps = Omit<
  UseMutateProps<
    ResponseBoolean,
    Failure | Error,
    ValidateArtifactForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate docker artifact with tag/tagregx if given
 */
export const useValidateArtifactForDocker = (props: UseValidateArtifactForDockerProps) =>
  useMutate<ResponseBoolean, Failure | Error, ValidateArtifactForDockerQueryParams, DockerRequestDTORequestBody, void>(
    'POST',
    `/artifacts/docker/validateArtifact`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate docker artifact with tag/tagregx if given
 */
export const validateArtifactForDockerPromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    ValidateArtifactForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    Failure | Error,
    ValidateArtifactForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/docker/validateArtifact`, props, signal)

export interface ValidateArtifactServerForDockerQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateArtifactServerForDockerProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker artifact server
 */
export const ValidateArtifactServerForDocker = (props: ValidateArtifactServerForDockerProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>
    path={`/artifacts/docker/validateArtifactServer`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactServerForDockerProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker artifact server
 */
export const useValidateArtifactServerForDocker = (props: UseValidateArtifactServerForDockerProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>(
    `/artifacts/docker/validateArtifactServer`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate docker artifact server
 */
export const validateArtifactServerForDockerPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/docker/validateArtifactServer`,
    props,
    signal
  )

export interface ValidateArtifactImageForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateArtifactImageForDockerProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker image
 */
export const ValidateArtifactImageForDocker = (props: ValidateArtifactImageForDockerProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>
    path={`/artifacts/docker/validateArtifactSource`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactImageForDockerProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker image
 */
export const useValidateArtifactImageForDocker = (props: UseValidateArtifactImageForDockerProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>(
    `/artifacts/docker/validateArtifactSource`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate docker image
 */
export const validateArtifactImageForDockerPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/docker/validateArtifactSource`,
    props,
    signal
  )

export interface GetBuildDetailsForEcrQueryParams {
  registryId?: string
  imagePath: string
  region: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetBuildDetailsForEcrProps = Omit<
  GetProps<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>,
  'path'
>

/**
 * Gets ecr build details
 */
export const GetBuildDetailsForEcr = (props: GetBuildDetailsForEcrProps) => (
  <Get<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>
    path={`/artifacts/ecr/getBuildDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForEcrProps = Omit<
  UseGetProps<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>,
  'path'
>

/**
 * Gets ecr build details
 */
export const useGetBuildDetailsForEcr = (props: UseGetBuildDetailsForEcrProps) =>
  useGet<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>(
    `/artifacts/ecr/getBuildDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets ecr build details
 */
export const getBuildDetailsForEcrPromise = (
  props: GetUsingFetchProps<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/ecr/getBuildDetails`,
    props,
    signal
  )

export interface GetBuildDetailsForEcrWithYamlQueryParams {
  registryId?: string
  imagePath?: string
  region?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  serviceId?: string
}

export type GetBuildDetailsForEcrWithYamlProps = Omit<
  MutateProps<
    ResponseEcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForEcrWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ecr build details with yaml expression
 */
export const GetBuildDetailsForEcrWithYaml = (props: GetBuildDetailsForEcrWithYamlProps) => (
  <Mutate<
    ResponseEcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForEcrWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/ecr/getBuildDetailsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForEcrWithYamlProps = Omit<
  UseMutateProps<
    ResponseEcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForEcrWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ecr build details with yaml expression
 */
export const useGetBuildDetailsForEcrWithYaml = (props: UseGetBuildDetailsForEcrWithYamlProps) =>
  useMutate<
    ResponseEcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForEcrWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', `/artifacts/ecr/getBuildDetailsV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets ecr build details with yaml expression
 */
export const getBuildDetailsForEcrWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseEcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForEcrWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForEcrWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/ecr/getBuildDetailsV2`, props, signal)

export interface GetImagesListForEcrQueryParams {
  registryId?: string
  region?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  fqnPath?: string
  pipelineIdentifier?: string
  serviceId?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  projectIdentifier?: string
}

export type GetImagesListForEcrProps = Omit<
  MutateProps<
    ResponseEcrListImagesDTO,
    Failure | Error,
    GetImagesListForEcrQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ecr images
 */
export const GetImagesListForEcr = (props: GetImagesListForEcrProps) => (
  <Mutate<
    ResponseEcrListImagesDTO,
    Failure | Error,
    GetImagesListForEcrQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/ecr/getImages`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetImagesListForEcrProps = Omit<
  UseMutateProps<
    ResponseEcrListImagesDTO,
    Failure | Error,
    GetImagesListForEcrQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ecr images
 */
export const useGetImagesListForEcr = (props: UseGetImagesListForEcrProps) =>
  useMutate<
    ResponseEcrListImagesDTO,
    Failure | Error,
    GetImagesListForEcrQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', `/artifacts/ecr/getImages`, { base: getConfig('ng/api'), ...props })

/**
 * Gets ecr images
 */
export const getImagesListForEcrPromise = (
  props: MutateUsingFetchProps<
    ResponseEcrListImagesDTO,
    Failure | Error,
    GetImagesListForEcrQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEcrListImagesDTO,
    Failure | Error,
    GetImagesListForEcrQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/ecr/getImages`, props, signal)

export interface GetLastSuccessfulBuildForEcrQueryParams {
  registryId?: string
  imagePath: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetLastSuccessfulBuildForEcrProps = Omit<
  MutateProps<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ecr last successful build
 */
export const GetLastSuccessfulBuildForEcr = (props: GetLastSuccessfulBuildForEcrProps) => (
  <Mutate<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/ecr/getLastSuccessfulBuild`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForEcrProps = Omit<
  UseMutateProps<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ecr last successful build
 */
export const useGetLastSuccessfulBuildForEcr = (props: UseGetLastSuccessfulBuildForEcrProps) =>
  useMutate<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >('POST', `/artifacts/ecr/getLastSuccessfulBuild`, { base: getConfig('ng/api'), ...props })

/**
 * Gets ecr last successful build
 */
export const getLastSuccessfulBuildForEcrPromise = (
  props: MutateUsingFetchProps<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/ecr/getLastSuccessfulBuild`, props, signal)

export interface GetLastSuccessfulBuildForEcrWithYamlQueryParams {
  registryId?: string
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  fqnPath: string
  serviceId?: string
  pipelineIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetLastSuccessfulBuildForEcrWithYamlProps = Omit<
  MutateProps<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrWithYamlQueryParams,
    EcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ecr last successful build with yaml expression
 */
export const GetLastSuccessfulBuildForEcrWithYaml = (props: GetLastSuccessfulBuildForEcrWithYamlProps) => (
  <Mutate<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrWithYamlQueryParams,
    EcrRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/ecr/getLastSuccessfulBuildV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForEcrWithYamlProps = Omit<
  UseMutateProps<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrWithYamlQueryParams,
    EcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ecr last successful build with yaml expression
 */
export const useGetLastSuccessfulBuildForEcrWithYaml = (props: UseGetLastSuccessfulBuildForEcrWithYamlProps) =>
  useMutate<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrWithYamlQueryParams,
    EcrRequestDTORequestBody,
    void
  >('POST', `/artifacts/ecr/getLastSuccessfulBuildV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets ecr last successful build with yaml expression
 */
export const getLastSuccessfulBuildForEcrWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrWithYamlQueryParams,
    EcrRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrWithYamlQueryParams,
    EcrRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/ecr/getLastSuccessfulBuildV2`, props, signal)

export interface ValidateArtifactForEcrQueryParams {
  registryId?: string
  imagePath: string
  region: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateArtifactForEcrProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, ValidateArtifactForEcrQueryParams, EcrRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Validate Ecr Artifact
 */
export const ValidateArtifactForEcr = (props: ValidateArtifactForEcrProps) => (
  <Mutate<ResponseBoolean, Failure | Error, ValidateArtifactForEcrQueryParams, EcrRequestDTORequestBody, void>
    verb="POST"
    path={`/artifacts/ecr/validateArtifact`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactForEcrProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, ValidateArtifactForEcrQueryParams, EcrRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Validate Ecr Artifact
 */
export const useValidateArtifactForEcr = (props: UseValidateArtifactForEcrProps) =>
  useMutate<ResponseBoolean, Failure | Error, ValidateArtifactForEcrQueryParams, EcrRequestDTORequestBody, void>(
    'POST',
    `/artifacts/ecr/validateArtifact`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate Ecr Artifact
 */
export const validateArtifactForEcrPromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    ValidateArtifactForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactForEcrQueryParams, EcrRequestDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/artifacts/ecr/validateArtifact`,
    props,
    signal
  )

export interface ValidateArtifactServerForEcrQueryParams {
  registryId?: string
  imagePath: string
  connectorRef: string
  region: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateArtifactServerForEcrProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>,
  'path'
>

/**
 * Validate ecr artifact server
 */
export const ValidateArtifactServerForEcr = (props: ValidateArtifactServerForEcrProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>
    path={`/artifacts/ecr/validateArtifactServer`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactServerForEcrProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>,
  'path'
>

/**
 * Validate ecr artifact server
 */
export const useValidateArtifactServerForEcr = (props: UseValidateArtifactServerForEcrProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>(
    `/artifacts/ecr/validateArtifactServer`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate ecr artifact server
 */
export const validateArtifactServerForEcrPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/ecr/validateArtifactServer`,
    props,
    signal
  )

export interface ValidateArtifactImageForEcrQueryParams {
  registryId?: string
  imagePath: string
  region: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateArtifactImageForEcrProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>,
  'path'
>

/**
 * Validate Ecr image
 */
export const ValidateArtifactImageForEcr = (props: ValidateArtifactImageForEcrProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>
    path={`/artifacts/ecr/validateArtifactSource`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactImageForEcrProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>,
  'path'
>

/**
 * Validate Ecr image
 */
export const useValidateArtifactImageForEcr = (props: UseValidateArtifactImageForEcrProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>(
    `/artifacts/ecr/validateArtifactSource`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate Ecr image
 */
export const validateArtifactImageForEcrPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/ecr/validateArtifactSource`,
    props,
    signal
  )

export interface GetBuildDetailsForGoogleArtifactRegistryQueryParams {
  connectorRef?: string
  region?: string
  repositoryName?: string
  project?: string
  package?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  version?: string
  versionRegex?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetBuildDetailsForGoogleArtifactRegistryProps = Omit<
  GetProps<ResponseGARResponseDTO, Failure | Error, GetBuildDetailsForGoogleArtifactRegistryQueryParams, void>,
  'path'
>

/**
 * Gets google artifact registry build details
 */
export const GetBuildDetailsForGoogleArtifactRegistry = (props: GetBuildDetailsForGoogleArtifactRegistryProps) => (
  <Get<ResponseGARResponseDTO, Failure | Error, GetBuildDetailsForGoogleArtifactRegistryQueryParams, void>
    path={`/artifacts/gar/getBuildDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForGoogleArtifactRegistryProps = Omit<
  UseGetProps<ResponseGARResponseDTO, Failure | Error, GetBuildDetailsForGoogleArtifactRegistryQueryParams, void>,
  'path'
>

/**
 * Gets google artifact registry build details
 */
export const useGetBuildDetailsForGoogleArtifactRegistry = (props: UseGetBuildDetailsForGoogleArtifactRegistryProps) =>
  useGet<ResponseGARResponseDTO, Failure | Error, GetBuildDetailsForGoogleArtifactRegistryQueryParams, void>(
    `/artifacts/gar/getBuildDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets google artifact registry build details
 */
export const getBuildDetailsForGoogleArtifactRegistryPromise = (
  props: GetUsingFetchProps<
    ResponseGARResponseDTO,
    Failure | Error,
    GetBuildDetailsForGoogleArtifactRegistryQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGARResponseDTO, Failure | Error, GetBuildDetailsForGoogleArtifactRegistryQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/gar/getBuildDetails`,
    props,
    signal
  )

export interface GetLastSuccessfulBuildForGoogleArtifactRegistryQueryParams {
  connectorRef?: string
  region?: string
  repositoryName?: string
  project?: string
  package?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetLastSuccessfulBuildForGoogleArtifactRegistryProps = Omit<
  MutateProps<
    ResponseGARBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGoogleArtifactRegistryQueryParams,
    GarRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets google artifact registry last successful build
 */
export const GetLastSuccessfulBuildForGoogleArtifactRegistry = (
  props: GetLastSuccessfulBuildForGoogleArtifactRegistryProps
) => (
  <Mutate<
    ResponseGARBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGoogleArtifactRegistryQueryParams,
    GarRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/gar/getLastSuccessfulBuild`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForGoogleArtifactRegistryProps = Omit<
  UseMutateProps<
    ResponseGARBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGoogleArtifactRegistryQueryParams,
    GarRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets google artifact registry last successful build
 */
export const useGetLastSuccessfulBuildForGoogleArtifactRegistry = (
  props: UseGetLastSuccessfulBuildForGoogleArtifactRegistryProps
) =>
  useMutate<
    ResponseGARBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGoogleArtifactRegistryQueryParams,
    GarRequestDTORequestBody,
    void
  >('POST', `/artifacts/gar/getLastSuccessfulBuild`, { base: getConfig('ng/api'), ...props })

/**
 * Gets google artifact registry last successful build
 */
export const getLastSuccessfulBuildForGoogleArtifactRegistryPromise = (
  props: MutateUsingFetchProps<
    ResponseGARBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGoogleArtifactRegistryQueryParams,
    GarRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGARBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGoogleArtifactRegistryQueryParams,
    GarRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/gar/getLastSuccessfulBuild`, props, signal)

export type GetRegionsForGoogleArtifactRegistryProps = Omit<
  GetProps<ResponseListRegionGar, Failure | Error, void, void>,
  'path'
>

/**
 * Gets google artifact registry regions
 */
export const GetRegionsForGoogleArtifactRegistry = (props: GetRegionsForGoogleArtifactRegistryProps) => (
  <Get<ResponseListRegionGar, Failure | Error, void, void>
    path={`/artifacts/gar/getRegions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetRegionsForGoogleArtifactRegistryProps = Omit<
  UseGetProps<ResponseListRegionGar, Failure | Error, void, void>,
  'path'
>

/**
 * Gets google artifact registry regions
 */
export const useGetRegionsForGoogleArtifactRegistry = (props: UseGetRegionsForGoogleArtifactRegistryProps) =>
  useGet<ResponseListRegionGar, Failure | Error, void, void>(`/artifacts/gar/getRegions`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets google artifact registry regions
 */
export const getRegionsForGoogleArtifactRegistryPromise = (
  props: GetUsingFetchProps<ResponseListRegionGar, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListRegionGar, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/artifacts/gar/getRegions`,
    props,
    signal
  )

export interface GetBuildDetailsForGoogleArtifactRegistryV2QueryParams {
  connectorRef?: string
  region?: string
  repositoryName?: string
  project?: string
  package?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  version?: string
  versionRegex?: string
  fqnPath: string
  serviceId?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetBuildDetailsForGoogleArtifactRegistryV2Props = Omit<
  MutateProps<
    ResponseGARResponseDTO,
    Failure | Error,
    GetBuildDetailsForGoogleArtifactRegistryV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets google artifact registry build details v2
 */
export const GetBuildDetailsForGoogleArtifactRegistryV2 = (props: GetBuildDetailsForGoogleArtifactRegistryV2Props) => (
  <Mutate<
    ResponseGARResponseDTO,
    Failure | Error,
    GetBuildDetailsForGoogleArtifactRegistryV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/gar/v2/getBuildDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForGoogleArtifactRegistryV2Props = Omit<
  UseMutateProps<
    ResponseGARResponseDTO,
    Failure | Error,
    GetBuildDetailsForGoogleArtifactRegistryV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets google artifact registry build details v2
 */
export const useGetBuildDetailsForGoogleArtifactRegistryV2 = (
  props: UseGetBuildDetailsForGoogleArtifactRegistryV2Props
) =>
  useMutate<
    ResponseGARResponseDTO,
    Failure | Error,
    GetBuildDetailsForGoogleArtifactRegistryV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/gar/v2/getBuildDetails`, { base: getConfig('ng/api'), ...props })

/**
 * Gets google artifact registry build details v2
 */
export const getBuildDetailsForGoogleArtifactRegistryV2Promise = (
  props: MutateUsingFetchProps<
    ResponseGARResponseDTO,
    Failure | Error,
    GetBuildDetailsForGoogleArtifactRegistryV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGARResponseDTO,
    Failure | Error,
    GetBuildDetailsForGoogleArtifactRegistryV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/gar/v2/getBuildDetails`, props, signal)

export interface GetLastSuccessfulBuildForGoogleArtifactRegistryV2QueryParams {
  connectorRef?: string
  region?: string
  repositoryName?: string
  project?: string
  package?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath: string
  serviceId?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetLastSuccessfulBuildForGoogleArtifactRegistryV2Props = Omit<
  MutateProps<
    ResponseGARBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGoogleArtifactRegistryV2QueryParams,
    GarRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets google artifact registry last successful build v2
 */
export const GetLastSuccessfulBuildForGoogleArtifactRegistryV2 = (
  props: GetLastSuccessfulBuildForGoogleArtifactRegistryV2Props
) => (
  <Mutate<
    ResponseGARBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGoogleArtifactRegistryV2QueryParams,
    GarRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/gar/v2/getLastSuccessfulBuild`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForGoogleArtifactRegistryV2Props = Omit<
  UseMutateProps<
    ResponseGARBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGoogleArtifactRegistryV2QueryParams,
    GarRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets google artifact registry last successful build v2
 */
export const useGetLastSuccessfulBuildForGoogleArtifactRegistryV2 = (
  props: UseGetLastSuccessfulBuildForGoogleArtifactRegistryV2Props
) =>
  useMutate<
    ResponseGARBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGoogleArtifactRegistryV2QueryParams,
    GarRequestDTORequestBody,
    void
  >('POST', `/artifacts/gar/v2/getLastSuccessfulBuild`, { base: getConfig('ng/api'), ...props })

/**
 * Gets google artifact registry last successful build v2
 */
export const getLastSuccessfulBuildForGoogleArtifactRegistryV2Promise = (
  props: MutateUsingFetchProps<
    ResponseGARBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGoogleArtifactRegistryV2QueryParams,
    GarRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGARBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGoogleArtifactRegistryV2QueryParams,
    GarRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/gar/v2/getLastSuccessfulBuild`, props, signal)

export interface GetBuildDetailsForGcrQueryParams {
  imagePath: string
  registryHostname: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetBuildDetailsForGcrProps = Omit<
  GetProps<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>,
  'path'
>

/**
 * Gets gcr build details
 */
export const GetBuildDetailsForGcr = (props: GetBuildDetailsForGcrProps) => (
  <Get<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>
    path={`/artifacts/gcr/getBuildDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForGcrProps = Omit<
  UseGetProps<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>,
  'path'
>

/**
 * Gets gcr build details
 */
export const useGetBuildDetailsForGcr = (props: UseGetBuildDetailsForGcrProps) =>
  useGet<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>(
    `/artifacts/gcr/getBuildDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets gcr build details
 */
export const getBuildDetailsForGcrPromise = (
  props: GetUsingFetchProps<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/gcr/getBuildDetails`,
    props,
    signal
  )

export interface GetBuildDetailsForGcrWithYamlQueryParams {
  imagePath?: string
  registryHostname?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  serviceId?: string
}

export type GetBuildDetailsForGcrWithYamlProps = Omit<
  MutateProps<
    ResponseGcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForGcrWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets gcr build details with Yaml expression
 */
export const GetBuildDetailsForGcrWithYaml = (props: GetBuildDetailsForGcrWithYamlProps) => (
  <Mutate<
    ResponseGcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForGcrWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/gcr/getBuildDetailsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForGcrWithYamlProps = Omit<
  UseMutateProps<
    ResponseGcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForGcrWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets gcr build details with Yaml expression
 */
export const useGetBuildDetailsForGcrWithYaml = (props: UseGetBuildDetailsForGcrWithYamlProps) =>
  useMutate<
    ResponseGcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForGcrWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', `/artifacts/gcr/getBuildDetailsV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets gcr build details with Yaml expression
 */
export const getBuildDetailsForGcrWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseGcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForGcrWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForGcrWithYamlQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/gcr/getBuildDetailsV2`, props, signal)

export interface GetLastSuccessfulBuildForGcrQueryParams {
  imagePath: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetLastSuccessfulBuildForGcrProps = Omit<
  MutateProps<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets gcr last successful build
 */
export const GetLastSuccessfulBuildForGcr = (props: GetLastSuccessfulBuildForGcrProps) => (
  <Mutate<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/gcr/getLastSuccessfulBuild`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForGcrProps = Omit<
  UseMutateProps<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets gcr last successful build
 */
export const useGetLastSuccessfulBuildForGcr = (props: UseGetLastSuccessfulBuildForGcrProps) =>
  useMutate<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >('POST', `/artifacts/gcr/getLastSuccessfulBuild`, { base: getConfig('ng/api'), ...props })

/**
 * Gets gcr last successful build
 */
export const getLastSuccessfulBuildForGcrPromise = (
  props: MutateUsingFetchProps<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/gcr/getLastSuccessfulBuild`, props, signal)

export interface GetLastSuccessfulBuildForGcrV2QueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  fqnPath: string
  serviceId?: string
  pipelineIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetLastSuccessfulBuildForGcrV2Props = Omit<
  MutateProps<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrV2QueryParams,
    GcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets gcr last successful build with Yaml expression
 */
export const GetLastSuccessfulBuildForGcrV2 = (props: GetLastSuccessfulBuildForGcrV2Props) => (
  <Mutate<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrV2QueryParams,
    GcrRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/gcr/getLastSuccessfulBuildV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForGcrV2Props = Omit<
  UseMutateProps<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrV2QueryParams,
    GcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets gcr last successful build with Yaml expression
 */
export const useGetLastSuccessfulBuildForGcrV2 = (props: UseGetLastSuccessfulBuildForGcrV2Props) =>
  useMutate<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrV2QueryParams,
    GcrRequestDTORequestBody,
    void
  >('POST', `/artifacts/gcr/getLastSuccessfulBuildV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets gcr last successful build with Yaml expression
 */
export const getLastSuccessfulBuildForGcrV2Promise = (
  props: MutateUsingFetchProps<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrV2QueryParams,
    GcrRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrV2QueryParams,
    GcrRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/gcr/getLastSuccessfulBuildV2`, props, signal)

export interface ValidateArtifactForGcrQueryParams {
  imagePath: string
  registryHostname: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateArtifactForGcrProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, ValidateArtifactForGcrQueryParams, GcrRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Validate Gcr Artifact
 */
export const ValidateArtifactForGcr = (props: ValidateArtifactForGcrProps) => (
  <Mutate<ResponseBoolean, Failure | Error, ValidateArtifactForGcrQueryParams, GcrRequestDTORequestBody, void>
    verb="POST"
    path={`/artifacts/gcr/validateArtifact`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactForGcrProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, ValidateArtifactForGcrQueryParams, GcrRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Validate Gcr Artifact
 */
export const useValidateArtifactForGcr = (props: UseValidateArtifactForGcrProps) =>
  useMutate<ResponseBoolean, Failure | Error, ValidateArtifactForGcrQueryParams, GcrRequestDTORequestBody, void>(
    'POST',
    `/artifacts/gcr/validateArtifact`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate Gcr Artifact
 */
export const validateArtifactForGcrPromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    ValidateArtifactForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactForGcrQueryParams, GcrRequestDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/artifacts/gcr/validateArtifact`,
    props,
    signal
  )

export interface ValidateArtifactServerForGcrQueryParams {
  imagePath: string
  connectorRef: string
  registryHostname: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateArtifactServerForGcrProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>,
  'path'
>

/**
 * Validate gcr artifact server
 */
export const ValidateArtifactServerForGcr = (props: ValidateArtifactServerForGcrProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>
    path={`/artifacts/gcr/validateArtifactServer`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactServerForGcrProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>,
  'path'
>

/**
 * Validate gcr artifact server
 */
export const useValidateArtifactServerForGcr = (props: UseValidateArtifactServerForGcrProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>(
    `/artifacts/gcr/validateArtifactServer`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate gcr artifact server
 */
export const validateArtifactServerForGcrPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/gcr/validateArtifactServer`,
    props,
    signal
  )

export interface ValidateArtifactImageForGcrQueryParams {
  imagePath: string
  registryHostname: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateArtifactImageForGcrProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>,
  'path'
>

/**
 * Validate Gcr image
 */
export const ValidateArtifactImageForGcr = (props: ValidateArtifactImageForGcrProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>
    path={`/artifacts/gcr/validateArtifactSource`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactImageForGcrProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>,
  'path'
>

/**
 * Validate Gcr image
 */
export const useValidateArtifactImageForGcr = (props: UseValidateArtifactImageForGcrProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>(
    `/artifacts/gcr/validateArtifactSource`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate Gcr image
 */
export const validateArtifactImageForGcrPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/gcr/validateArtifactSource`,
    props,
    signal
  )

export interface GetLastSuccessfulVersionQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  packageName: string
  packageType: string
  version?: string
  versionRegex?: string
  org?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetLastSuccessfulVersionProps = Omit<
  GetProps<ResponseBuildDetails, Failure | Error, GetLastSuccessfulVersionQueryParams, void>,
  'path'
>

/**
 * Gets Last Successful Version for the Package
 */
export const GetLastSuccessfulVersion = (props: GetLastSuccessfulVersionProps) => (
  <Get<ResponseBuildDetails, Failure | Error, GetLastSuccessfulVersionQueryParams, void>
    path={`/artifacts/githubpackages/lastSuccessfulVersion`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulVersionProps = Omit<
  UseGetProps<ResponseBuildDetails, Failure | Error, GetLastSuccessfulVersionQueryParams, void>,
  'path'
>

/**
 * Gets Last Successful Version for the Package
 */
export const useGetLastSuccessfulVersion = (props: UseGetLastSuccessfulVersionProps) =>
  useGet<ResponseBuildDetails, Failure | Error, GetLastSuccessfulVersionQueryParams, void>(
    `/artifacts/githubpackages/lastSuccessfulVersion`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Last Successful Version for the Package
 */
export const getLastSuccessfulVersionPromise = (
  props: GetUsingFetchProps<ResponseBuildDetails, Failure | Error, GetLastSuccessfulVersionQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBuildDetails, Failure | Error, GetLastSuccessfulVersionQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/githubpackages/lastSuccessfulVersion`,
    props,
    signal
  )

export interface GetPackagesFromGithubQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  packageType: string
  org?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetPackagesFromGithubProps = Omit<
  GetProps<ResponseGithubPackagesResponseDTO, Failure | Error, GetPackagesFromGithubQueryParams, void>,
  'path'
>

/**
 * Gets Package details for GithubPackages
 */
export const GetPackagesFromGithub = (props: GetPackagesFromGithubProps) => (
  <Get<ResponseGithubPackagesResponseDTO, Failure | Error, GetPackagesFromGithubQueryParams, void>
    path={`/artifacts/githubpackages/packages`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPackagesFromGithubProps = Omit<
  UseGetProps<ResponseGithubPackagesResponseDTO, Failure | Error, GetPackagesFromGithubQueryParams, void>,
  'path'
>

/**
 * Gets Package details for GithubPackages
 */
export const useGetPackagesFromGithub = (props: UseGetPackagesFromGithubProps) =>
  useGet<ResponseGithubPackagesResponseDTO, Failure | Error, GetPackagesFromGithubQueryParams, void>(
    `/artifacts/githubpackages/packages`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Package details for GithubPackages
 */
export const getPackagesFromGithubPromise = (
  props: GetUsingFetchProps<ResponseGithubPackagesResponseDTO, Failure | Error, GetPackagesFromGithubQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGithubPackagesResponseDTO, Failure | Error, GetPackagesFromGithubQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/githubpackages/packages`,
    props,
    signal
  )

export interface GetLastSuccessfulVersionWithServiceV2QueryParams {
  connectorRef?: string
  packageName?: string
  packageType?: string
  version?: string
  versionRegex?: string
  org?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath: string
  serviceId?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetLastSuccessfulVersionWithServiceV2Props = Omit<
  MutateProps<
    ResponseBuildDetails,
    Failure | Error,
    GetLastSuccessfulVersionWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Last Successful Version for the Package
 */
export const GetLastSuccessfulVersionWithServiceV2 = (props: GetLastSuccessfulVersionWithServiceV2Props) => (
  <Mutate<
    ResponseBuildDetails,
    Failure | Error,
    GetLastSuccessfulVersionWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/githubpackages/v2/lastSuccessfulVersion`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulVersionWithServiceV2Props = Omit<
  UseMutateProps<
    ResponseBuildDetails,
    Failure | Error,
    GetLastSuccessfulVersionWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Last Successful Version for the Package
 */
export const useGetLastSuccessfulVersionWithServiceV2 = (props: UseGetLastSuccessfulVersionWithServiceV2Props) =>
  useMutate<
    ResponseBuildDetails,
    Failure | Error,
    GetLastSuccessfulVersionWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/githubpackages/v2/lastSuccessfulVersion`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Last Successful Version for the Package
 */
export const getLastSuccessfulVersionWithServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseBuildDetails,
    Failure | Error,
    GetLastSuccessfulVersionWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBuildDetails,
    Failure | Error,
    GetLastSuccessfulVersionWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/githubpackages/v2/lastSuccessfulVersion`, props, signal)

export interface GetPackagesFromGithubWithServiceV2QueryParams {
  connectorRef?: string
  packageType?: string
  org?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath: string
  serviceId?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetPackagesFromGithubWithServiceV2Props = Omit<
  MutateProps<
    ResponseGithubPackagesResponseDTO,
    Failure | Error,
    GetPackagesFromGithubWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Package details for GithubPackages
 */
export const GetPackagesFromGithubWithServiceV2 = (props: GetPackagesFromGithubWithServiceV2Props) => (
  <Mutate<
    ResponseGithubPackagesResponseDTO,
    Failure | Error,
    GetPackagesFromGithubWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/githubpackages/v2/packages`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPackagesFromGithubWithServiceV2Props = Omit<
  UseMutateProps<
    ResponseGithubPackagesResponseDTO,
    Failure | Error,
    GetPackagesFromGithubWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Package details for GithubPackages
 */
export const useGetPackagesFromGithubWithServiceV2 = (props: UseGetPackagesFromGithubWithServiceV2Props) =>
  useMutate<
    ResponseGithubPackagesResponseDTO,
    Failure | Error,
    GetPackagesFromGithubWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/githubpackages/v2/packages`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Package details for GithubPackages
 */
export const getPackagesFromGithubWithServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseGithubPackagesResponseDTO,
    Failure | Error,
    GetPackagesFromGithubWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGithubPackagesResponseDTO,
    Failure | Error,
    GetPackagesFromGithubWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/githubpackages/v2/packages`, props, signal)

export interface GetVersionsFromPackagesWithServiceV2QueryParams {
  connectorRef?: string
  packageName?: string
  packageType?: string
  versionRegex?: string
  org?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath: string
  serviceId?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetVersionsFromPackagesWithServiceV2Props = Omit<
  MutateProps<
    ResponseListBuildDetails,
    Failure | Error,
    GetVersionsFromPackagesWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Versions from Packages
 */
export const GetVersionsFromPackagesWithServiceV2 = (props: GetVersionsFromPackagesWithServiceV2Props) => (
  <Mutate<
    ResponseListBuildDetails,
    Failure | Error,
    GetVersionsFromPackagesWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/githubpackages/v2/versions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetVersionsFromPackagesWithServiceV2Props = Omit<
  UseMutateProps<
    ResponseListBuildDetails,
    Failure | Error,
    GetVersionsFromPackagesWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Versions from Packages
 */
export const useGetVersionsFromPackagesWithServiceV2 = (props: UseGetVersionsFromPackagesWithServiceV2Props) =>
  useMutate<
    ResponseListBuildDetails,
    Failure | Error,
    GetVersionsFromPackagesWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/githubpackages/v2/versions`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Versions from Packages
 */
export const getVersionsFromPackagesWithServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseListBuildDetails,
    Failure | Error,
    GetVersionsFromPackagesWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListBuildDetails,
    Failure | Error,
    GetVersionsFromPackagesWithServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/githubpackages/v2/versions`, props, signal)

export interface GetVersionsFromPackagesQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  packageName: string
  packageType: string
  versionRegex?: string
  org?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetVersionsFromPackagesProps = Omit<
  GetProps<ResponseListBuildDetails, Failure | Error, GetVersionsFromPackagesQueryParams, void>,
  'path'
>

/**
 * Gets Versions from Packages
 */
export const GetVersionsFromPackages = (props: GetVersionsFromPackagesProps) => (
  <Get<ResponseListBuildDetails, Failure | Error, GetVersionsFromPackagesQueryParams, void>
    path={`/artifacts/githubpackages/versions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetVersionsFromPackagesProps = Omit<
  UseGetProps<ResponseListBuildDetails, Failure | Error, GetVersionsFromPackagesQueryParams, void>,
  'path'
>

/**
 * Gets Versions from Packages
 */
export const useGetVersionsFromPackages = (props: UseGetVersionsFromPackagesProps) =>
  useGet<ResponseListBuildDetails, Failure | Error, GetVersionsFromPackagesQueryParams, void>(
    `/artifacts/githubpackages/versions`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Versions from Packages
 */
export const getVersionsFromPackagesPromise = (
  props: GetUsingFetchProps<ResponseListBuildDetails, Failure | Error, GetVersionsFromPackagesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListBuildDetails, Failure | Error, GetVersionsFromPackagesQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/githubpackages/versions`,
    props,
    signal
  )

export interface GetGcsBucketsQueryParams {
  project?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  serviceId?: string
}

export type GetGcsBucketsProps = Omit<
  MutateProps<
    ResponseGoogleCloudStorageBucketsResponseDTO,
    Failure | Error,
    GetGcsBucketsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get list of buckets from google cloud storage
 */
export const GetGcsBuckets = (props: GetGcsBucketsProps) => (
  <Mutate<
    ResponseGoogleCloudStorageBucketsResponseDTO,
    Failure | Error,
    GetGcsBucketsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/google-cloud-storage/buckets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGcsBucketsProps = Omit<
  UseMutateProps<
    ResponseGoogleCloudStorageBucketsResponseDTO,
    Failure | Error,
    GetGcsBucketsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get list of buckets from google cloud storage
 */
export const useGetGcsBuckets = (props: UseGetGcsBucketsProps) =>
  useMutate<
    ResponseGoogleCloudStorageBucketsResponseDTO,
    Failure | Error,
    GetGcsBucketsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/google-cloud-storage/buckets`, { base: getConfig('ng/api'), ...props })

/**
 * Get list of buckets from google cloud storage
 */
export const getGcsBucketsPromise = (
  props: MutateUsingFetchProps<
    ResponseGoogleCloudStorageBucketsResponseDTO,
    Failure | Error,
    GetGcsBucketsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGoogleCloudStorageBucketsResponseDTO,
    Failure | Error,
    GetGcsBucketsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/google-cloud-storage/buckets`, props, signal)

export interface GetBuildsForJenkinsQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  artifactPath?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export interface GetBuildsForJenkinsPathParams {
  jobName: string
}

export type GetBuildsForJenkinsProps = Omit<
  GetProps<ResponseListBuildDetails, Failure | Error, GetBuildsForJenkinsQueryParams, GetBuildsForJenkinsPathParams>,
  'path'
> &
  GetBuildsForJenkinsPathParams

/**
 * Gets Jenkins builds
 */
export const GetBuildsForJenkins = ({ jobName, ...props }: GetBuildsForJenkinsProps) => (
  <Get<ResponseListBuildDetails, Failure | Error, GetBuildsForJenkinsQueryParams, GetBuildsForJenkinsPathParams>
    path={`/artifacts/jenkins/job/${jobName}/builds`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildsForJenkinsProps = Omit<
  UseGetProps<ResponseListBuildDetails, Failure | Error, GetBuildsForJenkinsQueryParams, GetBuildsForJenkinsPathParams>,
  'path'
> &
  GetBuildsForJenkinsPathParams

/**
 * Gets Jenkins builds
 */
export const useGetBuildsForJenkins = ({ jobName, ...props }: UseGetBuildsForJenkinsProps) =>
  useGet<ResponseListBuildDetails, Failure | Error, GetBuildsForJenkinsQueryParams, GetBuildsForJenkinsPathParams>(
    (paramsInPath: GetBuildsForJenkinsPathParams) => `/artifacts/jenkins/job/${paramsInPath.jobName}/builds`,
    { base: getConfig('ng/api'), pathParams: { jobName }, ...props }
  )

/**
 * Gets Jenkins builds
 */
export const getBuildsForJenkinsPromise = (
  {
    jobName,
    ...props
  }: GetUsingFetchProps<
    ResponseListBuildDetails,
    Failure | Error,
    GetBuildsForJenkinsQueryParams,
    GetBuildsForJenkinsPathParams
  > & { jobName: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseListBuildDetails,
    Failure | Error,
    GetBuildsForJenkinsQueryParams,
    GetBuildsForJenkinsPathParams
  >(getConfig('ng/api'), `/artifacts/jenkins/job/${jobName}/builds`, props, signal)

export interface GetJobParametersForJenkinsQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export interface GetJobParametersForJenkinsPathParams {
  jobName: string
}

export type GetJobParametersForJenkinsProps = Omit<
  GetProps<
    ResponseListJobParameter,
    Failure | Error,
    GetJobParametersForJenkinsQueryParams,
    GetJobParametersForJenkinsPathParams
  >,
  'path'
> &
  GetJobParametersForJenkinsPathParams

/**
 * Gets Jenkins Job paramter
 */
export const GetJobParametersForJenkins = ({ jobName, ...props }: GetJobParametersForJenkinsProps) => (
  <Get<
    ResponseListJobParameter,
    Failure | Error,
    GetJobParametersForJenkinsQueryParams,
    GetJobParametersForJenkinsPathParams
  >
    path={`/artifacts/jenkins/job/${jobName}/details`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJobParametersForJenkinsProps = Omit<
  UseGetProps<
    ResponseListJobParameter,
    Failure | Error,
    GetJobParametersForJenkinsQueryParams,
    GetJobParametersForJenkinsPathParams
  >,
  'path'
> &
  GetJobParametersForJenkinsPathParams

/**
 * Gets Jenkins Job paramter
 */
export const useGetJobParametersForJenkins = ({ jobName, ...props }: UseGetJobParametersForJenkinsProps) =>
  useGet<
    ResponseListJobParameter,
    Failure | Error,
    GetJobParametersForJenkinsQueryParams,
    GetJobParametersForJenkinsPathParams
  >((paramsInPath: GetJobParametersForJenkinsPathParams) => `/artifacts/jenkins/job/${paramsInPath.jobName}/details`, {
    base: getConfig('ng/api'),
    pathParams: { jobName },
    ...props
  })

/**
 * Gets Jenkins Job paramter
 */
export const getJobParametersForJenkinsPromise = (
  {
    jobName,
    ...props
  }: GetUsingFetchProps<
    ResponseListJobParameter,
    Failure | Error,
    GetJobParametersForJenkinsQueryParams,
    GetJobParametersForJenkinsPathParams
  > & { jobName: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseListJobParameter,
    Failure | Error,
    GetJobParametersForJenkinsQueryParams,
    GetJobParametersForJenkinsPathParams
  >(getConfig('ng/api'), `/artifacts/jenkins/job/${jobName}/details`, props, signal)

export interface GetArtifactPathForJenkinsQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export interface GetArtifactPathForJenkinsPathParams {
  jobName: string
}

export type GetArtifactPathForJenkinsProps = Omit<
  GetProps<
    ResponseListString,
    Failure | Error,
    GetArtifactPathForJenkinsQueryParams,
    GetArtifactPathForJenkinsPathParams
  >,
  'path'
> &
  GetArtifactPathForJenkinsPathParams

/**
 * Gets jenkins Artifact Paths
 */
export const GetArtifactPathForJenkins = ({ jobName, ...props }: GetArtifactPathForJenkinsProps) => (
  <Get<ResponseListString, Failure | Error, GetArtifactPathForJenkinsQueryParams, GetArtifactPathForJenkinsPathParams>
    path={`/artifacts/jenkins/job/${jobName}/paths`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetArtifactPathForJenkinsProps = Omit<
  UseGetProps<
    ResponseListString,
    Failure | Error,
    GetArtifactPathForJenkinsQueryParams,
    GetArtifactPathForJenkinsPathParams
  >,
  'path'
> &
  GetArtifactPathForJenkinsPathParams

/**
 * Gets jenkins Artifact Paths
 */
export const useGetArtifactPathForJenkins = ({ jobName, ...props }: UseGetArtifactPathForJenkinsProps) =>
  useGet<
    ResponseListString,
    Failure | Error,
    GetArtifactPathForJenkinsQueryParams,
    GetArtifactPathForJenkinsPathParams
  >((paramsInPath: GetArtifactPathForJenkinsPathParams) => `/artifacts/jenkins/job/${paramsInPath.jobName}/paths`, {
    base: getConfig('ng/api'),
    pathParams: { jobName },
    ...props
  })

/**
 * Gets jenkins Artifact Paths
 */
export const getArtifactPathForJenkinsPromise = (
  {
    jobName,
    ...props
  }: GetUsingFetchProps<
    ResponseListString,
    Failure | Error,
    GetArtifactPathForJenkinsQueryParams,
    GetArtifactPathForJenkinsPathParams
  > & { jobName: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseListString,
    Failure | Error,
    GetArtifactPathForJenkinsQueryParams,
    GetArtifactPathForJenkinsPathParams
  >(getConfig('ng/api'), `/artifacts/jenkins/job/${jobName}/paths`, props, signal)

export interface GetJobDetailsForJenkinsQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  parentJobName?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetJobDetailsForJenkinsProps = Omit<
  GetProps<ResponseJenkinsJobDetailsDTO, Failure | Error, GetJobDetailsForJenkinsQueryParams, void>,
  'path'
>

/**
 * Gets Job details for Jenkins
 */
export const GetJobDetailsForJenkins = (props: GetJobDetailsForJenkinsProps) => (
  <Get<ResponseJenkinsJobDetailsDTO, Failure | Error, GetJobDetailsForJenkinsQueryParams, void>
    path={`/artifacts/jenkins/jobs`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJobDetailsForJenkinsProps = Omit<
  UseGetProps<ResponseJenkinsJobDetailsDTO, Failure | Error, GetJobDetailsForJenkinsQueryParams, void>,
  'path'
>

/**
 * Gets Job details for Jenkins
 */
export const useGetJobDetailsForJenkins = (props: UseGetJobDetailsForJenkinsProps) =>
  useGet<ResponseJenkinsJobDetailsDTO, Failure | Error, GetJobDetailsForJenkinsQueryParams, void>(
    `/artifacts/jenkins/jobs`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Job details for Jenkins
 */
export const getJobDetailsForJenkinsPromise = (
  props: GetUsingFetchProps<ResponseJenkinsJobDetailsDTO, Failure | Error, GetJobDetailsForJenkinsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJenkinsJobDetailsDTO, Failure | Error, GetJobDetailsForJenkinsQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/jenkins/jobs`,
    props,
    signal
  )

export interface GetArtifactPathForJenkinsServiceV2QueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  jobName?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  fqnPath?: string
  serviceId?: string
}

export type GetArtifactPathForJenkinsServiceV2Props = Omit<
  MutateProps<
    ResponseListString,
    Failure | Error,
    GetArtifactPathForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets jenkins Artifact Paths ServiceV2
 */
export const GetArtifactPathForJenkinsServiceV2 = (props: GetArtifactPathForJenkinsServiceV2Props) => (
  <Mutate<
    ResponseListString,
    Failure | Error,
    GetArtifactPathForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/jenkins/v2/jobArtifactPaths`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetArtifactPathForJenkinsServiceV2Props = Omit<
  UseMutateProps<
    ResponseListString,
    Failure | Error,
    GetArtifactPathForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets jenkins Artifact Paths ServiceV2
 */
export const useGetArtifactPathForJenkinsServiceV2 = (props: UseGetArtifactPathForJenkinsServiceV2Props) =>
  useMutate<
    ResponseListString,
    Failure | Error,
    GetArtifactPathForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/jenkins/v2/jobArtifactPaths`, { base: getConfig('ng/api'), ...props })

/**
 * Gets jenkins Artifact Paths ServiceV2
 */
export const getArtifactPathForJenkinsServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseListString,
    Failure | Error,
    GetArtifactPathForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListString,
    Failure | Error,
    GetArtifactPathForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/jenkins/v2/jobArtifactPaths`, props, signal)

export interface GetBuildsForJenkinsServiceV2QueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  jobName?: string
  artifactPath?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  fqnPath?: string
  serviceId?: string
}

export type GetBuildsForJenkinsServiceV2Props = Omit<
  MutateProps<
    ResponseListBuildDetails,
    Failure | Error,
    GetBuildsForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Jenkins builds ServiceV2
 */
export const GetBuildsForJenkinsServiceV2 = (props: GetBuildsForJenkinsServiceV2Props) => (
  <Mutate<
    ResponseListBuildDetails,
    Failure | Error,
    GetBuildsForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/jenkins/v2/jobBuilds`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildsForJenkinsServiceV2Props = Omit<
  UseMutateProps<
    ResponseListBuildDetails,
    Failure | Error,
    GetBuildsForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Jenkins builds ServiceV2
 */
export const useGetBuildsForJenkinsServiceV2 = (props: UseGetBuildsForJenkinsServiceV2Props) =>
  useMutate<
    ResponseListBuildDetails,
    Failure | Error,
    GetBuildsForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/jenkins/v2/jobBuilds`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Jenkins builds ServiceV2
 */
export const getBuildsForJenkinsServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseListBuildDetails,
    Failure | Error,
    GetBuildsForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListBuildDetails,
    Failure | Error,
    GetBuildsForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/jenkins/v2/jobBuilds`, props, signal)

export interface GetJobParametersForJenkinsServiceV2QueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  jobName?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  fqnPath?: string
  serviceId?: string
}

export type GetJobParametersForJenkinsServiceV2Props = Omit<
  MutateProps<
    ResponseListJobParameter,
    Failure | Error,
    GetJobParametersForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Jenkins Job paramter ServiceV2
 */
export const GetJobParametersForJenkinsServiceV2 = (props: GetJobParametersForJenkinsServiceV2Props) => (
  <Mutate<
    ResponseListJobParameter,
    Failure | Error,
    GetJobParametersForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/jenkins/v2/jobDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJobParametersForJenkinsServiceV2Props = Omit<
  UseMutateProps<
    ResponseListJobParameter,
    Failure | Error,
    GetJobParametersForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Jenkins Job paramter ServiceV2
 */
export const useGetJobParametersForJenkinsServiceV2 = (props: UseGetJobParametersForJenkinsServiceV2Props) =>
  useMutate<
    ResponseListJobParameter,
    Failure | Error,
    GetJobParametersForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/jenkins/v2/jobDetails`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Jenkins Job paramter ServiceV2
 */
export const getJobParametersForJenkinsServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseListJobParameter,
    Failure | Error,
    GetJobParametersForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListJobParameter,
    Failure | Error,
    GetJobParametersForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/jenkins/v2/jobDetails`, props, signal)

export interface GetJobDetailsForJenkinsServiceV2QueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  parentJobName?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  fqnPath?: string
  serviceId?: string
}

export type GetJobDetailsForJenkinsServiceV2Props = Omit<
  MutateProps<
    ResponseJenkinsJobDetailsDTO,
    Failure | Error,
    GetJobDetailsForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Job details for Jenkins ServiceV2
 */
export const GetJobDetailsForJenkinsServiceV2 = (props: GetJobDetailsForJenkinsServiceV2Props) => (
  <Mutate<
    ResponseJenkinsJobDetailsDTO,
    Failure | Error,
    GetJobDetailsForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/jenkins/v2/jobs`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJobDetailsForJenkinsServiceV2Props = Omit<
  UseMutateProps<
    ResponseJenkinsJobDetailsDTO,
    Failure | Error,
    GetJobDetailsForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Job details for Jenkins ServiceV2
 */
export const useGetJobDetailsForJenkinsServiceV2 = (props: UseGetJobDetailsForJenkinsServiceV2Props) =>
  useMutate<
    ResponseJenkinsJobDetailsDTO,
    Failure | Error,
    GetJobDetailsForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/jenkins/v2/jobs`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Job details for Jenkins ServiceV2
 */
export const getJobDetailsForJenkinsServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseJenkinsJobDetailsDTO,
    Failure | Error,
    GetJobDetailsForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseJenkinsJobDetailsDTO,
    Failure | Error,
    GetJobDetailsForJenkinsServiceV2QueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/jenkins/v2/jobs`, props, signal)

export interface ArtifactIdsQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  repositoryFormat?: string
  repository?: string
  groupId?: string
  nexusSourceType?: string
  fqnPath?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  serviceId?: string
}

export type ArtifactIdsProps = Omit<
  MutateProps<ResponseListString, Failure | Error, ArtifactIdsQueryParams, ListTagsForAMIArtifactBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * Get ArtifactIds for nexus
 */
export const ArtifactIds = (props: ArtifactIdsProps) => (
  <Mutate<ResponseListString, Failure | Error, ArtifactIdsQueryParams, ListTagsForAMIArtifactBodyRequestBody, void>
    verb="POST"
    path={`/artifacts/nexus/artifactIds`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseArtifactIdsProps = Omit<
  UseMutateProps<
    ResponseListString,
    Failure | Error,
    ArtifactIdsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get ArtifactIds for nexus
 */
export const useArtifactIds = (props: UseArtifactIdsProps) =>
  useMutate<ResponseListString, Failure | Error, ArtifactIdsQueryParams, ListTagsForAMIArtifactBodyRequestBody, void>(
    'POST',
    `/artifacts/nexus/artifactIds`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get ArtifactIds for nexus
 */
export const artifactIdsPromise = (
  props: MutateUsingFetchProps<
    ResponseListString,
    Failure | Error,
    ArtifactIdsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListString,
    Failure | Error,
    ArtifactIdsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/nexus/artifactIds`, props, signal)

export interface GetBuildDetailsForNexusArtifactQueryParams {
  repository?: string
  repositoryPort?: string
  repositoryFormat?: string
  repositoryUrl?: string
  artifactPath?: string
  connectorRef?: string
  groupId?: string
  artifactId?: string
  extension?: string
  classifier?: string
  packageName?: string
  group?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetBuildDetailsForNexusArtifactProps = Omit<
  GetProps<ResponseNexusResponseDTO, Failure | Error, GetBuildDetailsForNexusArtifactQueryParams, void>,
  'path'
>

/**
 * Gets nexus artifact build details
 */
export const GetBuildDetailsForNexusArtifact = (props: GetBuildDetailsForNexusArtifactProps) => (
  <Get<ResponseNexusResponseDTO, Failure | Error, GetBuildDetailsForNexusArtifactQueryParams, void>
    path={`/artifacts/nexus/getBuildDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForNexusArtifactProps = Omit<
  UseGetProps<ResponseNexusResponseDTO, Failure | Error, GetBuildDetailsForNexusArtifactQueryParams, void>,
  'path'
>

/**
 * Gets nexus artifact build details
 */
export const useGetBuildDetailsForNexusArtifact = (props: UseGetBuildDetailsForNexusArtifactProps) =>
  useGet<ResponseNexusResponseDTO, Failure | Error, GetBuildDetailsForNexusArtifactQueryParams, void>(
    `/artifacts/nexus/getBuildDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets nexus artifact build details
 */
export const getBuildDetailsForNexusArtifactPromise = (
  props: GetUsingFetchProps<
    ResponseNexusResponseDTO,
    Failure | Error,
    GetBuildDetailsForNexusArtifactQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNexusResponseDTO, Failure | Error, GetBuildDetailsForNexusArtifactQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/nexus/getBuildDetails`,
    props,
    signal
  )

export interface GetBuildDetailsForNexusArtifactWithYamlQueryParams {
  repository?: string
  repositoryPort?: string
  artifactPath?: string
  repositoryFormat?: string
  repositoryUrl?: string
  connectorRef?: string
  groupId?: string
  artifactId?: string
  extension?: string
  classifier?: string
  packageName?: string
  group?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  serviceId?: string
}

export type GetBuildDetailsForNexusArtifactWithYamlProps = Omit<
  MutateProps<
    ResponseNexusResponseDTO,
    Failure | Error,
    GetBuildDetailsForNexusArtifactWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets nexus artifact build details with yaml input for expression resolution
 */
export const GetBuildDetailsForNexusArtifactWithYaml = (props: GetBuildDetailsForNexusArtifactWithYamlProps) => (
  <Mutate<
    ResponseNexusResponseDTO,
    Failure | Error,
    GetBuildDetailsForNexusArtifactWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/nexus/getBuildDetailsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForNexusArtifactWithYamlProps = Omit<
  UseMutateProps<
    ResponseNexusResponseDTO,
    Failure | Error,
    GetBuildDetailsForNexusArtifactWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets nexus artifact build details with yaml input for expression resolution
 */
export const useGetBuildDetailsForNexusArtifactWithYaml = (props: UseGetBuildDetailsForNexusArtifactWithYamlProps) =>
  useMutate<
    ResponseNexusResponseDTO,
    Failure | Error,
    GetBuildDetailsForNexusArtifactWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/nexus/getBuildDetailsV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets nexus artifact build details with yaml input for expression resolution
 */
export const getBuildDetailsForNexusArtifactWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseNexusResponseDTO,
    Failure | Error,
    GetBuildDetailsForNexusArtifactWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseNexusResponseDTO,
    Failure | Error,
    GetBuildDetailsForNexusArtifactWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/nexus/getBuildDetailsV2`, props, signal)

export interface GetLastSuccessfulBuildForNexusArtifactQueryParams {
  repository?: string
  repositoryPort?: string
  artifactPath?: string
  repositoryFormat?: string
  repositoryUrl?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetLastSuccessfulBuildForNexusArtifactProps = Omit<
  MutateProps<
    ResponseNexusBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForNexusArtifactQueryParams,
    NexusRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets nexus artifact last successful build
 */
export const GetLastSuccessfulBuildForNexusArtifact = (props: GetLastSuccessfulBuildForNexusArtifactProps) => (
  <Mutate<
    ResponseNexusBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForNexusArtifactQueryParams,
    NexusRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/nexus/getLastSuccessfulBuild`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForNexusArtifactProps = Omit<
  UseMutateProps<
    ResponseNexusBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForNexusArtifactQueryParams,
    NexusRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets nexus artifact last successful build
 */
export const useGetLastSuccessfulBuildForNexusArtifact = (props: UseGetLastSuccessfulBuildForNexusArtifactProps) =>
  useMutate<
    ResponseNexusBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForNexusArtifactQueryParams,
    NexusRequestDTORequestBody,
    void
  >('POST', `/artifacts/nexus/getLastSuccessfulBuild`, { base: getConfig('ng/api'), ...props })

/**
 * Gets nexus artifact last successful build
 */
export const getLastSuccessfulBuildForNexusArtifactPromise = (
  props: MutateUsingFetchProps<
    ResponseNexusBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForNexusArtifactQueryParams,
    NexusRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseNexusBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForNexusArtifactQueryParams,
    NexusRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/nexus/getLastSuccessfulBuild`, props, signal)

export interface GetLastSuccessfulBuildForNexusArtifactWithYamlQueryParams {
  repository?: string
  repositoryPort?: string
  artifactPath?: string
  repositoryFormat?: string
  repositoryUrl?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  serviceId?: string
}

export type GetLastSuccessfulBuildForNexusArtifactWithYamlProps = Omit<
  MutateProps<
    ResponseNexusBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForNexusArtifactWithYamlQueryParams,
    NexusRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets nexus artifact last successful build with yaml input for expression resolution
 */
export const GetLastSuccessfulBuildForNexusArtifactWithYaml = (
  props: GetLastSuccessfulBuildForNexusArtifactWithYamlProps
) => (
  <Mutate<
    ResponseNexusBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForNexusArtifactWithYamlQueryParams,
    NexusRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/nexus/getLastSuccessfulBuildV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForNexusArtifactWithYamlProps = Omit<
  UseMutateProps<
    ResponseNexusBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForNexusArtifactWithYamlQueryParams,
    NexusRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets nexus artifact last successful build with yaml input for expression resolution
 */
export const useGetLastSuccessfulBuildForNexusArtifactWithYaml = (
  props: UseGetLastSuccessfulBuildForNexusArtifactWithYamlProps
) =>
  useMutate<
    ResponseNexusBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForNexusArtifactWithYamlQueryParams,
    NexusRequestDTORequestBody,
    void
  >('POST', `/artifacts/nexus/getLastSuccessfulBuildV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets nexus artifact last successful build with yaml input for expression resolution
 */
export const getLastSuccessfulBuildForNexusArtifactWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseNexusBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForNexusArtifactWithYamlQueryParams,
    NexusRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseNexusBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForNexusArtifactWithYamlQueryParams,
    NexusRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/nexus/getLastSuccessfulBuildV2`, props, signal)

export interface GetRepositoriesQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  repositoryFormat?: string
  fqnPath?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  serviceId?: string
}

export type GetRepositoriesProps = Omit<
  MutateProps<
    ResponseListNexusRepositories,
    Failure | Error,
    GetRepositoriesQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Repositories for nexus artifact server
 */
export const GetRepositories = (props: GetRepositoriesProps) => (
  <Mutate<
    ResponseListNexusRepositories,
    Failure | Error,
    GetRepositoriesQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/nexus/getRepositories`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetRepositoriesProps = Omit<
  UseMutateProps<
    ResponseListNexusRepositories,
    Failure | Error,
    GetRepositoriesQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Repositories for nexus artifact server
 */
export const useGetRepositories = (props: UseGetRepositoriesProps) =>
  useMutate<
    ResponseListNexusRepositories,
    Failure | Error,
    GetRepositoriesQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/artifacts/nexus/getRepositories`, { base: getConfig('ng/api'), ...props })

/**
 * Get Repositories for nexus artifact server
 */
export const getRepositoriesPromise = (
  props: MutateUsingFetchProps<
    ResponseListNexusRepositories,
    Failure | Error,
    GetRepositoriesQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListNexusRepositories,
    Failure | Error,
    GetRepositoriesQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/nexus/getRepositories`, props, signal)

export interface GetGroupIdsQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  repositoryFormat?: string
  repository?: string
  fqnPath?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  serviceId?: string
}

export type GetGroupIdsProps = Omit<
  MutateProps<ResponseListString, Failure | Error, GetGroupIdsQueryParams, ListTagsForAMIArtifactBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * Get GroupIds for nexus
 */
export const GetGroupIds = (props: GetGroupIdsProps) => (
  <Mutate<ResponseListString, Failure | Error, GetGroupIdsQueryParams, ListTagsForAMIArtifactBodyRequestBody, void>
    verb="POST"
    path={`/artifacts/nexus/groupIds`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGroupIdsProps = Omit<
  UseMutateProps<
    ResponseListString,
    Failure | Error,
    GetGroupIdsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get GroupIds for nexus
 */
export const useGetGroupIds = (props: UseGetGroupIdsProps) =>
  useMutate<ResponseListString, Failure | Error, GetGroupIdsQueryParams, ListTagsForAMIArtifactBodyRequestBody, void>(
    'POST',
    `/artifacts/nexus/groupIds`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get GroupIds for nexus
 */
export const getGroupIdsPromise = (
  props: MutateUsingFetchProps<
    ResponseListString,
    Failure | Error,
    GetGroupIdsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListString,
    Failure | Error,
    GetGroupIdsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/nexus/groupIds`, props, signal)

export interface ValidateArtifactServerForNexusQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateArtifactServerForNexusProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForNexusQueryParams, void>,
  'path'
>

/**
 * Validate nexus artifact server
 */
export const ValidateArtifactServerForNexus = (props: ValidateArtifactServerForNexusProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactServerForNexusQueryParams, void>
    path={`/artifacts/nexus/validateArtifactServer`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactServerForNexusProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForNexusQueryParams, void>,
  'path'
>

/**
 * Validate nexus artifact server
 */
export const useValidateArtifactServerForNexus = (props: UseValidateArtifactServerForNexusProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactServerForNexusQueryParams, void>(
    `/artifacts/nexus/validateArtifactServer`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate nexus artifact server
 */
export const validateArtifactServerForNexusPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForNexusQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactServerForNexusQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/nexus/validateArtifactServer`,
    props,
    signal
  )

export interface GetAuthenticationSettingsQueryParams {
  accountIdentifier: string
}

export type GetAuthenticationSettingsProps = Omit<
  GetProps<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsQueryParams, void>,
  'path'
>

/**
 * Get authentication settings for an account
 */
export const GetAuthenticationSettings = (props: GetAuthenticationSettingsProps) => (
  <Get<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsQueryParams, void>
    path={`/authentication-settings`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAuthenticationSettingsProps = Omit<
  UseGetProps<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsQueryParams, void>,
  'path'
>

/**
 * Get authentication settings for an account
 */
export const useGetAuthenticationSettings = (props: UseGetAuthenticationSettingsProps) =>
  useGet<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsQueryParams, void>(
    `/authentication-settings`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get authentication settings for an account
 */
export const getAuthenticationSettingsPromise = (
  props: GetUsingFetchProps<
    RestResponseAuthenticationSettingsResponse,
    unknown,
    GetAuthenticationSettingsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsQueryParams, void>(
    getConfig('ng/api'),
    `/authentication-settings`,
    props,
    signal
  )

export interface DeleteSamlMetaDataQueryParams {
  accountIdentifier: string
}

export type DeleteSamlMetaDataProps = Omit<
  MutateProps<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete SAML Config
 */
export const DeleteSamlMetaData = (props: DeleteSamlMetaDataProps) => (
  <Mutate<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>
    verb="DELETE"
    path={`/authentication-settings/delete-saml-metadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSamlMetaDataProps = Omit<
  UseMutateProps<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete SAML Config
 */
export const useDeleteSamlMetaData = (props: UseDeleteSamlMetaDataProps) =>
  useMutate<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>(
    'DELETE',
    `/authentication-settings/delete-saml-metadata`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete SAML Config
 */
export const deleteSamlMetaDataPromise = (
  props: MutateUsingFetchProps<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>(
    'DELETE',
    getConfig('ng/api'),
    `/authentication-settings/delete-saml-metadata`,
    props,
    signal
  )

export interface DeleteLdapSettingsQueryParams {
  accountIdentifier?: string
}

export type DeleteLdapSettingsProps = Omit<
  MutateProps<RestResponseBoolean, unknown, DeleteLdapSettingsQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete Ldap settings
 */
export const DeleteLdapSettings = (props: DeleteLdapSettingsProps) => (
  <Mutate<RestResponseBoolean, unknown, DeleteLdapSettingsQueryParams, void, void>
    verb="DELETE"
    path={`/authentication-settings/ldap/settings`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteLdapSettingsProps = Omit<
  UseMutateProps<RestResponseBoolean, unknown, DeleteLdapSettingsQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete Ldap settings
 */
export const useDeleteLdapSettings = (props: UseDeleteLdapSettingsProps) =>
  useMutate<RestResponseBoolean, unknown, DeleteLdapSettingsQueryParams, void, void>(
    'DELETE',
    `/authentication-settings/ldap/settings`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete Ldap settings
 */
export const deleteLdapSettingsPromise = (
  props: MutateUsingFetchProps<RestResponseBoolean, unknown, DeleteLdapSettingsQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseBoolean, unknown, DeleteLdapSettingsQueryParams, void, void>(
    'DELETE',
    getConfig('ng/api'),
    `/authentication-settings/ldap/settings`,
    props,
    signal
  )

export interface GetLdapSettingsQueryParams {
  accountIdentifier?: string
}

export type GetLdapSettingsProps = Omit<
  GetProps<RestResponseLDAPSettings, unknown, GetLdapSettingsQueryParams, void>,
  'path'
>

/**
 * Get Ldap settings
 */
export const GetLdapSettings = (props: GetLdapSettingsProps) => (
  <Get<RestResponseLDAPSettings, unknown, GetLdapSettingsQueryParams, void>
    path={`/authentication-settings/ldap/settings`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLdapSettingsProps = Omit<
  UseGetProps<RestResponseLDAPSettings, unknown, GetLdapSettingsQueryParams, void>,
  'path'
>

/**
 * Get Ldap settings
 */
export const useGetLdapSettings = (props: UseGetLdapSettingsProps) =>
  useGet<RestResponseLDAPSettings, unknown, GetLdapSettingsQueryParams, void>(
    `/authentication-settings/ldap/settings`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Ldap settings
 */
export const getLdapSettingsPromise = (
  props: GetUsingFetchProps<RestResponseLDAPSettings, unknown, GetLdapSettingsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseLDAPSettings, unknown, GetLdapSettingsQueryParams, void>(
    getConfig('ng/api'),
    `/authentication-settings/ldap/settings`,
    props,
    signal
  )

export interface CreateLdapSettingsQueryParams {
  accountIdentifier?: string
}

export type CreateLdapSettingsProps = Omit<
  MutateProps<RestResponseLDAPSettings, unknown, CreateLdapSettingsQueryParams, LDAPSettingsRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create Ldap settings - with user queries, group queries
 */
export const CreateLdapSettings = (props: CreateLdapSettingsProps) => (
  <Mutate<RestResponseLDAPSettings, unknown, CreateLdapSettingsQueryParams, LDAPSettingsRequestBody, void>
    verb="POST"
    path={`/authentication-settings/ldap/settings`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateLdapSettingsProps = Omit<
  UseMutateProps<RestResponseLDAPSettings, unknown, CreateLdapSettingsQueryParams, LDAPSettingsRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create Ldap settings - with user queries, group queries
 */
export const useCreateLdapSettings = (props: UseCreateLdapSettingsProps) =>
  useMutate<RestResponseLDAPSettings, unknown, CreateLdapSettingsQueryParams, LDAPSettingsRequestBody, void>(
    'POST',
    `/authentication-settings/ldap/settings`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create Ldap settings - with user queries, group queries
 */
export const createLdapSettingsPromise = (
  props: MutateUsingFetchProps<
    RestResponseLDAPSettings,
    unknown,
    CreateLdapSettingsQueryParams,
    LDAPSettingsRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseLDAPSettings, unknown, CreateLdapSettingsQueryParams, LDAPSettingsRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/authentication-settings/ldap/settings`,
    props,
    signal
  )

export interface UpdateLdapSettingsQueryParams {
  accountIdentifier?: string
}

export type UpdateLdapSettingsProps = Omit<
  MutateProps<RestResponseLDAPSettings, unknown, UpdateLdapSettingsQueryParams, LDAPSettingsRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update Ldap settings - user queries, group queries
 */
export const UpdateLdapSettings = (props: UpdateLdapSettingsProps) => (
  <Mutate<RestResponseLDAPSettings, unknown, UpdateLdapSettingsQueryParams, LDAPSettingsRequestBody, void>
    verb="PUT"
    path={`/authentication-settings/ldap/settings`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateLdapSettingsProps = Omit<
  UseMutateProps<RestResponseLDAPSettings, unknown, UpdateLdapSettingsQueryParams, LDAPSettingsRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update Ldap settings - user queries, group queries
 */
export const useUpdateLdapSettings = (props: UseUpdateLdapSettingsProps) =>
  useMutate<RestResponseLDAPSettings, unknown, UpdateLdapSettingsQueryParams, LDAPSettingsRequestBody, void>(
    'PUT',
    `/authentication-settings/ldap/settings`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update Ldap settings - user queries, group queries
 */
export const updateLdapSettingsPromise = (
  props: MutateUsingFetchProps<
    RestResponseLDAPSettings,
    unknown,
    UpdateLdapSettingsQueryParams,
    LDAPSettingsRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseLDAPSettings, unknown, UpdateLdapSettingsQueryParams, LDAPSettingsRequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/authentication-settings/ldap/settings`,
    props,
    signal
  )

export interface GetPasswordStrengthSettingsQueryParams {
  accountIdentifier: string
}

export type GetPasswordStrengthSettingsProps = Omit<
  GetProps<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>,
  'path'
>

/**
 * Get Password strength settings
 */
export const GetPasswordStrengthSettings = (props: GetPasswordStrengthSettingsProps) => (
  <Get<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>
    path={`/authentication-settings/login-settings/password-strength`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPasswordStrengthSettingsProps = Omit<
  UseGetProps<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>,
  'path'
>

/**
 * Get Password strength settings
 */
export const useGetPasswordStrengthSettings = (props: UseGetPasswordStrengthSettingsProps) =>
  useGet<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>(
    `/authentication-settings/login-settings/password-strength`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Password strength settings
 */
export const getPasswordStrengthSettingsPromise = (
  props: GetUsingFetchProps<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>(
    getConfig('ng/api'),
    `/authentication-settings/login-settings/password-strength`,
    props,
    signal
  )

export interface PutLoginSettingsQueryParams {
  accountIdentifier?: string
}

export interface PutLoginSettingsPathParams {
  loginSettingsId: string
}

export type PutLoginSettingsProps = Omit<
  MutateProps<
    RestResponseLoginSettings,
    unknown,
    PutLoginSettingsQueryParams,
    LoginSettings,
    PutLoginSettingsPathParams
  >,
  'path' | 'verb'
> &
  PutLoginSettingsPathParams

/**
 * Update login settings - lockout, expiration, strength
 */
export const PutLoginSettings = ({ loginSettingsId, ...props }: PutLoginSettingsProps) => (
  <Mutate<RestResponseLoginSettings, unknown, PutLoginSettingsQueryParams, LoginSettings, PutLoginSettingsPathParams>
    verb="PUT"
    path={`/authentication-settings/login-settings/${loginSettingsId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutLoginSettingsProps = Omit<
  UseMutateProps<
    RestResponseLoginSettings,
    unknown,
    PutLoginSettingsQueryParams,
    LoginSettings,
    PutLoginSettingsPathParams
  >,
  'path' | 'verb'
> &
  PutLoginSettingsPathParams

/**
 * Update login settings - lockout, expiration, strength
 */
export const usePutLoginSettings = ({ loginSettingsId, ...props }: UsePutLoginSettingsProps) =>
  useMutate<RestResponseLoginSettings, unknown, PutLoginSettingsQueryParams, LoginSettings, PutLoginSettingsPathParams>(
    'PUT',
    (paramsInPath: PutLoginSettingsPathParams) =>
      `/authentication-settings/login-settings/${paramsInPath.loginSettingsId}`,
    { base: getConfig('ng/api'), pathParams: { loginSettingsId }, ...props }
  )

/**
 * Update login settings - lockout, expiration, strength
 */
export const putLoginSettingsPromise = (
  {
    loginSettingsId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseLoginSettings,
    unknown,
    PutLoginSettingsQueryParams,
    LoginSettings,
    PutLoginSettingsPathParams
  > & { loginSettingsId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseLoginSettings,
    unknown,
    PutLoginSettingsQueryParams,
    LoginSettings,
    PutLoginSettingsPathParams
  >('PUT', getConfig('ng/api'), `/authentication-settings/login-settings/${loginSettingsId}`, props, signal)

export interface RemoveOauthMechanismQueryParams {
  accountIdentifier: string
}

export type RemoveOauthMechanismProps = Omit<
  MutateProps<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Remove Oauth mechanism for an account
 */
export const RemoveOauthMechanism = (props: RemoveOauthMechanismProps) => (
  <Mutate<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>
    verb="DELETE"
    path={`/authentication-settings/oauth/remove-mechanism`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRemoveOauthMechanismProps = Omit<
  UseMutateProps<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Remove Oauth mechanism for an account
 */
export const useRemoveOauthMechanism = (props: UseRemoveOauthMechanismProps) =>
  useMutate<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>(
    'DELETE',
    `/authentication-settings/oauth/remove-mechanism`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Remove Oauth mechanism for an account
 */
export const removeOauthMechanismPromise = (
  props: MutateUsingFetchProps<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>(
    'DELETE',
    getConfig('ng/api'),
    `/authentication-settings/oauth/remove-mechanism`,
    props,
    signal
  )

export interface UpdateOauthProvidersQueryParams {
  accountIdentifier: string
}

export type UpdateOauthProvidersProps = Omit<
  MutateProps<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>,
  'path' | 'verb'
>

/**
 * Update Oauth providers for an account
 */
export const UpdateOauthProviders = (props: UpdateOauthProvidersProps) => (
  <Mutate<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>
    verb="PUT"
    path={`/authentication-settings/oauth/update-providers`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateOauthProvidersProps = Omit<
  UseMutateProps<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>,
  'path' | 'verb'
>

/**
 * Update Oauth providers for an account
 */
export const useUpdateOauthProviders = (props: UseUpdateOauthProvidersProps) =>
  useMutate<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>(
    'PUT',
    `/authentication-settings/oauth/update-providers`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update Oauth providers for an account
 */
export const updateOauthProvidersPromise = (
  props: MutateUsingFetchProps<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>(
    'PUT',
    getConfig('ng/api'),
    `/authentication-settings/oauth/update-providers`,
    props,
    signal
  )

export interface SetPublicAccessQueryParams {
  accountIdentifier: string
}

export type SetPublicAccessProps = Omit<
  MutateProps<
    RestResponseBoolean,
    unknown,
    SetPublicAccessQueryParams,
    UpdateHarnessSupportAccessNGBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Enable/disable public access
 */
export const SetPublicAccess = (props: SetPublicAccessProps) => (
  <Mutate<RestResponseBoolean, unknown, SetPublicAccessQueryParams, UpdateHarnessSupportAccessNGBodyRequestBody, void>
    verb="PUT"
    path={`/authentication-settings/public-access`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSetPublicAccessProps = Omit<
  UseMutateProps<
    RestResponseBoolean,
    unknown,
    SetPublicAccessQueryParams,
    UpdateHarnessSupportAccessNGBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Enable/disable public access
 */
export const useSetPublicAccess = (props: UseSetPublicAccessProps) =>
  useMutate<
    RestResponseBoolean,
    unknown,
    SetPublicAccessQueryParams,
    UpdateHarnessSupportAccessNGBodyRequestBody,
    void
  >('PUT', `/authentication-settings/public-access`, { base: getConfig('ng/api'), ...props })

/**
 * Enable/disable public access
 */
export const setPublicAccessPromise = (
  props: MutateUsingFetchProps<
    RestResponseBoolean,
    unknown,
    SetPublicAccessQueryParams,
    UpdateHarnessSupportAccessNGBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseBoolean,
    unknown,
    SetPublicAccessQueryParams,
    UpdateHarnessSupportAccessNGBodyRequestBody,
    void
  >('PUT', getConfig('ng/api'), `/authentication-settings/public-access`, props, signal)

export interface GetSamlLoginTestQueryParams {
  accountId: string
}

export type GetSamlLoginTestProps = Omit<
  GetProps<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>,
  'path'
>

/**
 * Get SAML Login Test
 */
export const GetSamlLoginTest = (props: GetSamlLoginTestProps) => (
  <Get<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>
    path={`/authentication-settings/saml-login-test`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSamlLoginTestProps = Omit<
  UseGetProps<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>,
  'path'
>

/**
 * Get SAML Login Test
 */
export const useGetSamlLoginTest = (props: UseGetSamlLoginTestProps) =>
  useGet<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>(
    `/authentication-settings/saml-login-test`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get SAML Login Test
 */
export const getSamlLoginTestPromise = (
  props: GetUsingFetchProps<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>(
    getConfig('ng/api'),
    `/authentication-settings/saml-login-test`,
    props,
    signal
  )

export interface GetSamlLoginTestV2QueryParams {
  accountIdentifier: string
}

export interface GetSamlLoginTestV2PathParams {
  samlSSOId: string
}

export type GetSamlLoginTestV2Props = Omit<
  GetProps<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestV2QueryParams, GetSamlLoginTestV2PathParams>,
  'path'
> &
  GetSamlLoginTestV2PathParams

/**
 * Get SAML Login Test
 */
export const GetSamlLoginTestV2 = ({ samlSSOId, ...props }: GetSamlLoginTestV2Props) => (
  <Get<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestV2QueryParams, GetSamlLoginTestV2PathParams>
    path={`/authentication-settings/saml-login-test/${samlSSOId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSamlLoginTestV2Props = Omit<
  UseGetProps<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestV2QueryParams, GetSamlLoginTestV2PathParams>,
  'path'
> &
  GetSamlLoginTestV2PathParams

/**
 * Get SAML Login Test
 */
export const useGetSamlLoginTestV2 = ({ samlSSOId, ...props }: UseGetSamlLoginTestV2Props) =>
  useGet<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestV2QueryParams, GetSamlLoginTestV2PathParams>(
    (paramsInPath: GetSamlLoginTestV2PathParams) =>
      `/authentication-settings/saml-login-test/${paramsInPath.samlSSOId}`,
    { base: getConfig('ng/api'), pathParams: { samlSSOId }, ...props }
  )

/**
 * Get SAML Login Test
 */
export const getSamlLoginTestV2Promise = (
  {
    samlSSOId,
    ...props
  }: GetUsingFetchProps<
    RestResponseLoginTypeResponse,
    unknown,
    GetSamlLoginTestV2QueryParams,
    GetSamlLoginTestV2PathParams
  > & { samlSSOId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestV2QueryParams, GetSamlLoginTestV2PathParams>(
    getConfig('ng/api'),
    `/authentication-settings/saml-login-test/${samlSSOId}`,
    props,
    signal
  )

export interface UploadSamlMetaDataQueryParams {
  accountId: string
}

export type UploadSamlMetaDataProps = Omit<
  MutateProps<
    RestResponseSSOConfig,
    unknown,
    UploadSamlMetaDataQueryParams,
    UpdateSamlMetaDataForSamlSSOIdRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create SAML Config
 */
export const UploadSamlMetaData = (props: UploadSamlMetaDataProps) => (
  <Mutate<
    RestResponseSSOConfig,
    unknown,
    UploadSamlMetaDataQueryParams,
    UpdateSamlMetaDataForSamlSSOIdRequestBody,
    void
  >
    verb="POST"
    path={`/authentication-settings/saml-metadata-upload`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUploadSamlMetaDataProps = Omit<
  UseMutateProps<
    RestResponseSSOConfig,
    unknown,
    UploadSamlMetaDataQueryParams,
    UpdateSamlMetaDataForSamlSSOIdRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create SAML Config
 */
export const useUploadSamlMetaData = (props: UseUploadSamlMetaDataProps) =>
  useMutate<
    RestResponseSSOConfig,
    unknown,
    UploadSamlMetaDataQueryParams,
    UpdateSamlMetaDataForSamlSSOIdRequestBody,
    void
  >('POST', `/authentication-settings/saml-metadata-upload`, { base: getConfig('ng/api'), ...props })

/**
 * Create SAML Config
 */
export const uploadSamlMetaDataPromise = (
  props: MutateUsingFetchProps<
    RestResponseSSOConfig,
    unknown,
    UploadSamlMetaDataQueryParams,
    UpdateSamlMetaDataForSamlSSOIdRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseSSOConfig,
    unknown,
    UploadSamlMetaDataQueryParams,
    UpdateSamlMetaDataForSamlSSOIdRequestBody,
    void
  >('POST', getConfig('ng/api'), `/authentication-settings/saml-metadata-upload`, props, signal)

export interface UpdateSamlMetaDataQueryParams {
  accountId: string
}

export type UpdateSamlMetaDataProps = Omit<
  MutateProps<RestResponseSSOConfig, unknown, UpdateSamlMetaDataQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Edit SAML Config
 */
export const UpdateSamlMetaData = (props: UpdateSamlMetaDataProps) => (
  <Mutate<RestResponseSSOConfig, unknown, UpdateSamlMetaDataQueryParams, void, void>
    verb="PUT"
    path={`/authentication-settings/saml-metadata-upload`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateSamlMetaDataProps = Omit<
  UseMutateProps<RestResponseSSOConfig, unknown, UpdateSamlMetaDataQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Edit SAML Config
 */
export const useUpdateSamlMetaData = (props: UseUpdateSamlMetaDataProps) =>
  useMutate<RestResponseSSOConfig, unknown, UpdateSamlMetaDataQueryParams, void, void>(
    'PUT',
    `/authentication-settings/saml-metadata-upload`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Edit SAML Config
 */
export const updateSamlMetaDataPromise = (
  props: MutateUsingFetchProps<RestResponseSSOConfig, unknown, UpdateSamlMetaDataQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseSSOConfig, unknown, UpdateSamlMetaDataQueryParams, void, void>(
    'PUT',
    getConfig('ng/api'),
    `/authentication-settings/saml-metadata-upload`,
    props,
    signal
  )

export interface UpdateSamlMetaDataForSamlSSOIdQueryParams {
  accountIdentifier: string
}

export interface UpdateSamlMetaDataForSamlSSOIdPathParams {
  samlSSOId: string
}

export type UpdateSamlMetaDataForSamlSSOIdProps = Omit<
  MutateProps<
    RestResponseSSOConfig,
    unknown,
    UpdateSamlMetaDataForSamlSSOIdQueryParams,
    UpdateSamlMetaDataForSamlSSOIdRequestBody,
    UpdateSamlMetaDataForSamlSSOIdPathParams
  >,
  'path' | 'verb'
> &
  UpdateSamlMetaDataForSamlSSOIdPathParams

/**
 * Edit SAML Config for a given SAML SSO Id
 */
export const UpdateSamlMetaDataForSamlSSOId = ({ samlSSOId, ...props }: UpdateSamlMetaDataForSamlSSOIdProps) => (
  <Mutate<
    RestResponseSSOConfig,
    unknown,
    UpdateSamlMetaDataForSamlSSOIdQueryParams,
    UpdateSamlMetaDataForSamlSSOIdRequestBody,
    UpdateSamlMetaDataForSamlSSOIdPathParams
  >
    verb="PUT"
    path={`/authentication-settings/saml-metadata-upload/${samlSSOId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateSamlMetaDataForSamlSSOIdProps = Omit<
  UseMutateProps<
    RestResponseSSOConfig,
    unknown,
    UpdateSamlMetaDataForSamlSSOIdQueryParams,
    UpdateSamlMetaDataForSamlSSOIdRequestBody,
    UpdateSamlMetaDataForSamlSSOIdPathParams
  >,
  'path' | 'verb'
> &
  UpdateSamlMetaDataForSamlSSOIdPathParams

/**
 * Edit SAML Config for a given SAML SSO Id
 */
export const useUpdateSamlMetaDataForSamlSSOId = ({ samlSSOId, ...props }: UseUpdateSamlMetaDataForSamlSSOIdProps) =>
  useMutate<
    RestResponseSSOConfig,
    unknown,
    UpdateSamlMetaDataForSamlSSOIdQueryParams,
    UpdateSamlMetaDataForSamlSSOIdRequestBody,
    UpdateSamlMetaDataForSamlSSOIdPathParams
  >(
    'PUT',
    (paramsInPath: UpdateSamlMetaDataForSamlSSOIdPathParams) =>
      `/authentication-settings/saml-metadata-upload/${paramsInPath.samlSSOId}`,
    { base: getConfig('ng/api'), pathParams: { samlSSOId }, ...props }
  )

/**
 * Edit SAML Config for a given SAML SSO Id
 */
export const updateSamlMetaDataForSamlSSOIdPromise = (
  {
    samlSSOId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseSSOConfig,
    unknown,
    UpdateSamlMetaDataForSamlSSOIdQueryParams,
    UpdateSamlMetaDataForSamlSSOIdRequestBody,
    UpdateSamlMetaDataForSamlSSOIdPathParams
  > & { samlSSOId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseSSOConfig,
    unknown,
    UpdateSamlMetaDataForSamlSSOIdQueryParams,
    UpdateSamlMetaDataForSamlSSOIdRequestBody,
    UpdateSamlMetaDataForSamlSSOIdPathParams
  >('PUT', getConfig('ng/api'), `/authentication-settings/saml-metadata-upload/${samlSSOId}`, props, signal)

export interface EnableDisableAuthenticationForSAMLSettingQueryParams {
  accountIdentifier: string
  enable: boolean
}

export interface EnableDisableAuthenticationForSAMLSettingPathParams {
  samlSSOId: string
}

export type EnableDisableAuthenticationForSAMLSettingProps = Omit<
  MutateProps<
    RestResponseBoolean,
    unknown,
    EnableDisableAuthenticationForSAMLSettingQueryParams,
    void,
    EnableDisableAuthenticationForSAMLSettingPathParams
  >,
  'path' | 'verb'
> &
  EnableDisableAuthenticationForSAMLSettingPathParams

/**
 * Enables or disables authentication for the given SAML sso id
 */
export const EnableDisableAuthenticationForSAMLSetting = ({
  samlSSOId,
  ...props
}: EnableDisableAuthenticationForSAMLSettingProps) => (
  <Mutate<
    RestResponseBoolean,
    unknown,
    EnableDisableAuthenticationForSAMLSettingQueryParams,
    void,
    EnableDisableAuthenticationForSAMLSettingPathParams
  >
    verb="PUT"
    path={`/authentication-settings/saml-metadata-upload/${samlSSOId}/authentication`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseEnableDisableAuthenticationForSAMLSettingProps = Omit<
  UseMutateProps<
    RestResponseBoolean,
    unknown,
    EnableDisableAuthenticationForSAMLSettingQueryParams,
    void,
    EnableDisableAuthenticationForSAMLSettingPathParams
  >,
  'path' | 'verb'
> &
  EnableDisableAuthenticationForSAMLSettingPathParams

/**
 * Enables or disables authentication for the given SAML sso id
 */
export const useEnableDisableAuthenticationForSAMLSetting = ({
  samlSSOId,
  ...props
}: UseEnableDisableAuthenticationForSAMLSettingProps) =>
  useMutate<
    RestResponseBoolean,
    unknown,
    EnableDisableAuthenticationForSAMLSettingQueryParams,
    void,
    EnableDisableAuthenticationForSAMLSettingPathParams
  >(
    'PUT',
    (paramsInPath: EnableDisableAuthenticationForSAMLSettingPathParams) =>
      `/authentication-settings/saml-metadata-upload/${paramsInPath.samlSSOId}/authentication`,
    { base: getConfig('ng/api'), pathParams: { samlSSOId }, ...props }
  )

/**
 * Enables or disables authentication for the given SAML sso id
 */
export const enableDisableAuthenticationForSAMLSettingPromise = (
  {
    samlSSOId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseBoolean,
    unknown,
    EnableDisableAuthenticationForSAMLSettingQueryParams,
    void,
    EnableDisableAuthenticationForSAMLSettingPathParams
  > & { samlSSOId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseBoolean,
    unknown,
    EnableDisableAuthenticationForSAMLSettingQueryParams,
    void,
    EnableDisableAuthenticationForSAMLSettingPathParams
  >(
    'PUT',
    getConfig('ng/api'),
    `/authentication-settings/saml-metadata-upload/${samlSSOId}/authentication`,
    props,
    signal
  )

export interface DeleteSamlMetaDataForSamlSSOIdQueryParams {
  accountIdentifier: string
}

export interface DeleteSamlMetaDataForSamlSSOIdPathParams {
  samlSSOId: string
}

export type DeleteSamlMetaDataForSamlSSOIdProps = Omit<
  MutateProps<
    RestResponseSSOConfig,
    unknown,
    DeleteSamlMetaDataForSamlSSOIdQueryParams,
    void,
    DeleteSamlMetaDataForSamlSSOIdPathParams
  >,
  'path' | 'verb'
> &
  DeleteSamlMetaDataForSamlSSOIdPathParams

/**
 * Delete SAML Config for given SAML sso id
 */
export const DeleteSamlMetaDataForSamlSSOId = ({ samlSSOId, ...props }: DeleteSamlMetaDataForSamlSSOIdProps) => (
  <Mutate<
    RestResponseSSOConfig,
    unknown,
    DeleteSamlMetaDataForSamlSSOIdQueryParams,
    void,
    DeleteSamlMetaDataForSamlSSOIdPathParams
  >
    verb="DELETE"
    path={`/authentication-settings/saml-metadata/${samlSSOId}/delete`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSamlMetaDataForSamlSSOIdProps = Omit<
  UseMutateProps<
    RestResponseSSOConfig,
    unknown,
    DeleteSamlMetaDataForSamlSSOIdQueryParams,
    void,
    DeleteSamlMetaDataForSamlSSOIdPathParams
  >,
  'path' | 'verb'
> &
  DeleteSamlMetaDataForSamlSSOIdPathParams

/**
 * Delete SAML Config for given SAML sso id
 */
export const useDeleteSamlMetaDataForSamlSSOId = ({ samlSSOId, ...props }: UseDeleteSamlMetaDataForSamlSSOIdProps) =>
  useMutate<
    RestResponseSSOConfig,
    unknown,
    DeleteSamlMetaDataForSamlSSOIdQueryParams,
    void,
    DeleteSamlMetaDataForSamlSSOIdPathParams
  >(
    'DELETE',
    (paramsInPath: DeleteSamlMetaDataForSamlSSOIdPathParams) =>
      `/authentication-settings/saml-metadata/${paramsInPath.samlSSOId}/delete`,
    { base: getConfig('ng/api'), pathParams: { samlSSOId }, ...props }
  )

/**
 * Delete SAML Config for given SAML sso id
 */
export const deleteSamlMetaDataForSamlSSOIdPromise = (
  {
    samlSSOId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseSSOConfig,
    unknown,
    DeleteSamlMetaDataForSamlSSOIdQueryParams,
    void,
    DeleteSamlMetaDataForSamlSSOIdPathParams
  > & { samlSSOId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseSSOConfig,
    unknown,
    DeleteSamlMetaDataForSamlSSOIdQueryParams,
    void,
    DeleteSamlMetaDataForSamlSSOIdPathParams
  >('DELETE', getConfig('ng/api'), `/authentication-settings/saml-metadata/${samlSSOId}/delete`, props, signal)

export interface SetSessionTimeoutAtAccountLevelQueryParams {
  accountIdentifier: string
}

export type SetSessionTimeoutAtAccountLevelProps = Omit<
  MutateProps<RestResponseBoolean, unknown, SetSessionTimeoutAtAccountLevelQueryParams, SessionTimeoutSettings, void>,
  'path' | 'verb'
>

/**
 * Set account level session timeout
 */
export const SetSessionTimeoutAtAccountLevel = (props: SetSessionTimeoutAtAccountLevelProps) => (
  <Mutate<RestResponseBoolean, unknown, SetSessionTimeoutAtAccountLevelQueryParams, SessionTimeoutSettings, void>
    verb="PUT"
    path={`/authentication-settings/session-timeout-account-level`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSetSessionTimeoutAtAccountLevelProps = Omit<
  UseMutateProps<
    RestResponseBoolean,
    unknown,
    SetSessionTimeoutAtAccountLevelQueryParams,
    SessionTimeoutSettings,
    void
  >,
  'path' | 'verb'
>

/**
 * Set account level session timeout
 */
export const useSetSessionTimeoutAtAccountLevel = (props: UseSetSessionTimeoutAtAccountLevelProps) =>
  useMutate<RestResponseBoolean, unknown, SetSessionTimeoutAtAccountLevelQueryParams, SessionTimeoutSettings, void>(
    'PUT',
    `/authentication-settings/session-timeout-account-level`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Set account level session timeout
 */
export const setSessionTimeoutAtAccountLevelPromise = (
  props: MutateUsingFetchProps<
    RestResponseBoolean,
    unknown,
    SetSessionTimeoutAtAccountLevelQueryParams,
    SessionTimeoutSettings,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseBoolean,
    unknown,
    SetSessionTimeoutAtAccountLevelQueryParams,
    SessionTimeoutSettings,
    void
  >('PUT', getConfig('ng/api'), `/authentication-settings/session-timeout-account-level`, props, signal)

export interface SetTwoFactorAuthAtAccountLevelQueryParams {
  accountIdentifier: string
}

export type SetTwoFactorAuthAtAccountLevelProps = Omit<
  MutateProps<
    RestResponseBoolean,
    unknown,
    SetTwoFactorAuthAtAccountLevelQueryParams,
    TwoFactorAdminOverrideSettings,
    void
  >,
  'path' | 'verb'
>

/**
 * Set account level two factor auth setting
 */
export const SetTwoFactorAuthAtAccountLevel = (props: SetTwoFactorAuthAtAccountLevelProps) => (
  <Mutate<RestResponseBoolean, unknown, SetTwoFactorAuthAtAccountLevelQueryParams, TwoFactorAdminOverrideSettings, void>
    verb="PUT"
    path={`/authentication-settings/two-factor-admin-override-settings`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSetTwoFactorAuthAtAccountLevelProps = Omit<
  UseMutateProps<
    RestResponseBoolean,
    unknown,
    SetTwoFactorAuthAtAccountLevelQueryParams,
    TwoFactorAdminOverrideSettings,
    void
  >,
  'path' | 'verb'
>

/**
 * Set account level two factor auth setting
 */
export const useSetTwoFactorAuthAtAccountLevel = (props: UseSetTwoFactorAuthAtAccountLevelProps) =>
  useMutate<
    RestResponseBoolean,
    unknown,
    SetTwoFactorAuthAtAccountLevelQueryParams,
    TwoFactorAdminOverrideSettings,
    void
  >('PUT', `/authentication-settings/two-factor-admin-override-settings`, { base: getConfig('ng/api'), ...props })

/**
 * Set account level two factor auth setting
 */
export const setTwoFactorAuthAtAccountLevelPromise = (
  props: MutateUsingFetchProps<
    RestResponseBoolean,
    unknown,
    SetTwoFactorAuthAtAccountLevelQueryParams,
    TwoFactorAdminOverrideSettings,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseBoolean,
    unknown,
    SetTwoFactorAuthAtAccountLevelQueryParams,
    TwoFactorAdminOverrideSettings,
    void
  >('PUT', getConfig('ng/api'), `/authentication-settings/two-factor-admin-override-settings`, props, signal)

export interface UpdateAuthMechanismQueryParams {
  accountIdentifier: string
  authenticationMechanism?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
}

export type UpdateAuthMechanismProps = Omit<
  MutateProps<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Update Auth mechanism for an account
 */
export const UpdateAuthMechanism = (props: UpdateAuthMechanismProps) => (
  <Mutate<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>
    verb="PUT"
    path={`/authentication-settings/update-auth-mechanism`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateAuthMechanismProps = Omit<
  UseMutateProps<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Update Auth mechanism for an account
 */
export const useUpdateAuthMechanism = (props: UseUpdateAuthMechanismProps) =>
  useMutate<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>(
    'PUT',
    `/authentication-settings/update-auth-mechanism`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update Auth mechanism for an account
 */
export const updateAuthMechanismPromise = (
  props: MutateUsingFetchProps<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>(
    'PUT',
    getConfig('ng/api'),
    `/authentication-settings/update-auth-mechanism`,
    props,
    signal
  )

export interface GetAuthenticationSettingsV2QueryParams {
  accountIdentifier: string
}

export type GetAuthenticationSettingsV2Props = Omit<
  GetProps<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsV2QueryParams, void>,
  'path'
>

/**
 * Get authentication settings version 2 for an account
 */
export const GetAuthenticationSettingsV2 = (props: GetAuthenticationSettingsV2Props) => (
  <Get<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsV2QueryParams, void>
    path={`/authentication-settings/v2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAuthenticationSettingsV2Props = Omit<
  UseGetProps<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsV2QueryParams, void>,
  'path'
>

/**
 * Get authentication settings version 2 for an account
 */
export const useGetAuthenticationSettingsV2 = (props: UseGetAuthenticationSettingsV2Props) =>
  useGet<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsV2QueryParams, void>(
    `/authentication-settings/v2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get authentication settings version 2 for an account
 */
export const getAuthenticationSettingsV2Promise = (
  props: GetUsingFetchProps<
    RestResponseAuthenticationSettingsResponse,
    unknown,
    GetAuthenticationSettingsV2QueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsV2QueryParams, void>(
    getConfig('ng/api'),
    `/authentication-settings/v2`,
    props,
    signal
  )

export interface UpdateWhitelistedDomainsQueryParams {
  accountIdentifier: string
}

export type UpdateWhitelistedDomainsProps = Omit<
  MutateProps<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update Whitelisted domains for an account
 */
export const UpdateWhitelistedDomains = (props: UpdateWhitelistedDomainsProps) => (
  <Mutate<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >
    verb="PUT"
    path={`/authentication-settings/whitelisted-domains`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateWhitelistedDomainsProps = Omit<
  UseMutateProps<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update Whitelisted domains for an account
 */
export const useUpdateWhitelistedDomains = (props: UseUpdateWhitelistedDomainsProps) =>
  useMutate<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >('PUT', `/authentication-settings/whitelisted-domains`, { base: getConfig('ng/api'), ...props })

/**
 * Update Whitelisted domains for an account
 */
export const updateWhitelistedDomainsPromise = (
  props: MutateUsingFetchProps<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >('PUT', getConfig('ng/api'), `/authentication-settings/whitelisted-domains`, props, signal)

export interface AutoScalingGroupsQueryParams {
  awsConnectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  region?: string
  envId?: string
  infraDefinitionId?: string
}

export type AutoScalingGroupsProps = Omit<
  GetProps<ResponseListString, Failure | Error, AutoScalingGroupsQueryParams, void>,
  'path'
>

/**
 * Get auto scaling groups
 */
export const AutoScalingGroups = (props: AutoScalingGroupsProps) => (
  <Get<ResponseListString, Failure | Error, AutoScalingGroupsQueryParams, void>
    path={`/aws/aws-helper/auto-scaling-groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAutoScalingGroupsProps = Omit<
  UseGetProps<ResponseListString, Failure | Error, AutoScalingGroupsQueryParams, void>,
  'path'
>

/**
 * Get auto scaling groups
 */
export const useAutoScalingGroups = (props: UseAutoScalingGroupsProps) =>
  useGet<ResponseListString, Failure | Error, AutoScalingGroupsQueryParams, void>(
    `/aws/aws-helper/auto-scaling-groups`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get auto scaling groups
 */
export const autoScalingGroupsPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, AutoScalingGroupsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, AutoScalingGroupsQueryParams, void>(
    getConfig('ng/api'),
    `/aws/aws-helper/auto-scaling-groups`,
    props,
    signal
  )

export type CFCapabilitiesForAwsProps = Omit<GetProps<ResponseListString, Failure | Error, void, void>, 'path'>

/**
 * Get the Cloudformation capabilities
 */
export const CFCapabilitiesForAws = (props: CFCapabilitiesForAwsProps) => (
  <Get<ResponseListString, Failure | Error, void, void>
    path={`/aws/aws-helper/cf-capabilities`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCFCapabilitiesForAwsProps = Omit<UseGetProps<ResponseListString, Failure | Error, void, void>, 'path'>

/**
 * Get the Cloudformation capabilities
 */
export const useCFCapabilitiesForAws = (props: UseCFCapabilitiesForAwsProps) =>
  useGet<ResponseListString, Failure | Error, void, void>(`/aws/aws-helper/cf-capabilities`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get the Cloudformation capabilities
 */
export const cFCapabilitiesForAwsPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/aws/aws-helper/cf-capabilities`,
    props,
    signal
  )

export interface CFParametersForAwsQueryParams {
  type: string
  region: string
  isBranch?: boolean
  branch?: string
  filePath?: string
  commitId?: string
  awsConnectorRef: string
  gitConnectorRef?: string
  repoName?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CFParametersForAwsProps = Omit<
  MutateProps<
    ResponseListAwsCFTemplateParamsData,
    Failure | Error,
    CFParametersForAwsQueryParams,
    CFParametersForAwsBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Cloudformation parameters from a template
 */
export const CFParametersForAws = (props: CFParametersForAwsProps) => (
  <Mutate<
    ResponseListAwsCFTemplateParamsData,
    Failure | Error,
    CFParametersForAwsQueryParams,
    CFParametersForAwsBodyRequestBody,
    void
  >
    verb="POST"
    path={`/aws/aws-helper/cf-parameters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCFParametersForAwsProps = Omit<
  UseMutateProps<
    ResponseListAwsCFTemplateParamsData,
    Failure | Error,
    CFParametersForAwsQueryParams,
    CFParametersForAwsBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Cloudformation parameters from a template
 */
export const useCFParametersForAws = (props: UseCFParametersForAwsProps) =>
  useMutate<
    ResponseListAwsCFTemplateParamsData,
    Failure | Error,
    CFParametersForAwsQueryParams,
    CFParametersForAwsBodyRequestBody,
    void
  >('POST', `/aws/aws-helper/cf-parameters`, { base: getConfig('ng/api'), ...props })

/**
 * Get Cloudformation parameters from a template
 */
export const cFParametersForAwsPromise = (
  props: MutateUsingFetchProps<
    ResponseListAwsCFTemplateParamsData,
    Failure | Error,
    CFParametersForAwsQueryParams,
    CFParametersForAwsBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListAwsCFTemplateParamsData,
    Failure | Error,
    CFParametersForAwsQueryParams,
    CFParametersForAwsBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/aws/aws-helper/cf-parameters`, props, signal)

export type CFStatesForAwsProps = Omit<GetProps<ResponseSetString, Failure | Error, void, void>, 'path'>

/**
 * Get all the Cloudformation states for a stack
 */
export const CFStatesForAws = (props: CFStatesForAwsProps) => (
  <Get<ResponseSetString, Failure | Error, void, void>
    path={`/aws/aws-helper/cf-states`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCFStatesForAwsProps = Omit<UseGetProps<ResponseSetString, Failure | Error, void, void>, 'path'>

/**
 * Get all the Cloudformation states for a stack
 */
export const useCFStatesForAws = (props: UseCFStatesForAwsProps) =>
  useGet<ResponseSetString, Failure | Error, void, void>(`/aws/aws-helper/cf-states`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get all the Cloudformation states for a stack
 */
export const cFStatesForAwsPromise = (
  props: GetUsingFetchProps<ResponseSetString, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSetString, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/aws/aws-helper/cf-states`,
    props,
    signal
  )

export interface ClustersQueryParams {
  awsConnectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  region?: string
  envId?: string
  infraDefinitionId?: string
}

export type ClustersProps = Omit<GetProps<ResponseListString, Failure | Error, ClustersQueryParams, void>, 'path'>

/**
 * Get clusters
 */
export const Clusters = (props: ClustersProps) => (
  <Get<ResponseListString, Failure | Error, ClustersQueryParams, void>
    path={`/aws/aws-helper/clusters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseClustersProps = Omit<UseGetProps<ResponseListString, Failure | Error, ClustersQueryParams, void>, 'path'>

/**
 * Get clusters
 */
export const useClusters = (props: UseClustersProps) =>
  useGet<ResponseListString, Failure | Error, ClustersQueryParams, void>(`/aws/aws-helper/clusters`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get clusters
 */
export const clustersPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, ClustersQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, ClustersQueryParams, void>(
    getConfig('ng/api'),
    `/aws/aws-helper/clusters`,
    props,
    signal
  )

export interface GetEKSClusterNamesQueryParams {
  awsConnectorRef?: string
  region?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  envId?: string
  infraDefinitionId?: string
}

export type GetEKSClusterNamesProps = Omit<
  GetProps<ResponseListString, Failure | Error, GetEKSClusterNamesQueryParams, void>,
  'path'
>

/**
 * Get EKS clusters list
 */
export const GetEKSClusterNames = (props: GetEKSClusterNamesProps) => (
  <Get<ResponseListString, Failure | Error, GetEKSClusterNamesQueryParams, void>
    path={`/aws/aws-helper/eks/clusters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEKSClusterNamesProps = Omit<
  UseGetProps<ResponseListString, Failure | Error, GetEKSClusterNamesQueryParams, void>,
  'path'
>

/**
 * Get EKS clusters list
 */
export const useGetEKSClusterNames = (props: UseGetEKSClusterNamesProps) =>
  useGet<ResponseListString, Failure | Error, GetEKSClusterNamesQueryParams, void>(`/aws/aws-helper/eks/clusters`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get EKS clusters list
 */
export const getEKSClusterNamesPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, GetEKSClusterNamesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, GetEKSClusterNamesQueryParams, void>(
    getConfig('ng/api'),
    `/aws/aws-helper/eks/clusters`,
    props,
    signal
  )

export interface ElasticLoadBalancersQueryParams {
  awsConnectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  region?: string
  envId?: string
  infraDefinitionId?: string
}

export type ElasticLoadBalancersProps = Omit<
  GetProps<ResponseListString, Failure | Error, ElasticLoadBalancersQueryParams, void>,
  'path'
>

/**
 * Get elastic load balancers
 */
export const ElasticLoadBalancers = (props: ElasticLoadBalancersProps) => (
  <Get<ResponseListString, Failure | Error, ElasticLoadBalancersQueryParams, void>
    path={`/aws/aws-helper/elastic-load-balancers`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseElasticLoadBalancersProps = Omit<
  UseGetProps<ResponseListString, Failure | Error, ElasticLoadBalancersQueryParams, void>,
  'path'
>

/**
 * Get elastic load balancers
 */
export const useElasticLoadBalancers = (props: UseElasticLoadBalancersProps) =>
  useGet<ResponseListString, Failure | Error, ElasticLoadBalancersQueryParams, void>(
    `/aws/aws-helper/elastic-load-balancers`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get elastic load balancers
 */
export const elasticLoadBalancersPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, ElasticLoadBalancersQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, ElasticLoadBalancersQueryParams, void>(
    getConfig('ng/api'),
    `/aws/aws-helper/elastic-load-balancers`,
    props,
    signal
  )

export interface FilterHostsQueryParams {
  awsConnectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type FilterHostsProps = Omit<GetProps<ResponseListString, Failure | Error, FilterHostsQueryParams, void>, 'path'>

/**
 * Get all the IAM hosts
 */
export const FilterHosts = (props: FilterHostsProps) => (
  <Get<ResponseListString, Failure | Error, FilterHostsQueryParams, void>
    path={`/aws/aws-helper/hosts`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseFilterHostsProps = Omit<
  UseGetProps<ResponseListString, Failure | Error, FilterHostsQueryParams, void>,
  'path'
>

/**
 * Get all the IAM hosts
 */
export const useFilterHosts = (props: UseFilterHostsProps) =>
  useGet<ResponseListString, Failure | Error, FilterHostsQueryParams, void>(`/aws/aws-helper/hosts`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get all the IAM hosts
 */
export const filterHostsPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, FilterHostsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, FilterHostsQueryParams, void>(
    getConfig('ng/api'),
    `/aws/aws-helper/hosts`,
    props,
    signal
  )

export interface GetIamRolesForAwsQueryParams {
  awsConnectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  region?: string
}

export type GetIamRolesForAwsProps = Omit<
  GetProps<ResponseMapStringString, Failure | Error, GetIamRolesForAwsQueryParams, void>,
  'path'
>

/**
 * Get all the IAM roles
 */
export const GetIamRolesForAws = (props: GetIamRolesForAwsProps) => (
  <Get<ResponseMapStringString, Failure | Error, GetIamRolesForAwsQueryParams, void>
    path={`/aws/aws-helper/iam-roles`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetIamRolesForAwsProps = Omit<
  UseGetProps<ResponseMapStringString, Failure | Error, GetIamRolesForAwsQueryParams, void>,
  'path'
>

/**
 * Get all the IAM roles
 */
export const useGetIamRolesForAws = (props: UseGetIamRolesForAwsProps) =>
  useGet<ResponseMapStringString, Failure | Error, GetIamRolesForAwsQueryParams, void>(`/aws/aws-helper/iam-roles`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get all the IAM roles
 */
export const getIamRolesForAwsPromise = (
  props: GetUsingFetchProps<ResponseMapStringString, Failure | Error, GetIamRolesForAwsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapStringString, Failure | Error, GetIamRolesForAwsQueryParams, void>(
    getConfig('ng/api'),
    `/aws/aws-helper/iam-roles`,
    props,
    signal
  )

export interface ListenerRulesQueryParams {
  awsConnectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  region?: string
  elasticLoadBalancer: string
  listenerArn: string
  envId?: string
  infraDefinitionId?: string
}

export type ListenerRulesProps = Omit<
  GetProps<ResponseListString, Failure | Error, ListenerRulesQueryParams, void>,
  'path'
>

/**
 * Get elastic load balancer listener rules
 */
export const ListenerRules = (props: ListenerRulesProps) => (
  <Get<ResponseListString, Failure | Error, ListenerRulesQueryParams, void>
    path={`/aws/aws-helper/listener-rules-arns`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListenerRulesProps = Omit<
  UseGetProps<ResponseListString, Failure | Error, ListenerRulesQueryParams, void>,
  'path'
>

/**
 * Get elastic load balancer listener rules
 */
export const useListenerRules = (props: UseListenerRulesProps) =>
  useGet<ResponseListString, Failure | Error, ListenerRulesQueryParams, void>(`/aws/aws-helper/listener-rules-arns`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get elastic load balancer listener rules
 */
export const listenerRulesPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, ListenerRulesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, ListenerRulesQueryParams, void>(
    getConfig('ng/api'),
    `/aws/aws-helper/listener-rules-arns`,
    props,
    signal
  )

export interface ListenersQueryParams {
  awsConnectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  region?: string
  elasticLoadBalancer: string
  envId?: string
  infraDefinitionId?: string
}

export type ListenersProps = Omit<
  GetProps<ResponseMapStringString, Failure | Error, ListenersQueryParams, void>,
  'path'
>

/**
 * Get elastic load balancer listeners
 */
export const Listeners = (props: ListenersProps) => (
  <Get<ResponseMapStringString, Failure | Error, ListenersQueryParams, void>
    path={`/aws/aws-helper/listeners`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListenersProps = Omit<
  UseGetProps<ResponseMapStringString, Failure | Error, ListenersQueryParams, void>,
  'path'
>

/**
 * Get elastic load balancer listeners
 */
export const useListeners = (props: UseListenersProps) =>
  useGet<ResponseMapStringString, Failure | Error, ListenersQueryParams, void>(`/aws/aws-helper/listeners`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get elastic load balancer listeners
 */
export const listenersPromise = (
  props: GetUsingFetchProps<ResponseMapStringString, Failure | Error, ListenersQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapStringString, Failure | Error, ListenersQueryParams, void>(
    getConfig('ng/api'),
    `/aws/aws-helper/listeners`,
    props,
    signal
  )

export interface LoadBalancersQueryParams {
  awsConnectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  region: string
}

export type LoadBalancersProps = Omit<
  GetProps<ResponseListString, Failure | Error, LoadBalancersQueryParams, void>,
  'path'
>

/**
 * Get load balancers
 */
export const LoadBalancers = (props: LoadBalancersProps) => (
  <Get<ResponseListString, Failure | Error, LoadBalancersQueryParams, void>
    path={`/aws/aws-helper/load-balancers`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseLoadBalancersProps = Omit<
  UseGetProps<ResponseListString, Failure | Error, LoadBalancersQueryParams, void>,
  'path'
>

/**
 * Get load balancers
 */
export const useLoadBalancers = (props: UseLoadBalancersProps) =>
  useGet<ResponseListString, Failure | Error, LoadBalancersQueryParams, void>(`/aws/aws-helper/load-balancers`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get load balancers
 */
export const loadBalancersPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, LoadBalancersQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, LoadBalancersQueryParams, void>(
    getConfig('ng/api'),
    `/aws/aws-helper/load-balancers`,
    props,
    signal
  )

export type RegionsForAwsProps = Omit<GetProps<ResponseMapStringString, Failure | Error, void, void>, 'path'>

/**
 * Get all the AWS regions defined in the application
 */
export const RegionsForAws = (props: RegionsForAwsProps) => (
  <Get<ResponseMapStringString, Failure | Error, void, void>
    path={`/aws/aws-helper/regions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRegionsForAwsProps = Omit<UseGetProps<ResponseMapStringString, Failure | Error, void, void>, 'path'>

/**
 * Get all the AWS regions defined in the application
 */
export const useRegionsForAws = (props: UseRegionsForAwsProps) =>
  useGet<ResponseMapStringString, Failure | Error, void, void>(`/aws/aws-helper/regions`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get all the AWS regions defined in the application
 */
export const regionsForAwsPromise = (
  props: GetUsingFetchProps<ResponseMapStringString, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapStringString, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/aws/aws-helper/regions`,
    props,
    signal
  )

export interface TagsQueryParams {
  awsConnectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  region: string
}

export type TagsProps = Omit<GetProps<ResponseSetString, Failure | Error, TagsQueryParams, void>, 'path'>

/**
 * Get all the tags
 */
export const Tags = (props: TagsProps) => (
  <Get<ResponseSetString, Failure | Error, TagsQueryParams, void>
    path={`/aws/aws-helper/tags`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseTagsProps = Omit<UseGetProps<ResponseSetString, Failure | Error, TagsQueryParams, void>, 'path'>

/**
 * Get all the tags
 */
export const useTags = (props: UseTagsProps) =>
  useGet<ResponseSetString, Failure | Error, TagsQueryParams, void>(`/aws/aws-helper/tags`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get all the tags
 */
export const tagsPromise = (
  props: GetUsingFetchProps<ResponseSetString, Failure | Error, TagsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSetString, Failure | Error, TagsQueryParams, void>(
    getConfig('ng/api'),
    `/aws/aws-helper/tags`,
    props,
    signal
  )

export interface TagsV2QueryParams {
  awsConnectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  region?: string
  envId?: string
  infraDefinitionId?: string
}

export type TagsV2Props = Omit<GetProps<ResponseSetString, Failure | Error, TagsV2QueryParams, void>, 'path'>

/**
 * Get all the tags V2
 */
export const TagsV2 = (props: TagsV2Props) => (
  <Get<ResponseSetString, Failure | Error, TagsV2QueryParams, void>
    path={`/aws/aws-helper/v2/tags`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseTagsV2Props = Omit<UseGetProps<ResponseSetString, Failure | Error, TagsV2QueryParams, void>, 'path'>

/**
 * Get all the tags V2
 */
export const useTagsV2 = (props: UseTagsV2Props) =>
  useGet<ResponseSetString, Failure | Error, TagsV2QueryParams, void>(`/aws/aws-helper/v2/tags`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get all the tags V2
 */
export const tagsV2Promise = (
  props: GetUsingFetchProps<ResponseSetString, Failure | Error, TagsV2QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSetString, Failure | Error, TagsV2QueryParams, void>(
    getConfig('ng/api'),
    `/aws/aws-helper/v2/tags`,
    props,
    signal
  )

export interface VpcsQueryParams {
  awsConnectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  region: string
}

export type VpcsProps = Omit<GetProps<ResponseListAwsVPC, Failure | Error, VpcsQueryParams, void>, 'path'>

/**
 * Get all the vpcs
 */
export const Vpcs = (props: VpcsProps) => (
  <Get<ResponseListAwsVPC, Failure | Error, VpcsQueryParams, void>
    path={`/aws/aws-helper/vpcs`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseVpcsProps = Omit<UseGetProps<ResponseListAwsVPC, Failure | Error, VpcsQueryParams, void>, 'path'>

/**
 * Get all the vpcs
 */
export const useVpcs = (props: UseVpcsProps) =>
  useGet<ResponseListAwsVPC, Failure | Error, VpcsQueryParams, void>(`/aws/aws-helper/vpcs`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get all the vpcs
 */
export const vpcsPromise = (
  props: GetUsingFetchProps<ResponseListAwsVPC, Failure | Error, VpcsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListAwsVPC, Failure | Error, VpcsQueryParams, void>(
    getConfig('ng/api'),
    `/aws/aws-helper/vpcs`,
    props,
    signal
  )

export interface GetLocationsBySubscriptionQueryParams {
  connectorRef: string
  subscriptionId?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetLocationsBySubscriptionProps = Omit<
  GetProps<ResponseAzureLocationsDTO, Failure | Error, GetLocationsBySubscriptionQueryParams, void>,
  'path'
>

/**
 * Gets azure locations defined for a subscription
 */
export const GetLocationsBySubscription = (props: GetLocationsBySubscriptionProps) => (
  <Get<ResponseAzureLocationsDTO, Failure | Error, GetLocationsBySubscriptionQueryParams, void>
    path={`/azure/locations`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLocationsBySubscriptionProps = Omit<
  UseGetProps<ResponseAzureLocationsDTO, Failure | Error, GetLocationsBySubscriptionQueryParams, void>,
  'path'
>

/**
 * Gets azure locations defined for a subscription
 */
export const useGetLocationsBySubscription = (props: UseGetLocationsBySubscriptionProps) =>
  useGet<ResponseAzureLocationsDTO, Failure | Error, GetLocationsBySubscriptionQueryParams, void>(`/azure/locations`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets azure locations defined for a subscription
 */
export const getLocationsBySubscriptionPromise = (
  props: GetUsingFetchProps<ResponseAzureLocationsDTO, Failure | Error, GetLocationsBySubscriptionQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAzureLocationsDTO, Failure | Error, GetLocationsBySubscriptionQueryParams, void>(
    getConfig('ng/api'),
    `/azure/locations`,
    props,
    signal
  )

export interface GetManagementGroupsQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetManagementGroupsProps = Omit<
  GetProps<ResponseAzureManagementGroupsDTO, Failure | Error, GetManagementGroupsQueryParams, void>,
  'path'
>

/**
 * Gets azure management groups
 */
export const GetManagementGroups = (props: GetManagementGroupsProps) => (
  <Get<ResponseAzureManagementGroupsDTO, Failure | Error, GetManagementGroupsQueryParams, void>
    path={`/azure/management-groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetManagementGroupsProps = Omit<
  UseGetProps<ResponseAzureManagementGroupsDTO, Failure | Error, GetManagementGroupsQueryParams, void>,
  'path'
>

/**
 * Gets azure management groups
 */
export const useGetManagementGroups = (props: UseGetManagementGroupsProps) =>
  useGet<ResponseAzureManagementGroupsDTO, Failure | Error, GetManagementGroupsQueryParams, void>(
    `/azure/management-groups`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets azure management groups
 */
export const getManagementGroupsPromise = (
  props: GetUsingFetchProps<ResponseAzureManagementGroupsDTO, Failure | Error, GetManagementGroupsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAzureManagementGroupsDTO, Failure | Error, GetManagementGroupsQueryParams, void>(
    getConfig('ng/api'),
    `/azure/management-groups`,
    props,
    signal
  )

export interface GetAzureSubscriptionsQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  envId?: string
  infraDefinitionId?: string
}

export type GetAzureSubscriptionsProps = Omit<
  GetProps<ResponseAzureSubscriptionsDTO, Failure | Error, GetAzureSubscriptionsQueryParams, void>,
  'path'
>

/**
 * Gets azure subscriptions
 */
export const GetAzureSubscriptions = (props: GetAzureSubscriptionsProps) => (
  <Get<ResponseAzureSubscriptionsDTO, Failure | Error, GetAzureSubscriptionsQueryParams, void>
    path={`/azure/subscriptions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAzureSubscriptionsProps = Omit<
  UseGetProps<ResponseAzureSubscriptionsDTO, Failure | Error, GetAzureSubscriptionsQueryParams, void>,
  'path'
>

/**
 * Gets azure subscriptions
 */
export const useGetAzureSubscriptions = (props: UseGetAzureSubscriptionsProps) =>
  useGet<ResponseAzureSubscriptionsDTO, Failure | Error, GetAzureSubscriptionsQueryParams, void>(
    `/azure/subscriptions`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets azure subscriptions
 */
export const getAzureSubscriptionsPromise = (
  props: GetUsingFetchProps<ResponseAzureSubscriptionsDTO, Failure | Error, GetAzureSubscriptionsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAzureSubscriptionsDTO, Failure | Error, GetAzureSubscriptionsQueryParams, void>(
    getConfig('ng/api'),
    `/azure/subscriptions`,
    props,
    signal
  )

export interface GetAzureResourceGroupsBySubscriptionQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetAzureResourceGroupsBySubscriptionPathParams {
  subscriptionId: string
}

export type GetAzureResourceGroupsBySubscriptionProps = Omit<
  GetProps<
    ResponseAzureResourceGroupsDTO,
    Failure | Error,
    GetAzureResourceGroupsBySubscriptionQueryParams,
    GetAzureResourceGroupsBySubscriptionPathParams
  >,
  'path'
> &
  GetAzureResourceGroupsBySubscriptionPathParams

/**
 * Gets azure resource groups by subscription
 */
export const GetAzureResourceGroupsBySubscription = ({
  subscriptionId,
  ...props
}: GetAzureResourceGroupsBySubscriptionProps) => (
  <Get<
    ResponseAzureResourceGroupsDTO,
    Failure | Error,
    GetAzureResourceGroupsBySubscriptionQueryParams,
    GetAzureResourceGroupsBySubscriptionPathParams
  >
    path={`/azure/subscriptions/${subscriptionId}/resourceGroups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAzureResourceGroupsBySubscriptionProps = Omit<
  UseGetProps<
    ResponseAzureResourceGroupsDTO,
    Failure | Error,
    GetAzureResourceGroupsBySubscriptionQueryParams,
    GetAzureResourceGroupsBySubscriptionPathParams
  >,
  'path'
> &
  GetAzureResourceGroupsBySubscriptionPathParams

/**
 * Gets azure resource groups by subscription
 */
export const useGetAzureResourceGroupsBySubscription = ({
  subscriptionId,
  ...props
}: UseGetAzureResourceGroupsBySubscriptionProps) =>
  useGet<
    ResponseAzureResourceGroupsDTO,
    Failure | Error,
    GetAzureResourceGroupsBySubscriptionQueryParams,
    GetAzureResourceGroupsBySubscriptionPathParams
  >(
    (paramsInPath: GetAzureResourceGroupsBySubscriptionPathParams) =>
      `/azure/subscriptions/${paramsInPath.subscriptionId}/resourceGroups`,
    { base: getConfig('ng/api'), pathParams: { subscriptionId }, ...props }
  )

/**
 * Gets azure resource groups by subscription
 */
export const getAzureResourceGroupsBySubscriptionPromise = (
  {
    subscriptionId,
    ...props
  }: GetUsingFetchProps<
    ResponseAzureResourceGroupsDTO,
    Failure | Error,
    GetAzureResourceGroupsBySubscriptionQueryParams,
    GetAzureResourceGroupsBySubscriptionPathParams
  > & { subscriptionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseAzureResourceGroupsDTO,
    Failure | Error,
    GetAzureResourceGroupsBySubscriptionQueryParams,
    GetAzureResourceGroupsBySubscriptionPathParams
  >(getConfig('ng/api'), `/azure/subscriptions/${subscriptionId}/resourceGroups`, props, signal)

export interface GetAzureWebAppNamesQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetAzureWebAppNamesPathParams {
  subscriptionId: string
  resourceGroup: string
}

export type GetAzureWebAppNamesProps = Omit<
  GetProps<ResponseAzureWebAppNamesDTO, Failure | Error, GetAzureWebAppNamesQueryParams, GetAzureWebAppNamesPathParams>,
  'path'
> &
  GetAzureWebAppNamesPathParams

/**
 * Gets azure app services names by subscriptionId and resourceGroup
 */
export const GetAzureWebAppNames = ({ subscriptionId, resourceGroup, ...props }: GetAzureWebAppNamesProps) => (
  <Get<ResponseAzureWebAppNamesDTO, Failure | Error, GetAzureWebAppNamesQueryParams, GetAzureWebAppNamesPathParams>
    path={`/azure/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/app-services-names`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAzureWebAppNamesProps = Omit<
  UseGetProps<
    ResponseAzureWebAppNamesDTO,
    Failure | Error,
    GetAzureWebAppNamesQueryParams,
    GetAzureWebAppNamesPathParams
  >,
  'path'
> &
  GetAzureWebAppNamesPathParams

/**
 * Gets azure app services names by subscriptionId and resourceGroup
 */
export const useGetAzureWebAppNames = ({ subscriptionId, resourceGroup, ...props }: UseGetAzureWebAppNamesProps) =>
  useGet<ResponseAzureWebAppNamesDTO, Failure | Error, GetAzureWebAppNamesQueryParams, GetAzureWebAppNamesPathParams>(
    (paramsInPath: GetAzureWebAppNamesPathParams) =>
      `/azure/subscriptions/${paramsInPath.subscriptionId}/resourceGroups/${paramsInPath.resourceGroup}/app-services-names`,
    { base: getConfig('ng/api'), pathParams: { subscriptionId, resourceGroup }, ...props }
  )

/**
 * Gets azure app services names by subscriptionId and resourceGroup
 */
export const getAzureWebAppNamesPromise = (
  {
    subscriptionId,
    resourceGroup,
    ...props
  }: GetUsingFetchProps<
    ResponseAzureWebAppNamesDTO,
    Failure | Error,
    GetAzureWebAppNamesQueryParams,
    GetAzureWebAppNamesPathParams
  > & { subscriptionId: string; resourceGroup: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseAzureWebAppNamesDTO,
    Failure | Error,
    GetAzureWebAppNamesQueryParams,
    GetAzureWebAppNamesPathParams
  >(
    getConfig('ng/api'),
    `/azure/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/app-services-names`,
    props,
    signal
  )

export interface GetAzureWebAppDeploymentSlotsQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetAzureWebAppDeploymentSlotsPathParams {
  subscriptionId: string
  resourceGroup: string
  webAppName: string
}

export type GetAzureWebAppDeploymentSlotsProps = Omit<
  GetProps<
    ResponseAzureDeploymentSlotsDTO,
    Failure | Error,
    GetAzureWebAppDeploymentSlotsQueryParams,
    GetAzureWebAppDeploymentSlotsPathParams
  >,
  'path'
> &
  GetAzureWebAppDeploymentSlotsPathParams

/**
 * Gets azure webApp deployment slots
 */
export const GetAzureWebAppDeploymentSlots = ({
  subscriptionId,
  resourceGroup,
  webAppName,
  ...props
}: GetAzureWebAppDeploymentSlotsProps) => (
  <Get<
    ResponseAzureDeploymentSlotsDTO,
    Failure | Error,
    GetAzureWebAppDeploymentSlotsQueryParams,
    GetAzureWebAppDeploymentSlotsPathParams
  >
    path={`/azure/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/app-services/${webAppName}/slots`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAzureWebAppDeploymentSlotsProps = Omit<
  UseGetProps<
    ResponseAzureDeploymentSlotsDTO,
    Failure | Error,
    GetAzureWebAppDeploymentSlotsQueryParams,
    GetAzureWebAppDeploymentSlotsPathParams
  >,
  'path'
> &
  GetAzureWebAppDeploymentSlotsPathParams

/**
 * Gets azure webApp deployment slots
 */
export const useGetAzureWebAppDeploymentSlots = ({
  subscriptionId,
  resourceGroup,
  webAppName,
  ...props
}: UseGetAzureWebAppDeploymentSlotsProps) =>
  useGet<
    ResponseAzureDeploymentSlotsDTO,
    Failure | Error,
    GetAzureWebAppDeploymentSlotsQueryParams,
    GetAzureWebAppDeploymentSlotsPathParams
  >(
    (paramsInPath: GetAzureWebAppDeploymentSlotsPathParams) =>
      `/azure/subscriptions/${paramsInPath.subscriptionId}/resourceGroups/${paramsInPath.resourceGroup}/app-services/${paramsInPath.webAppName}/slots`,
    { base: getConfig('ng/api'), pathParams: { subscriptionId, resourceGroup, webAppName }, ...props }
  )

/**
 * Gets azure webApp deployment slots
 */
export const getAzureWebAppDeploymentSlotsPromise = (
  {
    subscriptionId,
    resourceGroup,
    webAppName,
    ...props
  }: GetUsingFetchProps<
    ResponseAzureDeploymentSlotsDTO,
    Failure | Error,
    GetAzureWebAppDeploymentSlotsQueryParams,
    GetAzureWebAppDeploymentSlotsPathParams
  > & { subscriptionId: string; resourceGroup: string; webAppName: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseAzureDeploymentSlotsDTO,
    Failure | Error,
    GetAzureWebAppDeploymentSlotsQueryParams,
    GetAzureWebAppDeploymentSlotsPathParams
  >(
    getConfig('ng/api'),
    `/azure/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/app-services/${webAppName}/slots`,
    props,
    signal
  )

export interface GetAzureClustersQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetAzureClustersPathParams {
  subscriptionId: string
  resourceGroup: string
}

export type GetAzureClustersProps = Omit<
  GetProps<ResponseAzureClustersDTO, Failure | Error, GetAzureClustersQueryParams, GetAzureClustersPathParams>,
  'path'
> &
  GetAzureClustersPathParams

/**
 * Gets azure k8s clusters by subscription
 */
export const GetAzureClusters = ({ subscriptionId, resourceGroup, ...props }: GetAzureClustersProps) => (
  <Get<ResponseAzureClustersDTO, Failure | Error, GetAzureClustersQueryParams, GetAzureClustersPathParams>
    path={`/azure/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/clusters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAzureClustersProps = Omit<
  UseGetProps<ResponseAzureClustersDTO, Failure | Error, GetAzureClustersQueryParams, GetAzureClustersPathParams>,
  'path'
> &
  GetAzureClustersPathParams

/**
 * Gets azure k8s clusters by subscription
 */
export const useGetAzureClusters = ({ subscriptionId, resourceGroup, ...props }: UseGetAzureClustersProps) =>
  useGet<ResponseAzureClustersDTO, Failure | Error, GetAzureClustersQueryParams, GetAzureClustersPathParams>(
    (paramsInPath: GetAzureClustersPathParams) =>
      `/azure/subscriptions/${paramsInPath.subscriptionId}/resourceGroups/${paramsInPath.resourceGroup}/clusters`,
    { base: getConfig('ng/api'), pathParams: { subscriptionId, resourceGroup }, ...props }
  )

/**
 * Gets azure k8s clusters by subscription
 */
export const getAzureClustersPromise = (
  {
    subscriptionId,
    resourceGroup,
    ...props
  }: GetUsingFetchProps<
    ResponseAzureClustersDTO,
    Failure | Error,
    GetAzureClustersQueryParams,
    GetAzureClustersPathParams
  > & { subscriptionId: string; resourceGroup: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAzureClustersDTO, Failure | Error, GetAzureClustersQueryParams, GetAzureClustersPathParams>(
    getConfig('ng/api'),
    `/azure/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/clusters`,
    props,
    signal
  )

export interface GetsazureimageGalleriesbyresourcegroupQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  fqnPath?: string
  serviceId?: string
}

export interface GetsazureimageGalleriesbyresourcegroupPathParams {
  subscriptionId: string
  resourceGroup: string
}

export type GetsazureimageGalleriesbyresourcegroupProps = Omit<
  GetProps<
    ResponseAzureImageGalleriesDTO,
    Failure | Error,
    GetsazureimageGalleriesbyresourcegroupQueryParams,
    GetsazureimageGalleriesbyresourcegroupPathParams
  >,
  'path'
> &
  GetsazureimageGalleriesbyresourcegroupPathParams

/**
 * Gets azure image Galleries by resource group
 */
export const GetsazureimageGalleriesbyresourcegroup = ({
  subscriptionId,
  resourceGroup,
  ...props
}: GetsazureimageGalleriesbyresourcegroupProps) => (
  <Get<
    ResponseAzureImageGalleriesDTO,
    Failure | Error,
    GetsazureimageGalleriesbyresourcegroupQueryParams,
    GetsazureimageGalleriesbyresourcegroupPathParams
  >
    path={`/azure/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/imageGalleries`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetsazureimageGalleriesbyresourcegroupProps = Omit<
  UseGetProps<
    ResponseAzureImageGalleriesDTO,
    Failure | Error,
    GetsazureimageGalleriesbyresourcegroupQueryParams,
    GetsazureimageGalleriesbyresourcegroupPathParams
  >,
  'path'
> &
  GetsazureimageGalleriesbyresourcegroupPathParams

/**
 * Gets azure image Galleries by resource group
 */
export const useGetsazureimageGalleriesbyresourcegroup = ({
  subscriptionId,
  resourceGroup,
  ...props
}: UseGetsazureimageGalleriesbyresourcegroupProps) =>
  useGet<
    ResponseAzureImageGalleriesDTO,
    Failure | Error,
    GetsazureimageGalleriesbyresourcegroupQueryParams,
    GetsazureimageGalleriesbyresourcegroupPathParams
  >(
    (paramsInPath: GetsazureimageGalleriesbyresourcegroupPathParams) =>
      `/azure/subscriptions/${paramsInPath.subscriptionId}/resourceGroups/${paramsInPath.resourceGroup}/imageGalleries`,
    { base: getConfig('ng/api'), pathParams: { subscriptionId, resourceGroup }, ...props }
  )

/**
 * Gets azure image Galleries by resource group
 */
export const getsazureimageGalleriesbyresourcegroupPromise = (
  {
    subscriptionId,
    resourceGroup,
    ...props
  }: GetUsingFetchProps<
    ResponseAzureImageGalleriesDTO,
    Failure | Error,
    GetsazureimageGalleriesbyresourcegroupQueryParams,
    GetsazureimageGalleriesbyresourcegroupPathParams
  > & { subscriptionId: string; resourceGroup: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseAzureImageGalleriesDTO,
    Failure | Error,
    GetsazureimageGalleriesbyresourcegroupQueryParams,
    GetsazureimageGalleriesbyresourcegroupPathParams
  >(
    getConfig('ng/api'),
    `/azure/subscriptions/${subscriptionId}/resourceGroups/${resourceGroup}/imageGalleries`,
    props,
    signal
  )

export interface GetSubscriptionTagsQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetSubscriptionTagsPathParams {
  subscriptionId: string
}

export type GetSubscriptionTagsProps = Omit<
  GetProps<ResponseAzureTagsDTO, Failure | Error, GetSubscriptionTagsQueryParams, GetSubscriptionTagsPathParams>,
  'path'
> &
  GetSubscriptionTagsPathParams

/**
 * Gets azure tags by subscription
 */
export const GetSubscriptionTags = ({ subscriptionId, ...props }: GetSubscriptionTagsProps) => (
  <Get<ResponseAzureTagsDTO, Failure | Error, GetSubscriptionTagsQueryParams, GetSubscriptionTagsPathParams>
    path={`/azure/subscriptions/${subscriptionId}/tags`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSubscriptionTagsProps = Omit<
  UseGetProps<ResponseAzureTagsDTO, Failure | Error, GetSubscriptionTagsQueryParams, GetSubscriptionTagsPathParams>,
  'path'
> &
  GetSubscriptionTagsPathParams

/**
 * Gets azure tags by subscription
 */
export const useGetSubscriptionTags = ({ subscriptionId, ...props }: UseGetSubscriptionTagsProps) =>
  useGet<ResponseAzureTagsDTO, Failure | Error, GetSubscriptionTagsQueryParams, GetSubscriptionTagsPathParams>(
    (paramsInPath: GetSubscriptionTagsPathParams) => `/azure/subscriptions/${paramsInPath.subscriptionId}/tags`,
    { base: getConfig('ng/api'), pathParams: { subscriptionId }, ...props }
  )

/**
 * Gets azure tags by subscription
 */
export const getSubscriptionTagsPromise = (
  {
    subscriptionId,
    ...props
  }: GetUsingFetchProps<
    ResponseAzureTagsDTO,
    Failure | Error,
    GetSubscriptionTagsQueryParams,
    GetSubscriptionTagsPathParams
  > & { subscriptionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAzureTagsDTO, Failure | Error, GetSubscriptionTagsQueryParams, GetSubscriptionTagsPathParams>(
    getConfig('ng/api'),
    `/azure/subscriptions/${subscriptionId}/tags`,
    props,
    signal
  )

export interface GetAzureWebAppNamesV2QueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  subscriptionId?: string
  resourceGroup?: string
  envId?: string
  infraDefinitionId?: string
}

export type GetAzureWebAppNamesV2Props = Omit<
  GetProps<ResponseAzureWebAppNamesDTO, Failure | Error, GetAzureWebAppNamesV2QueryParams, void>,
  'path'
>

/**
 * Gets azure app services names V2
 */
export const GetAzureWebAppNamesV2 = (props: GetAzureWebAppNamesV2Props) => (
  <Get<ResponseAzureWebAppNamesDTO, Failure | Error, GetAzureWebAppNamesV2QueryParams, void>
    path={`/azure/v2/app-services-names`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAzureWebAppNamesV2Props = Omit<
  UseGetProps<ResponseAzureWebAppNamesDTO, Failure | Error, GetAzureWebAppNamesV2QueryParams, void>,
  'path'
>

/**
 * Gets azure app services names V2
 */
export const useGetAzureWebAppNamesV2 = (props: UseGetAzureWebAppNamesV2Props) =>
  useGet<ResponseAzureWebAppNamesDTO, Failure | Error, GetAzureWebAppNamesV2QueryParams, void>(
    `/azure/v2/app-services-names`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets azure app services names V2
 */
export const getAzureWebAppNamesV2Promise = (
  props: GetUsingFetchProps<ResponseAzureWebAppNamesDTO, Failure | Error, GetAzureWebAppNamesV2QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAzureWebAppNamesDTO, Failure | Error, GetAzureWebAppNamesV2QueryParams, void>(
    getConfig('ng/api'),
    `/azure/v2/app-services-names`,
    props,
    signal
  )

export interface GetAzureWebAppDeploymentSlotsV2QueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  subscriptionId?: string
  resourceGroup?: string
  envId?: string
  infraDefinitionId?: string
}

export interface GetAzureWebAppDeploymentSlotsV2PathParams {
  webAppName: string
}

export type GetAzureWebAppDeploymentSlotsV2Props = Omit<
  GetProps<
    ResponseAzureDeploymentSlotsDTO,
    Failure | Error,
    GetAzureWebAppDeploymentSlotsV2QueryParams,
    GetAzureWebAppDeploymentSlotsV2PathParams
  >,
  'path'
> &
  GetAzureWebAppDeploymentSlotsV2PathParams

/**
 * Gets azure webApp deployment slots V2
 */
export const GetAzureWebAppDeploymentSlotsV2 = ({ webAppName, ...props }: GetAzureWebAppDeploymentSlotsV2Props) => (
  <Get<
    ResponseAzureDeploymentSlotsDTO,
    Failure | Error,
    GetAzureWebAppDeploymentSlotsV2QueryParams,
    GetAzureWebAppDeploymentSlotsV2PathParams
  >
    path={`/azure/v2/app-services/${webAppName}/slots`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAzureWebAppDeploymentSlotsV2Props = Omit<
  UseGetProps<
    ResponseAzureDeploymentSlotsDTO,
    Failure | Error,
    GetAzureWebAppDeploymentSlotsV2QueryParams,
    GetAzureWebAppDeploymentSlotsV2PathParams
  >,
  'path'
> &
  GetAzureWebAppDeploymentSlotsV2PathParams

/**
 * Gets azure webApp deployment slots V2
 */
export const useGetAzureWebAppDeploymentSlotsV2 = ({ webAppName, ...props }: UseGetAzureWebAppDeploymentSlotsV2Props) =>
  useGet<
    ResponseAzureDeploymentSlotsDTO,
    Failure | Error,
    GetAzureWebAppDeploymentSlotsV2QueryParams,
    GetAzureWebAppDeploymentSlotsV2PathParams
  >(
    (paramsInPath: GetAzureWebAppDeploymentSlotsV2PathParams) =>
      `/azure/v2/app-services/${paramsInPath.webAppName}/slots`,
    { base: getConfig('ng/api'), pathParams: { webAppName }, ...props }
  )

/**
 * Gets azure webApp deployment slots V2
 */
export const getAzureWebAppDeploymentSlotsV2Promise = (
  {
    webAppName,
    ...props
  }: GetUsingFetchProps<
    ResponseAzureDeploymentSlotsDTO,
    Failure | Error,
    GetAzureWebAppDeploymentSlotsV2QueryParams,
    GetAzureWebAppDeploymentSlotsV2PathParams
  > & { webAppName: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseAzureDeploymentSlotsDTO,
    Failure | Error,
    GetAzureWebAppDeploymentSlotsV2QueryParams,
    GetAzureWebAppDeploymentSlotsV2PathParams
  >(getConfig('ng/api'), `/azure/v2/app-services/${webAppName}/slots`, props, signal)

export interface GetAzureClustersV2QueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  subscriptionId?: string
  resourceGroup?: string
  envId?: string
  infraDefinitionId?: string
}

export type GetAzureClustersV2Props = Omit<
  GetProps<ResponseAzureClustersDTO, Failure | Error, GetAzureClustersV2QueryParams, void>,
  'path'
>

/**
 * Gets azure k8s clusters
 */
export const GetAzureClustersV2 = (props: GetAzureClustersV2Props) => (
  <Get<ResponseAzureClustersDTO, Failure | Error, GetAzureClustersV2QueryParams, void>
    path={`/azure/v2/clusters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAzureClustersV2Props = Omit<
  UseGetProps<ResponseAzureClustersDTO, Failure | Error, GetAzureClustersV2QueryParams, void>,
  'path'
>

/**
 * Gets azure k8s clusters
 */
export const useGetAzureClustersV2 = (props: UseGetAzureClustersV2Props) =>
  useGet<ResponseAzureClustersDTO, Failure | Error, GetAzureClustersV2QueryParams, void>(`/azure/v2/clusters`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets azure k8s clusters
 */
export const getAzureClustersV2Promise = (
  props: GetUsingFetchProps<ResponseAzureClustersDTO, Failure | Error, GetAzureClustersV2QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAzureClustersDTO, Failure | Error, GetAzureClustersV2QueryParams, void>(
    getConfig('ng/api'),
    `/azure/v2/clusters`,
    props,
    signal
  )

export interface GetAzureResourceGroupsV2QueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  subscriptionId?: string
  envId?: string
  infraDefinitionId?: string
}

export type GetAzureResourceGroupsV2Props = Omit<
  GetProps<ResponseAzureResourceGroupsDTO, Failure | Error, GetAzureResourceGroupsV2QueryParams, void>,
  'path'
>

/**
 * Gets azure resource groups V2
 */
export const GetAzureResourceGroupsV2 = (props: GetAzureResourceGroupsV2Props) => (
  <Get<ResponseAzureResourceGroupsDTO, Failure | Error, GetAzureResourceGroupsV2QueryParams, void>
    path={`/azure/v2/resourceGroups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAzureResourceGroupsV2Props = Omit<
  UseGetProps<ResponseAzureResourceGroupsDTO, Failure | Error, GetAzureResourceGroupsV2QueryParams, void>,
  'path'
>

/**
 * Gets azure resource groups V2
 */
export const useGetAzureResourceGroupsV2 = (props: UseGetAzureResourceGroupsV2Props) =>
  useGet<ResponseAzureResourceGroupsDTO, Failure | Error, GetAzureResourceGroupsV2QueryParams, void>(
    `/azure/v2/resourceGroups`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets azure resource groups V2
 */
export const getAzureResourceGroupsV2Promise = (
  props: GetUsingFetchProps<ResponseAzureResourceGroupsDTO, Failure | Error, GetAzureResourceGroupsV2QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAzureResourceGroupsDTO, Failure | Error, GetAzureResourceGroupsV2QueryParams, void>(
    getConfig('ng/api'),
    `/azure/v2/resourceGroups`,
    props,
    signal
  )

export interface GetSubscriptionTagsV2QueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  subscriptionId?: string
  envId?: string
  infraDefinitionId?: string
}

export type GetSubscriptionTagsV2Props = Omit<
  GetProps<ResponseAzureTagsDTO, Failure | Error, GetSubscriptionTagsV2QueryParams, void>,
  'path'
>

/**
 * Gets azure tags by subscription
 */
export const GetSubscriptionTagsV2 = (props: GetSubscriptionTagsV2Props) => (
  <Get<ResponseAzureTagsDTO, Failure | Error, GetSubscriptionTagsV2QueryParams, void>
    path={`/azure/v2/tags`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSubscriptionTagsV2Props = Omit<
  UseGetProps<ResponseAzureTagsDTO, Failure | Error, GetSubscriptionTagsV2QueryParams, void>,
  'path'
>

/**
 * Gets azure tags by subscription
 */
export const useGetSubscriptionTagsV2 = (props: UseGetSubscriptionTagsV2Props) =>
  useGet<ResponseAzureTagsDTO, Failure | Error, GetSubscriptionTagsV2QueryParams, void>(`/azure/v2/tags`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets azure tags by subscription
 */
export const getSubscriptionTagsV2Promise = (
  props: GetUsingFetchProps<ResponseAzureTagsDTO, Failure | Error, GetSubscriptionTagsV2QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAzureTagsDTO, Failure | Error, GetSubscriptionTagsV2QueryParams, void>(
    getConfig('ng/api'),
    `/azure/v2/tags`,
    props,
    signal
  )

export interface GetGCSBucketListQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  fqnPath?: string
  serviceId?: string
}

export type GetGCSBucketListProps = Omit<
  GetProps<ResponseMapStringString, Failure | Error, GetGCSBucketListQueryParams, void>,
  'path'
>

/**
 * Gets GCS buckets list
 */
export const GetGCSBucketList = (props: GetGCSBucketListProps) => (
  <Get<ResponseMapStringString, Failure | Error, GetGCSBucketListQueryParams, void>
    path={`/buckets/gcs`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGCSBucketListProps = Omit<
  UseGetProps<ResponseMapStringString, Failure | Error, GetGCSBucketListQueryParams, void>,
  'path'
>

/**
 * Gets GCS buckets list
 */
export const useGetGCSBucketList = (props: UseGetGCSBucketListProps) =>
  useGet<ResponseMapStringString, Failure | Error, GetGCSBucketListQueryParams, void>(`/buckets/gcs`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets GCS buckets list
 */
export const getGCSBucketListPromise = (
  props: GetUsingFetchProps<ResponseMapStringString, Failure | Error, GetGCSBucketListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapStringString, Failure | Error, GetGCSBucketListQueryParams, void>(
    getConfig('ng/api'),
    `/buckets/gcs`,
    props,
    signal
  )

export interface GetBucketListForS3QueryParams {
  region?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  fqnPath?: string
  serviceId?: string
}

export type GetBucketListForS3Props = Omit<
  GetProps<ResponseMapStringString, Failure | Error, GetBucketListForS3QueryParams, void>,
  'path'
>

/**
 * Gets s3 buckets
 */
export const GetBucketListForS3 = (props: GetBucketListForS3Props) => (
  <Get<ResponseMapStringString, Failure | Error, GetBucketListForS3QueryParams, void>
    path={`/buckets/s3/getBuckets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBucketListForS3Props = Omit<
  UseGetProps<ResponseMapStringString, Failure | Error, GetBucketListForS3QueryParams, void>,
  'path'
>

/**
 * Gets s3 buckets
 */
export const useGetBucketListForS3 = (props: UseGetBucketListForS3Props) =>
  useGet<ResponseMapStringString, Failure | Error, GetBucketListForS3QueryParams, void>(`/buckets/s3/getBuckets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets s3 buckets
 */
export const getBucketListForS3Promise = (
  props: GetUsingFetchProps<ResponseMapStringString, Failure | Error, GetBucketListForS3QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapStringString, Failure | Error, GetBucketListForS3QueryParams, void>(
    getConfig('ng/api'),
    `/buckets/s3/getBuckets`,
    props,
    signal
  )

export interface GetV2BucketListForS3QueryParams {
  region?: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetV2BucketListForS3Props = Omit<
  GetProps<ResponseListBucketResponse, Failure | Error, GetV2BucketListForS3QueryParams, void>,
  'path'
>

/**
 * Gets s3 buckets
 */
export const GetV2BucketListForS3 = (props: GetV2BucketListForS3Props) => (
  <Get<ResponseListBucketResponse, Failure | Error, GetV2BucketListForS3QueryParams, void>
    path={`/buckets/s3/getBucketsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetV2BucketListForS3Props = Omit<
  UseGetProps<ResponseListBucketResponse, Failure | Error, GetV2BucketListForS3QueryParams, void>,
  'path'
>

/**
 * Gets s3 buckets
 */
export const useGetV2BucketListForS3 = (props: UseGetV2BucketListForS3Props) =>
  useGet<ResponseListBucketResponse, Failure | Error, GetV2BucketListForS3QueryParams, void>(
    `/buckets/s3/getBucketsV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets s3 buckets
 */
export const getV2BucketListForS3Promise = (
  props: GetUsingFetchProps<ResponseListBucketResponse, Failure | Error, GetV2BucketListForS3QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListBucketResponse, Failure | Error, GetV2BucketListForS3QueryParams, void>(
    getConfig('ng/api'),
    `/buckets/s3/getBucketsV2`,
    props,
    signal
  )

export interface GetFilePathsForS3QueryParams {
  region?: string
  connectorRef: string
  bucketName: string
  filePathRegex?: string
  fileFilter?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetFilePathsForS3Props = Omit<
  GetProps<ResponseListFilePaths, Failure | Error, GetFilePathsForS3QueryParams, void>,
  'path'
>

/**
 * Gets s3 file paths
 */
export const GetFilePathsForS3 = (props: GetFilePathsForS3Props) => (
  <Get<ResponseListFilePaths, Failure | Error, GetFilePathsForS3QueryParams, void>
    path={`/buckets/s3/getFilePaths`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFilePathsForS3Props = Omit<
  UseGetProps<ResponseListFilePaths, Failure | Error, GetFilePathsForS3QueryParams, void>,
  'path'
>

/**
 * Gets s3 file paths
 */
export const useGetFilePathsForS3 = (props: UseGetFilePathsForS3Props) =>
  useGet<ResponseListFilePaths, Failure | Error, GetFilePathsForS3QueryParams, void>(`/buckets/s3/getFilePaths`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets s3 file paths
 */
export const getFilePathsForS3Promise = (
  props: GetUsingFetchProps<ResponseListFilePaths, Failure | Error, GetFilePathsForS3QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListFilePaths, Failure | Error, GetFilePathsForS3QueryParams, void>(
    getConfig('ng/api'),
    `/buckets/s3/getFilePaths`,
    props,
    signal
  )

export interface ListBucketsWithServiceV2QueryParams {
  region?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath: string
  serviceId?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type ListBucketsWithServiceV2Props = Omit<
  MutateProps<
    ResponseListBucketResponse,
    Failure | Error,
    ListBucketsWithServiceV2QueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets s3 buckets
 */
export const ListBucketsWithServiceV2 = (props: ListBucketsWithServiceV2Props) => (
  <Mutate<
    ResponseListBucketResponse,
    Failure | Error,
    ListBucketsWithServiceV2QueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >
    verb="POST"
    path={`/buckets/s3/v2/getBuckets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListBucketsWithServiceV2Props = Omit<
  UseMutateProps<
    ResponseListBucketResponse,
    Failure | Error,
    ListBucketsWithServiceV2QueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets s3 buckets
 */
export const useListBucketsWithServiceV2 = (props: UseListBucketsWithServiceV2Props) =>
  useMutate<
    ResponseListBucketResponse,
    Failure | Error,
    ListBucketsWithServiceV2QueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', `/buckets/s3/v2/getBuckets`, { base: getConfig('ng/api'), ...props })

/**
 * Gets s3 buckets
 */
export const listBucketsWithServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseListBucketResponse,
    Failure | Error,
    ListBucketsWithServiceV2QueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListBucketResponse,
    Failure | Error,
    ListBucketsWithServiceV2QueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/buckets/s3/v2/getBuckets`, props, signal)

export interface GetBucketsInManifestsQueryParams {
  region?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath?: string
  serviceId?: string
}

export type GetBucketsInManifestsProps = Omit<
  MutateProps<
    ResponseMapStringString,
    Failure | Error,
    GetBucketsInManifestsQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets s3 buckets
 */
export const GetBucketsInManifests = (props: GetBucketsInManifestsProps) => (
  <Mutate<
    ResponseMapStringString,
    Failure | Error,
    GetBucketsInManifestsQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >
    verb="POST"
    path={`/buckets/s3/v2/getBucketsInManifests`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBucketsInManifestsProps = Omit<
  UseMutateProps<
    ResponseMapStringString,
    Failure | Error,
    GetBucketsInManifestsQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets s3 buckets
 */
export const useGetBucketsInManifests = (props: UseGetBucketsInManifestsProps) =>
  useMutate<
    ResponseMapStringString,
    Failure | Error,
    GetBucketsInManifestsQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', `/buckets/s3/v2/getBucketsInManifests`, { base: getConfig('ng/api'), ...props })

/**
 * Gets s3 buckets
 */
export const getBucketsInManifestsPromise = (
  props: MutateUsingFetchProps<
    ResponseMapStringString,
    Failure | Error,
    GetBucketsInManifestsQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseMapStringString,
    Failure | Error,
    GetBucketsInManifestsQueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/buckets/s3/v2/getBucketsInManifests`, props, signal)

export interface GetFilePathsV2ForS3QueryParams {
  region?: string
  connectorRef?: string
  bucketName?: string
  filePathRegex?: string
  fileFilter?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath: string
  serviceId?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetFilePathsV2ForS3Props = Omit<
  MutateProps<
    ResponseListFilePaths,
    Failure | Error,
    GetFilePathsV2ForS3QueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets s3 file paths
 */
export const GetFilePathsV2ForS3 = (props: GetFilePathsV2ForS3Props) => (
  <Mutate<
    ResponseListFilePaths,
    Failure | Error,
    GetFilePathsV2ForS3QueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >
    verb="POST"
    path={`/buckets/s3/v2/getFilePaths`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFilePathsV2ForS3Props = Omit<
  UseMutateProps<
    ResponseListFilePaths,
    Failure | Error,
    GetFilePathsV2ForS3QueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets s3 file paths
 */
export const useGetFilePathsV2ForS3 = (props: UseGetFilePathsV2ForS3Props) =>
  useMutate<
    ResponseListFilePaths,
    Failure | Error,
    GetFilePathsV2ForS3QueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', `/buckets/s3/v2/getFilePaths`, { base: getConfig('ng/api'), ...props })

/**
 * Gets s3 file paths
 */
export const getFilePathsV2ForS3Promise = (
  props: MutateUsingFetchProps<
    ResponseListFilePaths,
    Failure | Error,
    GetFilePathsV2ForS3QueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListFilePaths,
    Failure | Error,
    GetFilePathsV2ForS3QueryParams,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/buckets/s3/v2/getFilePaths`, props, signal)

export interface GetCannyBoardsQueryParams {
  accountIdentifier: string
}

export type GetCannyBoardsProps = Omit<
  GetProps<ResponseCannyBoardsResponseDTO, Failure | AccessControlCheckError | Error, GetCannyBoardsQueryParams, void>,
  'path'
>

/**
 * Get a list of boards available on Canny
 */
export const GetCannyBoards = (props: GetCannyBoardsProps) => (
  <Get<ResponseCannyBoardsResponseDTO, Failure | AccessControlCheckError | Error, GetCannyBoardsQueryParams, void>
    path={`/canny/boards`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCannyBoardsProps = Omit<
  UseGetProps<
    ResponseCannyBoardsResponseDTO,
    Failure | AccessControlCheckError | Error,
    GetCannyBoardsQueryParams,
    void
  >,
  'path'
>

/**
 * Get a list of boards available on Canny
 */
export const useGetCannyBoards = (props: UseGetCannyBoardsProps) =>
  useGet<ResponseCannyBoardsResponseDTO, Failure | AccessControlCheckError | Error, GetCannyBoardsQueryParams, void>(
    `/canny/boards`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get a list of boards available on Canny
 */
export const getCannyBoardsPromise = (
  props: GetUsingFetchProps<
    ResponseCannyBoardsResponseDTO,
    Failure | AccessControlCheckError | Error,
    GetCannyBoardsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseCannyBoardsResponseDTO,
    Failure | AccessControlCheckError | Error,
    GetCannyBoardsQueryParams,
    void
  >(getConfig('ng/api'), `/canny/boards`, props, signal)

export interface CreateCannyPostQueryParams {
  accountIdentifier?: string
}

export type CreateCannyPostProps = Omit<
  MutateProps<
    ResponseCannyPostResponseDTO,
    Failure | AccessControlCheckError | Error,
    CreateCannyPostQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * create Canny Post for given user
 */
export const CreateCannyPost = (props: CreateCannyPostProps) => (
  <Mutate<
    ResponseCannyPostResponseDTO,
    Failure | AccessControlCheckError | Error,
    CreateCannyPostQueryParams,
    void,
    void
  >
    verb="POST"
    path={`/canny/post`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateCannyPostProps = Omit<
  UseMutateProps<
    ResponseCannyPostResponseDTO,
    Failure | AccessControlCheckError | Error,
    CreateCannyPostQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * create Canny Post for given user
 */
export const useCreateCannyPost = (props: UseCreateCannyPostProps) =>
  useMutate<
    ResponseCannyPostResponseDTO,
    Failure | AccessControlCheckError | Error,
    CreateCannyPostQueryParams,
    void,
    void
  >('POST', `/canny/post`, { base: getConfig('ng/api'), ...props })

/**
 * create Canny Post for given user
 */
export const createCannyPostPromise = (
  props: MutateUsingFetchProps<
    ResponseCannyPostResponseDTO,
    Failure | AccessControlCheckError | Error,
    CreateCannyPostQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseCannyPostResponseDTO,
    Failure | AccessControlCheckError | Error,
    CreateCannyPostQueryParams,
    void,
    void
  >('POST', getConfig('ng/api'), `/canny/post`, props, signal)

export type GetCdDeployStageMetadataProps = Omit<
  MutateProps<ResponseCDStageMetaDataDTO, unknown, void, CdDeployStageMetadataRequestDTO, void>,
  'path' | 'verb'
>

/**
 * Gets the Service and Environment refs from CD Stage Yaml
 */
export const GetCdDeployStageMetadata = (props: GetCdDeployStageMetadataProps) => (
  <Mutate<ResponseCDStageMetaDataDTO, unknown, void, CdDeployStageMetadataRequestDTO, void>
    verb="POST"
    path={`/cdStage/metadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCdDeployStageMetadataProps = Omit<
  UseMutateProps<ResponseCDStageMetaDataDTO, unknown, void, CdDeployStageMetadataRequestDTO, void>,
  'path' | 'verb'
>

/**
 * Gets the Service and Environment refs from CD Stage Yaml
 */
export const useGetCdDeployStageMetadata = (props: UseGetCdDeployStageMetadataProps) =>
  useMutate<ResponseCDStageMetaDataDTO, unknown, void, CdDeployStageMetadataRequestDTO, void>(
    'POST',
    `/cdStage/metadata`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets the Service and Environment refs from CD Stage Yaml
 */
export const getCdDeployStageMetadataPromise = (
  props: MutateUsingFetchProps<ResponseCDStageMetaDataDTO, unknown, void, CdDeployStageMetadataRequestDTO, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseCDStageMetaDataDTO, unknown, void, CdDeployStageMetadataRequestDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/cdStage/metadata`,
    props,
    signal
  )

export interface ListStageExecutionFormattedSummaryByStageExecutionIdentifiersQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  stageExecutionIdentifiers: string[]
}

export type ListStageExecutionFormattedSummaryByStageExecutionIdentifiersProps = Omit<
  GetProps<
    ResponseMapStringCDStageSummaryResponseDTO,
    Failure | Error,
    ListStageExecutionFormattedSummaryByStageExecutionIdentifiersQueryParams,
    void
  >,
  'path'
>

/**
 * Lists summary of execution of deployment stages filtered by stage execution identifiers
 */
export const ListStageExecutionFormattedSummaryByStageExecutionIdentifiers = (
  props: ListStageExecutionFormattedSummaryByStageExecutionIdentifiersProps
) => (
  <Get<
    ResponseMapStringCDStageSummaryResponseDTO,
    Failure | Error,
    ListStageExecutionFormattedSummaryByStageExecutionIdentifiersQueryParams,
    void
  >
    path={`/cdStageSummary/listStageExecutionFormattedSummary`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListStageExecutionFormattedSummaryByStageExecutionIdentifiersProps = Omit<
  UseGetProps<
    ResponseMapStringCDStageSummaryResponseDTO,
    Failure | Error,
    ListStageExecutionFormattedSummaryByStageExecutionIdentifiersQueryParams,
    void
  >,
  'path'
>

/**
 * Lists summary of execution of deployment stages filtered by stage execution identifiers
 */
export const useListStageExecutionFormattedSummaryByStageExecutionIdentifiers = (
  props: UseListStageExecutionFormattedSummaryByStageExecutionIdentifiersProps
) =>
  useGet<
    ResponseMapStringCDStageSummaryResponseDTO,
    Failure | Error,
    ListStageExecutionFormattedSummaryByStageExecutionIdentifiersQueryParams,
    void
  >(`/cdStageSummary/listStageExecutionFormattedSummary`, { base: getConfig('ng/api'), ...props })

/**
 * Lists summary of execution of deployment stages filtered by stage execution identifiers
 */
export const listStageExecutionFormattedSummaryByStageExecutionIdentifiersPromise = (
  props: GetUsingFetchProps<
    ResponseMapStringCDStageSummaryResponseDTO,
    Failure | Error,
    ListStageExecutionFormattedSummaryByStageExecutionIdentifiersQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseMapStringCDStageSummaryResponseDTO,
    Failure | Error,
    ListStageExecutionFormattedSummaryByStageExecutionIdentifiersQueryParams,
    void
  >(getConfig('ng/api'), `/cdStageSummary/listStageExecutionFormattedSummary`, props, signal)

export interface ListStagePlanCreationFormattedSummaryByStageIdentifiersQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  planExecutionId: string
  stageIdentifiers: string[]
}

export type ListStagePlanCreationFormattedSummaryByStageIdentifiersProps = Omit<
  GetProps<
    ResponseMapStringCDStageSummaryResponseDTO,
    Failure | Error,
    ListStagePlanCreationFormattedSummaryByStageIdentifiersQueryParams,
    void
  >,
  'path'
>

/**
 * Lists summary of deployment stages available at plan creation filtered by stage identifiers
 */
export const ListStagePlanCreationFormattedSummaryByStageIdentifiers = (
  props: ListStagePlanCreationFormattedSummaryByStageIdentifiersProps
) => (
  <Get<
    ResponseMapStringCDStageSummaryResponseDTO,
    Failure | Error,
    ListStagePlanCreationFormattedSummaryByStageIdentifiersQueryParams,
    void
  >
    path={`/cdStageSummary/listStagePlanCreationFormattedSummary`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListStagePlanCreationFormattedSummaryByStageIdentifiersProps = Omit<
  UseGetProps<
    ResponseMapStringCDStageSummaryResponseDTO,
    Failure | Error,
    ListStagePlanCreationFormattedSummaryByStageIdentifiersQueryParams,
    void
  >,
  'path'
>

/**
 * Lists summary of deployment stages available at plan creation filtered by stage identifiers
 */
export const useListStagePlanCreationFormattedSummaryByStageIdentifiers = (
  props: UseListStagePlanCreationFormattedSummaryByStageIdentifiersProps
) =>
  useGet<
    ResponseMapStringCDStageSummaryResponseDTO,
    Failure | Error,
    ListStagePlanCreationFormattedSummaryByStageIdentifiersQueryParams,
    void
  >(`/cdStageSummary/listStagePlanCreationFormattedSummary`, { base: getConfig('ng/api'), ...props })

/**
 * Lists summary of deployment stages available at plan creation filtered by stage identifiers
 */
export const listStagePlanCreationFormattedSummaryByStageIdentifiersPromise = (
  props: GetUsingFetchProps<
    ResponseMapStringCDStageSummaryResponseDTO,
    Failure | Error,
    ListStagePlanCreationFormattedSummaryByStageIdentifiersQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseMapStringCDStageSummaryResponseDTO,
    Failure | Error,
    ListStagePlanCreationFormattedSummaryByStageIdentifiersQueryParams,
    void
  >(getConfig('ng/api'), `/cdStageSummary/listStagePlanCreationFormattedSummary`, props, signal)

export interface GetConnectorListQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  type?:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Azure'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
    | 'ErrorTracking'
    | 'Pdc'
    | 'AzureRepo'
    | 'Jenkins'
    | 'OciHelmRepo'
    | 'CustomSecretManager'
    | 'ElasticSearch'
    | 'GcpSecretManager'
    | 'AzureArtifacts'
    | 'Tas'
    | 'Spot'
    | 'Bamboo'
    | 'TerraformCloud'
    | 'SignalFX'
    | 'Harness'
    | 'Rancher'
  category?:
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  source_category?:
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  version?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetConnectorListProps = Omit<
  GetProps<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>,
  'path'
>

/**
 * Gets Connector list
 */
export const GetConnectorList = (props: GetConnectorListProps) => (
  <Get<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>
    path={`/connectors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorListProps = Omit<
  UseGetProps<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>,
  'path'
>

/**
 * Gets Connector list
 */
export const useGetConnectorList = (props: UseGetConnectorListProps) =>
  useGet<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>(`/connectors`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Connector list
 */
export const getConnectorListPromise = (
  props: GetUsingFetchProps<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>(
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface CreateConnectorQueryParams {
  accountIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  repoName?: string
}

export type CreateConnectorProps = Omit<
  MutateProps<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>,
  'path' | 'verb'
>

/**
 * Creates a Connector
 */
export const CreateConnector = (props: CreateConnectorProps) => (
  <Mutate<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>
    verb="POST"
    path={`/connectors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateConnectorProps = Omit<
  UseMutateProps<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>,
  'path' | 'verb'
>

/**
 * Creates a Connector
 */
export const useCreateConnector = (props: UseCreateConnectorProps) =>
  useMutate<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>(
    'POST',
    `/connectors`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Creates a Connector
 */
export const createConnectorPromise = (
  props: MutateUsingFetchProps<
    ResponseConnectorResponse,
    Failure | Error,
    CreateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface UpdateConnectorQueryParams {
  accountIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  lastCommitId?: string
  isNewBranch?: boolean
}

export type UpdateConnectorProps = Omit<
  MutateProps<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>,
  'path' | 'verb'
>

/**
 * Updates a Connector
 */
export const UpdateConnector = (props: UpdateConnectorProps) => (
  <Mutate<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>
    verb="PUT"
    path={`/connectors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateConnectorProps = Omit<
  UseMutateProps<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>,
  'path' | 'verb'
>

/**
 * Updates a Connector
 */
export const useUpdateConnector = (props: UseUpdateConnectorProps) =>
  useMutate<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>(
    'PUT',
    `/connectors`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Updates a Connector
 */
export const updateConnectorPromise = (
  props: MutateUsingFetchProps<
    ResponseConnectorResponse,
    Failure | Error,
    UpdateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface GetConnectorCatalogueQueryParams {
  accountIdentifier?: string
}

export type GetConnectorCatalogueProps = Omit<
  GetProps<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>,
  'path'
>

/**
 * Get Connector Catalogue
 */
export const GetConnectorCatalogue = (props: GetConnectorCatalogueProps) => (
  <Get<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>
    path={`/connectors/catalogue`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorCatalogueProps = Omit<
  UseGetProps<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>,
  'path'
>

/**
 * Get Connector Catalogue
 */
export const useGetConnectorCatalogue = (props: UseGetConnectorCatalogueProps) =>
  useGet<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>(
    `/connectors/catalogue`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Connector Catalogue
 */
export const getConnectorCataloguePromise = (
  props: GetUsingFetchProps<
    ResponseConnectorCatalogueResponse,
    Failure | Error,
    GetConnectorCatalogueQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>(
    getConfig('ng/api'),
    `/connectors/catalogue`,
    props,
    signal
  )

export interface GetCCMK8SConnectorListQueryParams {
  accountIdentifier?: string
  searchTerm?: string
  orgIdentifier?: string
  projectIdentifier?: string
  filterIdentifier?: string
  includeAllConnectorsAvailableAtScope?: boolean
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  getDistinctFromBranches?: boolean
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type GetCCMK8SConnectorListProps = Omit<
  MutateProps<
    ResponsePageCcmK8sConnectorResponse,
    Failure | Error,
    GetCCMK8SConnectorListQueryParams,
    ConnectorFilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets CCMK8S Connector list
 */
export const GetCCMK8SConnectorList = (props: GetCCMK8SConnectorListProps) => (
  <Mutate<
    ResponsePageCcmK8sConnectorResponse,
    Failure | Error,
    GetCCMK8SConnectorListQueryParams,
    ConnectorFilterPropertiesRequestBody,
    void
  >
    verb="POST"
    path={`/connectors/ccmK8sList`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCCMK8SConnectorListProps = Omit<
  UseMutateProps<
    ResponsePageCcmK8sConnectorResponse,
    Failure | Error,
    GetCCMK8SConnectorListQueryParams,
    ConnectorFilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets CCMK8S Connector list
 */
export const useGetCCMK8SConnectorList = (props: UseGetCCMK8SConnectorListProps) =>
  useMutate<
    ResponsePageCcmK8sConnectorResponse,
    Failure | Error,
    GetCCMK8SConnectorListQueryParams,
    ConnectorFilterPropertiesRequestBody,
    void
  >('POST', `/connectors/ccmK8sList`, { base: getConfig('ng/api'), ...props })

/**
 * Gets CCMK8S Connector list
 */
export const getCCMK8SConnectorListPromise = (
  props: MutateUsingFetchProps<
    ResponsePageCcmK8sConnectorResponse,
    Failure | Error,
    GetCCMK8SConnectorListQueryParams,
    ConnectorFilterPropertiesRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageCcmK8sConnectorResponse,
    Failure | Error,
    GetCCMK8SConnectorListQueryParams,
    ConnectorFilterPropertiesRequestBody,
    void
  >('POST', getConfig('ng/api'), `/connectors/ccmK8sList`, props, signal)

export interface GetAllAllowedFieldValuesQueryParams {
  accountIdentifier?: string
  connectorType:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Azure'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
    | 'ErrorTracking'
    | 'Pdc'
    | 'AzureRepo'
    | 'Jenkins'
    | 'OciHelmRepo'
    | 'CustomSecretManager'
    | 'ElasticSearch'
    | 'GcpSecretManager'
    | 'AzureArtifacts'
    | 'Tas'
    | 'Spot'
    | 'Bamboo'
    | 'TerraformCloud'
    | 'SignalFX'
    | 'Harness'
    | 'Rancher'
}

export type GetAllAllowedFieldValuesProps = Omit<
  GetProps<ResponseFieldValues, Failure | Error, GetAllAllowedFieldValuesQueryParams, void>,
  'path'
>

/**
 * Get All Allowed field values for Connector Type
 */
export const GetAllAllowedFieldValues = (props: GetAllAllowedFieldValuesProps) => (
  <Get<ResponseFieldValues, Failure | Error, GetAllAllowedFieldValuesQueryParams, void>
    path={`/connectors/fieldValues`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAllAllowedFieldValuesProps = Omit<
  UseGetProps<ResponseFieldValues, Failure | Error, GetAllAllowedFieldValuesQueryParams, void>,
  'path'
>

/**
 * Get All Allowed field values for Connector Type
 */
export const useGetAllAllowedFieldValues = (props: UseGetAllAllowedFieldValuesProps) =>
  useGet<ResponseFieldValues, Failure | Error, GetAllAllowedFieldValuesQueryParams, void>(`/connectors/fieldValues`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get All Allowed field values for Connector Type
 */
export const getAllAllowedFieldValuesPromise = (
  props: GetUsingFetchProps<ResponseFieldValues, Failure | Error, GetAllAllowedFieldValuesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseFieldValues, Failure | Error, GetAllAllowedFieldValuesQueryParams, void>(
    getConfig('ng/api'),
    `/connectors/fieldValues`,
    props,
    signal
  )

export interface GetCEAwsTemplateQueryParams {
  eventsEnabled?: boolean
  curEnabled?: boolean
  optimizationEnabled?: boolean
}

export type GetCEAwsTemplateProps = Omit<
  MutateProps<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Get CCM Aws Connector Template URL Environment Wise
 */
export const GetCEAwsTemplate = (props: GetCEAwsTemplateProps) => (
  <Mutate<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>
    verb="POST"
    path={`/connectors/getceawstemplateurl`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCEAwsTemplateProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Get CCM Aws Connector Template URL Environment Wise
 */
export const useGetCEAwsTemplate = (props: UseGetCEAwsTemplateProps) =>
  useMutate<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>(
    'POST',
    `/connectors/getceawstemplateurl`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get CCM Aws Connector Template URL Environment Wise
 */
export const getCEAwsTemplatePromise = (
  props: MutateUsingFetchProps<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/connectors/getceawstemplateurl`,
    props,
    signal
  )

export interface GetConnectorListV2QueryParams {
  accountIdentifier?: string
  searchTerm?: string
  orgIdentifier?: string
  projectIdentifier?: string
  filterIdentifier?: string
  includeAllConnectorsAvailableAtScope?: boolean
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  getDistinctFromBranches?: boolean
  version?: string
  onlyFavorites?: boolean
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type GetConnectorListV2Props = Omit<
  MutateProps<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Connector list
 */
export const GetConnectorListV2 = (props: GetConnectorListV2Props) => (
  <Mutate<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterPropertiesRequestBody,
    void
  >
    verb="POST"
    path={`/connectors/listV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorListV2Props = Omit<
  UseMutateProps<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Connector list
 */
export const useGetConnectorListV2 = (props: UseGetConnectorListV2Props) =>
  useMutate<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterPropertiesRequestBody,
    void
  >('POST', `/connectors/listV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Connector list
 */
export const getConnectorListV2Promise = (
  props: MutateUsingFetchProps<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterPropertiesRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterPropertiesRequestBody,
    void
  >('POST', getConfig('ng/api'), `/connectors/listV2`, props, signal)

export interface ListConnectorByFQNQueryParams {
  accountIdentifier?: string
}

export type ListConnectorByFQNProps = Omit<
  MutateProps<ResponseListConnectorResponse, Failure | Error, ListConnectorByFQNQueryParams, string[], void>,
  'path' | 'verb'
>

/**
 * Gets Connector list
 */
export const ListConnectorByFQN = (props: ListConnectorByFQNProps) => (
  <Mutate<ResponseListConnectorResponse, Failure | Error, ListConnectorByFQNQueryParams, string[], void>
    verb="POST"
    path={`/connectors/listbyfqn`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListConnectorByFQNProps = Omit<
  UseMutateProps<ResponseListConnectorResponse, Failure | Error, ListConnectorByFQNQueryParams, string[], void>,
  'path' | 'verb'
>

/**
 * Gets Connector list
 */
export const useListConnectorByFQN = (props: UseListConnectorByFQNProps) =>
  useMutate<ResponseListConnectorResponse, Failure | Error, ListConnectorByFQNQueryParams, string[], void>(
    'POST',
    `/connectors/listbyfqn`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Connector list
 */
export const listConnectorByFQNPromise = (
  props: MutateUsingFetchProps<
    ResponseListConnectorResponse,
    Failure | Error,
    ListConnectorByFQNQueryParams,
    string[],
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseListConnectorResponse, Failure | Error, ListConnectorByFQNQueryParams, string[], void>(
    'POST',
    getConfig('ng/api'),
    `/connectors/listbyfqn`,
    props,
    signal
  )

export interface GetConnectorStatisticsQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetConnectorStatisticsProps = Omit<
  GetProps<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>,
  'path'
>

/**
 * Get Connectors statistics
 */
export const GetConnectorStatistics = (props: GetConnectorStatisticsProps) => (
  <Get<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>
    path={`/connectors/stats`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorStatisticsProps = Omit<
  UseGetProps<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>,
  'path'
>

/**
 * Get Connectors statistics
 */
export const useGetConnectorStatistics = (props: UseGetConnectorStatisticsProps) =>
  useGet<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>(`/connectors/stats`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Connectors statistics
 */
export const getConnectorStatisticsPromise = (
  props: GetUsingFetchProps<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>(
    getConfig('ng/api'),
    `/connectors/stats`,
    props,
    signal
  )

export interface GetTestConnectionResultQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export interface GetTestConnectionResultPathParams {
  identifier: string
}

export type GetTestConnectionResultProps = Omit<
  MutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestConnectionResultPathParams

/**
 * Test the connection
 */
export const GetTestConnectionResult = ({ identifier, ...props }: GetTestConnectionResultProps) => (
  <Mutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >
    verb="POST"
    path={`/connectors/testConnection/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTestConnectionResultProps = Omit<
  UseMutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestConnectionResultPathParams

/**
 * Test the connection
 */
export const useGetTestConnectionResult = ({ identifier, ...props }: UseGetTestConnectionResultProps) =>
  useMutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >(
    'POST',
    (paramsInPath: GetTestConnectionResultPathParams) => `/connectors/testConnection/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Test the connection
 */
export const getTestConnectionResultPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >('POST', getConfig('ng/api'), `/connectors/testConnection/${identifier}`, props, signal)

export interface GetTestConnectionResultInternalQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetTestConnectionResultInternalPathParams {
  identifier: string
}

export type GetTestConnectionResultInternalProps = Omit<
  MutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultInternalQueryParams,
    void,
    GetTestConnectionResultInternalPathParams
  >,
  'path' | 'verb'
> &
  GetTestConnectionResultInternalPathParams

/**
 * Test the connection internal api
 */
export const GetTestConnectionResultInternal = ({ identifier, ...props }: GetTestConnectionResultInternalProps) => (
  <Mutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultInternalQueryParams,
    void,
    GetTestConnectionResultInternalPathParams
  >
    verb="POST"
    path={`/connectors/testConnectionInternal/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTestConnectionResultInternalProps = Omit<
  UseMutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultInternalQueryParams,
    void,
    GetTestConnectionResultInternalPathParams
  >,
  'path' | 'verb'
> &
  GetTestConnectionResultInternalPathParams

/**
 * Test the connection internal api
 */
export const useGetTestConnectionResultInternal = ({ identifier, ...props }: UseGetTestConnectionResultInternalProps) =>
  useMutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultInternalQueryParams,
    void,
    GetTestConnectionResultInternalPathParams
  >(
    'POST',
    (paramsInPath: GetTestConnectionResultInternalPathParams) =>
      `/connectors/testConnectionInternal/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Test the connection internal api
 */
export const getTestConnectionResultInternalPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultInternalQueryParams,
    void,
    GetTestConnectionResultInternalPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultInternalQueryParams,
    void,
    GetTestConnectionResultInternalPathParams
  >('POST', getConfig('ng/api'), `/connectors/testConnectionInternal/${identifier}`, props, signal)

export interface GetTestGitRepoConnectionResultQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repoURL?: string
}

export interface GetTestGitRepoConnectionResultPathParams {
  identifier: string
}

export type GetTestGitRepoConnectionResultProps = Omit<
  MutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestGitRepoConnectionResultPathParams

/**
 * Test the connection
 */
export const GetTestGitRepoConnectionResult = ({ identifier, ...props }: GetTestGitRepoConnectionResultProps) => (
  <Mutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >
    verb="POST"
    path={`/connectors/testGitRepoConnection/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTestGitRepoConnectionResultProps = Omit<
  UseMutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestGitRepoConnectionResultPathParams

/**
 * Test the connection
 */
export const useGetTestGitRepoConnectionResult = ({ identifier, ...props }: UseGetTestGitRepoConnectionResultProps) =>
  useMutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >(
    'POST',
    (paramsInPath: GetTestGitRepoConnectionResultPathParams) =>
      `/connectors/testGitRepoConnection/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Test the connection
 */
export const getTestGitRepoConnectionResultPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >('POST', getConfig('ng/api'), `/connectors/testGitRepoConnection/${identifier}`, props, signal)

export interface ValidateTheIdentifierIsUniqueQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
}

export type ValidateTheIdentifierIsUniqueProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>,
  'path'
>

/**
 * Validate Identifier is unique
 */
export const ValidateTheIdentifierIsUnique = (props: ValidateTheIdentifierIsUniqueProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>
    path={`/connectors/validateUniqueIdentifier`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateTheIdentifierIsUniqueProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>,
  'path'
>

/**
 * Validate Identifier is unique
 */
export const useValidateTheIdentifierIsUnique = (props: UseValidateTheIdentifierIsUniqueProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>(
    `/connectors/validateUniqueIdentifier`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate Identifier is unique
 */
export const validateTheIdentifierIsUniquePromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>(
    getConfig('ng/api'),
    `/connectors/validateUniqueIdentifier`,
    props,
    signal
  )

export interface DeleteConnectorQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  forceDelete?: boolean
}

export type DeleteConnectorProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a connector by identifier
 */
export const DeleteConnector = (props: DeleteConnectorProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>
    verb="DELETE"
    path={`/connectors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteConnectorProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a connector by identifier
 */
export const useDeleteConnector = (props: UseDeleteConnectorProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>('DELETE', `/connectors`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a connector by identifier
 */
export const deleteConnectorPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface GetConnectorQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export interface GetConnectorPathParams {
  identifier: string
}

export type GetConnectorProps = Omit<
  GetProps<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>,
  'path'
> &
  GetConnectorPathParams

/**
 * Get Connector
 */
export const GetConnector = ({ identifier, ...props }: GetConnectorProps) => (
  <Get<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>
    path={`/connectors/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorProps = Omit<
  UseGetProps<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>,
  'path'
> &
  GetConnectorPathParams

/**
 * Get Connector
 */
export const useGetConnector = ({ identifier, ...props }: UseGetConnectorProps) =>
  useGet<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>(
    (paramsInPath: GetConnectorPathParams) => `/connectors/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Connector
 */
export const getConnectorPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>(
    getConfig('ng/api'),
    `/connectors/${identifier}`,
    props,
    signal
  )

export interface SaveCardQueryParams {
  accountIdentifier: string
}

export type SaveCardProps = Omit<
  MutateProps<ResponseCreditCardResponse, Failure | Error, SaveCardQueryParams, CreditCardDTO, void>,
  'path' | 'verb'
>

/**
 * Saves non-sensitive credit card information
 */
export const SaveCard = (props: SaveCardProps) => (
  <Mutate<ResponseCreditCardResponse, Failure | Error, SaveCardQueryParams, CreditCardDTO, void>
    verb="POST"
    path={`/credit-cards`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSaveCardProps = Omit<
  UseMutateProps<ResponseCreditCardResponse, Failure | Error, SaveCardQueryParams, CreditCardDTO, void>,
  'path' | 'verb'
>

/**
 * Saves non-sensitive credit card information
 */
export const useSaveCard = (props: UseSaveCardProps) =>
  useMutate<ResponseCreditCardResponse, Failure | Error, SaveCardQueryParams, CreditCardDTO, void>(
    'POST',
    `/credit-cards`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Saves non-sensitive credit card information
 */
export const saveCardPromise = (
  props: MutateUsingFetchProps<ResponseCreditCardResponse, Failure | Error, SaveCardQueryParams, CreditCardDTO, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseCreditCardResponse, Failure | Error, SaveCardQueryParams, CreditCardDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/credit-cards`,
    props,
    signal
  )

export interface GetDefaultCardQueryParams {
  accountIdentifier: string
}

export type GetDefaultCardProps = Omit<
  GetProps<ResponseCardDTO, Failure | Error, GetDefaultCardQueryParams, void>,
  'path'
>

/**
 * Gets the default card for the customer
 */
export const GetDefaultCard = (props: GetDefaultCardProps) => (
  <Get<ResponseCardDTO, Failure | Error, GetDefaultCardQueryParams, void>
    path={`/credit-cards/default`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDefaultCardProps = Omit<
  UseGetProps<ResponseCardDTO, Failure | Error, GetDefaultCardQueryParams, void>,
  'path'
>

/**
 * Gets the default card for the customer
 */
export const useGetDefaultCard = (props: UseGetDefaultCardProps) =>
  useGet<ResponseCardDTO, Failure | Error, GetDefaultCardQueryParams, void>(`/credit-cards/default`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets the default card for the customer
 */
export const getDefaultCardPromise = (
  props: GetUsingFetchProps<ResponseCardDTO, Failure | Error, GetDefaultCardQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCardDTO, Failure | Error, GetDefaultCardQueryParams, void>(
    getConfig('ng/api'),
    `/credit-cards/default`,
    props,
    signal
  )

export interface HasAValidCardQueryParams {
  accountIdentifier: string
}

export type HasAValidCardProps = Omit<
  GetProps<ResponseAccountCreditCardValidationResponse, Failure | Error, HasAValidCardQueryParams, void>,
  'path'
>

/**
 * Checks for a valid credit card
 */
export const HasAValidCard = (props: HasAValidCardProps) => (
  <Get<ResponseAccountCreditCardValidationResponse, Failure | Error, HasAValidCardQueryParams, void>
    path={`/credit-cards/has-valid-card`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseHasAValidCardProps = Omit<
  UseGetProps<ResponseAccountCreditCardValidationResponse, Failure | Error, HasAValidCardQueryParams, void>,
  'path'
>

/**
 * Checks for a valid credit card
 */
export const useHasAValidCard = (props: UseHasAValidCardProps) =>
  useGet<ResponseAccountCreditCardValidationResponse, Failure | Error, HasAValidCardQueryParams, void>(
    `/credit-cards/has-valid-card`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Checks for a valid credit card
 */
export const hasAValidCardPromise = (
  props: GetUsingFetchProps<
    ResponseAccountCreditCardValidationResponse,
    Failure | Error,
    HasAValidCardQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAccountCreditCardValidationResponse, Failure | Error, HasAValidCardQueryParams, void>(
    getConfig('ng/api'),
    `/credit-cards/has-valid-card`,
    props,
    signal
  )

export interface DeleteCardQueryParams {
  accountIdentifier: string
}

export type DeleteCardProps = Omit<
  MutateProps<ResponseCreditCardResponse, Failure | Error, DeleteCardQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes credit card information
 */
export const DeleteCard = (props: DeleteCardProps) => (
  <Mutate<ResponseCreditCardResponse, Failure | Error, DeleteCardQueryParams, string, void>
    verb="DELETE"
    path={`/credit-cards`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteCardProps = Omit<
  UseMutateProps<ResponseCreditCardResponse, Failure | Error, DeleteCardQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes credit card information
 */
export const useDeleteCard = (props: UseDeleteCardProps) =>
  useMutate<ResponseCreditCardResponse, Failure | Error, DeleteCardQueryParams, string, void>(
    'DELETE',
    `/credit-cards`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Deletes credit card information
 */
export const deleteCardPromise = (
  props: MutateUsingFetchProps<ResponseCreditCardResponse, Failure | Error, DeleteCardQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseCreditCardResponse, Failure | Error, DeleteCardQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/credit-cards`,
    props,
    signal
  )

export interface IsValidQueryParams {
  accountIdentifier: string
}

export interface IsValidPathParams {
  identifier: string
}

export type IsValidProps = Omit<
  GetProps<ResponseCreditCardValidationResponse, Failure | Error, IsValidQueryParams, IsValidPathParams>,
  'path'
> &
  IsValidPathParams

/**
 * Checks validity of a credit card
 */
export const IsValid = ({ identifier, ...props }: IsValidProps) => (
  <Get<ResponseCreditCardValidationResponse, Failure | Error, IsValidQueryParams, IsValidPathParams>
    path={`/credit-cards/${identifier}/is-valid`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseIsValidProps = Omit<
  UseGetProps<ResponseCreditCardValidationResponse, Failure | Error, IsValidQueryParams, IsValidPathParams>,
  'path'
> &
  IsValidPathParams

/**
 * Checks validity of a credit card
 */
export const useIsValid = ({ identifier, ...props }: UseIsValidProps) =>
  useGet<ResponseCreditCardValidationResponse, Failure | Error, IsValidQueryParams, IsValidPathParams>(
    (paramsInPath: IsValidPathParams) => `/credit-cards/${paramsInPath.identifier}/is-valid`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Checks validity of a credit card
 */
export const isValidPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseCreditCardValidationResponse,
    Failure | Error,
    IsValidQueryParams,
    IsValidPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCreditCardValidationResponse, Failure | Error, IsValidQueryParams, IsValidPathParams>(
    getConfig('ng/api'),
    `/credit-cards/${identifier}/is-valid`,
    props,
    signal
  )

export interface GetCreditsByAccountPathParams {
  accountIdentifier: string
}

export type GetCreditsByAccountProps = Omit<
  GetProps<ResponseListCreditDTO, Failure | Error, void, GetCreditsByAccountPathParams>,
  'path'
> &
  GetCreditsByAccountPathParams

/**
 * Get Credits purchase history of an Account in expiry time ascending order
 */
export const GetCreditsByAccount = ({ accountIdentifier, ...props }: GetCreditsByAccountProps) => (
  <Get<ResponseListCreditDTO, Failure | Error, void, GetCreditsByAccountPathParams>
    path={`/credits/${accountIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCreditsByAccountProps = Omit<
  UseGetProps<ResponseListCreditDTO, Failure | Error, void, GetCreditsByAccountPathParams>,
  'path'
> &
  GetCreditsByAccountPathParams

/**
 * Get Credits purchase history of an Account in expiry time ascending order
 */
export const useGetCreditsByAccount = ({ accountIdentifier, ...props }: UseGetCreditsByAccountProps) =>
  useGet<ResponseListCreditDTO, Failure | Error, void, GetCreditsByAccountPathParams>(
    (paramsInPath: GetCreditsByAccountPathParams) => `/credits/${paramsInPath.accountIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Get Credits purchase history of an Account in expiry time ascending order
 */
export const getCreditsByAccountPromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseListCreditDTO, Failure | Error, void, GetCreditsByAccountPathParams> & {
    accountIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListCreditDTO, Failure | Error, void, GetCreditsByAccountPathParams>(
    getConfig('ng/api'),
    `/credits/${accountIdentifier}`,
    props,
    signal
  )

export type GetCustomDeploymentExpressionVariablesProps = Omit<
  MutateProps<
    ResponseCustomDeploymentVariableResponse,
    Failure | Error,
    void,
    CustomDeploymentYamlRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Custom Deployment Expression Variables
 */
export const GetCustomDeploymentExpressionVariables = (props: GetCustomDeploymentExpressionVariablesProps) => (
  <Mutate<ResponseCustomDeploymentVariableResponse, Failure | Error, void, CustomDeploymentYamlRequestRequestBody, void>
    verb="POST"
    path={`/customDeployment/expression-variables`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCustomDeploymentExpressionVariablesProps = Omit<
  UseMutateProps<
    ResponseCustomDeploymentVariableResponse,
    Failure | Error,
    void,
    CustomDeploymentYamlRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Custom Deployment Expression Variables
 */
export const useGetCustomDeploymentExpressionVariables = (props: UseGetCustomDeploymentExpressionVariablesProps) =>
  useMutate<
    ResponseCustomDeploymentVariableResponse,
    Failure | Error,
    void,
    CustomDeploymentYamlRequestRequestBody,
    void
  >('POST', `/customDeployment/expression-variables`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Custom Deployment Expression Variables
 */
export const getCustomDeploymentExpressionVariablesPromise = (
  props: MutateUsingFetchProps<
    ResponseCustomDeploymentVariableResponse,
    Failure | Error,
    void,
    CustomDeploymentYamlRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseCustomDeploymentVariableResponse,
    Failure | Error,
    void,
    CustomDeploymentYamlRequestRequestBody,
    void
  >('POST', getConfig('ng/api'), `/customDeployment/expression-variables`, props, signal)

export interface GetCustomDeploymentEntityReferencesQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetCustomDeploymentEntityReferencesProps = Omit<
  MutateProps<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetCustomDeploymentEntityReferencesQueryParams,
    CustomDeploymentYamlRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Custom Deployment entity references
 */
export const GetCustomDeploymentEntityReferences = (props: GetCustomDeploymentEntityReferencesProps) => (
  <Mutate<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetCustomDeploymentEntityReferencesQueryParams,
    CustomDeploymentYamlRequestRequestBody,
    void
  >
    verb="POST"
    path={`/customDeployment/get-references`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCustomDeploymentEntityReferencesProps = Omit<
  UseMutateProps<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetCustomDeploymentEntityReferencesQueryParams,
    CustomDeploymentYamlRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Custom Deployment entity references
 */
export const useGetCustomDeploymentEntityReferences = (props: UseGetCustomDeploymentEntityReferencesProps) =>
  useMutate<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetCustomDeploymentEntityReferencesQueryParams,
    CustomDeploymentYamlRequestRequestBody,
    void
  >('POST', `/customDeployment/get-references`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Custom Deployment entity references
 */
export const getCustomDeploymentEntityReferencesPromise = (
  props: MutateUsingFetchProps<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetCustomDeploymentEntityReferencesQueryParams,
    CustomDeploymentYamlRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetCustomDeploymentEntityReferencesQueryParams,
    CustomDeploymentYamlRequestRequestBody,
    void
  >('POST', getConfig('ng/api'), `/customDeployment/get-references`, props, signal)

export interface GetUpdatedYamlForInfrastructureQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetUpdatedYamlForInfrastructurePathParams {
  infraIdentifier: string
}

export type GetUpdatedYamlForInfrastructureProps = Omit<
  MutateProps<
    ResponseCustomDeploymentRefreshYaml,
    Failure | Error,
    GetUpdatedYamlForInfrastructureQueryParams,
    CustomDeploymentYaml,
    GetUpdatedYamlForInfrastructurePathParams
  >,
  'path' | 'verb'
> &
  GetUpdatedYamlForInfrastructurePathParams

/**
 * Return the updated yaml for infrastructure based on Deployment template
 */
export const GetUpdatedYamlForInfrastructure = ({
  infraIdentifier,
  ...props
}: GetUpdatedYamlForInfrastructureProps) => (
  <Mutate<
    ResponseCustomDeploymentRefreshYaml,
    Failure | Error,
    GetUpdatedYamlForInfrastructureQueryParams,
    CustomDeploymentYaml,
    GetUpdatedYamlForInfrastructurePathParams
  >
    verb="POST"
    path={`/customDeployment/get-updated-Yaml/${infraIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUpdatedYamlForInfrastructureProps = Omit<
  UseMutateProps<
    ResponseCustomDeploymentRefreshYaml,
    Failure | Error,
    GetUpdatedYamlForInfrastructureQueryParams,
    CustomDeploymentYaml,
    GetUpdatedYamlForInfrastructurePathParams
  >,
  'path' | 'verb'
> &
  GetUpdatedYamlForInfrastructurePathParams

/**
 * Return the updated yaml for infrastructure based on Deployment template
 */
export const useGetUpdatedYamlForInfrastructure = ({
  infraIdentifier,
  ...props
}: UseGetUpdatedYamlForInfrastructureProps) =>
  useMutate<
    ResponseCustomDeploymentRefreshYaml,
    Failure | Error,
    GetUpdatedYamlForInfrastructureQueryParams,
    CustomDeploymentYaml,
    GetUpdatedYamlForInfrastructurePathParams
  >(
    'POST',
    (paramsInPath: GetUpdatedYamlForInfrastructurePathParams) =>
      `/customDeployment/get-updated-Yaml/${paramsInPath.infraIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { infraIdentifier }, ...props }
  )

/**
 * Return the updated yaml for infrastructure based on Deployment template
 */
export const getUpdatedYamlForInfrastructurePromise = (
  {
    infraIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseCustomDeploymentRefreshYaml,
    Failure | Error,
    GetUpdatedYamlForInfrastructureQueryParams,
    CustomDeploymentYaml,
    GetUpdatedYamlForInfrastructurePathParams
  > & { infraIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseCustomDeploymentRefreshYaml,
    Failure | Error,
    GetUpdatedYamlForInfrastructureQueryParams,
    CustomDeploymentYaml,
    GetUpdatedYamlForInfrastructurePathParams
  >('POST', getConfig('ng/api'), `/customDeployment/get-updated-Yaml/${infraIdentifier}`, props, signal)

export interface ValidateInfrastructureForDeploymentTemplateQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  envIdentifier?: string
}

export interface ValidateInfrastructureForDeploymentTemplatePathParams {
  infraIdentifier: string
}

export type ValidateInfrastructureForDeploymentTemplateProps = Omit<
  GetProps<
    ResponseCustomDeploymentInfraResponse,
    Failure | Error,
    ValidateInfrastructureForDeploymentTemplateQueryParams,
    ValidateInfrastructureForDeploymentTemplatePathParams
  >,
  'path'
> &
  ValidateInfrastructureForDeploymentTemplatePathParams

/**
 * This validates whether Infrastructure is valid or not
 */
export const ValidateInfrastructureForDeploymentTemplate = ({
  infraIdentifier,
  ...props
}: ValidateInfrastructureForDeploymentTemplateProps) => (
  <Get<
    ResponseCustomDeploymentInfraResponse,
    Failure | Error,
    ValidateInfrastructureForDeploymentTemplateQueryParams,
    ValidateInfrastructureForDeploymentTemplatePathParams
  >
    path={`/customDeployment/validate-infrastructure/${infraIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateInfrastructureForDeploymentTemplateProps = Omit<
  UseGetProps<
    ResponseCustomDeploymentInfraResponse,
    Failure | Error,
    ValidateInfrastructureForDeploymentTemplateQueryParams,
    ValidateInfrastructureForDeploymentTemplatePathParams
  >,
  'path'
> &
  ValidateInfrastructureForDeploymentTemplatePathParams

/**
 * This validates whether Infrastructure is valid or not
 */
export const useValidateInfrastructureForDeploymentTemplate = ({
  infraIdentifier,
  ...props
}: UseValidateInfrastructureForDeploymentTemplateProps) =>
  useGet<
    ResponseCustomDeploymentInfraResponse,
    Failure | Error,
    ValidateInfrastructureForDeploymentTemplateQueryParams,
    ValidateInfrastructureForDeploymentTemplatePathParams
  >(
    (paramsInPath: ValidateInfrastructureForDeploymentTemplatePathParams) =>
      `/customDeployment/validate-infrastructure/${paramsInPath.infraIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { infraIdentifier }, ...props }
  )

/**
 * This validates whether Infrastructure is valid or not
 */
export const validateInfrastructureForDeploymentTemplatePromise = (
  {
    infraIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseCustomDeploymentInfraResponse,
    Failure | Error,
    ValidateInfrastructureForDeploymentTemplateQueryParams,
    ValidateInfrastructureForDeploymentTemplatePathParams
  > & { infraIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseCustomDeploymentInfraResponse,
    Failure | Error,
    ValidateInfrastructureForDeploymentTemplateQueryParams,
    ValidateInfrastructureForDeploymentTemplatePathParams
  >(getConfig('ng/api'), `/customDeployment/validate-infrastructure/${infraIdentifier}`, props, signal)

export interface GetCustomDeploymentInfraVariablesQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  versionLabel?: string
  deleted?: boolean
}

export interface GetCustomDeploymentInfraVariablesPathParams {
  templateIdentifier: string
}

export type GetCustomDeploymentInfraVariablesProps = Omit<
  GetProps<
    ResponseString,
    Failure | Error,
    GetCustomDeploymentInfraVariablesQueryParams,
    GetCustomDeploymentInfraVariablesPathParams
  >,
  'path'
> &
  GetCustomDeploymentInfraVariablesPathParams

/**
 * Gets Infra variables from a Custom Deployment Template by identifier
 */
export const GetCustomDeploymentInfraVariables = ({
  templateIdentifier,
  ...props
}: GetCustomDeploymentInfraVariablesProps) => (
  <Get<
    ResponseString,
    Failure | Error,
    GetCustomDeploymentInfraVariablesQueryParams,
    GetCustomDeploymentInfraVariablesPathParams
  >
    path={`/customDeployment/variables/${templateIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCustomDeploymentInfraVariablesProps = Omit<
  UseGetProps<
    ResponseString,
    Failure | Error,
    GetCustomDeploymentInfraVariablesQueryParams,
    GetCustomDeploymentInfraVariablesPathParams
  >,
  'path'
> &
  GetCustomDeploymentInfraVariablesPathParams

/**
 * Gets Infra variables from a Custom Deployment Template by identifier
 */
export const useGetCustomDeploymentInfraVariables = ({
  templateIdentifier,
  ...props
}: UseGetCustomDeploymentInfraVariablesProps) =>
  useGet<
    ResponseString,
    Failure | Error,
    GetCustomDeploymentInfraVariablesQueryParams,
    GetCustomDeploymentInfraVariablesPathParams
  >(
    (paramsInPath: GetCustomDeploymentInfraVariablesPathParams) =>
      `/customDeployment/variables/${paramsInPath.templateIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { templateIdentifier }, ...props }
  )

/**
 * Gets Infra variables from a Custom Deployment Template by identifier
 */
export const getCustomDeploymentInfraVariablesPromise = (
  {
    templateIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseString,
    Failure | Error,
    GetCustomDeploymentInfraVariablesQueryParams,
    GetCustomDeploymentInfraVariablesPathParams
  > & { templateIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseString,
    Failure | Error,
    GetCustomDeploymentInfraVariablesQueryParams,
    GetCustomDeploymentInfraVariablesPathParams
  >(getConfig('ng/api'), `/customDeployment/variables/${templateIdentifier}`, props, signal)

export interface GetCustomSequenceQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId?: string
}

export type GetCustomSequenceProps = Omit<
  GetProps<ResponseCustomSequenceDTO, Failure | Error, GetCustomSequenceQueryParams, void>,
  'path'
>

/**
 * Get custom sequence for env and env groups
 */
export const GetCustomSequence = (props: GetCustomSequenceProps) => (
  <Get<ResponseCustomSequenceDTO, Failure | Error, GetCustomSequenceQueryParams, void>
    path={`/dashboard/customSequence`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCustomSequenceProps = Omit<
  UseGetProps<ResponseCustomSequenceDTO, Failure | Error, GetCustomSequenceQueryParams, void>,
  'path'
>

/**
 * Get custom sequence for env and env groups
 */
export const useGetCustomSequence = (props: UseGetCustomSequenceProps) =>
  useGet<ResponseCustomSequenceDTO, Failure | Error, GetCustomSequenceQueryParams, void>(`/dashboard/customSequence`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get custom sequence for env and env groups
 */
export const getCustomSequencePromise = (
  props: GetUsingFetchProps<ResponseCustomSequenceDTO, Failure | Error, GetCustomSequenceQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCustomSequenceDTO, Failure | Error, GetCustomSequenceQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/customSequence`,
    props,
    signal
  )

export interface SaveCustomSequenceQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId?: string
}

export type SaveCustomSequenceProps = Omit<
  MutateProps<ResponseServiceSequence, Failure | Error, SaveCustomSequenceQueryParams, CustomSequenceDTO, void>,
  'path' | 'verb'
>

/**
 * Save custom sequence for env and env groups
 */
export const SaveCustomSequence = (props: SaveCustomSequenceProps) => (
  <Mutate<ResponseServiceSequence, Failure | Error, SaveCustomSequenceQueryParams, CustomSequenceDTO, void>
    verb="POST"
    path={`/dashboard/customSequence`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSaveCustomSequenceProps = Omit<
  UseMutateProps<ResponseServiceSequence, Failure | Error, SaveCustomSequenceQueryParams, CustomSequenceDTO, void>,
  'path' | 'verb'
>

/**
 * Save custom sequence for env and env groups
 */
export const useSaveCustomSequence = (props: UseSaveCustomSequenceProps) =>
  useMutate<ResponseServiceSequence, Failure | Error, SaveCustomSequenceQueryParams, CustomSequenceDTO, void>(
    'POST',
    `/dashboard/customSequence`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Save custom sequence for env and env groups
 */
export const saveCustomSequencePromise = (
  props: MutateUsingFetchProps<
    ResponseServiceSequence,
    Failure | Error,
    SaveCustomSequenceQueryParams,
    CustomSequenceDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseServiceSequence, Failure | Error, SaveCustomSequenceQueryParams, CustomSequenceDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/dashboard/customSequence`,
    props,
    signal
  )

export interface DefaultSequenceQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId?: string
}

export type DefaultSequenceProps = Omit<
  GetProps<ResponseCustomSequenceDTO, Failure | Error, DefaultSequenceQueryParams, void>,
  'path'
>

/**
 * Get default sequence for env and env groups
 */
export const DefaultSequence = (props: DefaultSequenceProps) => (
  <Get<ResponseCustomSequenceDTO, Failure | Error, DefaultSequenceQueryParams, void>
    path={`/dashboard/defaultSequence`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDefaultSequenceProps = Omit<
  UseGetProps<ResponseCustomSequenceDTO, Failure | Error, DefaultSequenceQueryParams, void>,
  'path'
>

/**
 * Get default sequence for env and env groups
 */
export const useDefaultSequence = (props: UseDefaultSequenceProps) =>
  useGet<ResponseCustomSequenceDTO, Failure | Error, DefaultSequenceQueryParams, void>(`/dashboard/defaultSequence`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get default sequence for env and env groups
 */
export const defaultSequencePromise = (
  props: GetUsingFetchProps<ResponseCustomSequenceDTO, Failure | Error, DefaultSequenceQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCustomSequenceDTO, Failure | Error, DefaultSequenceQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/defaultSequence`,
    props,
    signal
  )

export interface GetDeploymentExecutionQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  startTime: number
  endTime: number
}

export type GetDeploymentExecutionProps = Omit<
  GetProps<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>,
  'path'
>

/**
 * Get deployment execution
 */
export const GetDeploymentExecution = (props: GetDeploymentExecutionProps) => (
  <Get<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>
    path={`/dashboard/deploymentExecution`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDeploymentExecutionProps = Omit<
  UseGetProps<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>,
  'path'
>

/**
 * Get deployment execution
 */
export const useGetDeploymentExecution = (props: UseGetDeploymentExecutionProps) =>
  useGet<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>(
    `/dashboard/deploymentExecution`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get deployment execution
 */
export const getDeploymentExecutionPromise = (
  props: GetUsingFetchProps<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/deploymentExecution`,
    props,
    signal
  )

export interface GetDeploymentHealthQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  startTime: number
  endTime: number
}

export type GetDeploymentHealthProps = Omit<
  GetProps<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>,
  'path'
>

/**
 * Get deployment health
 */
export const GetDeploymentHealth = (props: GetDeploymentHealthProps) => (
  <Get<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>
    path={`/dashboard/deploymentHealth`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDeploymentHealthProps = Omit<
  UseGetProps<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>,
  'path'
>

/**
 * Get deployment health
 */
export const useGetDeploymentHealth = (props: UseGetDeploymentHealthProps) =>
  useGet<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>(
    `/dashboard/deploymentHealth`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get deployment health
 */
export const getDeploymentHealthPromise = (
  props: GetUsingFetchProps<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/deploymentHealth`,
    props,
    signal
  )

export interface GetDeploymentHealthV2QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  startTime: number
  endTime: number
}

export type GetDeploymentHealthV2Props = Omit<
  GetProps<ResponseHealthDeploymentDashboardV2, Failure | Error, GetDeploymentHealthV2QueryParams, void>,
  'path'
>

/**
 * Get deployment health V2
 */
export const GetDeploymentHealthV2 = (props: GetDeploymentHealthV2Props) => (
  <Get<ResponseHealthDeploymentDashboardV2, Failure | Error, GetDeploymentHealthV2QueryParams, void>
    path={`/dashboard/deploymentHealthV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDeploymentHealthV2Props = Omit<
  UseGetProps<ResponseHealthDeploymentDashboardV2, Failure | Error, GetDeploymentHealthV2QueryParams, void>,
  'path'
>

/**
 * Get deployment health V2
 */
export const useGetDeploymentHealthV2 = (props: UseGetDeploymentHealthV2Props) =>
  useGet<ResponseHealthDeploymentDashboardV2, Failure | Error, GetDeploymentHealthV2QueryParams, void>(
    `/dashboard/deploymentHealthV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get deployment health V2
 */
export const getDeploymentHealthV2Promise = (
  props: GetUsingFetchProps<
    ResponseHealthDeploymentDashboardV2,
    Failure | Error,
    GetDeploymentHealthV2QueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseHealthDeploymentDashboardV2, Failure | Error, GetDeploymentHealthV2QueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/deploymentHealthV2`,
    props,
    signal
  )

export interface GetActiveInstanceGroupedByArtifactQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
  environmentIdentifier?: string
  envGroupIdentifier?: string
  artifact?: string
  filterOnArtifact: boolean
}

export type GetActiveInstanceGroupedByArtifactProps = Omit<
  GetProps<ResponseInstanceGroupedOnArtifactList, Failure | Error, GetActiveInstanceGroupedByArtifactQueryParams, void>,
  'path'
>

/**
 * Get active instance count for a service grouped on artifact, environment, infrastructure
 */
export const GetActiveInstanceGroupedByArtifact = (props: GetActiveInstanceGroupedByArtifactProps) => (
  <Get<ResponseInstanceGroupedOnArtifactList, Failure | Error, GetActiveInstanceGroupedByArtifactQueryParams, void>
    path={`/dashboard/getActiveInstanceGroupedByArtifact`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveInstanceGroupedByArtifactProps = Omit<
  UseGetProps<
    ResponseInstanceGroupedOnArtifactList,
    Failure | Error,
    GetActiveInstanceGroupedByArtifactQueryParams,
    void
  >,
  'path'
>

/**
 * Get active instance count for a service grouped on artifact, environment, infrastructure
 */
export const useGetActiveInstanceGroupedByArtifact = (props: UseGetActiveInstanceGroupedByArtifactProps) =>
  useGet<ResponseInstanceGroupedOnArtifactList, Failure | Error, GetActiveInstanceGroupedByArtifactQueryParams, void>(
    `/dashboard/getActiveInstanceGroupedByArtifact`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get active instance count for a service grouped on artifact, environment, infrastructure
 */
export const getActiveInstanceGroupedByArtifactPromise = (
  props: GetUsingFetchProps<
    ResponseInstanceGroupedOnArtifactList,
    Failure | Error,
    GetActiveInstanceGroupedByArtifactQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInstanceGroupedOnArtifactList,
    Failure | Error,
    GetActiveInstanceGroupedByArtifactQueryParams,
    void
  >(getConfig('ng/api'), `/dashboard/getActiveInstanceGroupedByArtifact`, props, signal)

export interface GetActiveInstanceGroupedByChartVersionQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
  environmentIdentifier?: string
  envGroupIdentifier?: string
  chartVersion?: string
  filterOnChartVersion: boolean
}

export type GetActiveInstanceGroupedByChartVersionProps = Omit<
  GetProps<
    ResponseInstanceGroupedOnChartVersionList,
    Failure | Error,
    GetActiveInstanceGroupedByChartVersionQueryParams,
    void
  >,
  'path'
>

/**
 * Get active instance count for a service grouped on chart version, artifact, environment, infrastructure
 */
export const GetActiveInstanceGroupedByChartVersion = (props: GetActiveInstanceGroupedByChartVersionProps) => (
  <Get<
    ResponseInstanceGroupedOnChartVersionList,
    Failure | Error,
    GetActiveInstanceGroupedByChartVersionQueryParams,
    void
  >
    path={`/dashboard/getActiveInstanceGroupedByChartVersion`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveInstanceGroupedByChartVersionProps = Omit<
  UseGetProps<
    ResponseInstanceGroupedOnChartVersionList,
    Failure | Error,
    GetActiveInstanceGroupedByChartVersionQueryParams,
    void
  >,
  'path'
>

/**
 * Get active instance count for a service grouped on chart version, artifact, environment, infrastructure
 */
export const useGetActiveInstanceGroupedByChartVersion = (props: UseGetActiveInstanceGroupedByChartVersionProps) =>
  useGet<
    ResponseInstanceGroupedOnChartVersionList,
    Failure | Error,
    GetActiveInstanceGroupedByChartVersionQueryParams,
    void
  >(`/dashboard/getActiveInstanceGroupedByChartVersion`, { base: getConfig('ng/api'), ...props })

/**
 * Get active instance count for a service grouped on chart version, artifact, environment, infrastructure
 */
export const getActiveInstanceGroupedByChartVersionPromise = (
  props: GetUsingFetchProps<
    ResponseInstanceGroupedOnChartVersionList,
    Failure | Error,
    GetActiveInstanceGroupedByChartVersionQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInstanceGroupedOnChartVersionList,
    Failure | Error,
    GetActiveInstanceGroupedByChartVersionQueryParams,
    void
  >(getConfig('ng/api'), `/dashboard/getActiveInstanceGroupedByChartVersion`, props, signal)

export interface GetActiveInstanceGroupedByEnvironmentQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
  environmentIdentifier?: string
  envGroupIdentifier?: string
}

export type GetActiveInstanceGroupedByEnvironmentProps = Omit<
  GetProps<
    ResponseInstanceGroupedByEnvironmentList,
    Failure | Error,
    GetActiveInstanceGroupedByEnvironmentQueryParams,
    void
  >,
  'path'
>

/**
 * Get active instance count for a service grouped on environment, infrastructure, artifact
 */
export const GetActiveInstanceGroupedByEnvironment = (props: GetActiveInstanceGroupedByEnvironmentProps) => (
  <Get<
    ResponseInstanceGroupedByEnvironmentList,
    Failure | Error,
    GetActiveInstanceGroupedByEnvironmentQueryParams,
    void
  >
    path={`/dashboard/getActiveInstanceGroupedByEnvironment`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveInstanceGroupedByEnvironmentProps = Omit<
  UseGetProps<
    ResponseInstanceGroupedByEnvironmentList,
    Failure | Error,
    GetActiveInstanceGroupedByEnvironmentQueryParams,
    void
  >,
  'path'
>

/**
 * Get active instance count for a service grouped on environment, infrastructure, artifact
 */
export const useGetActiveInstanceGroupedByEnvironment = (props: UseGetActiveInstanceGroupedByEnvironmentProps) =>
  useGet<
    ResponseInstanceGroupedByEnvironmentList,
    Failure | Error,
    GetActiveInstanceGroupedByEnvironmentQueryParams,
    void
  >(`/dashboard/getActiveInstanceGroupedByEnvironment`, { base: getConfig('ng/api'), ...props })

/**
 * Get active instance count for a service grouped on environment, infrastructure, artifact
 */
export const getActiveInstanceGroupedByEnvironmentPromise = (
  props: GetUsingFetchProps<
    ResponseInstanceGroupedByEnvironmentList,
    Failure | Error,
    GetActiveInstanceGroupedByEnvironmentQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInstanceGroupedByEnvironmentList,
    Failure | Error,
    GetActiveInstanceGroupedByEnvironmentQueryParams,
    void
  >(getConfig('ng/api'), `/dashboard/getActiveInstanceGroupedByEnvironment`, props, signal)

export interface GetActiveServiceDeploymentsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
}

export type GetActiveServiceDeploymentsProps = Omit<
  GetProps<ResponseInstanceGroupedByService, Failure | Error, GetActiveServiceDeploymentsQueryParams, void>,
  'path'
>

/**
 * Get Information about artifacts for a particular service, deployed to different environments
 */
export const GetActiveServiceDeployments = (props: GetActiveServiceDeploymentsProps) => (
  <Get<ResponseInstanceGroupedByService, Failure | Error, GetActiveServiceDeploymentsQueryParams, void>
    path={`/dashboard/getActiveServiceDeployments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveServiceDeploymentsProps = Omit<
  UseGetProps<ResponseInstanceGroupedByService, Failure | Error, GetActiveServiceDeploymentsQueryParams, void>,
  'path'
>

/**
 * Get Information about artifacts for a particular service, deployed to different environments
 */
export const useGetActiveServiceDeployments = (props: UseGetActiveServiceDeploymentsProps) =>
  useGet<ResponseInstanceGroupedByService, Failure | Error, GetActiveServiceDeploymentsQueryParams, void>(
    `/dashboard/getActiveServiceDeployments`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Information about artifacts for a particular service, deployed to different environments
 */
export const getActiveServiceDeploymentsPromise = (
  props: GetUsingFetchProps<
    ResponseInstanceGroupedByService,
    Failure | Error,
    GetActiveServiceDeploymentsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseInstanceGroupedByService, Failure | Error, GetActiveServiceDeploymentsQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getActiveServiceDeployments`,
    props,
    signal
  )

export interface GetActiveServiceInstanceDetailsGroupedByPipelineExecutionQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
  envId: string
  environmentType?: 'PreProduction' | 'Production'
  infraIdentifier?: string
  clusterIdentifier?: string
  artifact?: string
  chartVersion?: string
}

export type GetActiveServiceInstanceDetailsGroupedByPipelineExecutionProps = Omit<
  GetProps<
    ResponseInstanceDetailGroupedByPipelineExecutionList,
    Failure | Error,
    GetActiveServiceInstanceDetailsGroupedByPipelineExecutionQueryParams,
    void
  >,
  'path'
>

/**
 * Get list of active instance metadata grouped by pipeline execution for a service
 */
export const GetActiveServiceInstanceDetailsGroupedByPipelineExecution = (
  props: GetActiveServiceInstanceDetailsGroupedByPipelineExecutionProps
) => (
  <Get<
    ResponseInstanceDetailGroupedByPipelineExecutionList,
    Failure | Error,
    GetActiveServiceInstanceDetailsGroupedByPipelineExecutionQueryParams,
    void
  >
    path={`/dashboard/getActiveServiceInstanceDetailsGroupedByPipelineExecution`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveServiceInstanceDetailsGroupedByPipelineExecutionProps = Omit<
  UseGetProps<
    ResponseInstanceDetailGroupedByPipelineExecutionList,
    Failure | Error,
    GetActiveServiceInstanceDetailsGroupedByPipelineExecutionQueryParams,
    void
  >,
  'path'
>

/**
 * Get list of active instance metadata grouped by pipeline execution for a service
 */
export const useGetActiveServiceInstanceDetailsGroupedByPipelineExecution = (
  props: UseGetActiveServiceInstanceDetailsGroupedByPipelineExecutionProps
) =>
  useGet<
    ResponseInstanceDetailGroupedByPipelineExecutionList,
    Failure | Error,
    GetActiveServiceInstanceDetailsGroupedByPipelineExecutionQueryParams,
    void
  >(`/dashboard/getActiveServiceInstanceDetailsGroupedByPipelineExecution`, { base: getConfig('ng/api'), ...props })

/**
 * Get list of active instance metadata grouped by pipeline execution for a service
 */
export const getActiveServiceInstanceDetailsGroupedByPipelineExecutionPromise = (
  props: GetUsingFetchProps<
    ResponseInstanceDetailGroupedByPipelineExecutionList,
    Failure | Error,
    GetActiveServiceInstanceDetailsGroupedByPipelineExecutionQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInstanceDetailGroupedByPipelineExecutionList,
    Failure | Error,
    GetActiveServiceInstanceDetailsGroupedByPipelineExecutionQueryParams,
    void
  >(getConfig('ng/api'), `/dashboard/getActiveServiceInstanceDetailsGroupedByPipelineExecution`, props, signal)

export interface GetActiveServiceInstanceSummaryQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
  timestamp: number
}

export type GetActiveServiceInstanceSummaryProps = Omit<
  GetProps<ResponseActiveServiceInstanceSummary, Failure | Error, GetActiveServiceInstanceSummaryQueryParams, void>,
  'path'
>

/**
 * Get active service instance summary
 */
export const GetActiveServiceInstanceSummary = (props: GetActiveServiceInstanceSummaryProps) => (
  <Get<ResponseActiveServiceInstanceSummary, Failure | Error, GetActiveServiceInstanceSummaryQueryParams, void>
    path={`/dashboard/getActiveServiceInstanceSummary`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveServiceInstanceSummaryProps = Omit<
  UseGetProps<ResponseActiveServiceInstanceSummary, Failure | Error, GetActiveServiceInstanceSummaryQueryParams, void>,
  'path'
>

/**
 * Get active service instance summary
 */
export const useGetActiveServiceInstanceSummary = (props: UseGetActiveServiceInstanceSummaryProps) =>
  useGet<ResponseActiveServiceInstanceSummary, Failure | Error, GetActiveServiceInstanceSummaryQueryParams, void>(
    `/dashboard/getActiveServiceInstanceSummary`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get active service instance summary
 */
export const getActiveServiceInstanceSummaryPromise = (
  props: GetUsingFetchProps<
    ResponseActiveServiceInstanceSummary,
    Failure | Error,
    GetActiveServiceInstanceSummaryQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseActiveServiceInstanceSummary,
    Failure | Error,
    GetActiveServiceInstanceSummaryQueryParams,
    void
  >(getConfig('ng/api'), `/dashboard/getActiveServiceInstanceSummary`, props, signal)

export interface GetActiveServiceInstanceSummaryV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
  timestamp: number
}

export type GetActiveServiceInstanceSummaryV2Props = Omit<
  GetProps<ResponseActiveServiceInstanceSummaryV2, Failure | Error, GetActiveServiceInstanceSummaryV2QueryParams, void>,
  'path'
>

/**
 * Get active service instance summary v2
 */
export const GetActiveServiceInstanceSummaryV2 = (props: GetActiveServiceInstanceSummaryV2Props) => (
  <Get<ResponseActiveServiceInstanceSummaryV2, Failure | Error, GetActiveServiceInstanceSummaryV2QueryParams, void>
    path={`/dashboard/getActiveServiceInstanceSummaryV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveServiceInstanceSummaryV2Props = Omit<
  UseGetProps<
    ResponseActiveServiceInstanceSummaryV2,
    Failure | Error,
    GetActiveServiceInstanceSummaryV2QueryParams,
    void
  >,
  'path'
>

/**
 * Get active service instance summary v2
 */
export const useGetActiveServiceInstanceSummaryV2 = (props: UseGetActiveServiceInstanceSummaryV2Props) =>
  useGet<ResponseActiveServiceInstanceSummaryV2, Failure | Error, GetActiveServiceInstanceSummaryV2QueryParams, void>(
    `/dashboard/getActiveServiceInstanceSummaryV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get active service instance summary v2
 */
export const getActiveServiceInstanceSummaryV2Promise = (
  props: GetUsingFetchProps<
    ResponseActiveServiceInstanceSummaryV2,
    Failure | Error,
    GetActiveServiceInstanceSummaryV2QueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseActiveServiceInstanceSummaryV2,
    Failure | Error,
    GetActiveServiceInstanceSummaryV2QueryParams,
    void
  >(getConfig('ng/api'), `/dashboard/getActiveServiceInstanceSummaryV2`, props, signal)

export interface GetActiveServiceInstancesQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
}

export type GetActiveServiceInstancesProps = Omit<
  GetProps<ResponseInstanceGroupedByService, Failure | Error, GetActiveServiceInstancesQueryParams, void>,
  'path'
>

/**
 * Get list of artifact version, last pipeline execution, environment, infrastructure with instance count
 */
export const GetActiveServiceInstances = (props: GetActiveServiceInstancesProps) => (
  <Get<ResponseInstanceGroupedByService, Failure | Error, GetActiveServiceInstancesQueryParams, void>
    path={`/dashboard/getActiveServiceInstances`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveServiceInstancesProps = Omit<
  UseGetProps<ResponseInstanceGroupedByService, Failure | Error, GetActiveServiceInstancesQueryParams, void>,
  'path'
>

/**
 * Get list of artifact version, last pipeline execution, environment, infrastructure with instance count
 */
export const useGetActiveServiceInstances = (props: UseGetActiveServiceInstancesProps) =>
  useGet<ResponseInstanceGroupedByService, Failure | Error, GetActiveServiceInstancesQueryParams, void>(
    `/dashboard/getActiveServiceInstances`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get list of artifact version, last pipeline execution, environment, infrastructure with instance count
 */
export const getActiveServiceInstancesPromise = (
  props: GetUsingFetchProps<
    ResponseInstanceGroupedByService,
    Failure | Error,
    GetActiveServiceInstancesQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseInstanceGroupedByService, Failure | Error, GetActiveServiceInstancesQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getActiveServiceInstances`,
    props,
    signal
  )

export interface GetAllDeploymentsByServiceIdQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
  startTime: number
  endTime: number
}

export type GetAllDeploymentsByServiceIdProps = Omit<
  GetProps<ResponseServiceDeployments, Failure | Error, GetAllDeploymentsByServiceIdQueryParams, void>,
  'path'
>

/**
 * Get all deployments by serviceId
 */
export const GetAllDeploymentsByServiceId = (props: GetAllDeploymentsByServiceIdProps) => (
  <Get<ResponseServiceDeployments, Failure | Error, GetAllDeploymentsByServiceIdQueryParams, void>
    path={`/dashboard/getAllDeploymentsByServiceId`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAllDeploymentsByServiceIdProps = Omit<
  UseGetProps<ResponseServiceDeployments, Failure | Error, GetAllDeploymentsByServiceIdQueryParams, void>,
  'path'
>

/**
 * Get all deployments by serviceId
 */
export const useGetAllDeploymentsByServiceId = (props: UseGetAllDeploymentsByServiceIdProps) =>
  useGet<ResponseServiceDeployments, Failure | Error, GetAllDeploymentsByServiceIdQueryParams, void>(
    `/dashboard/getAllDeploymentsByServiceId`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get all deployments by serviceId
 */
export const getAllDeploymentsByServiceIdPromise = (
  props: GetUsingFetchProps<ResponseServiceDeployments, Failure | Error, GetAllDeploymentsByServiceIdQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceDeployments, Failure | Error, GetAllDeploymentsByServiceIdQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getAllDeploymentsByServiceId`,
    props,
    signal
  )

export interface GetArtifactInstanceDetailsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
}

export type GetArtifactInstanceDetailsProps = Omit<
  GetProps<ResponseArtifactInstanceDetails, Failure | Error, GetArtifactInstanceDetailsQueryParams, void>,
  'path'
>

/**
 * Get last deployment detail in each environment for artifacts having active instances of a service
 */
export const GetArtifactInstanceDetails = (props: GetArtifactInstanceDetailsProps) => (
  <Get<ResponseArtifactInstanceDetails, Failure | Error, GetArtifactInstanceDetailsQueryParams, void>
    path={`/dashboard/getArtifactInstanceDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetArtifactInstanceDetailsProps = Omit<
  UseGetProps<ResponseArtifactInstanceDetails, Failure | Error, GetArtifactInstanceDetailsQueryParams, void>,
  'path'
>

/**
 * Get last deployment detail in each environment for artifacts having active instances of a service
 */
export const useGetArtifactInstanceDetails = (props: UseGetArtifactInstanceDetailsProps) =>
  useGet<ResponseArtifactInstanceDetails, Failure | Error, GetArtifactInstanceDetailsQueryParams, void>(
    `/dashboard/getArtifactInstanceDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get last deployment detail in each environment for artifacts having active instances of a service
 */
export const getArtifactInstanceDetailsPromise = (
  props: GetUsingFetchProps<
    ResponseArtifactInstanceDetails,
    Failure | Error,
    GetArtifactInstanceDetailsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseArtifactInstanceDetails, Failure | Error, GetArtifactInstanceDetailsQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getArtifactInstanceDetails`,
    props,
    signal
  )

export interface GetChartVersionInstanceDetailsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
}

export type GetChartVersionInstanceDetailsProps = Omit<
  GetProps<ResponseChartVersionInstanceDetails, Failure | Error, GetChartVersionInstanceDetailsQueryParams, void>,
  'path'
>

/**
 * Get last deployment detail in each environment for chart versions having active instances of a service
 */
export const GetChartVersionInstanceDetails = (props: GetChartVersionInstanceDetailsProps) => (
  <Get<ResponseChartVersionInstanceDetails, Failure | Error, GetChartVersionInstanceDetailsQueryParams, void>
    path={`/dashboard/getChartVersionInstanceDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetChartVersionInstanceDetailsProps = Omit<
  UseGetProps<ResponseChartVersionInstanceDetails, Failure | Error, GetChartVersionInstanceDetailsQueryParams, void>,
  'path'
>

/**
 * Get last deployment detail in each environment for chart versions having active instances of a service
 */
export const useGetChartVersionInstanceDetails = (props: UseGetChartVersionInstanceDetailsProps) =>
  useGet<ResponseChartVersionInstanceDetails, Failure | Error, GetChartVersionInstanceDetailsQueryParams, void>(
    `/dashboard/getChartVersionInstanceDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get last deployment detail in each environment for chart versions having active instances of a service
 */
export const getChartVersionInstanceDetailsPromise = (
  props: GetUsingFetchProps<
    ResponseChartVersionInstanceDetails,
    Failure | Error,
    GetChartVersionInstanceDetailsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseChartVersionInstanceDetails, Failure | Error, GetChartVersionInstanceDetailsQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getChartVersionInstanceDetails`,
    props,
    signal
  )

export interface GetDeploymentsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  startTime: number
  endTime: number
  top?: number
}

export type GetDeploymentsProps = Omit<
  GetProps<ResponseDashboardExecutionStatusInfo, Failure | Error, GetDeploymentsQueryParams, void>,
  'path'
>

/**
 * Get deployments
 */
export const GetDeployments = (props: GetDeploymentsProps) => (
  <Get<ResponseDashboardExecutionStatusInfo, Failure | Error, GetDeploymentsQueryParams, void>
    path={`/dashboard/getDeployments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDeploymentsProps = Omit<
  UseGetProps<ResponseDashboardExecutionStatusInfo, Failure | Error, GetDeploymentsQueryParams, void>,
  'path'
>

/**
 * Get deployments
 */
export const useGetDeployments = (props: UseGetDeploymentsProps) =>
  useGet<ResponseDashboardExecutionStatusInfo, Failure | Error, GetDeploymentsQueryParams, void>(
    `/dashboard/getDeployments`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get deployments
 */
export const getDeploymentsPromise = (
  props: GetUsingFetchProps<ResponseDashboardExecutionStatusInfo, Failure | Error, GetDeploymentsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDashboardExecutionStatusInfo, Failure | Error, GetDeploymentsQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getDeployments`,
    props,
    signal
  )

export interface GetDeploymentsByServiceIdQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
  startTime: number
  endTime: number
}

export type GetDeploymentsByServiceIdProps = Omit<
  GetProps<ResponseDeploymentsInfo, Failure | Error, GetDeploymentsByServiceIdQueryParams, void>,
  'path'
>

/**
 * Get deployments by serviceId
 */
export const GetDeploymentsByServiceId = (props: GetDeploymentsByServiceIdProps) => (
  <Get<ResponseDeploymentsInfo, Failure | Error, GetDeploymentsByServiceIdQueryParams, void>
    path={`/dashboard/getDeploymentsByServiceId`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDeploymentsByServiceIdProps = Omit<
  UseGetProps<ResponseDeploymentsInfo, Failure | Error, GetDeploymentsByServiceIdQueryParams, void>,
  'path'
>

/**
 * Get deployments by serviceId
 */
export const useGetDeploymentsByServiceId = (props: UseGetDeploymentsByServiceIdProps) =>
  useGet<ResponseDeploymentsInfo, Failure | Error, GetDeploymentsByServiceIdQueryParams, void>(
    `/dashboard/getDeploymentsByServiceId`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get deployments by serviceId
 */
export const getDeploymentsByServiceIdPromise = (
  props: GetUsingFetchProps<ResponseDeploymentsInfo, Failure | Error, GetDeploymentsByServiceIdQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDeploymentsInfo, Failure | Error, GetDeploymentsByServiceIdQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getDeploymentsByServiceId`,
    props,
    signal
  )

export interface GetEnvArtifactDetailsByServiceIdQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
}

export type GetEnvArtifactDetailsByServiceIdProps = Omit<
  GetProps<ResponseEnvironmentDeploymentInfo, Failure | Error, GetEnvArtifactDetailsByServiceIdQueryParams, void>,
  'path'
>

/**
 * Get list of unique environment and Artifact version filter by service_id
 */
export const GetEnvArtifactDetailsByServiceId = (props: GetEnvArtifactDetailsByServiceIdProps) => (
  <Get<ResponseEnvironmentDeploymentInfo, Failure | Error, GetEnvArtifactDetailsByServiceIdQueryParams, void>
    path={`/dashboard/getEnvArtifactDetailsByServiceId`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvArtifactDetailsByServiceIdProps = Omit<
  UseGetProps<ResponseEnvironmentDeploymentInfo, Failure | Error, GetEnvArtifactDetailsByServiceIdQueryParams, void>,
  'path'
>

/**
 * Get list of unique environment and Artifact version filter by service_id
 */
export const useGetEnvArtifactDetailsByServiceId = (props: UseGetEnvArtifactDetailsByServiceIdProps) =>
  useGet<ResponseEnvironmentDeploymentInfo, Failure | Error, GetEnvArtifactDetailsByServiceIdQueryParams, void>(
    `/dashboard/getEnvArtifactDetailsByServiceId`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get list of unique environment and Artifact version filter by service_id
 */
export const getEnvArtifactDetailsByServiceIdPromise = (
  props: GetUsingFetchProps<
    ResponseEnvironmentDeploymentInfo,
    Failure | Error,
    GetEnvArtifactDetailsByServiceIdQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEnvironmentDeploymentInfo, Failure | Error, GetEnvArtifactDetailsByServiceIdQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getEnvArtifactDetailsByServiceId`,
    props,
    signal
  )

export interface GetEnvBuildInstanceCountQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
}

export type GetEnvBuildInstanceCountProps = Omit<
  GetProps<ResponseEnvBuildIdAndInstanceCountInfoList, Failure | Error, GetEnvBuildInstanceCountQueryParams, void>,
  'path'
>

/**
 * Get list of unique environment and build ids with instance count
 */
export const GetEnvBuildInstanceCount = (props: GetEnvBuildInstanceCountProps) => (
  <Get<ResponseEnvBuildIdAndInstanceCountInfoList, Failure | Error, GetEnvBuildInstanceCountQueryParams, void>
    path={`/dashboard/getEnvBuildInstanceCountByService`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvBuildInstanceCountProps = Omit<
  UseGetProps<ResponseEnvBuildIdAndInstanceCountInfoList, Failure | Error, GetEnvBuildInstanceCountQueryParams, void>,
  'path'
>

/**
 * Get list of unique environment and build ids with instance count
 */
export const useGetEnvBuildInstanceCount = (props: UseGetEnvBuildInstanceCountProps) =>
  useGet<ResponseEnvBuildIdAndInstanceCountInfoList, Failure | Error, GetEnvBuildInstanceCountQueryParams, void>(
    `/dashboard/getEnvBuildInstanceCountByService`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get list of unique environment and build ids with instance count
 */
export const getEnvBuildInstanceCountPromise = (
  props: GetUsingFetchProps<
    ResponseEnvBuildIdAndInstanceCountInfoList,
    Failure | Error,
    GetEnvBuildInstanceCountQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEnvBuildIdAndInstanceCountInfoList, Failure | Error, GetEnvBuildInstanceCountQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getEnvBuildInstanceCountByService`,
    props,
    signal
  )

export interface GetEnvironmentInstanceDetailsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
}

export type GetEnvironmentInstanceDetailsProps = Omit<
  MutateProps<
    ResponseEnvironmentGroupInstanceDetails,
    Failure | Error,
    GetEnvironmentInstanceDetailsQueryParams,
    EnvironmentFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * Get instance count and last artifact deployment detail in each environment for a particular service
 */
export const GetEnvironmentInstanceDetails = (props: GetEnvironmentInstanceDetailsProps) => (
  <Mutate<
    ResponseEnvironmentGroupInstanceDetails,
    Failure | Error,
    GetEnvironmentInstanceDetailsQueryParams,
    EnvironmentFilterProperties,
    void
  >
    verb="POST"
    path={`/dashboard/getEnvironmentInstanceDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentInstanceDetailsProps = Omit<
  UseMutateProps<
    ResponseEnvironmentGroupInstanceDetails,
    Failure | Error,
    GetEnvironmentInstanceDetailsQueryParams,
    EnvironmentFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * Get instance count and last artifact deployment detail in each environment for a particular service
 */
export const useGetEnvironmentInstanceDetails = (props: UseGetEnvironmentInstanceDetailsProps) =>
  useMutate<
    ResponseEnvironmentGroupInstanceDetails,
    Failure | Error,
    GetEnvironmentInstanceDetailsQueryParams,
    EnvironmentFilterProperties,
    void
  >('POST', `/dashboard/getEnvironmentInstanceDetails`, { base: getConfig('ng/api'), ...props })

/**
 * Get instance count and last artifact deployment detail in each environment for a particular service
 */
export const getEnvironmentInstanceDetailsPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentGroupInstanceDetails,
    Failure | Error,
    GetEnvironmentInstanceDetailsQueryParams,
    EnvironmentFilterProperties,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentGroupInstanceDetails,
    Failure | Error,
    GetEnvironmentInstanceDetailsQueryParams,
    EnvironmentFilterProperties,
    void
  >('POST', getConfig('ng/api'), `/dashboard/getEnvironmentInstanceDetails`, props, signal)

export interface GetActiveServiceInstanceCountBreakdownQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string[]
}

export type GetActiveServiceInstanceCountBreakdownProps = Omit<
  GetProps<
    ResponseInstanceCountDetailsByEnvTypeAndServiceId,
    Failure | Error,
    GetActiveServiceInstanceCountBreakdownQueryParams,
    void
  >,
  'path'
>

/**
 * Get active service instance count breakdown by env type
 */
export const GetActiveServiceInstanceCountBreakdown = (props: GetActiveServiceInstanceCountBreakdownProps) => (
  <Get<
    ResponseInstanceCountDetailsByEnvTypeAndServiceId,
    Failure | Error,
    GetActiveServiceInstanceCountBreakdownQueryParams,
    void
  >
    path={`/dashboard/getInstanceCountDetailsByService`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveServiceInstanceCountBreakdownProps = Omit<
  UseGetProps<
    ResponseInstanceCountDetailsByEnvTypeAndServiceId,
    Failure | Error,
    GetActiveServiceInstanceCountBreakdownQueryParams,
    void
  >,
  'path'
>

/**
 * Get active service instance count breakdown by env type
 */
export const useGetActiveServiceInstanceCountBreakdown = (props: UseGetActiveServiceInstanceCountBreakdownProps) =>
  useGet<
    ResponseInstanceCountDetailsByEnvTypeAndServiceId,
    Failure | Error,
    GetActiveServiceInstanceCountBreakdownQueryParams,
    void
  >(`/dashboard/getInstanceCountDetailsByService`, { base: getConfig('ng/api'), ...props })

/**
 * Get active service instance count breakdown by env type
 */
export const getActiveServiceInstanceCountBreakdownPromise = (
  props: GetUsingFetchProps<
    ResponseInstanceCountDetailsByEnvTypeAndServiceId,
    Failure | Error,
    GetActiveServiceInstanceCountBreakdownQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInstanceCountDetailsByEnvTypeAndServiceId,
    Failure | Error,
    GetActiveServiceInstanceCountBreakdownQueryParams,
    void
  >(getConfig('ng/api'), `/dashboard/getInstanceCountDetailsByService`, props, signal)

export interface GetInstanceCountHistoryQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
  startTime: number
  endTime: number
}

export type GetInstanceCountHistoryProps = Omit<
  GetProps<ResponseTimeValuePairListDTOEnvIdCountPair, Failure | Error, GetInstanceCountHistoryQueryParams, void>,
  'path'
>

/**
 * Get instance count history
 */
export const GetInstanceCountHistory = (props: GetInstanceCountHistoryProps) => (
  <Get<ResponseTimeValuePairListDTOEnvIdCountPair, Failure | Error, GetInstanceCountHistoryQueryParams, void>
    path={`/dashboard/getInstanceCountHistory`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInstanceCountHistoryProps = Omit<
  UseGetProps<ResponseTimeValuePairListDTOEnvIdCountPair, Failure | Error, GetInstanceCountHistoryQueryParams, void>,
  'path'
>

/**
 * Get instance count history
 */
export const useGetInstanceCountHistory = (props: UseGetInstanceCountHistoryProps) =>
  useGet<ResponseTimeValuePairListDTOEnvIdCountPair, Failure | Error, GetInstanceCountHistoryQueryParams, void>(
    `/dashboard/getInstanceCountHistory`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get instance count history
 */
export const getInstanceCountHistoryPromise = (
  props: GetUsingFetchProps<
    ResponseTimeValuePairListDTOEnvIdCountPair,
    Failure | Error,
    GetInstanceCountHistoryQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseTimeValuePairListDTOEnvIdCountPair, Failure | Error, GetInstanceCountHistoryQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getInstanceCountHistory`,
    props,
    signal
  )

export interface GetInstanceGrowthTrendQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
  startTime: number
  endTime: number
}

export type GetInstanceGrowthTrendProps = Omit<
  GetProps<ResponseTimeValuePairListDTOInteger, Failure | Error, GetInstanceGrowthTrendQueryParams, void>,
  'path'
>

/**
 * Get instance growth trend
 */
export const GetInstanceGrowthTrend = (props: GetInstanceGrowthTrendProps) => (
  <Get<ResponseTimeValuePairListDTOInteger, Failure | Error, GetInstanceGrowthTrendQueryParams, void>
    path={`/dashboard/getInstanceGrowthTrend`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInstanceGrowthTrendProps = Omit<
  UseGetProps<ResponseTimeValuePairListDTOInteger, Failure | Error, GetInstanceGrowthTrendQueryParams, void>,
  'path'
>

/**
 * Get instance growth trend
 */
export const useGetInstanceGrowthTrend = (props: UseGetInstanceGrowthTrendProps) =>
  useGet<ResponseTimeValuePairListDTOInteger, Failure | Error, GetInstanceGrowthTrendQueryParams, void>(
    `/dashboard/getInstanceGrowthTrend`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get instance growth trend
 */
export const getInstanceGrowthTrendPromise = (
  props: GetUsingFetchProps<
    ResponseTimeValuePairListDTOInteger,
    Failure | Error,
    GetInstanceGrowthTrendQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseTimeValuePairListDTOInteger, Failure | Error, GetInstanceGrowthTrendQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getInstanceGrowthTrend`,
    props,
    signal
  )

export interface GetActiveInstancesByServiceIdEnvIdAndBuildIdsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
  envId: string
  buildIds: string[]
  infraIdentifier?: string
  clusterIdentifier?: string
  pipelineExecutionId?: string
}

export type GetActiveInstancesByServiceIdEnvIdAndBuildIdsProps = Omit<
  GetProps<
    ResponseInstancesByBuildIdList,
    Failure | Error,
    GetActiveInstancesByServiceIdEnvIdAndBuildIdsQueryParams,
    void
  >,
  'path'
>

/**
 * Get list of buildId and instances
 */
export const GetActiveInstancesByServiceIdEnvIdAndBuildIds = (
  props: GetActiveInstancesByServiceIdEnvIdAndBuildIdsProps
) => (
  <Get<ResponseInstancesByBuildIdList, Failure | Error, GetActiveInstancesByServiceIdEnvIdAndBuildIdsQueryParams, void>
    path={`/dashboard/getInstancesByServiceEnvAndBuilds`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveInstancesByServiceIdEnvIdAndBuildIdsProps = Omit<
  UseGetProps<
    ResponseInstancesByBuildIdList,
    Failure | Error,
    GetActiveInstancesByServiceIdEnvIdAndBuildIdsQueryParams,
    void
  >,
  'path'
>

/**
 * Get list of buildId and instances
 */
export const useGetActiveInstancesByServiceIdEnvIdAndBuildIds = (
  props: UseGetActiveInstancesByServiceIdEnvIdAndBuildIdsProps
) =>
  useGet<
    ResponseInstancesByBuildIdList,
    Failure | Error,
    GetActiveInstancesByServiceIdEnvIdAndBuildIdsQueryParams,
    void
  >(`/dashboard/getInstancesByServiceEnvAndBuilds`, { base: getConfig('ng/api'), ...props })

/**
 * Get list of buildId and instances
 */
export const getActiveInstancesByServiceIdEnvIdAndBuildIdsPromise = (
  props: GetUsingFetchProps<
    ResponseInstancesByBuildIdList,
    Failure | Error,
    GetActiveInstancesByServiceIdEnvIdAndBuildIdsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInstancesByBuildIdList,
    Failure | Error,
    GetActiveInstancesByServiceIdEnvIdAndBuildIdsQueryParams,
    void
  >(getConfig('ng/api'), `/dashboard/getInstancesByServiceEnvAndBuilds`, props, signal)

export interface GetInstancesDetailsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
  envId: string
  infraIdentifier?: string
  clusterIdentifier?: string
  pipelineExecutionId?: string
  buildId?: string
}

export type GetInstancesDetailsProps = Omit<
  GetProps<ResponseInstanceDetailsByBuildId, Failure | Error, GetInstancesDetailsQueryParams, void>,
  'path'
>

/**
 * Get list of instances grouped by serviceId, buildId, environment, infrastructure and pipeline execution
 */
export const GetInstancesDetails = (props: GetInstancesDetailsProps) => (
  <Get<ResponseInstanceDetailsByBuildId, Failure | Error, GetInstancesDetailsQueryParams, void>
    path={`/dashboard/getInstancesDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInstancesDetailsProps = Omit<
  UseGetProps<ResponseInstanceDetailsByBuildId, Failure | Error, GetInstancesDetailsQueryParams, void>,
  'path'
>

/**
 * Get list of instances grouped by serviceId, buildId, environment, infrastructure and pipeline execution
 */
export const useGetInstancesDetails = (props: UseGetInstancesDetailsProps) =>
  useGet<ResponseInstanceDetailsByBuildId, Failure | Error, GetInstancesDetailsQueryParams, void>(
    `/dashboard/getInstancesDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get list of instances grouped by serviceId, buildId, environment, infrastructure and pipeline execution
 */
export const getInstancesDetailsPromise = (
  props: GetUsingFetchProps<ResponseInstanceDetailsByBuildId, Failure | Error, GetInstancesDetailsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseInstanceDetailsByBuildId, Failure | Error, GetInstancesDetailsQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getInstancesDetails`,
    props,
    signal
  )

export interface GetOpenTasksQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
  startTime: number
}

export type GetOpenTasksProps = Omit<
  GetProps<ResponseOpenTaskDetails, Failure | Error, GetOpenTasksQueryParams, void>,
  'path'
>

/**
 * Get list of pipelines failed and waiting for approval in 5 days
 */
export const GetOpenTasks = (props: GetOpenTasksProps) => (
  <Get<ResponseOpenTaskDetails, Failure | Error, GetOpenTasksQueryParams, void>
    path={`/dashboard/getOpenTasks`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOpenTasksProps = Omit<
  UseGetProps<ResponseOpenTaskDetails, Failure | Error, GetOpenTasksQueryParams, void>,
  'path'
>

/**
 * Get list of pipelines failed and waiting for approval in 5 days
 */
export const useGetOpenTasks = (props: UseGetOpenTasksProps) =>
  useGet<ResponseOpenTaskDetails, Failure | Error, GetOpenTasksQueryParams, void>(`/dashboard/getOpenTasks`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get list of pipelines failed and waiting for approval in 5 days
 */
export const getOpenTasksPromise = (
  props: GetUsingFetchProps<ResponseOpenTaskDetails, Failure | Error, GetOpenTasksQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseOpenTaskDetails, Failure | Error, GetOpenTasksQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getOpenTasks`,
    props,
    signal
  )

export interface GetPipelineExecutionCountQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId?: string
  startTime?: number
  endTime?: number
  artifactPath?: string
  artifactVersion?: string
  artifact?: string
  status?: string
}

export type GetPipelineExecutionCountProps = Omit<
  GetProps<ResponsePipelineExecutionCountInfo, Failure | Error, GetPipelineExecutionCountQueryParams, void>,
  'path'
>

/**
 * Get pipeline execution count info
 */
export const GetPipelineExecutionCount = (props: GetPipelineExecutionCountProps) => (
  <Get<ResponsePipelineExecutionCountInfo, Failure | Error, GetPipelineExecutionCountQueryParams, void>
    path={`/dashboard/getPipelineExecutionCount`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPipelineExecutionCountProps = Omit<
  UseGetProps<ResponsePipelineExecutionCountInfo, Failure | Error, GetPipelineExecutionCountQueryParams, void>,
  'path'
>

/**
 * Get pipeline execution count info
 */
export const useGetPipelineExecutionCount = (props: UseGetPipelineExecutionCountProps) =>
  useGet<ResponsePipelineExecutionCountInfo, Failure | Error, GetPipelineExecutionCountQueryParams, void>(
    `/dashboard/getPipelineExecutionCount`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get pipeline execution count info
 */
export const getPipelineExecutionCountPromise = (
  props: GetUsingFetchProps<
    ResponsePipelineExecutionCountInfo,
    Failure | Error,
    GetPipelineExecutionCountQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePipelineExecutionCountInfo, Failure | Error, GetPipelineExecutionCountQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getPipelineExecutionCount`,
    props,
    signal
  )

export interface GetServiceHeaderInfoQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  loadFromFallbackBranch?: boolean
}

export type GetServiceHeaderInfoProps = Omit<
  GetProps<ResponseServiceHeaderInfo, Failure | Error, GetServiceHeaderInfoQueryParams, void>,
  'path'
>

/**
 * Get service header info
 */
export const GetServiceHeaderInfo = (props: GetServiceHeaderInfoProps) => (
  <Get<ResponseServiceHeaderInfo, Failure | Error, GetServiceHeaderInfoQueryParams, void>
    path={`/dashboard/getServiceHeaderInfo`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceHeaderInfoProps = Omit<
  UseGetProps<ResponseServiceHeaderInfo, Failure | Error, GetServiceHeaderInfoQueryParams, void>,
  'path'
>

/**
 * Get service header info
 */
export const useGetServiceHeaderInfo = (props: UseGetServiceHeaderInfoProps) =>
  useGet<ResponseServiceHeaderInfo, Failure | Error, GetServiceHeaderInfoQueryParams, void>(
    `/dashboard/getServiceHeaderInfo`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get service header info
 */
export const getServiceHeaderInfoPromise = (
  props: GetUsingFetchProps<ResponseServiceHeaderInfo, Failure | Error, GetServiceHeaderInfoQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceHeaderInfo, Failure | Error, GetServiceHeaderInfoQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getServiceHeaderInfo`,
    props,
    signal
  )

export interface GetServicesGrowthTrendQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  startTime: number
  endTime: number
  timeGroupByType: 'HOUR' | 'DAY' | 'WEEK'
}

export type GetServicesGrowthTrendProps = Omit<
  GetProps<ResponseTimeValuePairListDTOInteger, Failure | Error, GetServicesGrowthTrendQueryParams, void>,
  'path'
>

/**
 * Get service growth trend
 */
export const GetServicesGrowthTrend = (props: GetServicesGrowthTrendProps) => (
  <Get<ResponseTimeValuePairListDTOInteger, Failure | Error, GetServicesGrowthTrendQueryParams, void>
    path={`/dashboard/getServicesGrowthTrend`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServicesGrowthTrendProps = Omit<
  UseGetProps<ResponseTimeValuePairListDTOInteger, Failure | Error, GetServicesGrowthTrendQueryParams, void>,
  'path'
>

/**
 * Get service growth trend
 */
export const useGetServicesGrowthTrend = (props: UseGetServicesGrowthTrendProps) =>
  useGet<ResponseTimeValuePairListDTOInteger, Failure | Error, GetServicesGrowthTrendQueryParams, void>(
    `/dashboard/getServicesGrowthTrend`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get service growth trend
 */
export const getServicesGrowthTrendPromise = (
  props: GetUsingFetchProps<
    ResponseTimeValuePairListDTOInteger,
    Failure | Error,
    GetServicesGrowthTrendQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseTimeValuePairListDTOInteger, Failure | Error, GetServicesGrowthTrendQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getServicesGrowthTrend`,
    props,
    signal
  )

export interface GetWorkloadsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  startTime: number
  endTime: number
  environmentType?: 'PreProduction' | 'Production'
}

export type GetWorkloadsProps = Omit<
  GetProps<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>,
  'path'
>

/**
 * Get workloads
 */
export const GetWorkloads = (props: GetWorkloadsProps) => (
  <Get<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>
    path={`/dashboard/getWorkloads`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetWorkloadsProps = Omit<
  UseGetProps<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>,
  'path'
>

/**
 * Get workloads
 */
export const useGetWorkloads = (props: UseGetWorkloadsProps) =>
  useGet<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>(
    `/dashboard/getWorkloads`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get workloads
 */
export const getWorkloadsPromise = (
  props: GetUsingFetchProps<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getWorkloads`,
    props,
    signal
  )

export interface GetWorkloadsV2QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  startTime: number
  endTime: number
  environmentType?: 'PreProduction' | 'Production'
}

export type GetWorkloadsV2Props = Omit<
  GetProps<ResponseDashboardWorkloadDeploymentV2, Failure | Error, GetWorkloadsV2QueryParams, void>,
  'path'
>

/**
 * Get workloads
 */
export const GetWorkloadsV2 = (props: GetWorkloadsV2Props) => (
  <Get<ResponseDashboardWorkloadDeploymentV2, Failure | Error, GetWorkloadsV2QueryParams, void>
    path={`/dashboard/getWorkloadsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetWorkloadsV2Props = Omit<
  UseGetProps<ResponseDashboardWorkloadDeploymentV2, Failure | Error, GetWorkloadsV2QueryParams, void>,
  'path'
>

/**
 * Get workloads
 */
export const useGetWorkloadsV2 = (props: UseGetWorkloadsV2Props) =>
  useGet<ResponseDashboardWorkloadDeploymentV2, Failure | Error, GetWorkloadsV2QueryParams, void>(
    `/dashboard/getWorkloadsV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get workloads
 */
export const getWorkloadsV2Promise = (
  props: GetUsingFetchProps<ResponseDashboardWorkloadDeploymentV2, Failure | Error, GetWorkloadsV2QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDashboardWorkloadDeploymentV2, Failure | Error, GetWorkloadsV2QueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getWorkloadsV2`,
    props,
    signal
  )

export interface GetServiceDeploymentsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  startTime: number
  endTime: number
  serviceId?: string
  bucketSizeInDays?: number
}

export type GetServiceDeploymentsProps = Omit<
  GetProps<ResponseServiceDeploymentInfoDTO, Failure | Error, GetServiceDeploymentsQueryParams, void>,
  'path'
>

/**
 * Get service deployment
 */
export const GetServiceDeployments = (props: GetServiceDeploymentsProps) => (
  <Get<ResponseServiceDeploymentInfoDTO, Failure | Error, GetServiceDeploymentsQueryParams, void>
    path={`/dashboard/serviceDeployments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceDeploymentsProps = Omit<
  UseGetProps<ResponseServiceDeploymentInfoDTO, Failure | Error, GetServiceDeploymentsQueryParams, void>,
  'path'
>

/**
 * Get service deployment
 */
export const useGetServiceDeployments = (props: UseGetServiceDeploymentsProps) =>
  useGet<ResponseServiceDeploymentInfoDTO, Failure | Error, GetServiceDeploymentsQueryParams, void>(
    `/dashboard/serviceDeployments`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get service deployment
 */
export const getServiceDeploymentsPromise = (
  props: GetUsingFetchProps<ResponseServiceDeploymentInfoDTO, Failure | Error, GetServiceDeploymentsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceDeploymentInfoDTO, Failure | Error, GetServiceDeploymentsQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/serviceDeployments`,
    props,
    signal
  )

export interface GetServiceDeploymentsInfoQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  startTime: number
  endTime: number
  serviceId?: string
  bucketSizeInDays?: number
}

export type GetServiceDeploymentsInfoProps = Omit<
  GetProps<ResponseServiceDeploymentListInfo, Failure | Error, GetServiceDeploymentsInfoQueryParams, void>,
  'path'
>

/**
 * Get service deployments info
 */
export const GetServiceDeploymentsInfo = (props: GetServiceDeploymentsInfoProps) => (
  <Get<ResponseServiceDeploymentListInfo, Failure | Error, GetServiceDeploymentsInfoQueryParams, void>
    path={`/dashboard/serviceDeploymentsInfo`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceDeploymentsInfoProps = Omit<
  UseGetProps<ResponseServiceDeploymentListInfo, Failure | Error, GetServiceDeploymentsInfoQueryParams, void>,
  'path'
>

/**
 * Get service deployments info
 */
export const useGetServiceDeploymentsInfo = (props: UseGetServiceDeploymentsInfoProps) =>
  useGet<ResponseServiceDeploymentListInfo, Failure | Error, GetServiceDeploymentsInfoQueryParams, void>(
    `/dashboard/serviceDeploymentsInfo`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get service deployments info
 */
export const getServiceDeploymentsInfoPromise = (
  props: GetUsingFetchProps<
    ResponseServiceDeploymentListInfo,
    Failure | Error,
    GetServiceDeploymentsInfoQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceDeploymentListInfo, Failure | Error, GetServiceDeploymentsInfoQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/serviceDeploymentsInfo`,
    props,
    signal
  )

export interface GetServiceDeploymentsInfoV2QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  startTime: number
  endTime: number
  serviceId?: string
  bucketSizeInDays?: number
}

export type GetServiceDeploymentsInfoV2Props = Omit<
  GetProps<ResponseServiceDeploymentListInfoV2, Failure | Error, GetServiceDeploymentsInfoV2QueryParams, void>,
  'path'
>

/**
 * Get service deployments info v2
 */
export const GetServiceDeploymentsInfoV2 = (props: GetServiceDeploymentsInfoV2Props) => (
  <Get<ResponseServiceDeploymentListInfoV2, Failure | Error, GetServiceDeploymentsInfoV2QueryParams, void>
    path={`/dashboard/serviceDeploymentsInfoV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceDeploymentsInfoV2Props = Omit<
  UseGetProps<ResponseServiceDeploymentListInfoV2, Failure | Error, GetServiceDeploymentsInfoV2QueryParams, void>,
  'path'
>

/**
 * Get service deployments info v2
 */
export const useGetServiceDeploymentsInfoV2 = (props: UseGetServiceDeploymentsInfoV2Props) =>
  useGet<ResponseServiceDeploymentListInfoV2, Failure | Error, GetServiceDeploymentsInfoV2QueryParams, void>(
    `/dashboard/serviceDeploymentsInfoV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get service deployments info v2
 */
export const getServiceDeploymentsInfoV2Promise = (
  props: GetUsingFetchProps<
    ResponseServiceDeploymentListInfoV2,
    Failure | Error,
    GetServiceDeploymentsInfoV2QueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceDeploymentListInfoV2, Failure | Error, GetServiceDeploymentsInfoV2QueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/serviceDeploymentsInfoV2`,
    props,
    signal
  )

export interface GetServiceDetailsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  startTime: number
  endTime: number
  sort?: string[]
}

export type GetServiceDetailsProps = Omit<
  GetProps<ResponseServiceDetailsInfoDTO, Failure | Error, GetServiceDetailsQueryParams, void>,
  'path'
>

/**
 * Get service details list
 */
export const GetServiceDetails = (props: GetServiceDetailsProps) => (
  <Get<ResponseServiceDetailsInfoDTO, Failure | Error, GetServiceDetailsQueryParams, void>
    path={`/dashboard/serviceDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceDetailsProps = Omit<
  UseGetProps<ResponseServiceDetailsInfoDTO, Failure | Error, GetServiceDetailsQueryParams, void>,
  'path'
>

/**
 * Get service details list
 */
export const useGetServiceDetails = (props: UseGetServiceDetailsProps) =>
  useGet<ResponseServiceDetailsInfoDTO, Failure | Error, GetServiceDetailsQueryParams, void>(
    `/dashboard/serviceDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get service details list
 */
export const getServiceDetailsPromise = (
  props: GetUsingFetchProps<ResponseServiceDetailsInfoDTO, Failure | Error, GetServiceDetailsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceDetailsInfoDTO, Failure | Error, GetServiceDetailsQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/serviceDetails`,
    props,
    signal
  )

export interface GetServiceDetailsV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  startTime: number
  endTime: number
  sort?: string[]
  repoName?: string
}

export type GetServiceDetailsV2Props = Omit<
  GetProps<ResponseServiceDetailsInfoDTOV2, Failure | Error, GetServiceDetailsV2QueryParams, void>,
  'path'
>

/**
 * Get service details list v2
 */
export const GetServiceDetailsV2 = (props: GetServiceDetailsV2Props) => (
  <Get<ResponseServiceDetailsInfoDTOV2, Failure | Error, GetServiceDetailsV2QueryParams, void>
    path={`/dashboard/serviceDetailsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceDetailsV2Props = Omit<
  UseGetProps<ResponseServiceDetailsInfoDTOV2, Failure | Error, GetServiceDetailsV2QueryParams, void>,
  'path'
>

/**
 * Get service details list v2
 */
export const useGetServiceDetailsV2 = (props: UseGetServiceDetailsV2Props) =>
  useGet<ResponseServiceDetailsInfoDTOV2, Failure | Error, GetServiceDetailsV2QueryParams, void>(
    `/dashboard/serviceDetailsV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get service details list v2
 */
export const getServiceDetailsV2Promise = (
  props: GetUsingFetchProps<ResponseServiceDetailsInfoDTOV2, Failure | Error, GetServiceDetailsV2QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceDetailsInfoDTOV2, Failure | Error, GetServiceDetailsV2QueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/serviceDetailsV2`,
    props,
    signal
  )

export interface GetCustomSequenceStatusQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId?: string
}

export type GetCustomSequenceStatusProps = Omit<
  GetProps<ResponseSequenceToggleDTO, Failure | Error, GetCustomSequenceStatusQueryParams, void>,
  'path'
>

/**
 * get the status of current sequence of env cards
 */
export const GetCustomSequenceStatus = (props: GetCustomSequenceStatusProps) => (
  <Get<ResponseSequenceToggleDTO, Failure | Error, GetCustomSequenceStatusQueryParams, void>
    path={`/dashboard/useCustomSequence`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCustomSequenceStatusProps = Omit<
  UseGetProps<ResponseSequenceToggleDTO, Failure | Error, GetCustomSequenceStatusQueryParams, void>,
  'path'
>

/**
 * get the status of current sequence of env cards
 */
export const useGetCustomSequenceStatus = (props: UseGetCustomSequenceStatusProps) =>
  useGet<ResponseSequenceToggleDTO, Failure | Error, GetCustomSequenceStatusQueryParams, void>(
    `/dashboard/useCustomSequence`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * get the status of current sequence of env cards
 */
export const getCustomSequenceStatusPromise = (
  props: GetUsingFetchProps<ResponseSequenceToggleDTO, Failure | Error, GetCustomSequenceStatusQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSequenceToggleDTO, Failure | Error, GetCustomSequenceStatusQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/useCustomSequence`,
    props,
    signal
  )

export interface SetCustomSequenceStatusQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId?: string
  useCustomSequence: boolean
}

export type SetCustomSequenceStatusProps = Omit<
  MutateProps<ResponseServiceSequence, Failure | Error, SetCustomSequenceStatusQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Save the status of current sequence of env cards
 */
export const SetCustomSequenceStatus = (props: SetCustomSequenceStatusProps) => (
  <Mutate<ResponseServiceSequence, Failure | Error, SetCustomSequenceStatusQueryParams, void, void>
    verb="POST"
    path={`/dashboard/useCustomSequence`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSetCustomSequenceStatusProps = Omit<
  UseMutateProps<ResponseServiceSequence, Failure | Error, SetCustomSequenceStatusQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Save the status of current sequence of env cards
 */
export const useSetCustomSequenceStatus = (props: UseSetCustomSequenceStatusProps) =>
  useMutate<ResponseServiceSequence, Failure | Error, SetCustomSequenceStatusQueryParams, void, void>(
    'POST',
    `/dashboard/useCustomSequence`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Save the status of current sequence of env cards
 */
export const setCustomSequenceStatusPromise = (
  props: MutateUsingFetchProps<
    ResponseServiceSequence,
    Failure | Error,
    SetCustomSequenceStatusQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseServiceSequence, Failure | Error, SetCustomSequenceStatusQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/dashboard/useCustomSequence`,
    props,
    signal
  )

export interface ListDelegateGroupsUsingTagsQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ListDelegateGroupsUsingTagsProps = Omit<
  MutateProps<
    RestResponseListDelegateGroupDTO,
    unknown,
    ListDelegateGroupsUsingTagsQueryParams,
    DelegateGroupTagsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * List delegate groups that are having mentioned tags.
 */
export const ListDelegateGroupsUsingTags = (props: ListDelegateGroupsUsingTagsProps) => (
  <Mutate<
    RestResponseListDelegateGroupDTO,
    unknown,
    ListDelegateGroupsUsingTagsQueryParams,
    DelegateGroupTagsRequestBody,
    void
  >
    verb="POST"
    path={`/delegate-group-tags/delegate-groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListDelegateGroupsUsingTagsProps = Omit<
  UseMutateProps<
    RestResponseListDelegateGroupDTO,
    unknown,
    ListDelegateGroupsUsingTagsQueryParams,
    DelegateGroupTagsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * List delegate groups that are having mentioned tags.
 */
export const useListDelegateGroupsUsingTags = (props: UseListDelegateGroupsUsingTagsProps) =>
  useMutate<
    RestResponseListDelegateGroupDTO,
    unknown,
    ListDelegateGroupsUsingTagsQueryParams,
    DelegateGroupTagsRequestBody,
    void
  >('POST', `/delegate-group-tags/delegate-groups`, { base: getConfig('ng/api'), ...props })

/**
 * List delegate groups that are having mentioned tags.
 */
export const listDelegateGroupsUsingTagsPromise = (
  props: MutateUsingFetchProps<
    RestResponseListDelegateGroupDTO,
    unknown,
    ListDelegateGroupsUsingTagsQueryParams,
    DelegateGroupTagsRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseListDelegateGroupDTO,
    unknown,
    ListDelegateGroupsUsingTagsQueryParams,
    DelegateGroupTagsRequestBody,
    void
  >('POST', getConfig('ng/api'), `/delegate-group-tags/delegate-groups`, props, signal)

export interface DeleteTagsFromDelegateGroupQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteTagsFromDelegateGroupProps = Omit<
  MutateProps<RestResponseDelegateGroupDTO, unknown, DeleteTagsFromDelegateGroupQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes all tags from the Delegate group
 */
export const DeleteTagsFromDelegateGroup = (props: DeleteTagsFromDelegateGroupProps) => (
  <Mutate<RestResponseDelegateGroupDTO, unknown, DeleteTagsFromDelegateGroupQueryParams, string, void>
    verb="DELETE"
    path={`/delegate-group-tags`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteTagsFromDelegateGroupProps = Omit<
  UseMutateProps<RestResponseDelegateGroupDTO, unknown, DeleteTagsFromDelegateGroupQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes all tags from the Delegate group
 */
export const useDeleteTagsFromDelegateGroup = (props: UseDeleteTagsFromDelegateGroupProps) =>
  useMutate<RestResponseDelegateGroupDTO, unknown, DeleteTagsFromDelegateGroupQueryParams, string, void>(
    'DELETE',
    `/delegate-group-tags`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Deletes all tags from the Delegate group
 */
export const deleteTagsFromDelegateGroupPromise = (
  props: MutateUsingFetchProps<
    RestResponseDelegateGroupDTO,
    unknown,
    DeleteTagsFromDelegateGroupQueryParams,
    string,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseDelegateGroupDTO, unknown, DeleteTagsFromDelegateGroupQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/delegate-group-tags`,
    props,
    signal
  )

export interface ListTagsForDelegateGroupQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface ListTagsForDelegateGroupPathParams {
  groupIdentifier: string
}

export type ListTagsForDelegateGroupProps = Omit<
  GetProps<
    RestResponseDelegateGroupDTO,
    unknown,
    ListTagsForDelegateGroupQueryParams,
    ListTagsForDelegateGroupPathParams
  >,
  'path'
> &
  ListTagsForDelegateGroupPathParams

/**
 * List tags attached with Delegate group
 */
export const ListTagsForDelegateGroup = ({ groupIdentifier, ...props }: ListTagsForDelegateGroupProps) => (
  <Get<RestResponseDelegateGroupDTO, unknown, ListTagsForDelegateGroupQueryParams, ListTagsForDelegateGroupPathParams>
    path={`/delegate-group-tags/${groupIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListTagsForDelegateGroupProps = Omit<
  UseGetProps<
    RestResponseDelegateGroupDTO,
    unknown,
    ListTagsForDelegateGroupQueryParams,
    ListTagsForDelegateGroupPathParams
  >,
  'path'
> &
  ListTagsForDelegateGroupPathParams

/**
 * List tags attached with Delegate group
 */
export const useListTagsForDelegateGroup = ({ groupIdentifier, ...props }: UseListTagsForDelegateGroupProps) =>
  useGet<
    RestResponseDelegateGroupDTO,
    unknown,
    ListTagsForDelegateGroupQueryParams,
    ListTagsForDelegateGroupPathParams
  >((paramsInPath: ListTagsForDelegateGroupPathParams) => `/delegate-group-tags/${paramsInPath.groupIdentifier}`, {
    base: getConfig('ng/api'),
    pathParams: { groupIdentifier },
    ...props
  })

/**
 * List tags attached with Delegate group
 */
export const listTagsForDelegateGroupPromise = (
  {
    groupIdentifier,
    ...props
  }: GetUsingFetchProps<
    RestResponseDelegateGroupDTO,
    unknown,
    ListTagsForDelegateGroupQueryParams,
    ListTagsForDelegateGroupPathParams
  > & { groupIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    RestResponseDelegateGroupDTO,
    unknown,
    ListTagsForDelegateGroupQueryParams,
    ListTagsForDelegateGroupPathParams
  >(getConfig('ng/api'), `/delegate-group-tags/${groupIdentifier}`, props, signal)

export interface AddTagsToDelegateGroupQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface AddTagsToDelegateGroupPathParams {
  groupIdentifier: string
}

export type AddTagsToDelegateGroupProps = Omit<
  MutateProps<
    RestResponseDelegateGroupDTO,
    unknown,
    AddTagsToDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    AddTagsToDelegateGroupPathParams
  >,
  'path' | 'verb'
> &
  AddTagsToDelegateGroupPathParams

/**
 * Add tags to the Delegate group
 */
export const AddTagsToDelegateGroup = ({ groupIdentifier, ...props }: AddTagsToDelegateGroupProps) => (
  <Mutate<
    RestResponseDelegateGroupDTO,
    unknown,
    AddTagsToDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    AddTagsToDelegateGroupPathParams
  >
    verb="POST"
    path={`/delegate-group-tags/${groupIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAddTagsToDelegateGroupProps = Omit<
  UseMutateProps<
    RestResponseDelegateGroupDTO,
    unknown,
    AddTagsToDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    AddTagsToDelegateGroupPathParams
  >,
  'path' | 'verb'
> &
  AddTagsToDelegateGroupPathParams

/**
 * Add tags to the Delegate group
 */
export const useAddTagsToDelegateGroup = ({ groupIdentifier, ...props }: UseAddTagsToDelegateGroupProps) =>
  useMutate<
    RestResponseDelegateGroupDTO,
    unknown,
    AddTagsToDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    AddTagsToDelegateGroupPathParams
  >(
    'POST',
    (paramsInPath: AddTagsToDelegateGroupPathParams) => `/delegate-group-tags/${paramsInPath.groupIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { groupIdentifier }, ...props }
  )

/**
 * Add tags to the Delegate group
 */
export const addTagsToDelegateGroupPromise = (
  {
    groupIdentifier,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateGroupDTO,
    unknown,
    AddTagsToDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    AddTagsToDelegateGroupPathParams
  > & { groupIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateGroupDTO,
    unknown,
    AddTagsToDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    AddTagsToDelegateGroupPathParams
  >('POST', getConfig('ng/api'), `/delegate-group-tags/${groupIdentifier}`, props, signal)

export interface UpdateTagsOfDelegateGroupQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface UpdateTagsOfDelegateGroupPathParams {
  groupIdentifier: string
}

export type UpdateTagsOfDelegateGroupProps = Omit<
  MutateProps<
    RestResponseDelegateGroupDTO,
    unknown,
    UpdateTagsOfDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    UpdateTagsOfDelegateGroupPathParams
  >,
  'path' | 'verb'
> &
  UpdateTagsOfDelegateGroupPathParams

/**
 * Update tags of the Delegate group
 */
export const UpdateTagsOfDelegateGroup = ({ groupIdentifier, ...props }: UpdateTagsOfDelegateGroupProps) => (
  <Mutate<
    RestResponseDelegateGroupDTO,
    unknown,
    UpdateTagsOfDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    UpdateTagsOfDelegateGroupPathParams
  >
    verb="PUT"
    path={`/delegate-group-tags/${groupIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateTagsOfDelegateGroupProps = Omit<
  UseMutateProps<
    RestResponseDelegateGroupDTO,
    unknown,
    UpdateTagsOfDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    UpdateTagsOfDelegateGroupPathParams
  >,
  'path' | 'verb'
> &
  UpdateTagsOfDelegateGroupPathParams

/**
 * Update tags of the Delegate group
 */
export const useUpdateTagsOfDelegateGroup = ({ groupIdentifier, ...props }: UseUpdateTagsOfDelegateGroupProps) =>
  useMutate<
    RestResponseDelegateGroupDTO,
    unknown,
    UpdateTagsOfDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    UpdateTagsOfDelegateGroupPathParams
  >(
    'PUT',
    (paramsInPath: UpdateTagsOfDelegateGroupPathParams) => `/delegate-group-tags/${paramsInPath.groupIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { groupIdentifier }, ...props }
  )

/**
 * Update tags of the Delegate group
 */
export const updateTagsOfDelegateGroupPromise = (
  {
    groupIdentifier,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateGroupDTO,
    unknown,
    UpdateTagsOfDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    UpdateTagsOfDelegateGroupPathParams
  > & { groupIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateGroupDTO,
    unknown,
    UpdateTagsOfDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    UpdateTagsOfDelegateGroupPathParams
  >('PUT', getConfig('ng/api'), `/delegate-group-tags/${groupIdentifier}`, props, signal)

export interface ListDelegateProfilesNgQueryParams {
  offset?: string
  limit?: string
  fieldsIncluded?: string[]
  fieldsExcluded?: string[]
  accountId?: string
  orgId?: string
  projectId?: string
}

export type ListDelegateProfilesNgProps = Omit<
  GetProps<RestResponsePageResponseDelegateProfileDetailsNg, unknown, ListDelegateProfilesNgQueryParams, void>,
  'path'
>

/**
 * Lists the Delegate Configurations (profiles)
 */
export const ListDelegateProfilesNg = (props: ListDelegateProfilesNgProps) => (
  <Get<RestResponsePageResponseDelegateProfileDetailsNg, unknown, ListDelegateProfilesNgQueryParams, void>
    path={`/delegate-profiles/ng`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListDelegateProfilesNgProps = Omit<
  UseGetProps<RestResponsePageResponseDelegateProfileDetailsNg, unknown, ListDelegateProfilesNgQueryParams, void>,
  'path'
>

/**
 * Lists the Delegate Configurations (profiles)
 */
export const useListDelegateProfilesNg = (props: UseListDelegateProfilesNgProps) =>
  useGet<RestResponsePageResponseDelegateProfileDetailsNg, unknown, ListDelegateProfilesNgQueryParams, void>(
    `/delegate-profiles/ng`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Lists the Delegate Configurations (profiles)
 */
export const listDelegateProfilesNgPromise = (
  props: GetUsingFetchProps<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateProfilesNgQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponsePageResponseDelegateProfileDetailsNg, unknown, ListDelegateProfilesNgQueryParams, void>(
    getConfig('ng/api'),
    `/delegate-profiles/ng`,
    props,
    signal
  )

export interface AddDelegateProfileNgQueryParams {
  accountId?: string
  orgId?: string
  projectId?: string
}

export type AddDelegateProfileNgProps = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Adds a Delegate Configuration (profile)
 */
export const AddDelegateProfileNg = (props: AddDelegateProfileNgProps) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >
    verb="POST"
    path={`/delegate-profiles/ng`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAddDelegateProfileNgProps = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Adds a Delegate Configuration (profile)
 */
export const useAddDelegateProfileNg = (props: UseAddDelegateProfileNgProps) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >('POST', `/delegate-profiles/ng`, { base: getConfig('ng/api'), ...props })

/**
 * Adds a Delegate Configuration (profile)
 */
export const addDelegateProfileNgPromise = (
  props: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >('POST', getConfig('ng/api'), `/delegate-profiles/ng`, props, signal)

export interface DeleteDelegateProfileNgQueryParams {
  accountId?: string
  orgId?: string
  projectId?: string
}

export type DeleteDelegateProfileNgProps = Omit<
  MutateProps<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes a Delegate Configuration (profile)
 */
export const DeleteDelegateProfileNg = (props: DeleteDelegateProfileNgProps) => (
  <Mutate<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>
    verb="DELETE"
    path={`/delegate-profiles/ng`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteDelegateProfileNgProps = Omit<
  UseMutateProps<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes a Delegate Configuration (profile)
 */
export const useDeleteDelegateProfileNg = (props: UseDeleteDelegateProfileNgProps) =>
  useMutate<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>(
    'DELETE',
    `/delegate-profiles/ng`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Deletes a Delegate Configuration (profile)
 */
export const deleteDelegateProfileNgPromise = (
  props: MutateUsingFetchProps<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/delegate-profiles/ng`,
    props,
    signal
  )

export interface GetDelegateProfileNgQueryParams {
  accountId?: string
  orgId?: string
  projectId?: string
}

export interface GetDelegateProfileNgPathParams {
  delegateProfileId: string
}

export type GetDelegateProfileNgProps = Omit<
  GetProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateProfileNgQueryParams,
    GetDelegateProfileNgPathParams
  >,
  'path'
> &
  GetDelegateProfileNgPathParams

/**
 * Gets Delegate Configuration (profile)
 */
export const GetDelegateProfileNg = ({ delegateProfileId, ...props }: GetDelegateProfileNgProps) => (
  <Get<RestResponseDelegateProfileDetailsNg, unknown, GetDelegateProfileNgQueryParams, GetDelegateProfileNgPathParams>
    path={`/delegate-profiles/ng/${delegateProfileId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDelegateProfileNgProps = Omit<
  UseGetProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateProfileNgQueryParams,
    GetDelegateProfileNgPathParams
  >,
  'path'
> &
  GetDelegateProfileNgPathParams

/**
 * Gets Delegate Configuration (profile)
 */
export const useGetDelegateProfileNg = ({ delegateProfileId, ...props }: UseGetDelegateProfileNgProps) =>
  useGet<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateProfileNgQueryParams,
    GetDelegateProfileNgPathParams
  >((paramsInPath: GetDelegateProfileNgPathParams) => `/delegate-profiles/ng/${paramsInPath.delegateProfileId}`, {
    base: getConfig('ng/api'),
    pathParams: { delegateProfileId },
    ...props
  })

/**
 * Gets Delegate Configuration (profile)
 */
export const getDelegateProfileNgPromise = (
  {
    delegateProfileId,
    ...props
  }: GetUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateProfileNgQueryParams,
    GetDelegateProfileNgPathParams
  > & { delegateProfileId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateProfileNgQueryParams,
    GetDelegateProfileNgPathParams
  >(getConfig('ng/api'), `/delegate-profiles/ng/${delegateProfileId}`, props, signal)

export interface UpdateDelegateProfileNgQueryParams {
  accountId?: string
  orgId?: string
  projectId?: string
}

export interface UpdateDelegateProfileNgPathParams {
  delegateProfileId: string
}

export type UpdateDelegateProfileNgProps = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateDelegateProfileNgPathParams

/**
 * Updates a Delegate profile
 */
export const UpdateDelegateProfileNg = ({ delegateProfileId, ...props }: UpdateDelegateProfileNgProps) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  >
    verb="PUT"
    path={`/delegate-profiles/ng/${delegateProfileId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateDelegateProfileNgProps = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateDelegateProfileNgPathParams

/**
 * Updates a Delegate profile
 */
export const useUpdateDelegateProfileNg = ({ delegateProfileId, ...props }: UseUpdateDelegateProfileNgProps) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  >(
    'PUT',
    (paramsInPath: UpdateDelegateProfileNgPathParams) => `/delegate-profiles/ng/${paramsInPath.delegateProfileId}`,
    { base: getConfig('ng/api'), pathParams: { delegateProfileId }, ...props }
  )

/**
 * Updates a Delegate profile
 */
export const updateDelegateProfileNgPromise = (
  {
    delegateProfileId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  > & { delegateProfileId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  >('PUT', getConfig('ng/api'), `/delegate-profiles/ng/${delegateProfileId}`, props, signal)

export interface UpdateScopingRulesNgQueryParams {
  accountId?: string
  orgId?: string
  projectId?: string
}

export interface UpdateScopingRulesNgPathParams {
  delegateProfileId: string
}

export type UpdateScopingRulesNgProps = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateScopingRulesNgPathParams

/**
 * Updates the scoping rules inside the Delegate profile
 */
export const UpdateScopingRulesNg = ({ delegateProfileId, ...props }: UpdateScopingRulesNgProps) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgPathParams
  >
    verb="PUT"
    path={`/delegate-profiles/ng/${delegateProfileId}/scoping-rules`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateScopingRulesNgProps = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateScopingRulesNgPathParams

/**
 * Updates the scoping rules inside the Delegate profile
 */
export const useUpdateScopingRulesNg = ({ delegateProfileId, ...props }: UseUpdateScopingRulesNgProps) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgPathParams
  >(
    'PUT',
    (paramsInPath: UpdateScopingRulesNgPathParams) =>
      `/delegate-profiles/ng/${paramsInPath.delegateProfileId}/scoping-rules`,
    { base: getConfig('ng/api'), pathParams: { delegateProfileId }, ...props }
  )

/**
 * Updates the scoping rules inside the Delegate profile
 */
export const updateScopingRulesNgPromise = (
  {
    delegateProfileId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgPathParams
  > & { delegateProfileId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgPathParams
  >('PUT', getConfig('ng/api'), `/delegate-profiles/ng/${delegateProfileId}/scoping-rules`, props, signal)

export interface UpdateSelectorsNgQueryParams {
  accountId?: string
  orgId?: string
  projectId?: string
}

export interface UpdateSelectorsNgPathParams {
  delegateProfileId: string
}

export type UpdateSelectorsNgProps = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateSelectorsNgPathParams

/**
 * Updates the selectors inside the Delegate profile
 */
export const UpdateSelectorsNg = ({ delegateProfileId, ...props }: UpdateSelectorsNgProps) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  >
    verb="PUT"
    path={`/delegate-profiles/ng/${delegateProfileId}/selectors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateSelectorsNgProps = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateSelectorsNgPathParams

/**
 * Updates the selectors inside the Delegate profile
 */
export const useUpdateSelectorsNg = ({ delegateProfileId, ...props }: UseUpdateSelectorsNgProps) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  >(
    'PUT',
    (paramsInPath: UpdateSelectorsNgPathParams) => `/delegate-profiles/ng/${paramsInPath.delegateProfileId}/selectors`,
    { base: getConfig('ng/api'), pathParams: { delegateProfileId }, ...props }
  )

/**
 * Updates the selectors inside the Delegate profile
 */
export const updateSelectorsNgPromise = (
  {
    delegateProfileId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  > & { delegateProfileId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  >('PUT', getConfig('ng/api'), `/delegate-profiles/ng/${delegateProfileId}/selectors`, props, signal)

export interface GenerateTerraformModuleQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GenerateTerraformModuleProps = Omit<GetProps<void, void, GenerateTerraformModuleQueryParams, void>, 'path'>

/**
 * Generate delegate terraform example module file
 */
export const GenerateTerraformModule = (props: GenerateTerraformModuleProps) => (
  <Get<void, void, GenerateTerraformModuleQueryParams, void>
    path={`/delegate-setup/delegate-terraform-module-file`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGenerateTerraformModuleProps = Omit<
  UseGetProps<void, void, GenerateTerraformModuleQueryParams, void>,
  'path'
>

/**
 * Generate delegate terraform example module file
 */
export const useGenerateTerraformModule = (props: UseGenerateTerraformModuleProps) =>
  useGet<void, void, GenerateTerraformModuleQueryParams, void>(`/delegate-setup/delegate-terraform-module-file`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Generate delegate terraform example module file
 */
export const generateTerraformModulePromise = (
  props: GetUsingFetchProps<void, void, GenerateTerraformModuleQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, void, GenerateTerraformModuleQueryParams, void>(
    getConfig('ng/api'),
    `/delegate-setup/delegate-terraform-module-file`,
    props,
    signal
  )

export interface DeleteDelegateQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteDelegateProps = Omit<
  MutateProps<RestResponseDelegateDeleteResponse, unknown, DeleteDelegateQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes delegate
 */
export const DeleteDelegate = (props: DeleteDelegateProps) => (
  <Mutate<RestResponseDelegateDeleteResponse, unknown, DeleteDelegateQueryParams, string, void>
    verb="DELETE"
    path={`/delegate-setup/delegate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteDelegateProps = Omit<
  UseMutateProps<RestResponseDelegateDeleteResponse, unknown, DeleteDelegateQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes delegate
 */
export const useDeleteDelegate = (props: UseDeleteDelegateProps) =>
  useMutate<RestResponseDelegateDeleteResponse, unknown, DeleteDelegateQueryParams, string, void>(
    'DELETE',
    `/delegate-setup/delegate`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Deletes delegate
 */
export const deleteDelegatePromise = (
  props: MutateUsingFetchProps<RestResponseDelegateDeleteResponse, unknown, DeleteDelegateQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseDelegateDeleteResponse, unknown, DeleteDelegateQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/delegate-setup/delegate`,
    props,
    signal
  )

export interface GenerateNgHelmValuesYamlQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GenerateNgHelmValuesYamlProps = Omit<
  MutateProps<void, void, GenerateNgHelmValuesYamlQueryParams, DelegateSetupDetails, void>,
  'path' | 'verb'
>

/**
 * Generate helm values yaml file
 */
export const GenerateNgHelmValuesYaml = (props: GenerateNgHelmValuesYamlProps) => (
  <Mutate<void, void, GenerateNgHelmValuesYamlQueryParams, DelegateSetupDetails, void>
    verb="POST"
    path={`/delegate-setup/generate-helm-values`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGenerateNgHelmValuesYamlProps = Omit<
  UseMutateProps<void, void, GenerateNgHelmValuesYamlQueryParams, DelegateSetupDetails, void>,
  'path' | 'verb'
>

/**
 * Generate helm values yaml file
 */
export const useGenerateNgHelmValuesYaml = (props: UseGenerateNgHelmValuesYamlProps) =>
  useMutate<void, void, GenerateNgHelmValuesYamlQueryParams, DelegateSetupDetails, void>(
    'POST',
    `/delegate-setup/generate-helm-values`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Generate helm values yaml file
 */
export const generateNgHelmValuesYamlPromise = (
  props: MutateUsingFetchProps<void, void, GenerateNgHelmValuesYamlQueryParams, DelegateSetupDetails, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, void, GenerateNgHelmValuesYamlQueryParams, DelegateSetupDetails, void>(
    'POST',
    getConfig('ng/api'),
    `/delegate-setup/generate-helm-values`,
    props,
    signal
  )

export interface PublishedDelegateVersionQueryParams {
  accountIdentifier: string
}

export type PublishedDelegateVersionProps = Omit<
  GetProps<RestResponseSupportedDelegateVersion, unknown, PublishedDelegateVersionQueryParams, void>,
  'path'
>

/**
 * Gets the latest supported delegate version
 */
export const PublishedDelegateVersion = (props: PublishedDelegateVersionProps) => (
  <Get<RestResponseSupportedDelegateVersion, unknown, PublishedDelegateVersionQueryParams, void>
    path={`/delegate-setup/latest-supported-version`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePublishedDelegateVersionProps = Omit<
  UseGetProps<RestResponseSupportedDelegateVersion, unknown, PublishedDelegateVersionQueryParams, void>,
  'path'
>

/**
 * Gets the latest supported delegate version
 */
export const usePublishedDelegateVersion = (props: UsePublishedDelegateVersionProps) =>
  useGet<RestResponseSupportedDelegateVersion, unknown, PublishedDelegateVersionQueryParams, void>(
    `/delegate-setup/latest-supported-version`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets the latest supported delegate version
 */
export const publishedDelegateVersionPromise = (
  props: GetUsingFetchProps<RestResponseSupportedDelegateVersion, unknown, PublishedDelegateVersionQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseSupportedDelegateVersion, unknown, PublishedDelegateVersionQueryParams, void>(
    getConfig('ng/api'),
    `/delegate-setup/latest-supported-version`,
    props,
    signal
  )

export interface ListDelegatesQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ListDelegatesProps = Omit<
  MutateProps<RestResponseListDelegateListResponse, unknown, ListDelegatesQueryParams, DelegateFilterProperties, void>,
  'path' | 'verb'
>

/**
 * Lists all delegates in NG
 */
export const ListDelegates = (props: ListDelegatesProps) => (
  <Mutate<RestResponseListDelegateListResponse, unknown, ListDelegatesQueryParams, DelegateFilterProperties, void>
    verb="POST"
    path={`/delegate-setup/listDelegates`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListDelegatesProps = Omit<
  UseMutateProps<
    RestResponseListDelegateListResponse,
    unknown,
    ListDelegatesQueryParams,
    DelegateFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * Lists all delegates in NG
 */
export const useListDelegates = (props: UseListDelegatesProps) =>
  useMutate<RestResponseListDelegateListResponse, unknown, ListDelegatesQueryParams, DelegateFilterProperties, void>(
    'POST',
    `/delegate-setup/listDelegates`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Lists all delegates in NG
 */
export const listDelegatesPromise = (
  props: MutateUsingFetchProps<
    RestResponseListDelegateListResponse,
    unknown,
    ListDelegatesQueryParams,
    DelegateFilterProperties,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseListDelegateListResponse,
    unknown,
    ListDelegatesQueryParams,
    DelegateFilterProperties,
    void
  >('POST', getConfig('ng/api'), `/delegate-setup/listDelegates`, props, signal)

export interface OverrideDelegateImageTagQueryParams {
  accountIdentifier?: string
  delegateTag?: string
  validTillNextRelease?: boolean
  validForDays?: number
}

export type OverrideDelegateImageTagProps = Omit<
  MutateProps<RestResponseString, unknown, OverrideDelegateImageTagQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Overrides delegate image tag for account
 */
export const OverrideDelegateImageTag = (props: OverrideDelegateImageTagProps) => (
  <Mutate<RestResponseString, unknown, OverrideDelegateImageTagQueryParams, void, void>
    verb="PUT"
    path={`/delegate-setup/override-delegate-tag`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseOverrideDelegateImageTagProps = Omit<
  UseMutateProps<RestResponseString, unknown, OverrideDelegateImageTagQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Overrides delegate image tag for account
 */
export const useOverrideDelegateImageTag = (props: UseOverrideDelegateImageTagProps) =>
  useMutate<RestResponseString, unknown, OverrideDelegateImageTagQueryParams, void, void>(
    'PUT',
    `/delegate-setup/override-delegate-tag`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Overrides delegate image tag for account
 */
export const overrideDelegateImageTagPromise = (
  props: MutateUsingFetchProps<RestResponseString, unknown, OverrideDelegateImageTagQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseString, unknown, OverrideDelegateImageTagQueryParams, void, void>(
    'PUT',
    getConfig('ng/api'),
    `/delegate-setup/override-delegate-tag`,
    props,
    signal
  )

export interface GetDelegateTokensQueryParams {
  name?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  status?: 'ACTIVE' | 'REVOKED'
}

export type GetDelegateTokensProps = Omit<
  GetProps<RestResponseListDelegateTokenDetails, unknown, GetDelegateTokensQueryParams, void>,
  'path'
>

/**
 * Get Delegate Tokens
 */
export const GetDelegateTokens = (props: GetDelegateTokensProps) => (
  <Get<RestResponseListDelegateTokenDetails, unknown, GetDelegateTokensQueryParams, void>
    path={`/delegate-token-ng`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDelegateTokensProps = Omit<
  UseGetProps<RestResponseListDelegateTokenDetails, unknown, GetDelegateTokensQueryParams, void>,
  'path'
>

/**
 * Get Delegate Tokens
 */
export const useGetDelegateTokens = (props: UseGetDelegateTokensProps) =>
  useGet<RestResponseListDelegateTokenDetails, unknown, GetDelegateTokensQueryParams, void>(`/delegate-token-ng`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Delegate Tokens
 */
export const getDelegateTokensPromise = (
  props: GetUsingFetchProps<RestResponseListDelegateTokenDetails, unknown, GetDelegateTokensQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseListDelegateTokenDetails, unknown, GetDelegateTokensQueryParams, void>(
    getConfig('ng/api'),
    `/delegate-token-ng`,
    props,
    signal
  )

export interface CreateDelegateTokenQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  tokenName: string
  revokeAfter?: number
}

export type CreateDelegateTokenProps = Omit<
  MutateProps<RestResponseDelegateTokenDetails, unknown, CreateDelegateTokenQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Creates Delegate Token
 */
export const CreateDelegateToken = (props: CreateDelegateTokenProps) => (
  <Mutate<RestResponseDelegateTokenDetails, unknown, CreateDelegateTokenQueryParams, void, void>
    verb="POST"
    path={`/delegate-token-ng`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateDelegateTokenProps = Omit<
  UseMutateProps<RestResponseDelegateTokenDetails, unknown, CreateDelegateTokenQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Creates Delegate Token
 */
export const useCreateDelegateToken = (props: UseCreateDelegateTokenProps) =>
  useMutate<RestResponseDelegateTokenDetails, unknown, CreateDelegateTokenQueryParams, void, void>(
    'POST',
    `/delegate-token-ng`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Creates Delegate Token
 */
export const createDelegateTokenPromise = (
  props: MutateUsingFetchProps<RestResponseDelegateTokenDetails, unknown, CreateDelegateTokenQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseDelegateTokenDetails, unknown, CreateDelegateTokenQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/delegate-token-ng`,
    props,
    signal
  )

export interface RevokeDelegateTokenQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  tokenName: string
}

export type RevokeDelegateTokenProps = Omit<
  MutateProps<RestResponseDelegateTokenDetails, unknown, RevokeDelegateTokenQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Revokes Delegate Token
 */
export const RevokeDelegateToken = (props: RevokeDelegateTokenProps) => (
  <Mutate<RestResponseDelegateTokenDetails, unknown, RevokeDelegateTokenQueryParams, void, void>
    verb="PUT"
    path={`/delegate-token-ng`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRevokeDelegateTokenProps = Omit<
  UseMutateProps<RestResponseDelegateTokenDetails, unknown, RevokeDelegateTokenQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Revokes Delegate Token
 */
export const useRevokeDelegateToken = (props: UseRevokeDelegateTokenProps) =>
  useMutate<RestResponseDelegateTokenDetails, unknown, RevokeDelegateTokenQueryParams, void, void>(
    'PUT',
    `/delegate-token-ng`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Revokes Delegate Token
 */
export const revokeDelegateTokenPromise = (
  props: MutateUsingFetchProps<RestResponseDelegateTokenDetails, unknown, RevokeDelegateTokenQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseDelegateTokenDetails, unknown, RevokeDelegateTokenQueryParams, void, void>(
    'PUT',
    getConfig('ng/api'),
    `/delegate-token-ng`,
    props,
    signal
  )

export interface GetDelegateGroupsUsingTokenQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  delegateTokenName?: string
}

export type GetDelegateGroupsUsingTokenProps = Omit<
  GetProps<RestResponseDelegateGroupListing, unknown, GetDelegateGroupsUsingTokenQueryParams, void>,
  'path'
>

/**
 * Get Delegate Groups
 */
export const GetDelegateGroupsUsingToken = (props: GetDelegateGroupsUsingTokenProps) => (
  <Get<RestResponseDelegateGroupListing, unknown, GetDelegateGroupsUsingTokenQueryParams, void>
    path={`/delegate-token-ng/delegate-groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDelegateGroupsUsingTokenProps = Omit<
  UseGetProps<RestResponseDelegateGroupListing, unknown, GetDelegateGroupsUsingTokenQueryParams, void>,
  'path'
>

/**
 * Get Delegate Groups
 */
export const useGetDelegateGroupsUsingToken = (props: UseGetDelegateGroupsUsingTokenProps) =>
  useGet<RestResponseDelegateGroupListing, unknown, GetDelegateGroupsUsingTokenQueryParams, void>(
    `/delegate-token-ng/delegate-groups`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Delegate Groups
 */
export const getDelegateGroupsUsingTokenPromise = (
  props: GetUsingFetchProps<RestResponseDelegateGroupListing, unknown, GetDelegateGroupsUsingTokenQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseDelegateGroupListing, unknown, GetDelegateGroupsUsingTokenQueryParams, void>(
    getConfig('ng/api'),
    `/delegate-token-ng/delegate-groups`,
    props,
    signal
  )

export interface DownloadDockerDelegateYamlQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DownloadDockerDelegateYamlProps = Omit<
  MutateProps<void, void, DownloadDockerDelegateYamlQueryParams, DelegateDownloadRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * Downloads a docker delegate yaml file.
 */
export const DownloadDockerDelegateYaml = (props: DownloadDockerDelegateYamlProps) => (
  <Mutate<void, void, DownloadDockerDelegateYamlQueryParams, DelegateDownloadRequestRequestBody, void>
    verb="POST"
    path={`/download-delegates/docker`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDownloadDockerDelegateYamlProps = Omit<
  UseMutateProps<void, void, DownloadDockerDelegateYamlQueryParams, DelegateDownloadRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * Downloads a docker delegate yaml file.
 */
export const useDownloadDockerDelegateYaml = (props: UseDownloadDockerDelegateYamlProps) =>
  useMutate<void, void, DownloadDockerDelegateYamlQueryParams, DelegateDownloadRequestRequestBody, void>(
    'POST',
    `/download-delegates/docker`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Downloads a docker delegate yaml file.
 */
export const downloadDockerDelegateYamlPromise = (
  props: MutateUsingFetchProps<
    void,
    void,
    DownloadDockerDelegateYamlQueryParams,
    DelegateDownloadRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, void, DownloadDockerDelegateYamlQueryParams, DelegateDownloadRequestRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/download-delegates/docker`,
    props,
    signal
  )

export interface DownloadKubernetesDelegateYamlQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DownloadKubernetesDelegateYamlProps = Omit<
  MutateProps<void, void, DownloadKubernetesDelegateYamlQueryParams, DelegateDownloadRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * Downloads a kubernetes delegate yaml file.
 */
export const DownloadKubernetesDelegateYaml = (props: DownloadKubernetesDelegateYamlProps) => (
  <Mutate<void, void, DownloadKubernetesDelegateYamlQueryParams, DelegateDownloadRequestRequestBody, void>
    verb="POST"
    path={`/download-delegates/kubernetes`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDownloadKubernetesDelegateYamlProps = Omit<
  UseMutateProps<void, void, DownloadKubernetesDelegateYamlQueryParams, DelegateDownloadRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * Downloads a kubernetes delegate yaml file.
 */
export const useDownloadKubernetesDelegateYaml = (props: UseDownloadKubernetesDelegateYamlProps) =>
  useMutate<void, void, DownloadKubernetesDelegateYamlQueryParams, DelegateDownloadRequestRequestBody, void>(
    'POST',
    `/download-delegates/kubernetes`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Downloads a kubernetes delegate yaml file.
 */
export const downloadKubernetesDelegateYamlPromise = (
  props: MutateUsingFetchProps<
    void,
    void,
    DownloadKubernetesDelegateYamlQueryParams,
    DelegateDownloadRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, void, DownloadKubernetesDelegateYamlQueryParams, DelegateDownloadRequestRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/download-delegates/kubernetes`,
    props,
    signal
  )

export interface GetFeatureRestrictionDetailQueryParams {
  accountIdentifier: string
}

export type GetFeatureRestrictionDetailProps = Omit<
  MutateProps<
    ResponseFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailQueryParams,
    FeatureRestrictionDetailRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Fetch Feature Restriction Detail
 */
export const GetFeatureRestrictionDetail = (props: GetFeatureRestrictionDetailProps) => (
  <Mutate<
    ResponseFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailQueryParams,
    FeatureRestrictionDetailRequestDTO,
    void
  >
    verb="POST"
    path={`/enforcement`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFeatureRestrictionDetailProps = Omit<
  UseMutateProps<
    ResponseFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailQueryParams,
    FeatureRestrictionDetailRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Fetch Feature Restriction Detail
 */
export const useGetFeatureRestrictionDetail = (props: UseGetFeatureRestrictionDetailProps) =>
  useMutate<
    ResponseFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailQueryParams,
    FeatureRestrictionDetailRequestDTO,
    void
  >('POST', `/enforcement`, { base: getConfig('ng/api'), ...props })

/**
 * Fetch Feature Restriction Detail
 */
export const getFeatureRestrictionDetailPromise = (
  props: MutateUsingFetchProps<
    ResponseFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailQueryParams,
    FeatureRestrictionDetailRequestDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailQueryParams,
    FeatureRestrictionDetailRequestDTO,
    void
  >('POST', getConfig('ng/api'), `/enforcement`, props, signal)

export interface GetFeatureRestrictionDetailsQueryParams {
  accountIdentifier: string
}

export type GetFeatureRestrictionDetailsProps = Omit<
  MutateProps<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailsQueryParams,
    FeatureRestrictionDetailListRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Fetch List of Feature Restriction Detail
 */
export const GetFeatureRestrictionDetails = (props: GetFeatureRestrictionDetailsProps) => (
  <Mutate<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailsQueryParams,
    FeatureRestrictionDetailListRequestDTO,
    void
  >
    verb="POST"
    path={`/enforcement/details`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFeatureRestrictionDetailsProps = Omit<
  UseMutateProps<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailsQueryParams,
    FeatureRestrictionDetailListRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Fetch List of Feature Restriction Detail
 */
export const useGetFeatureRestrictionDetails = (props: UseGetFeatureRestrictionDetailsProps) =>
  useMutate<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailsQueryParams,
    FeatureRestrictionDetailListRequestDTO,
    void
  >('POST', `/enforcement/details`, { base: getConfig('ng/api'), ...props })

/**
 * Fetch List of Feature Restriction Detail
 */
export const getFeatureRestrictionDetailsPromise = (
  props: MutateUsingFetchProps<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailsQueryParams,
    FeatureRestrictionDetailListRequestDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailsQueryParams,
    FeatureRestrictionDetailListRequestDTO,
    void
  >('POST', getConfig('ng/api'), `/enforcement/details`, props, signal)

export interface GetEnabledFeatureRestrictionDetailByAccountIdQueryParams {
  accountIdentifier: string
}

export type GetEnabledFeatureRestrictionDetailByAccountIdProps = Omit<
  GetProps<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetEnabledFeatureRestrictionDetailByAccountIdQueryParams,
    void
  >,
  'path'
>

/**
 * Fetch the List of enabled Feature Restriction Detail for this Account
 */
export const GetEnabledFeatureRestrictionDetailByAccountId = (
  props: GetEnabledFeatureRestrictionDetailByAccountIdProps
) => (
  <Get<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetEnabledFeatureRestrictionDetailByAccountIdQueryParams,
    void
  >
    path={`/enforcement/enabled`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnabledFeatureRestrictionDetailByAccountIdProps = Omit<
  UseGetProps<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetEnabledFeatureRestrictionDetailByAccountIdQueryParams,
    void
  >,
  'path'
>

/**
 * Fetch the List of enabled Feature Restriction Detail for this Account
 */
export const useGetEnabledFeatureRestrictionDetailByAccountId = (
  props: UseGetEnabledFeatureRestrictionDetailByAccountIdProps
) =>
  useGet<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetEnabledFeatureRestrictionDetailByAccountIdQueryParams,
    void
  >(`/enforcement/enabled`, { base: getConfig('ng/api'), ...props })

/**
 * Fetch the List of enabled Feature Restriction Detail for this Account
 */
export const getEnabledFeatureRestrictionDetailByAccountIdPromise = (
  props: GetUsingFetchProps<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetEnabledFeatureRestrictionDetailByAccountIdQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetEnabledFeatureRestrictionDetailByAccountIdQueryParams,
    void
  >(getConfig('ng/api'), `/enforcement/enabled`, props, signal)

export interface GetAllFeatureRestrictionMetadataQueryParams {
  accountIdentifier?: string
}

export type GetAllFeatureRestrictionMetadataProps = Omit<
  GetProps<
    ResponseListFeatureRestrictionMetadataDTO,
    Failure | Error,
    GetAllFeatureRestrictionMetadataQueryParams,
    void
  >,
  'path'
>

/**
 * Fetch All Feature Restriction Metadata
 */
export const GetAllFeatureRestrictionMetadata = (props: GetAllFeatureRestrictionMetadataProps) => (
  <Get<ResponseListFeatureRestrictionMetadataDTO, Failure | Error, GetAllFeatureRestrictionMetadataQueryParams, void>
    path={`/enforcement/metadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAllFeatureRestrictionMetadataProps = Omit<
  UseGetProps<
    ResponseListFeatureRestrictionMetadataDTO,
    Failure | Error,
    GetAllFeatureRestrictionMetadataQueryParams,
    void
  >,
  'path'
>

/**
 * Fetch All Feature Restriction Metadata
 */
export const useGetAllFeatureRestrictionMetadata = (props: UseGetAllFeatureRestrictionMetadataProps) =>
  useGet<ResponseListFeatureRestrictionMetadataDTO, Failure | Error, GetAllFeatureRestrictionMetadataQueryParams, void>(
    `/enforcement/metadata`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Fetch All Feature Restriction Metadata
 */
export const getAllFeatureRestrictionMetadataPromise = (
  props: GetUsingFetchProps<
    ResponseListFeatureRestrictionMetadataDTO,
    Failure | Error,
    GetAllFeatureRestrictionMetadataQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseListFeatureRestrictionMetadataDTO,
    Failure | Error,
    GetAllFeatureRestrictionMetadataQueryParams,
    void
  >(getConfig('ng/api'), `/enforcement/metadata`, props, signal)

export interface FetchFeatureRestrictionMetadataQueryParams {
  accountIdentifier: string
}

export interface FetchFeatureRestrictionMetadataPathParams {
  featureRestrictionName:
    | 'TEST1'
    | 'TEST2'
    | 'TEST3'
    | 'TEST4'
    | 'TEST5'
    | 'TEST6'
    | 'TEST7'
    | 'PERSPECTIVES'
    | 'CCM_K8S_CLUSTERS'
    | 'CCM_AUTOSTOPPING_RULES'
    | 'MULTIPLE_ORGANIZATIONS'
    | 'MULTIPLE_PROJECTS'
    | 'MULTIPLE_SECRETS'
    | 'MULTIPLE_USER_GROUPS'
    | 'MULTIPLE_USERS'
    | 'MULTIPLE_SERVICE_ACCOUNTS'
    | 'MULTIPLE_VARIABLES'
    | 'MULTIPLE_CONNECTORS'
    | 'MULTIPLE_API_KEYS'
    | 'MULTIPLE_API_TOKENS'
    | 'INTEGRATED_APPROVALS_WITH_HARNESS_UI'
    | 'INTEGRATED_APPROVALS_WITH_CUSTOM_SCRIPT'
    | 'INTEGRATED_APPROVALS_WITH_JIRA'
    | 'SECRET_MANAGERS'
    | 'DEPLOYMENTS'
    | 'INITIAL_DEPLOYMENTS'
    | 'DEPLOYMENTS_PER_MONTH'
    | 'SERVICES'
    | 'BUILDS'
    | 'SAML_SUPPORT'
    | 'OAUTH_SUPPORT'
    | 'LDAP_SUPPORT'
    | 'TWO_FACTOR_AUTH_SUPPORT'
    | 'CUSTOM_ROLES'
    | 'CUSTOM_RESOURCE_GROUPS'
    | 'MAX_TOTAL_BUILDS'
    | 'MAX_BUILDS_PER_MONTH'
    | 'MAX_BUILDS_PER_DAY'
    | 'ACTIVE_COMMITTERS'
    | 'TEST_INTELLIGENCE'
    | 'TEMPLATE_SERVICE'
    | 'CACHE_SIZE_ALLOWANCE'
    | 'SRM_SERVICES'
    | 'ANALYZE_DEPLOYMENT_STEP'
    | 'TERRAFORM_APPLY'
    | 'TERRAFORM_PLAN'
    | 'TERRAFORM_DESTROY'
    | 'TERRAFORM_ROLLBACK'
    | 'INTEGRATED_APPROVALS_WITH_SERVICE_NOW'
    | 'CREATE_STACK'
    | 'DELETE_STACK'
    | 'ROLLBACK_STACK'
    | 'COMMAND'
    | 'AZURE_SLOT_DEPLOYMENT'
    | 'AZURE_TRAFFIC_SHIFT'
    | 'AZURE_SWAP_SLOT'
    | 'AZURE_WEBAPP_ROLLBACK'
    | 'JENKINS_BUILD'
    | 'AZURE_CREATE_ARM_RESOURCE'
    | 'AZURE_CREATE_BP_RESOURCE'
    | 'AZURE_ROLLBACK_ARM_RESOURCE'
    | 'SHELL_SCRIPT_PROVISION'
    | 'TERRAFORM_CLOUD_RUN'
    | 'TERRAFORM_CLOUD_ROLLBACK'
    | 'SECURITY'
    | 'DEVELOPERS'
    | 'MONTHLY_ACTIVE_USERS'
    | 'STRATEGY_MAX_CONCURRENT'
    | 'MAX_PARALLEL_STEP_IN_A_PIPELINE'
    | 'PIPELINE_EXECUTION_DATA_RETENTION_DAYS'
    | 'MAX_PIPELINE_TIMEOUT_SECONDS'
    | 'MAX_STAGE_TIMEOUT_SECONDS'
    | 'MAX_STEP_TIMEOUT_SECONDS'
    | 'MAX_CONCURRENT_ACTIVE_PIPELINE_EXECUTIONS'
    | 'MAX_CHAOS_EXPERIMENT_RUNS_PER_MONTH'
    | 'MAX_CHAOS_INFRASTRUCTURES'
    | 'TERRAGRUNT_PLAN'
    | 'TERRAGRUNT_APPLY'
    | 'TERRAGRUNT_DESTROY'
    | 'TERRAGRUNT_ROLLBACK'
    | 'SEI_MAX_NUMBER_OF_CONTRIBUTORS'
}

export type FetchFeatureRestrictionMetadataProps = Omit<
  GetProps<
    ResponseFeatureRestrictionMetadataDTO,
    Failure | Error,
    FetchFeatureRestrictionMetadataQueryParams,
    FetchFeatureRestrictionMetadataPathParams
  >,
  'path'
> &
  FetchFeatureRestrictionMetadataPathParams

/**
 * Fetch Feature Restriction Metadata
 */
export const FetchFeatureRestrictionMetadata = ({
  featureRestrictionName,
  ...props
}: FetchFeatureRestrictionMetadataProps) => (
  <Get<
    ResponseFeatureRestrictionMetadataDTO,
    Failure | Error,
    FetchFeatureRestrictionMetadataQueryParams,
    FetchFeatureRestrictionMetadataPathParams
  >
    path={`/enforcement/${featureRestrictionName}/metadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseFetchFeatureRestrictionMetadataProps = Omit<
  UseGetProps<
    ResponseFeatureRestrictionMetadataDTO,
    Failure | Error,
    FetchFeatureRestrictionMetadataQueryParams,
    FetchFeatureRestrictionMetadataPathParams
  >,
  'path'
> &
  FetchFeatureRestrictionMetadataPathParams

/**
 * Fetch Feature Restriction Metadata
 */
export const useFetchFeatureRestrictionMetadata = ({
  featureRestrictionName,
  ...props
}: UseFetchFeatureRestrictionMetadataProps) =>
  useGet<
    ResponseFeatureRestrictionMetadataDTO,
    Failure | Error,
    FetchFeatureRestrictionMetadataQueryParams,
    FetchFeatureRestrictionMetadataPathParams
  >(
    (paramsInPath: FetchFeatureRestrictionMetadataPathParams) =>
      `/enforcement/${paramsInPath.featureRestrictionName}/metadata`,
    { base: getConfig('ng/api'), pathParams: { featureRestrictionName }, ...props }
  )

/**
 * Fetch Feature Restriction Metadata
 */
export const fetchFeatureRestrictionMetadataPromise = (
  {
    featureRestrictionName,
    ...props
  }: GetUsingFetchProps<
    ResponseFeatureRestrictionMetadataDTO,
    Failure | Error,
    FetchFeatureRestrictionMetadataQueryParams,
    FetchFeatureRestrictionMetadataPathParams
  > & {
    featureRestrictionName:
      | 'TEST1'
      | 'TEST2'
      | 'TEST3'
      | 'TEST4'
      | 'TEST5'
      | 'TEST6'
      | 'TEST7'
      | 'PERSPECTIVES'
      | 'CCM_K8S_CLUSTERS'
      | 'CCM_AUTOSTOPPING_RULES'
      | 'MULTIPLE_ORGANIZATIONS'
      | 'MULTIPLE_PROJECTS'
      | 'MULTIPLE_SECRETS'
      | 'MULTIPLE_USER_GROUPS'
      | 'MULTIPLE_USERS'
      | 'MULTIPLE_SERVICE_ACCOUNTS'
      | 'MULTIPLE_VARIABLES'
      | 'MULTIPLE_CONNECTORS'
      | 'MULTIPLE_API_KEYS'
      | 'MULTIPLE_API_TOKENS'
      | 'INTEGRATED_APPROVALS_WITH_HARNESS_UI'
      | 'INTEGRATED_APPROVALS_WITH_CUSTOM_SCRIPT'
      | 'INTEGRATED_APPROVALS_WITH_JIRA'
      | 'SECRET_MANAGERS'
      | 'DEPLOYMENTS'
      | 'INITIAL_DEPLOYMENTS'
      | 'DEPLOYMENTS_PER_MONTH'
      | 'SERVICES'
      | 'BUILDS'
      | 'SAML_SUPPORT'
      | 'OAUTH_SUPPORT'
      | 'LDAP_SUPPORT'
      | 'TWO_FACTOR_AUTH_SUPPORT'
      | 'CUSTOM_ROLES'
      | 'CUSTOM_RESOURCE_GROUPS'
      | 'MAX_TOTAL_BUILDS'
      | 'MAX_BUILDS_PER_MONTH'
      | 'MAX_BUILDS_PER_DAY'
      | 'ACTIVE_COMMITTERS'
      | 'TEST_INTELLIGENCE'
      | 'TEMPLATE_SERVICE'
      | 'CACHE_SIZE_ALLOWANCE'
      | 'SRM_SERVICES'
      | 'ANALYZE_DEPLOYMENT_STEP'
      | 'TERRAFORM_APPLY'
      | 'TERRAFORM_PLAN'
      | 'TERRAFORM_DESTROY'
      | 'TERRAFORM_ROLLBACK'
      | 'INTEGRATED_APPROVALS_WITH_SERVICE_NOW'
      | 'CREATE_STACK'
      | 'DELETE_STACK'
      | 'ROLLBACK_STACK'
      | 'COMMAND'
      | 'AZURE_SLOT_DEPLOYMENT'
      | 'AZURE_TRAFFIC_SHIFT'
      | 'AZURE_SWAP_SLOT'
      | 'AZURE_WEBAPP_ROLLBACK'
      | 'JENKINS_BUILD'
      | 'AZURE_CREATE_ARM_RESOURCE'
      | 'AZURE_CREATE_BP_RESOURCE'
      | 'AZURE_ROLLBACK_ARM_RESOURCE'
      | 'SHELL_SCRIPT_PROVISION'
      | 'TERRAFORM_CLOUD_RUN'
      | 'TERRAFORM_CLOUD_ROLLBACK'
      | 'SECURITY'
      | 'DEVELOPERS'
      | 'MONTHLY_ACTIVE_USERS'
      | 'STRATEGY_MAX_CONCURRENT'
      | 'MAX_PARALLEL_STEP_IN_A_PIPELINE'
      | 'PIPELINE_EXECUTION_DATA_RETENTION_DAYS'
      | 'MAX_PIPELINE_TIMEOUT_SECONDS'
      | 'MAX_STAGE_TIMEOUT_SECONDS'
      | 'MAX_STEP_TIMEOUT_SECONDS'
      | 'MAX_CONCURRENT_ACTIVE_PIPELINE_EXECUTIONS'
      | 'MAX_CHAOS_EXPERIMENT_RUNS_PER_MONTH'
      | 'MAX_CHAOS_INFRASTRUCTURES'
      | 'TERRAGRUNT_PLAN'
      | 'TERRAGRUNT_APPLY'
      | 'TERRAGRUNT_DESTROY'
      | 'TERRAGRUNT_ROLLBACK'
      | 'SEI_MAX_NUMBER_OF_CONTRIBUTORS'
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseFeatureRestrictionMetadataDTO,
    Failure | Error,
    FetchFeatureRestrictionMetadataQueryParams,
    FetchFeatureRestrictionMetadataPathParams
  >(getConfig('ng/api'), `/enforcement/${featureRestrictionName}/metadata`, props, signal)

export interface ListReferredByEntitiesQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  referredEntityType?:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  searchTerm?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type ListReferredByEntitiesProps = Omit<
  GetProps<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>,
  'path'
>

/**
 * Get Entities referring this resource
 */
export const ListReferredByEntities = (props: ListReferredByEntitiesProps) => (
  <Get<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>
    path={`/entitySetupUsage`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListReferredByEntitiesProps = Omit<
  UseGetProps<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>,
  'path'
>

/**
 * Get Entities referring this resource
 */
export const useListReferredByEntities = (props: UseListReferredByEntitiesProps) =>
  useGet<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>(`/entitySetupUsage`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Entities referring this resource
 */
export const listReferredByEntitiesPromise = (
  props: GetUsingFetchProps<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>(
    getConfig('ng/api'),
    `/entitySetupUsage`,
    props,
    signal
  )

export interface ListAllEntityUsageByFqnQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  referredEntityFQN?: string
  referredEntityType?:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  searchTerm?: string
}

export type ListAllEntityUsageByFqnProps = Omit<
  GetProps<ResponsePageEntitySetupUsageDTO, unknown, ListAllEntityUsageByFqnQueryParams, void>,
  'path'
>

/**
 * Get Entities referring this resource if fqn is given
 */
export const ListAllEntityUsageByFqn = (props: ListAllEntityUsageByFqnProps) => (
  <Get<ResponsePageEntitySetupUsageDTO, unknown, ListAllEntityUsageByFqnQueryParams, void>
    path={`/entitySetupUsage/v2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListAllEntityUsageByFqnProps = Omit<
  UseGetProps<ResponsePageEntitySetupUsageDTO, unknown, ListAllEntityUsageByFqnQueryParams, void>,
  'path'
>

/**
 * Get Entities referring this resource if fqn is given
 */
export const useListAllEntityUsageByFqn = (props: UseListAllEntityUsageByFqnProps) =>
  useGet<ResponsePageEntitySetupUsageDTO, unknown, ListAllEntityUsageByFqnQueryParams, void>(`/entitySetupUsage/v2`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Entities referring this resource if fqn is given
 */
export const listAllEntityUsageByFqnPromise = (
  props: GetUsingFetchProps<ResponsePageEntitySetupUsageDTO, unknown, ListAllEntityUsageByFqnQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageEntitySetupUsageDTO, unknown, ListAllEntityUsageByFqnQueryParams, void>(
    getConfig('ng/api'),
    `/entitySetupUsage/v2`,
    props,
    signal
  )

export interface CreateEnvironmentGroupQueryParams {
  accountIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type CreateEnvironmentGroupProps = Omit<
  MutateProps<
    ResponseEnvironmentGroupResponse,
    Failure | Error,
    CreateEnvironmentGroupQueryParams,
    EnvironmentGroupRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment Group
 */
export const CreateEnvironmentGroup = (props: CreateEnvironmentGroupProps) => (
  <Mutate<
    ResponseEnvironmentGroupResponse,
    Failure | Error,
    CreateEnvironmentGroupQueryParams,
    EnvironmentGroupRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/environmentGroup`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateEnvironmentGroupProps = Omit<
  UseMutateProps<
    ResponseEnvironmentGroupResponse,
    Failure | Error,
    CreateEnvironmentGroupQueryParams,
    EnvironmentGroupRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment Group
 */
export const useCreateEnvironmentGroup = (props: UseCreateEnvironmentGroupProps) =>
  useMutate<
    ResponseEnvironmentGroupResponse,
    Failure | Error,
    CreateEnvironmentGroupQueryParams,
    EnvironmentGroupRequestDTORequestBody,
    void
  >('POST', `/environmentGroup`, { base: getConfig('ng/api'), ...props })

/**
 * Create an Environment Group
 */
export const createEnvironmentGroupPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentGroupResponse,
    Failure | Error,
    CreateEnvironmentGroupQueryParams,
    EnvironmentGroupRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentGroupResponse,
    Failure | Error,
    CreateEnvironmentGroupQueryParams,
    EnvironmentGroupRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/environmentGroup`, props, signal)

export interface GetEnvironmentGroupListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  envGroupIdentifiers?: string[]
  searchTerm?: string
  page?: number
  size?: number
  sort?: string[]
  filterIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  includeAllEnvGroupsAccessibleAtScope?: boolean
}

export type GetEnvironmentGroupListProps = Omit<
  MutateProps<
    ResponsePageEnvironmentGroupResponse,
    Failure | Error,
    GetEnvironmentGroupListQueryParams,
    FilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Environment Group list
 */
export const GetEnvironmentGroupList = (props: GetEnvironmentGroupListProps) => (
  <Mutate<
    ResponsePageEnvironmentGroupResponse,
    Failure | Error,
    GetEnvironmentGroupListQueryParams,
    FilterProperties,
    void
  >
    verb="POST"
    path={`/environmentGroup/list`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentGroupListProps = Omit<
  UseMutateProps<
    ResponsePageEnvironmentGroupResponse,
    Failure | Error,
    GetEnvironmentGroupListQueryParams,
    FilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Environment Group list
 */
export const useGetEnvironmentGroupList = (props: UseGetEnvironmentGroupListProps) =>
  useMutate<
    ResponsePageEnvironmentGroupResponse,
    Failure | Error,
    GetEnvironmentGroupListQueryParams,
    FilterProperties,
    void
  >('POST', `/environmentGroup/list`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Environment Group list
 */
export const getEnvironmentGroupListPromise = (
  props: MutateUsingFetchProps<
    ResponsePageEnvironmentGroupResponse,
    Failure | Error,
    GetEnvironmentGroupListQueryParams,
    FilterProperties,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageEnvironmentGroupResponse,
    Failure | Error,
    GetEnvironmentGroupListQueryParams,
    FilterProperties,
    void
  >('POST', getConfig('ng/api'), `/environmentGroup/list`, props, signal)

export interface DeleteEnvironmentGroupQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  forceDelete?: boolean
}

export type DeleteEnvironmentGroupProps = Omit<
  MutateProps<ResponseEnvironmentGroupDeleteResponse, Failure | Error, DeleteEnvironmentGroupQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete en Environment Group by Identifier
 */
export const DeleteEnvironmentGroup = (props: DeleteEnvironmentGroupProps) => (
  <Mutate<ResponseEnvironmentGroupDeleteResponse, Failure | Error, DeleteEnvironmentGroupQueryParams, string, void>
    verb="DELETE"
    path={`/environmentGroup`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteEnvironmentGroupProps = Omit<
  UseMutateProps<
    ResponseEnvironmentGroupDeleteResponse,
    Failure | Error,
    DeleteEnvironmentGroupQueryParams,
    string,
    void
  >,
  'path' | 'verb'
>

/**
 * Delete en Environment Group by Identifier
 */
export const useDeleteEnvironmentGroup = (props: UseDeleteEnvironmentGroupProps) =>
  useMutate<ResponseEnvironmentGroupDeleteResponse, Failure | Error, DeleteEnvironmentGroupQueryParams, string, void>(
    'DELETE',
    `/environmentGroup`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete en Environment Group by Identifier
 */
export const deleteEnvironmentGroupPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentGroupDeleteResponse,
    Failure | Error,
    DeleteEnvironmentGroupQueryParams,
    string,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentGroupDeleteResponse,
    Failure | Error,
    DeleteEnvironmentGroupQueryParams,
    string,
    void
  >('DELETE', getConfig('ng/api'), `/environmentGroup`, props, signal)

export interface GetEnvironmentGroupQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  deleted?: boolean
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export interface GetEnvironmentGroupPathParams {
  envGroupIdentifier: string
}

export type GetEnvironmentGroupProps = Omit<
  GetProps<
    ResponseEnvironmentGroupResponse,
    Failure | Error,
    GetEnvironmentGroupQueryParams,
    GetEnvironmentGroupPathParams
  >,
  'path'
> &
  GetEnvironmentGroupPathParams

/**
 * Gets a Environment Group by identifier
 */
export const GetEnvironmentGroup = ({ envGroupIdentifier, ...props }: GetEnvironmentGroupProps) => (
  <Get<ResponseEnvironmentGroupResponse, Failure | Error, GetEnvironmentGroupQueryParams, GetEnvironmentGroupPathParams>
    path={`/environmentGroup/${envGroupIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentGroupProps = Omit<
  UseGetProps<
    ResponseEnvironmentGroupResponse,
    Failure | Error,
    GetEnvironmentGroupQueryParams,
    GetEnvironmentGroupPathParams
  >,
  'path'
> &
  GetEnvironmentGroupPathParams

/**
 * Gets a Environment Group by identifier
 */
export const useGetEnvironmentGroup = ({ envGroupIdentifier, ...props }: UseGetEnvironmentGroupProps) =>
  useGet<
    ResponseEnvironmentGroupResponse,
    Failure | Error,
    GetEnvironmentGroupQueryParams,
    GetEnvironmentGroupPathParams
  >((paramsInPath: GetEnvironmentGroupPathParams) => `/environmentGroup/${paramsInPath.envGroupIdentifier}`, {
    base: getConfig('ng/api'),
    pathParams: { envGroupIdentifier },
    ...props
  })

/**
 * Gets a Environment Group by identifier
 */
export const getEnvironmentGroupPromise = (
  {
    envGroupIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseEnvironmentGroupResponse,
    Failure | Error,
    GetEnvironmentGroupQueryParams,
    GetEnvironmentGroupPathParams
  > & { envGroupIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseEnvironmentGroupResponse,
    Failure | Error,
    GetEnvironmentGroupQueryParams,
    GetEnvironmentGroupPathParams
  >(getConfig('ng/api'), `/environmentGroup/${envGroupIdentifier}`, props, signal)

export interface UpdateEnvironmentGroupQueryParams {
  accountIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  lastCommitId?: string
  isNewBranch?: boolean
}

export interface UpdateEnvironmentGroupPathParams {
  envGroupIdentifier: string
}

export type UpdateEnvironmentGroupProps = Omit<
  MutateProps<
    ResponseEnvironmentGroupResponse,
    Failure | Error,
    UpdateEnvironmentGroupQueryParams,
    EnvironmentGroupRequestDTORequestBody,
    UpdateEnvironmentGroupPathParams
  >,
  'path' | 'verb'
> &
  UpdateEnvironmentGroupPathParams

/**
 * Update an Environment Group by Identifier
 */
export const UpdateEnvironmentGroup = ({ envGroupIdentifier, ...props }: UpdateEnvironmentGroupProps) => (
  <Mutate<
    ResponseEnvironmentGroupResponse,
    Failure | Error,
    UpdateEnvironmentGroupQueryParams,
    EnvironmentGroupRequestDTORequestBody,
    UpdateEnvironmentGroupPathParams
  >
    verb="PUT"
    path={`/environmentGroup/${envGroupIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateEnvironmentGroupProps = Omit<
  UseMutateProps<
    ResponseEnvironmentGroupResponse,
    Failure | Error,
    UpdateEnvironmentGroupQueryParams,
    EnvironmentGroupRequestDTORequestBody,
    UpdateEnvironmentGroupPathParams
  >,
  'path' | 'verb'
> &
  UpdateEnvironmentGroupPathParams

/**
 * Update an Environment Group by Identifier
 */
export const useUpdateEnvironmentGroup = ({ envGroupIdentifier, ...props }: UseUpdateEnvironmentGroupProps) =>
  useMutate<
    ResponseEnvironmentGroupResponse,
    Failure | Error,
    UpdateEnvironmentGroupQueryParams,
    EnvironmentGroupRequestDTORequestBody,
    UpdateEnvironmentGroupPathParams
  >('PUT', (paramsInPath: UpdateEnvironmentGroupPathParams) => `/environmentGroup/${paramsInPath.envGroupIdentifier}`, {
    base: getConfig('ng/api'),
    pathParams: { envGroupIdentifier },
    ...props
  })

/**
 * Update an Environment Group by Identifier
 */
export const updateEnvironmentGroupPromise = (
  {
    envGroupIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseEnvironmentGroupResponse,
    Failure | Error,
    UpdateEnvironmentGroupQueryParams,
    EnvironmentGroupRequestDTORequestBody,
    UpdateEnvironmentGroupPathParams
  > & { envGroupIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentGroupResponse,
    Failure | Error,
    UpdateEnvironmentGroupQueryParams,
    EnvironmentGroupRequestDTORequestBody,
    UpdateEnvironmentGroupPathParams
  >('PUT', getConfig('ng/api'), `/environmentGroup/${envGroupIdentifier}`, props, signal)

export interface GetEnvironmentListForProjectQueryParams {
  page?: number
  size?: number
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  envIdentifiers?: string[]
  sort?: string[]
}

export type GetEnvironmentListForProjectProps = Omit<
  GetProps<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>,
  'path'
>

/**
 * Gets environment list for a project
 */
export const GetEnvironmentListForProject = (props: GetEnvironmentListForProjectProps) => (
  <Get<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>
    path={`/environments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentListForProjectProps = Omit<
  UseGetProps<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>,
  'path'
>

/**
 * Gets environment list for a project
 */
export const useGetEnvironmentListForProject = (props: UseGetEnvironmentListForProjectProps) =>
  useGet<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>(
    `/environments`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets environment list for a project
 */
export const getEnvironmentListForProjectPromise = (
  props: GetUsingFetchProps<
    ResponsePageEnvironmentResponseDTO,
    Failure | Error,
    GetEnvironmentListForProjectQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>(
    getConfig('ng/api'),
    `/environments`,
    props,
    signal
  )

export interface CreateEnvironmentQueryParams {
  accountId?: string
}

export type CreateEnvironmentProps = Omit<
  MutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment
 */
export const CreateEnvironment = (props: CreateEnvironmentProps) => (
  <Mutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/environments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateEnvironmentProps = Omit<
  UseMutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment
 */
export const useCreateEnvironment = (props: UseCreateEnvironmentProps) =>
  useMutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('POST', `/environments`, { base: getConfig('ng/api'), ...props })

/**
 * Create an Environment
 */
export const createEnvironmentPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/environments`, props, signal)

export interface UpdateEnvironmentQueryParams {
  accountId?: string
}

export type UpdateEnvironmentProps = Omit<
  MutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an environment by identifier
 */
export const UpdateEnvironment = (props: UpdateEnvironmentProps) => (
  <Mutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="PUT"
    path={`/environments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateEnvironmentProps = Omit<
  UseMutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an environment by identifier
 */
export const useUpdateEnvironment = (props: UseUpdateEnvironmentProps) =>
  useMutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', `/environments`, { base: getConfig('ng/api'), ...props })

/**
 * Update an environment by identifier
 */
export const updateEnvironmentPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/environments`, props, signal)

export interface UpsertEnvironmentQueryParams {
  accountId?: string
}

export type UpsertEnvironmentProps = Omit<
  MutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an environment by identifier
 */
export const UpsertEnvironment = (props: UpsertEnvironmentProps) => (
  <Mutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="PUT"
    path={`/environments/upsert`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertEnvironmentProps = Omit<
  UseMutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an environment by identifier
 */
export const useUpsertEnvironment = (props: UseUpsertEnvironmentProps) =>
  useMutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', `/environments/upsert`, { base: getConfig('ng/api'), ...props })

/**
 * Upsert an environment by identifier
 */
export const upsertEnvironmentPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/environments/upsert`, props, signal)

export interface DeleteEnvironmentQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteEnvironmentProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete en environment by identifier
 */
export const DeleteEnvironment = (props: DeleteEnvironmentProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>
    verb="DELETE"
    path={`/environments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteEnvironmentProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete en environment by identifier
 */
export const useDeleteEnvironment = (props: UseDeleteEnvironmentProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>('DELETE', `/environments`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete en environment by identifier
 */
export const deleteEnvironmentPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/environments`,
    props,
    signal
  )

export interface GetEnvironmentQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  deleted?: boolean
}

export interface GetEnvironmentPathParams {
  environmentIdentifier: string
}

export type GetEnvironmentProps = Omit<
  GetProps<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>,
  'path'
> &
  GetEnvironmentPathParams

/**
 * Gets a Environment by identifier
 */
export const GetEnvironment = ({ environmentIdentifier, ...props }: GetEnvironmentProps) => (
  <Get<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>
    path={`/environments/${environmentIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentProps = Omit<
  UseGetProps<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>,
  'path'
> &
  GetEnvironmentPathParams

/**
 * Gets a Environment by identifier
 */
export const useGetEnvironment = ({ environmentIdentifier, ...props }: UseGetEnvironmentProps) =>
  useGet<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>(
    (paramsInPath: GetEnvironmentPathParams) => `/environments/${paramsInPath.environmentIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { environmentIdentifier }, ...props }
  )

/**
 * Gets a Environment by identifier
 */
export const getEnvironmentPromise = (
  {
    environmentIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    GetEnvironmentQueryParams,
    GetEnvironmentPathParams
  > & { environmentIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>(
    getConfig('ng/api'),
    `/environments/${environmentIdentifier}`,
    props,
    signal
  )

export interface GetEnvironmentListQueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  envIdentifiers?: string[]
  sort?: string[]
}

export type GetEnvironmentListProps = Omit<
  GetProps<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>,
  'path'
>

/**
 * Gets environment list
 */
export const GetEnvironmentList = (props: GetEnvironmentListProps) => (
  <Get<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>
    path={`/environmentsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentListProps = Omit<
  UseGetProps<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>,
  'path'
>

/**
 * Gets environment list
 */
export const useGetEnvironmentList = (props: UseGetEnvironmentListProps) =>
  useGet<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>(`/environmentsV2`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets environment list
 */
export const getEnvironmentListPromise = (
  props: GetUsingFetchProps<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>(
    getConfig('ng/api'),
    `/environmentsV2`,
    props,
    signal
  )

export interface CreateEnvironmentV2QueryParams {
  accountIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  repoName?: string
}

export type CreateEnvironmentV2Props = Omit<
  MutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment
 */
export const CreateEnvironmentV2 = (props: CreateEnvironmentV2Props) => (
  <Mutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/environmentsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateEnvironmentV2Props = Omit<
  UseMutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment
 */
export const useCreateEnvironmentV2 = (props: UseCreateEnvironmentV2Props) =>
  useMutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('POST', `/environmentsV2`, { base: getConfig('ng/api'), ...props })

/**
 * Create an Environment
 */
export const createEnvironmentV2Promise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/environmentsV2`, props, signal)

export interface UpdateEnvironmentV2QueryParams {
  accountIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  lastCommitId?: string
  isNewBranch?: boolean
}

export type UpdateEnvironmentV2Props = Omit<
  MutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an environment by identifier
 */
export const UpdateEnvironmentV2 = (props: UpdateEnvironmentV2Props) => (
  <Mutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="PUT"
    path={`/environmentsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateEnvironmentV2Props = Omit<
  UseMutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an environment by identifier
 */
export const useUpdateEnvironmentV2 = (props: UseUpdateEnvironmentV2Props) =>
  useMutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', `/environmentsV2`, { base: getConfig('ng/api'), ...props })

/**
 * Update an environment by identifier
 */
export const updateEnvironmentV2Promise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/environmentsV2`, props, signal)

export type DummyNGServiceOverrideConfigProps = Omit<
  GetProps<ResponseEnvSwaggerObjectWrapper, Failure | Error, void, void>,
  'path'
>

/**
 * This is dummy api to expose objects to swagger
 */
export const DummyNGServiceOverrideConfig = (props: DummyNGServiceOverrideConfigProps) => (
  <Get<ResponseEnvSwaggerObjectWrapper, Failure | Error, void, void>
    path={`/environmentsV2/dummy-api-for-exposing-objects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDummyNGServiceOverrideConfigProps = Omit<
  UseGetProps<ResponseEnvSwaggerObjectWrapper, Failure | Error, void, void>,
  'path'
>

/**
 * This is dummy api to expose objects to swagger
 */
export const useDummyNGServiceOverrideConfig = (props: UseDummyNGServiceOverrideConfigProps) =>
  useGet<ResponseEnvSwaggerObjectWrapper, Failure | Error, void, void>(
    `/environmentsV2/dummy-api-for-exposing-objects`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * This is dummy api to expose objects to swagger
 */
export const dummyNGServiceOverrideConfigPromise = (
  props: GetUsingFetchProps<ResponseEnvSwaggerObjectWrapper, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEnvSwaggerObjectWrapper, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/environmentsV2/dummy-api-for-exposing-objects`,
    props,
    signal
  )

export type DummyNGEnvironmentConfigApiProps = Omit<
  GetProps<ResponseNGEnvironmentConfig, Failure | Error, void, void>,
  'path'
>

/**
 * This is dummy api to expose NGEnvironmentConfig
 */
export const DummyNGEnvironmentConfigApi = (props: DummyNGEnvironmentConfigApiProps) => (
  <Get<ResponseNGEnvironmentConfig, Failure | Error, void, void>
    path={`/environmentsV2/dummy-env-api`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDummyNGEnvironmentConfigApiProps = Omit<
  UseGetProps<ResponseNGEnvironmentConfig, Failure | Error, void, void>,
  'path'
>

/**
 * This is dummy api to expose NGEnvironmentConfig
 */
export const useDummyNGEnvironmentConfigApi = (props: UseDummyNGEnvironmentConfigApiProps) =>
  useGet<ResponseNGEnvironmentConfig, Failure | Error, void, void>(`/environmentsV2/dummy-env-api`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * This is dummy api to expose NGEnvironmentConfig
 */
export const dummyNGEnvironmentConfigApiPromise = (
  props: GetUsingFetchProps<ResponseNGEnvironmentConfig, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNGEnvironmentConfig, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/environmentsV2/dummy-env-api`,
    props,
    signal
  )

export interface GetEnvironmentsInputYamlAndServiceOverridesQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetEnvironmentsInputYamlAndServiceOverridesProps = Omit<
  MutateProps<
    ResponseEnvironmentYamlMetadataDTO,
    Failure | Error,
    GetEnvironmentsInputYamlAndServiceOverridesQueryParams,
    EnvironmentInputsetYamlAndServiceOverridesMetadataInput,
    void
  >,
  'path' | 'verb'
>

/**
 * This api returns environments runtime input YAML and serviceOverrides Yaml
 */
export const GetEnvironmentsInputYamlAndServiceOverrides = (
  props: GetEnvironmentsInputYamlAndServiceOverridesProps
) => (
  <Mutate<
    ResponseEnvironmentYamlMetadataDTO,
    Failure | Error,
    GetEnvironmentsInputYamlAndServiceOverridesQueryParams,
    EnvironmentInputsetYamlAndServiceOverridesMetadataInput,
    void
  >
    verb="POST"
    path={`/environmentsV2/environmentInputYamlAndServiceOverridesMetadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentsInputYamlAndServiceOverridesProps = Omit<
  UseMutateProps<
    ResponseEnvironmentYamlMetadataDTO,
    Failure | Error,
    GetEnvironmentsInputYamlAndServiceOverridesQueryParams,
    EnvironmentInputsetYamlAndServiceOverridesMetadataInput,
    void
  >,
  'path' | 'verb'
>

/**
 * This api returns environments runtime input YAML and serviceOverrides Yaml
 */
export const useGetEnvironmentsInputYamlAndServiceOverrides = (
  props: UseGetEnvironmentsInputYamlAndServiceOverridesProps
) =>
  useMutate<
    ResponseEnvironmentYamlMetadataDTO,
    Failure | Error,
    GetEnvironmentsInputYamlAndServiceOverridesQueryParams,
    EnvironmentInputsetYamlAndServiceOverridesMetadataInput,
    void
  >('POST', `/environmentsV2/environmentInputYamlAndServiceOverridesMetadata`, { base: getConfig('ng/api'), ...props })

/**
 * This api returns environments runtime input YAML and serviceOverrides Yaml
 */
export const getEnvironmentsInputYamlAndServiceOverridesPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentYamlMetadataDTO,
    Failure | Error,
    GetEnvironmentsInputYamlAndServiceOverridesQueryParams,
    EnvironmentInputsetYamlAndServiceOverridesMetadataInput,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentYamlMetadataDTO,
    Failure | Error,
    GetEnvironmentsInputYamlAndServiceOverridesQueryParams,
    EnvironmentInputsetYamlAndServiceOverridesMetadataInput,
    void
  >('POST', getConfig('ng/api'), `/environmentsV2/environmentInputYamlAndServiceOverridesMetadata`, props, signal)

export interface GetActiveServiceInstancesForEnvironmentQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  environmentIdentifier: string
  serviceIdentifier?: string
  buildId?: string
}

export type GetActiveServiceInstancesForEnvironmentProps = Omit<
  GetProps<
    ResponseInstanceGroupedByServiceList,
    Failure | Error,
    GetActiveServiceInstancesForEnvironmentQueryParams,
    void
  >,
  'path'
>

/**
 * Get list of instances grouped by service for particular environment
 */
export const GetActiveServiceInstancesForEnvironment = (props: GetActiveServiceInstancesForEnvironmentProps) => (
  <Get<ResponseInstanceGroupedByServiceList, Failure | Error, GetActiveServiceInstancesForEnvironmentQueryParams, void>
    path={`/environmentsV2/getActiveServiceInstancesForEnvironment`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveServiceInstancesForEnvironmentProps = Omit<
  UseGetProps<
    ResponseInstanceGroupedByServiceList,
    Failure | Error,
    GetActiveServiceInstancesForEnvironmentQueryParams,
    void
  >,
  'path'
>

/**
 * Get list of instances grouped by service for particular environment
 */
export const useGetActiveServiceInstancesForEnvironment = (props: UseGetActiveServiceInstancesForEnvironmentProps) =>
  useGet<
    ResponseInstanceGroupedByServiceList,
    Failure | Error,
    GetActiveServiceInstancesForEnvironmentQueryParams,
    void
  >(`/environmentsV2/getActiveServiceInstancesForEnvironment`, { base: getConfig('ng/api'), ...props })

/**
 * Get list of instances grouped by service for particular environment
 */
export const getActiveServiceInstancesForEnvironmentPromise = (
  props: GetUsingFetchProps<
    ResponseInstanceGroupedByServiceList,
    Failure | Error,
    GetActiveServiceInstancesForEnvironmentQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInstanceGroupedByServiceList,
    Failure | Error,
    GetActiveServiceInstancesForEnvironmentQueryParams,
    void
  >(getConfig('ng/api'), `/environmentsV2/getActiveServiceInstancesForEnvironment`, props, signal)

export interface GetEnvironmentAccessListQueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  envIdentifiers?: string[]
  envGroupIdentifier?: string
  sort?: string[]
}

export type GetEnvironmentAccessListProps = Omit<
  GetProps<ResponseListEnvironmentResponse, Failure | Error, GetEnvironmentAccessListQueryParams, void>,
  'path'
>

/**
 * Gets environment access list
 */
export const GetEnvironmentAccessList = (props: GetEnvironmentAccessListProps) => (
  <Get<ResponseListEnvironmentResponse, Failure | Error, GetEnvironmentAccessListQueryParams, void>
    path={`/environmentsV2/list/access`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentAccessListProps = Omit<
  UseGetProps<ResponseListEnvironmentResponse, Failure | Error, GetEnvironmentAccessListQueryParams, void>,
  'path'
>

/**
 * Gets environment access list
 */
export const useGetEnvironmentAccessList = (props: UseGetEnvironmentAccessListProps) =>
  useGet<ResponseListEnvironmentResponse, Failure | Error, GetEnvironmentAccessListQueryParams, void>(
    `/environmentsV2/list/access`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets environment access list
 */
export const getEnvironmentAccessListPromise = (
  props: GetUsingFetchProps<
    ResponseListEnvironmentResponse,
    Failure | Error,
    GetEnvironmentAccessListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListEnvironmentResponse, Failure | Error, GetEnvironmentAccessListQueryParams, void>(
    getConfig('ng/api'),
    `/environmentsV2/list/access`,
    props,
    signal
  )

export interface GetEnvironmentListFilteredQueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  envIdentifiers?: string[]
}

export type GetEnvironmentListFilteredProps = Omit<
  GetProps<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListFilteredQueryParams, void>,
  'path'
>

/**
 * Gets environment list filtered by scoped env refs
 */
export const GetEnvironmentListFiltered = (props: GetEnvironmentListFilteredProps) => (
  <Get<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListFilteredQueryParams, void>
    path={`/environmentsV2/list/scoped`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentListFilteredProps = Omit<
  UseGetProps<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListFilteredQueryParams, void>,
  'path'
>

/**
 * Gets environment list filtered by scoped env refs
 */
export const useGetEnvironmentListFiltered = (props: UseGetEnvironmentListFilteredProps) =>
  useGet<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListFilteredQueryParams, void>(
    `/environmentsV2/list/scoped`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets environment list filtered by scoped env refs
 */
export const getEnvironmentListFilteredPromise = (
  props: GetUsingFetchProps<
    ResponsePageEnvironmentResponse,
    Failure | Error,
    GetEnvironmentListFilteredQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListFilteredQueryParams, void>(
    getConfig('ng/api'),
    `/environmentsV2/list/scoped`,
    props,
    signal
  )

export interface GetEnvironmentListV2QueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  envIdentifiers?: string[]
  sort?: string[]
  filterIdentifier?: string
  includeAllAccessibleAtScope?: boolean
  repoName?: string
}

export type GetEnvironmentListV2Props = Omit<
  MutateProps<
    ResponsePageEnvironmentResponse,
    Failure | Error,
    GetEnvironmentListV2QueryParams,
    EnvironmentFilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets environment list
 */
export const GetEnvironmentListV2 = (props: GetEnvironmentListV2Props) => (
  <Mutate<
    ResponsePageEnvironmentResponse,
    Failure | Error,
    GetEnvironmentListV2QueryParams,
    EnvironmentFilterPropertiesRequestBody,
    void
  >
    verb="POST"
    path={`/environmentsV2/listV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentListV2Props = Omit<
  UseMutateProps<
    ResponsePageEnvironmentResponse,
    Failure | Error,
    GetEnvironmentListV2QueryParams,
    EnvironmentFilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets environment list
 */
export const useGetEnvironmentListV2 = (props: UseGetEnvironmentListV2Props) =>
  useMutate<
    ResponsePageEnvironmentResponse,
    Failure | Error,
    GetEnvironmentListV2QueryParams,
    EnvironmentFilterPropertiesRequestBody,
    void
  >('POST', `/environmentsV2/listV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets environment list
 */
export const getEnvironmentListV2Promise = (
  props: MutateUsingFetchProps<
    ResponsePageEnvironmentResponse,
    Failure | Error,
    GetEnvironmentListV2QueryParams,
    EnvironmentFilterPropertiesRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageEnvironmentResponse,
    Failure | Error,
    GetEnvironmentListV2QueryParams,
    EnvironmentFilterPropertiesRequestBody,
    void
  >('POST', getConfig('ng/api'), `/environmentsV2/listV2`, props, signal)

export interface GetEnvironmentAccessListV2QueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  envIdentifiers?: string[]
  sort?: string[]
  filterIdentifier?: string
  includeAllAccessibleAtScope?: boolean
}

export type GetEnvironmentAccessListV2Props = Omit<
  MutateProps<
    ResponseListEnvironmentResponse,
    Failure | Error,
    GetEnvironmentAccessListV2QueryParams,
    EnvironmentFilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets environment access list
 */
export const GetEnvironmentAccessListV2 = (props: GetEnvironmentAccessListV2Props) => (
  <Mutate<
    ResponseListEnvironmentResponse,
    Failure | Error,
    GetEnvironmentAccessListV2QueryParams,
    EnvironmentFilterPropertiesRequestBody,
    void
  >
    verb="POST"
    path={`/environmentsV2/listV2/access`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentAccessListV2Props = Omit<
  UseMutateProps<
    ResponseListEnvironmentResponse,
    Failure | Error,
    GetEnvironmentAccessListV2QueryParams,
    EnvironmentFilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets environment access list
 */
export const useGetEnvironmentAccessListV2 = (props: UseGetEnvironmentAccessListV2Props) =>
  useMutate<
    ResponseListEnvironmentResponse,
    Failure | Error,
    GetEnvironmentAccessListV2QueryParams,
    EnvironmentFilterPropertiesRequestBody,
    void
  >('POST', `/environmentsV2/listV2/access`, { base: getConfig('ng/api'), ...props })

/**
 * Gets environment access list
 */
export const getEnvironmentAccessListV2Promise = (
  props: MutateUsingFetchProps<
    ResponseListEnvironmentResponse,
    Failure | Error,
    GetEnvironmentAccessListV2QueryParams,
    EnvironmentFilterPropertiesRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListEnvironmentResponse,
    Failure | Error,
    GetEnvironmentAccessListV2QueryParams,
    EnvironmentFilterPropertiesRequestBody,
    void
  >('POST', getConfig('ng/api'), `/environmentsV2/listV2/access`, props, signal)

export interface MergeEnvironmentInputsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface MergeEnvironmentInputsPathParams {
  environmentIdentifier: string
}

export type MergeEnvironmentInputsProps = Omit<
  MutateProps<
    ResponseEnvironmentInputsMergedResponseDto,
    Failure | Error,
    MergeEnvironmentInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeEnvironmentInputsPathParams
  >,
  'path' | 'verb'
> &
  MergeEnvironmentInputsPathParams

/**
 * This api merges old and new environment inputs YAML
 */
export const MergeEnvironmentInputs = ({ environmentIdentifier, ...props }: MergeEnvironmentInputsProps) => (
  <Mutate<
    ResponseEnvironmentInputsMergedResponseDto,
    Failure | Error,
    MergeEnvironmentInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeEnvironmentInputsPathParams
  >
    verb="POST"
    path={`/environmentsV2/mergeEnvironmentInputs/${environmentIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseMergeEnvironmentInputsProps = Omit<
  UseMutateProps<
    ResponseEnvironmentInputsMergedResponseDto,
    Failure | Error,
    MergeEnvironmentInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeEnvironmentInputsPathParams
  >,
  'path' | 'verb'
> &
  MergeEnvironmentInputsPathParams

/**
 * This api merges old and new environment inputs YAML
 */
export const useMergeEnvironmentInputs = ({ environmentIdentifier, ...props }: UseMergeEnvironmentInputsProps) =>
  useMutate<
    ResponseEnvironmentInputsMergedResponseDto,
    Failure | Error,
    MergeEnvironmentInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeEnvironmentInputsPathParams
  >(
    'POST',
    (paramsInPath: MergeEnvironmentInputsPathParams) =>
      `/environmentsV2/mergeEnvironmentInputs/${paramsInPath.environmentIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { environmentIdentifier }, ...props }
  )

/**
 * This api merges old and new environment inputs YAML
 */
export const mergeEnvironmentInputsPromise = (
  {
    environmentIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseEnvironmentInputsMergedResponseDto,
    Failure | Error,
    MergeEnvironmentInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeEnvironmentInputsPathParams
  > & { environmentIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentInputsMergedResponseDto,
    Failure | Error,
    MergeEnvironmentInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeEnvironmentInputsPathParams
  >('POST', getConfig('ng/api'), `/environmentsV2/mergeEnvironmentInputs/${environmentIdentifier}`, props, signal)

export interface GetEnvironmentInputsQueryParams {
  environmentIdentifier: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetEnvironmentInputsProps = Omit<
  GetProps<ResponseNGEntityTemplateResponseDTO, Failure | Error, GetEnvironmentInputsQueryParams, void>,
  'path'
>

/**
 * This api returns Environment inputs YAML
 */
export const GetEnvironmentInputs = (props: GetEnvironmentInputsProps) => (
  <Get<ResponseNGEntityTemplateResponseDTO, Failure | Error, GetEnvironmentInputsQueryParams, void>
    path={`/environmentsV2/runtimeInputs`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentInputsProps = Omit<
  UseGetProps<ResponseNGEntityTemplateResponseDTO, Failure | Error, GetEnvironmentInputsQueryParams, void>,
  'path'
>

/**
 * This api returns Environment inputs YAML
 */
export const useGetEnvironmentInputs = (props: UseGetEnvironmentInputsProps) =>
  useGet<ResponseNGEntityTemplateResponseDTO, Failure | Error, GetEnvironmentInputsQueryParams, void>(
    `/environmentsV2/runtimeInputs`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * This api returns Environment inputs YAML
 */
export const getEnvironmentInputsPromise = (
  props: GetUsingFetchProps<
    ResponseNGEntityTemplateResponseDTO,
    Failure | Error,
    GetEnvironmentInputsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNGEntityTemplateResponseDTO, Failure | Error, GetEnvironmentInputsQueryParams, void>(
    getConfig('ng/api'),
    `/environmentsV2/runtimeInputs`,
    props,
    signal
  )

export interface DeleteServiceOverrideQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  environmentIdentifier?: string
  serviceIdentifier?: string
}

export type DeleteServiceOverrideProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteServiceOverrideQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete a Service Override entity
 */
export const DeleteServiceOverride = (props: DeleteServiceOverrideProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteServiceOverrideQueryParams, void, void>
    verb="DELETE"
    path={`/environmentsV2/serviceOverrides`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteServiceOverrideProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteServiceOverrideQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete a Service Override entity
 */
export const useDeleteServiceOverride = (props: UseDeleteServiceOverrideProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteServiceOverrideQueryParams, void, void>(
    'DELETE',
    `/environmentsV2/serviceOverrides`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete a Service Override entity
 */
export const deleteServiceOverridePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteServiceOverrideQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteServiceOverrideQueryParams, void, void>(
    'DELETE',
    getConfig('ng/api'),
    `/environmentsV2/serviceOverrides`,
    props,
    signal
  )

export interface GetServiceOverridesListQueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  environmentIdentifier: string
  serviceIdentifier?: string
  sort?: string[]
}

export type GetServiceOverridesListProps = Omit<
  GetProps<ResponsePageServiceOverrideResponseDTO, Failure | Error, GetServiceOverridesListQueryParams, void>,
  'path'
>

/**
 * Gets Service Overrides list
 */
export const GetServiceOverridesList = (props: GetServiceOverridesListProps) => (
  <Get<ResponsePageServiceOverrideResponseDTO, Failure | Error, GetServiceOverridesListQueryParams, void>
    path={`/environmentsV2/serviceOverrides`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceOverridesListProps = Omit<
  UseGetProps<ResponsePageServiceOverrideResponseDTO, Failure | Error, GetServiceOverridesListQueryParams, void>,
  'path'
>

/**
 * Gets Service Overrides list
 */
export const useGetServiceOverridesList = (props: UseGetServiceOverridesListProps) =>
  useGet<ResponsePageServiceOverrideResponseDTO, Failure | Error, GetServiceOverridesListQueryParams, void>(
    `/environmentsV2/serviceOverrides`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Service Overrides list
 */
export const getServiceOverridesListPromise = (
  props: GetUsingFetchProps<
    ResponsePageServiceOverrideResponseDTO,
    Failure | Error,
    GetServiceOverridesListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageServiceOverrideResponseDTO, Failure | Error, GetServiceOverridesListQueryParams, void>(
    getConfig('ng/api'),
    `/environmentsV2/serviceOverrides`,
    props,
    signal
  )

export interface UpsertServiceOverrideQueryParams {
  accountIdentifier: string
}

export type UpsertServiceOverrideProps = Omit<
  MutateProps<
    ResponseServiceOverrideResponseDTO,
    Failure | Error,
    UpsertServiceOverrideQueryParams,
    ServiceOverrideRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * upsert a Service Override for an Environment
 */
export const UpsertServiceOverride = (props: UpsertServiceOverrideProps) => (
  <Mutate<
    ResponseServiceOverrideResponseDTO,
    Failure | Error,
    UpsertServiceOverrideQueryParams,
    ServiceOverrideRequestDTO,
    void
  >
    verb="POST"
    path={`/environmentsV2/serviceOverrides`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertServiceOverrideProps = Omit<
  UseMutateProps<
    ResponseServiceOverrideResponseDTO,
    Failure | Error,
    UpsertServiceOverrideQueryParams,
    ServiceOverrideRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * upsert a Service Override for an Environment
 */
export const useUpsertServiceOverride = (props: UseUpsertServiceOverrideProps) =>
  useMutate<
    ResponseServiceOverrideResponseDTO,
    Failure | Error,
    UpsertServiceOverrideQueryParams,
    ServiceOverrideRequestDTO,
    void
  >('POST', `/environmentsV2/serviceOverrides`, { base: getConfig('ng/api'), ...props })

/**
 * upsert a Service Override for an Environment
 */
export const upsertServiceOverridePromise = (
  props: MutateUsingFetchProps<
    ResponseServiceOverrideResponseDTO,
    Failure | Error,
    UpsertServiceOverrideQueryParams,
    ServiceOverrideRequestDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceOverrideResponseDTO,
    Failure | Error,
    UpsertServiceOverrideQueryParams,
    ServiceOverrideRequestDTO,
    void
  >('POST', getConfig('ng/api'), `/environmentsV2/serviceOverrides`, props, signal)

export interface GetServiceOverrideInputsQueryParams {
  environmentIdentifier: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceIdentifier: string
}

export type GetServiceOverrideInputsProps = Omit<
  GetProps<ResponseNGEntityTemplateResponseDTO, Failure | Error, GetServiceOverrideInputsQueryParams, void>,
  'path'
>

/**
 * This api returns Service Override inputs YAML
 */
export const GetServiceOverrideInputs = (props: GetServiceOverrideInputsProps) => (
  <Get<ResponseNGEntityTemplateResponseDTO, Failure | Error, GetServiceOverrideInputsQueryParams, void>
    path={`/environmentsV2/serviceOverrides/runtimeInputs`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceOverrideInputsProps = Omit<
  UseGetProps<ResponseNGEntityTemplateResponseDTO, Failure | Error, GetServiceOverrideInputsQueryParams, void>,
  'path'
>

/**
 * This api returns Service Override inputs YAML
 */
export const useGetServiceOverrideInputs = (props: UseGetServiceOverrideInputsProps) =>
  useGet<ResponseNGEntityTemplateResponseDTO, Failure | Error, GetServiceOverrideInputsQueryParams, void>(
    `/environmentsV2/serviceOverrides/runtimeInputs`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * This api returns Service Override inputs YAML
 */
export const getServiceOverrideInputsPromise = (
  props: GetUsingFetchProps<
    ResponseNGEntityTemplateResponseDTO,
    Failure | Error,
    GetServiceOverrideInputsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNGEntityTemplateResponseDTO, Failure | Error, GetServiceOverrideInputsQueryParams, void>(
    getConfig('ng/api'),
    `/environmentsV2/serviceOverrides/runtimeInputs`,
    props,
    signal
  )

export interface UpsertEnvironmentV2QueryParams {
  accountIdentifier: string
}

export type UpsertEnvironmentV2Props = Omit<
  MutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an environment by identifier
 */
export const UpsertEnvironmentV2 = (props: UpsertEnvironmentV2Props) => (
  <Mutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="PUT"
    path={`/environmentsV2/upsert`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertEnvironmentV2Props = Omit<
  UseMutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an environment by identifier
 */
export const useUpsertEnvironmentV2 = (props: UseUpsertEnvironmentV2Props) =>
  useMutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', `/environmentsV2/upsert`, { base: getConfig('ng/api'), ...props })

/**
 * Upsert an environment by identifier
 */
export const upsertEnvironmentV2Promise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/environmentsV2/upsert`, props, signal)

export interface GetEnvironmentsInputYamlAndServiceOverridesV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetEnvironmentsInputYamlAndServiceOverridesV2Props = Omit<
  MutateProps<
    ResponseEnvironmentYamlMetadataDTO,
    Failure | Error,
    GetEnvironmentsInputYamlAndServiceOverridesV2QueryParams,
    EnvironmentAndServiceOverridesMetadataInput,
    void
  >,
  'path' | 'verb'
>

/**
 * This api returns environments runtime input YAML and serviceOverrides Yaml
 */
export const GetEnvironmentsInputYamlAndServiceOverridesV2 = (
  props: GetEnvironmentsInputYamlAndServiceOverridesV2Props
) => (
  <Mutate<
    ResponseEnvironmentYamlMetadataDTO,
    Failure | Error,
    GetEnvironmentsInputYamlAndServiceOverridesV2QueryParams,
    EnvironmentAndServiceOverridesMetadataInput,
    void
  >
    verb="POST"
    path={`/environmentsV2/v2/env-service-override-metadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentsInputYamlAndServiceOverridesV2Props = Omit<
  UseMutateProps<
    ResponseEnvironmentYamlMetadataDTO,
    Failure | Error,
    GetEnvironmentsInputYamlAndServiceOverridesV2QueryParams,
    EnvironmentAndServiceOverridesMetadataInput,
    void
  >,
  'path' | 'verb'
>

/**
 * This api returns environments runtime input YAML and serviceOverrides Yaml
 */
export const useGetEnvironmentsInputYamlAndServiceOverridesV2 = (
  props: UseGetEnvironmentsInputYamlAndServiceOverridesV2Props
) =>
  useMutate<
    ResponseEnvironmentYamlMetadataDTO,
    Failure | Error,
    GetEnvironmentsInputYamlAndServiceOverridesV2QueryParams,
    EnvironmentAndServiceOverridesMetadataInput,
    void
  >('POST', `/environmentsV2/v2/env-service-override-metadata`, { base: getConfig('ng/api'), ...props })

/**
 * This api returns environments runtime input YAML and serviceOverrides Yaml
 */
export const getEnvironmentsInputYamlAndServiceOverridesV2Promise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentYamlMetadataDTO,
    Failure | Error,
    GetEnvironmentsInputYamlAndServiceOverridesV2QueryParams,
    EnvironmentAndServiceOverridesMetadataInput,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentYamlMetadataDTO,
    Failure | Error,
    GetEnvironmentsInputYamlAndServiceOverridesV2QueryParams,
    EnvironmentAndServiceOverridesMetadataInput,
    void
  >('POST', getConfig('ng/api'), `/environmentsV2/v2/env-service-override-metadata`, props, signal)

export interface DeleteEnvironmentV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  forceDelete?: boolean
}

export type DeleteEnvironmentV2Props = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete en environment by identifier
 */
export const DeleteEnvironmentV2 = (props: DeleteEnvironmentV2Props) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>
    verb="DELETE"
    path={`/environmentsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteEnvironmentV2Props = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete en environment by identifier
 */
export const useDeleteEnvironmentV2 = (props: UseDeleteEnvironmentV2Props) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>(
    'DELETE',
    `/environmentsV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete en environment by identifier
 */
export const deleteEnvironmentV2Promise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/environmentsV2`,
    props,
    signal
  )

export interface GetEnvironmentV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  deleted?: boolean
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  loadFromFallbackBranch?: boolean
}

export interface GetEnvironmentV2PathParams {
  environmentIdentifier: string
}

export type GetEnvironmentV2Props = Omit<
  GetProps<ResponseEnvironmentResponse, Failure | Error, GetEnvironmentV2QueryParams, GetEnvironmentV2PathParams>,
  'path'
> &
  GetEnvironmentV2PathParams

/**
 * Gets a Environment by identifier
 */
export const GetEnvironmentV2 = ({ environmentIdentifier, ...props }: GetEnvironmentV2Props) => (
  <Get<ResponseEnvironmentResponse, Failure | Error, GetEnvironmentV2QueryParams, GetEnvironmentV2PathParams>
    path={`/environmentsV2/${environmentIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentV2Props = Omit<
  UseGetProps<ResponseEnvironmentResponse, Failure | Error, GetEnvironmentV2QueryParams, GetEnvironmentV2PathParams>,
  'path'
> &
  GetEnvironmentV2PathParams

/**
 * Gets a Environment by identifier
 */
export const useGetEnvironmentV2 = ({ environmentIdentifier, ...props }: UseGetEnvironmentV2Props) =>
  useGet<ResponseEnvironmentResponse, Failure | Error, GetEnvironmentV2QueryParams, GetEnvironmentV2PathParams>(
    (paramsInPath: GetEnvironmentV2PathParams) => `/environmentsV2/${paramsInPath.environmentIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { environmentIdentifier }, ...props }
  )

/**
 * Gets a Environment by identifier
 */
export const getEnvironmentV2Promise = (
  {
    environmentIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    GetEnvironmentV2QueryParams,
    GetEnvironmentV2PathParams
  > & { environmentIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEnvironmentResponse, Failure | Error, GetEnvironmentV2QueryParams, GetEnvironmentV2PathParams>(
    getConfig('ng/api'),
    `/environmentsV2/${environmentIdentifier}`,
    props,
    signal
  )

export type DummyApiForSwaggerStageSchemaCheckProps = Omit<
  GetProps<ResponseStageElementConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking deployment stage
 */
export const DummyApiForSwaggerStageSchemaCheck = (props: DummyApiForSwaggerStageSchemaCheckProps) => (
  <Get<ResponseStageElementConfig, Failure | Error, void, void>
    path={`/executions/dummyApiForSwaggerStageSchemaCheck`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDummyApiForSwaggerStageSchemaCheckProps = Omit<
  UseGetProps<ResponseStageElementConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking deployment stage
 */
export const useDummyApiForSwaggerStageSchemaCheck = (props: UseDummyApiForSwaggerStageSchemaCheckProps) =>
  useGet<ResponseStageElementConfig, Failure | Error, void, void>(`/executions/dummyApiForSwaggerStageSchemaCheck`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * dummy api for checking deployment stage
 */
export const dummyApiForSwaggerStageSchemaCheckPromise = (
  props: GetUsingFetchProps<ResponseStageElementConfig, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseStageElementConfig, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/executions/dummyApiForSwaggerStageSchemaCheck`,
    props,
    signal
  )

export type DummyApiForSwaggerStepSchemaCheckProps = Omit<
  GetProps<ResponseStepElementConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking deployment stage
 */
export const DummyApiForSwaggerStepSchemaCheck = (props: DummyApiForSwaggerStepSchemaCheckProps) => (
  <Get<ResponseStepElementConfig, Failure | Error, void, void>
    path={`/executions/dummyApiForSwaggerStepSchemaCheck`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDummyApiForSwaggerStepSchemaCheckProps = Omit<
  UseGetProps<ResponseStepElementConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking deployment stage
 */
export const useDummyApiForSwaggerStepSchemaCheck = (props: UseDummyApiForSwaggerStepSchemaCheckProps) =>
  useGet<ResponseStepElementConfig, Failure | Error, void, void>(`/executions/dummyApiForSwaggerStepSchemaCheck`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * dummy api for checking deployment stage
 */
export const dummyApiForSwaggerStepSchemaCheckPromise = (
  props: GetUsingFetchProps<ResponseStepElementConfig, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseStepElementConfig, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/executions/dummyApiForSwaggerStepSchemaCheck`,
    props,
    signal
  )

export type GetDummyCDPipelineModuleInfoProps = Omit<
  GetProps<ResponseCDPipelineModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api
 */
export const GetDummyCDPipelineModuleInfo = (props: GetDummyCDPipelineModuleInfoProps) => (
  <Get<ResponseCDPipelineModuleInfo, Failure | Error, void, void>
    path={`/executions/dummyCDPipelineModuleInfo`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDummyCDPipelineModuleInfoProps = Omit<
  UseGetProps<ResponseCDPipelineModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api
 */
export const useGetDummyCDPipelineModuleInfo = (props: UseGetDummyCDPipelineModuleInfoProps) =>
  useGet<ResponseCDPipelineModuleInfo, Failure | Error, void, void>(`/executions/dummyCDPipelineModuleInfo`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * dummy api
 */
export const getDummyCDPipelineModuleInfoPromise = (
  props: GetUsingFetchProps<ResponseCDPipelineModuleInfo, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCDPipelineModuleInfo, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/executions/dummyCDPipelineModuleInfo`,
    props,
    signal
  )

export type GetDummyCDStageModuleInfoProps = Omit<
  GetProps<ResponseCDStageModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api
 */
export const GetDummyCDStageModuleInfo = (props: GetDummyCDStageModuleInfoProps) => (
  <Get<ResponseCDStageModuleInfo, Failure | Error, void, void>
    path={`/executions/dummyCDStageModuleInfo`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDummyCDStageModuleInfoProps = Omit<
  UseGetProps<ResponseCDStageModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api
 */
export const useGetDummyCDStageModuleInfo = (props: UseGetDummyCDStageModuleInfoProps) =>
  useGet<ResponseCDStageModuleInfo, Failure | Error, void, void>(`/executions/dummyCDStageModuleInfo`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * dummy api
 */
export const getDummyCDStageModuleInfoPromise = (
  props: GetUsingFetchProps<ResponseCDStageModuleInfo, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCDStageModuleInfo, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/executions/dummyCDStageModuleInfo`,
    props,
    signal
  )

export type GetExecutionStatusesProps = Omit<GetProps<ResponseListExecutionStatus, Failure | Error, void, void>, 'path'>

/**
 * Gets Execution Status list
 */
export const GetExecutionStatuses = (props: GetExecutionStatusesProps) => (
  <Get<ResponseListExecutionStatus, Failure | Error, void, void>
    path={`/executions/executionStatus`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetExecutionStatusesProps = Omit<
  UseGetProps<ResponseListExecutionStatus, Failure | Error, void, void>,
  'path'
>

/**
 * Gets Execution Status list
 */
export const useGetExecutionStatuses = (props: UseGetExecutionStatusesProps) =>
  useGet<ResponseListExecutionStatus, Failure | Error, void, void>(`/executions/executionStatus`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Execution Status list
 */
export const getExecutionStatusesPromise = (
  props: GetUsingFetchProps<ResponseListExecutionStatus, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListExecutionStatus, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/executions/executionStatus`,
    props,
    signal
  )

export interface SaveFeedbackQueryParams {
  accountIdentifier?: string
}

export type SaveFeedbackProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, SaveFeedbackQueryParams, FeedbackFormDTO, void>,
  'path' | 'verb'
>

/**
 * Saves Feedback
 */
export const SaveFeedback = (props: SaveFeedbackProps) => (
  <Mutate<ResponseBoolean, Failure | Error, SaveFeedbackQueryParams, FeedbackFormDTO, void>
    verb="POST"
    path={`/feedback`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSaveFeedbackProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, SaveFeedbackQueryParams, FeedbackFormDTO, void>,
  'path' | 'verb'
>

/**
 * Saves Feedback
 */
export const useSaveFeedback = (props: UseSaveFeedbackProps) =>
  useMutate<ResponseBoolean, Failure | Error, SaveFeedbackQueryParams, FeedbackFormDTO, void>('POST', `/feedback`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Saves Feedback
 */
export const saveFeedbackPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, SaveFeedbackQueryParams, FeedbackFormDTO, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, SaveFeedbackQueryParams, FeedbackFormDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/feedback`,
    props,
    signal
  )

export interface ListFilesAndFoldersQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifiers?: string[]
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type ListFilesAndFoldersProps = Omit<
  GetProps<ResponsePageFileDTO, Failure | Error, ListFilesAndFoldersQueryParams, void>,
  'path'
>

/**
 * List Files and Folders metadata
 */
export const ListFilesAndFolders = (props: ListFilesAndFoldersProps) => (
  <Get<ResponsePageFileDTO, Failure | Error, ListFilesAndFoldersQueryParams, void>
    path={`/file-store`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListFilesAndFoldersProps = Omit<
  UseGetProps<ResponsePageFileDTO, Failure | Error, ListFilesAndFoldersQueryParams, void>,
  'path'
>

/**
 * List Files and Folders metadata
 */
export const useListFilesAndFolders = (props: UseListFilesAndFoldersProps) =>
  useGet<ResponsePageFileDTO, Failure | Error, ListFilesAndFoldersQueryParams, void>(`/file-store`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * List Files and Folders metadata
 */
export const listFilesAndFoldersPromise = (
  props: GetUsingFetchProps<ResponsePageFileDTO, Failure | Error, ListFilesAndFoldersQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageFileDTO, Failure | Error, ListFilesAndFoldersQueryParams, void>(
    getConfig('ng/api'),
    `/file-store`,
    props,
    signal
  )

export interface CreateQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateProps = Omit<
  MutateProps<ResponseFileDTO, Failure | Error, CreateQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create Folder or File including content
 */
export const Create = (props: CreateProps) => (
  <Mutate<ResponseFileDTO, Failure | Error, CreateQueryParams, void, void>
    verb="POST"
    path={`/file-store`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateProps = Omit<
  UseMutateProps<ResponseFileDTO, Failure | Error, CreateQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create Folder or File including content
 */
export const useCreate = (props: UseCreateProps) =>
  useMutate<ResponseFileDTO, Failure | Error, CreateQueryParams, void, void>('POST', `/file-store`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create Folder or File including content
 */
export const createPromise = (
  props: MutateUsingFetchProps<ResponseFileDTO, Failure | Error, CreateQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFileDTO, Failure | Error, CreateQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/file-store`,
    props,
    signal
  )

export interface GetCreatedByListQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetCreatedByListProps = Omit<
  GetProps<ResponseSetEmbeddedUserDetailsDTO, Failure | Error, GetCreatedByListQueryParams, void>,
  'path'
>

/**
 * Get list of created by user details
 */
export const GetCreatedByList = (props: GetCreatedByListProps) => (
  <Get<ResponseSetEmbeddedUserDetailsDTO, Failure | Error, GetCreatedByListQueryParams, void>
    path={`/file-store/files/createdBy`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCreatedByListProps = Omit<
  UseGetProps<ResponseSetEmbeddedUserDetailsDTO, Failure | Error, GetCreatedByListQueryParams, void>,
  'path'
>

/**
 * Get list of created by user details
 */
export const useGetCreatedByList = (props: UseGetCreatedByListProps) =>
  useGet<ResponseSetEmbeddedUserDetailsDTO, Failure | Error, GetCreatedByListQueryParams, void>(
    `/file-store/files/createdBy`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get list of created by user details
 */
export const getCreatedByListPromise = (
  props: GetUsingFetchProps<ResponseSetEmbeddedUserDetailsDTO, Failure | Error, GetCreatedByListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSetEmbeddedUserDetailsDTO, Failure | Error, GetCreatedByListQueryParams, void>(
    getConfig('ng/api'),
    `/file-store/files/createdBy`,
    props,
    signal
  )

export interface ListFilesWithFilterQueryParams {
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  filterIdentifier?: string
  searchTerm?: string
}

export type ListFilesWithFilterProps = Omit<
  MutateProps<ResponsePageFileDTO, Failure | Error, ListFilesWithFilterQueryParams, FilesFilterProperties, void>,
  'path' | 'verb'
>

/**
 * Get filtered list of Files or Folders
 */
export const ListFilesWithFilter = (props: ListFilesWithFilterProps) => (
  <Mutate<ResponsePageFileDTO, Failure | Error, ListFilesWithFilterQueryParams, FilesFilterProperties, void>
    verb="POST"
    path={`/file-store/files/filter`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListFilesWithFilterProps = Omit<
  UseMutateProps<ResponsePageFileDTO, Failure | Error, ListFilesWithFilterQueryParams, FilesFilterProperties, void>,
  'path' | 'verb'
>

/**
 * Get filtered list of Files or Folders
 */
export const useListFilesWithFilter = (props: UseListFilesWithFilterProps) =>
  useMutate<ResponsePageFileDTO, Failure | Error, ListFilesWithFilterQueryParams, FilesFilterProperties, void>(
    'POST',
    `/file-store/files/filter`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get filtered list of Files or Folders
 */
export const listFilesWithFilterPromise = (
  props: MutateUsingFetchProps<
    ResponsePageFileDTO,
    Failure | Error,
    ListFilesWithFilterQueryParams,
    FilesFilterProperties,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponsePageFileDTO, Failure | Error, ListFilesWithFilterQueryParams, FilesFilterProperties, void>(
    'POST',
    getConfig('ng/api'),
    `/file-store/files/filter`,
    props,
    signal
  )

export interface DownloadFileQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface DownloadFilePathParams {
  identifier: string
}

export type DownloadFileProps = Omit<
  GetProps<void, Failure | Error, DownloadFileQueryParams, DownloadFilePathParams>,
  'path'
> &
  DownloadFilePathParams

/**
 * Download File content
 */
export const DownloadFile = ({ identifier, ...props }: DownloadFileProps) => (
  <Get<void, Failure | Error, DownloadFileQueryParams, DownloadFilePathParams>
    path={`/file-store/files/${identifier}/download`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDownloadFileProps = Omit<
  UseGetProps<void, Failure | Error, DownloadFileQueryParams, DownloadFilePathParams>,
  'path'
> &
  DownloadFilePathParams

/**
 * Download File content
 */
export const useDownloadFile = ({ identifier, ...props }: UseDownloadFileProps) =>
  useGet<void, Failure | Error, DownloadFileQueryParams, DownloadFilePathParams>(
    (paramsInPath: DownloadFilePathParams) => `/file-store/files/${paramsInPath.identifier}/download`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Download File content
 */
export const downloadFilePromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<void, Failure | Error, DownloadFileQueryParams, DownloadFilePathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, Failure | Error, DownloadFileQueryParams, DownloadFilePathParams>(
    getConfig('ng/api'),
    `/file-store/files/${identifier}/download`,
    props,
    signal
  )

export interface GetFileContentUsingScopedFilePathQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetFileContentUsingScopedFilePathPathParams {
  scopedFilePath: string
}

export type GetFileContentUsingScopedFilePathProps = Omit<
  GetProps<
    ResponseString,
    Failure | Error,
    GetFileContentUsingScopedFilePathQueryParams,
    GetFileContentUsingScopedFilePathPathParams
  >,
  'path'
> &
  GetFileContentUsingScopedFilePathPathParams

/**
 * Get file content as string using encoded scopedFilePath
 */
export const GetFileContentUsingScopedFilePath = ({
  scopedFilePath,
  ...props
}: GetFileContentUsingScopedFilePathProps) => (
  <Get<
    ResponseString,
    Failure | Error,
    GetFileContentUsingScopedFilePathQueryParams,
    GetFileContentUsingScopedFilePathPathParams
  >
    path={`/file-store/files/${scopedFilePath}/content`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFileContentUsingScopedFilePathProps = Omit<
  UseGetProps<
    ResponseString,
    Failure | Error,
    GetFileContentUsingScopedFilePathQueryParams,
    GetFileContentUsingScopedFilePathPathParams
  >,
  'path'
> &
  GetFileContentUsingScopedFilePathPathParams

/**
 * Get file content as string using encoded scopedFilePath
 */
export const useGetFileContentUsingScopedFilePath = ({
  scopedFilePath,
  ...props
}: UseGetFileContentUsingScopedFilePathProps) =>
  useGet<
    ResponseString,
    Failure | Error,
    GetFileContentUsingScopedFilePathQueryParams,
    GetFileContentUsingScopedFilePathPathParams
  >(
    (paramsInPath: GetFileContentUsingScopedFilePathPathParams) =>
      `/file-store/files/${paramsInPath.scopedFilePath}/content`,
    { base: getConfig('ng/api'), pathParams: { scopedFilePath }, ...props }
  )

/**
 * Get file content as string using encoded scopedFilePath
 */
export const getFileContentUsingScopedFilePathPromise = (
  {
    scopedFilePath,
    ...props
  }: GetUsingFetchProps<
    ResponseString,
    Failure | Error,
    GetFileContentUsingScopedFilePathQueryParams,
    GetFileContentUsingScopedFilePathPathParams
  > & { scopedFilePath: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseString,
    Failure | Error,
    GetFileContentUsingScopedFilePathQueryParams,
    GetFileContentUsingScopedFilePathPathParams
  >(getConfig('ng/api'), `/file-store/files/${scopedFilePath}/content`, props, signal)

export interface GetFileStoreNodesOnPathQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  path: string
  fileUsage?: 'MANIFEST_FILE' | 'CONFIG' | 'SCRIPT'
}

export type GetFileStoreNodesOnPathProps = Omit<
  GetProps<ResponseFolderNodeDTO, Failure | Error, GetFileStoreNodesOnPathQueryParams, void>,
  'path'
>

/**
 * Get file store nodes on path
 */
export const GetFileStoreNodesOnPath = (props: GetFileStoreNodesOnPathProps) => (
  <Get<ResponseFolderNodeDTO, Failure | Error, GetFileStoreNodesOnPathQueryParams, void>
    path={`/file-store/folder`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFileStoreNodesOnPathProps = Omit<
  UseGetProps<ResponseFolderNodeDTO, Failure | Error, GetFileStoreNodesOnPathQueryParams, void>,
  'path'
>

/**
 * Get file store nodes on path
 */
export const useGetFileStoreNodesOnPath = (props: UseGetFileStoreNodesOnPathProps) =>
  useGet<ResponseFolderNodeDTO, Failure | Error, GetFileStoreNodesOnPathQueryParams, void>(`/file-store/folder`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get file store nodes on path
 */
export const getFileStoreNodesOnPathPromise = (
  props: GetUsingFetchProps<ResponseFolderNodeDTO, Failure | Error, GetFileStoreNodesOnPathQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseFolderNodeDTO, Failure | Error, GetFileStoreNodesOnPathQueryParams, void>(
    getConfig('ng/api'),
    `/file-store/folder`,
    props,
    signal
  )

export interface GetFolderNodesQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  fileUsage?: 'MANIFEST_FILE' | 'CONFIG' | 'SCRIPT'
}

export type GetFolderNodesProps = Omit<
  MutateProps<ResponseFolderNodeDTO, Failure | Error, GetFolderNodesQueryParams, FolderNodeDTO, void>,
  'path' | 'verb'
>

/**
 * Get folder nodes at first level, not including sub-nodes
 */
export const GetFolderNodes = (props: GetFolderNodesProps) => (
  <Mutate<ResponseFolderNodeDTO, Failure | Error, GetFolderNodesQueryParams, FolderNodeDTO, void>
    verb="POST"
    path={`/file-store/folder`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFolderNodesProps = Omit<
  UseMutateProps<ResponseFolderNodeDTO, Failure | Error, GetFolderNodesQueryParams, FolderNodeDTO, void>,
  'path' | 'verb'
>

/**
 * Get folder nodes at first level, not including sub-nodes
 */
export const useGetFolderNodes = (props: UseGetFolderNodesProps) =>
  useMutate<ResponseFolderNodeDTO, Failure | Error, GetFolderNodesQueryParams, FolderNodeDTO, void>(
    'POST',
    `/file-store/folder`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get folder nodes at first level, not including sub-nodes
 */
export const getFolderNodesPromise = (
  props: MutateUsingFetchProps<ResponseFolderNodeDTO, Failure | Error, GetFolderNodesQueryParams, FolderNodeDTO, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFolderNodeDTO, Failure | Error, GetFolderNodesQueryParams, FolderNodeDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/file-store/folder`,
    props,
    signal
  )

export interface GetEntityTypesQueryParams {
  accountIdentifier?: string
}

export type GetEntityTypesProps = Omit<
  GetProps<ResponseListEntityType, Failure | Error, GetEntityTypesQueryParams, void>,
  'path'
>

/**
 * Get the list of supported entity types for files
 */
export const GetEntityTypes = (props: GetEntityTypesProps) => (
  <Get<ResponseListEntityType, Failure | Error, GetEntityTypesQueryParams, void>
    path={`/file-store/supported-entity-types`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEntityTypesProps = Omit<
  UseGetProps<ResponseListEntityType, Failure | Error, GetEntityTypesQueryParams, void>,
  'path'
>

/**
 * Get the list of supported entity types for files
 */
export const useGetEntityTypes = (props: UseGetEntityTypesProps) =>
  useGet<ResponseListEntityType, Failure | Error, GetEntityTypesQueryParams, void>(
    `/file-store/supported-entity-types`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get the list of supported entity types for files
 */
export const getEntityTypesPromise = (
  props: GetUsingFetchProps<ResponseListEntityType, Failure | Error, GetEntityTypesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListEntityType, Failure | Error, GetEntityTypesQueryParams, void>(
    getConfig('ng/api'),
    `/file-store/supported-entity-types`,
    props,
    signal
  )

export interface CreateViaYAMLQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateViaYAMLProps = Omit<
  MutateProps<ResponseFileDTO, Failure | Error, CreateViaYAMLQueryParams, FileStoreRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create File or Folder metadata via YAML
 */
export const CreateViaYAML = (props: CreateViaYAMLProps) => (
  <Mutate<ResponseFileDTO, Failure | Error, CreateViaYAMLQueryParams, FileStoreRequestRequestBody, void>
    verb="POST"
    path={`/file-store/yaml`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateViaYAMLProps = Omit<
  UseMutateProps<ResponseFileDTO, Failure | Error, CreateViaYAMLQueryParams, FileStoreRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create File or Folder metadata via YAML
 */
export const useCreateViaYAML = (props: UseCreateViaYAMLProps) =>
  useMutate<ResponseFileDTO, Failure | Error, CreateViaYAMLQueryParams, FileStoreRequestRequestBody, void>(
    'POST',
    `/file-store/yaml`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create File or Folder metadata via YAML
 */
export const createViaYAMLPromise = (
  props: MutateUsingFetchProps<
    ResponseFileDTO,
    Failure | Error,
    CreateViaYAMLQueryParams,
    FileStoreRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFileDTO, Failure | Error, CreateViaYAMLQueryParams, FileStoreRequestRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/file-store/yaml`,
    props,
    signal
  )

export interface UpdateViaYAMLQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface UpdateViaYAMLPathParams {
  identifier: string
}

export type UpdateViaYAMLProps = Omit<
  MutateProps<
    ResponseFileDTO,
    Failure | Error,
    UpdateViaYAMLQueryParams,
    FileStoreRequestRequestBody,
    UpdateViaYAMLPathParams
  >,
  'path' | 'verb'
> &
  UpdateViaYAMLPathParams

/**
 * Update File or Folder metadata via YAML
 */
export const UpdateViaYAML = ({ identifier, ...props }: UpdateViaYAMLProps) => (
  <Mutate<
    ResponseFileDTO,
    Failure | Error,
    UpdateViaYAMLQueryParams,
    FileStoreRequestRequestBody,
    UpdateViaYAMLPathParams
  >
    verb="PUT"
    path={`/file-store/yaml/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateViaYAMLProps = Omit<
  UseMutateProps<
    ResponseFileDTO,
    Failure | Error,
    UpdateViaYAMLQueryParams,
    FileStoreRequestRequestBody,
    UpdateViaYAMLPathParams
  >,
  'path' | 'verb'
> &
  UpdateViaYAMLPathParams

/**
 * Update File or Folder metadata via YAML
 */
export const useUpdateViaYAML = ({ identifier, ...props }: UseUpdateViaYAMLProps) =>
  useMutate<
    ResponseFileDTO,
    Failure | Error,
    UpdateViaYAMLQueryParams,
    FileStoreRequestRequestBody,
    UpdateViaYAMLPathParams
  >('PUT', (paramsInPath: UpdateViaYAMLPathParams) => `/file-store/yaml/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update File or Folder metadata via YAML
 */
export const updateViaYAMLPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseFileDTO,
    Failure | Error,
    UpdateViaYAMLQueryParams,
    FileStoreRequestRequestBody,
    UpdateViaYAMLPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseFileDTO,
    Failure | Error,
    UpdateViaYAMLQueryParams,
    FileStoreRequestRequestBody,
    UpdateViaYAMLPathParams
  >('PUT', getConfig('ng/api'), `/file-store/yaml/${identifier}`, props, signal)

export interface DeleteFileQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  forceDelete?: boolean
}

export type DeleteFileProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteFileQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete File or Folder by identifier
 */
export const DeleteFile = (props: DeleteFileProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteFileQueryParams, string, void>
    verb="DELETE"
    path={`/file-store`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteFileProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteFileQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete File or Folder by identifier
 */
export const useDeleteFile = (props: UseDeleteFileProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteFileQueryParams, string, void>('DELETE', `/file-store`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete File or Folder by identifier
 */
export const deleteFilePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteFileQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteFileQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/file-store`,
    props,
    signal
  )

export interface GetFileQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetFilePathParams {
  identifier: string
}

export type GetFileProps = Omit<
  GetProps<ResponseFileDTO, Failure | Error, GetFileQueryParams, GetFilePathParams>,
  'path'
> &
  GetFilePathParams

/**
 * Get the Folder or File metadata
 */
export const GetFile = ({ identifier, ...props }: GetFileProps) => (
  <Get<ResponseFileDTO, Failure | Error, GetFileQueryParams, GetFilePathParams>
    path={`/file-store/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFileProps = Omit<
  UseGetProps<ResponseFileDTO, Failure | Error, GetFileQueryParams, GetFilePathParams>,
  'path'
> &
  GetFilePathParams

/**
 * Get the Folder or File metadata
 */
export const useGetFile = ({ identifier, ...props }: UseGetFileProps) =>
  useGet<ResponseFileDTO, Failure | Error, GetFileQueryParams, GetFilePathParams>(
    (paramsInPath: GetFilePathParams) => `/file-store/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get the Folder or File metadata
 */
export const getFilePromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseFileDTO, Failure | Error, GetFileQueryParams, GetFilePathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseFileDTO, Failure | Error, GetFileQueryParams, GetFilePathParams>(
    getConfig('ng/api'),
    `/file-store/${identifier}`,
    props,
    signal
  )

export interface UpdateQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface UpdatePathParams {
  identifier: string
}

export type UpdateProps = Omit<
  MutateProps<ResponseFileDTO, Failure | Error, UpdateQueryParams, void, UpdatePathParams>,
  'path' | 'verb'
> &
  UpdatePathParams

/**
 * Update Folder or File including content
 */
export const Update = ({ identifier, ...props }: UpdateProps) => (
  <Mutate<ResponseFileDTO, Failure | Error, UpdateQueryParams, void, UpdatePathParams>
    verb="PUT"
    path={`/file-store/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateProps = Omit<
  UseMutateProps<ResponseFileDTO, Failure | Error, UpdateQueryParams, void, UpdatePathParams>,
  'path' | 'verb'
> &
  UpdatePathParams

/**
 * Update Folder or File including content
 */
export const useUpdate = ({ identifier, ...props }: UseUpdateProps) =>
  useMutate<ResponseFileDTO, Failure | Error, UpdateQueryParams, void, UpdatePathParams>(
    'PUT',
    (paramsInPath: UpdatePathParams) => `/file-store/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update Folder or File including content
 */
export const updatePromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<ResponseFileDTO, Failure | Error, UpdateQueryParams, void, UpdatePathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFileDTO, Failure | Error, UpdateQueryParams, void, UpdatePathParams>(
    'PUT',
    getConfig('ng/api'),
    `/file-store/${identifier}`,
    props,
    signal
  )

export interface GetReferencedByQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  entityType?:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  searchTerm?: string
}

export interface GetReferencedByPathParams {
  identifier: string
}

export type GetReferencedByProps = Omit<
  GetProps<ResponsePageEntitySetupUsageDTO, Failure | Error, GetReferencedByQueryParams, GetReferencedByPathParams>,
  'path'
> &
  GetReferencedByPathParams

/**
 * Get list of entities where file is referenced by queried entity type
 */
export const GetReferencedBy = ({ identifier, ...props }: GetReferencedByProps) => (
  <Get<ResponsePageEntitySetupUsageDTO, Failure | Error, GetReferencedByQueryParams, GetReferencedByPathParams>
    path={`/file-store/${identifier}/referenced-by`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetReferencedByProps = Omit<
  UseGetProps<ResponsePageEntitySetupUsageDTO, Failure | Error, GetReferencedByQueryParams, GetReferencedByPathParams>,
  'path'
> &
  GetReferencedByPathParams

/**
 * Get list of entities where file is referenced by queried entity type
 */
export const useGetReferencedBy = ({ identifier, ...props }: UseGetReferencedByProps) =>
  useGet<ResponsePageEntitySetupUsageDTO, Failure | Error, GetReferencedByQueryParams, GetReferencedByPathParams>(
    (paramsInPath: GetReferencedByPathParams) => `/file-store/${paramsInPath.identifier}/referenced-by`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get list of entities where file is referenced by queried entity type
 */
export const getReferencedByPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponsePageEntitySetupUsageDTO,
    Failure | Error,
    GetReferencedByQueryParams,
    GetReferencedByPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageEntitySetupUsageDTO,
    Failure | Error,
    GetReferencedByQueryParams,
    GetReferencedByPathParams
  >(getConfig('ng/api'), `/file-store/${identifier}/referenced-by`, props, signal)

export interface GetFilterListQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
    | 'Trigger'
    | 'EnvironmentGroup'
    | 'FileStore'
    | 'CCMRecommendation'
    | 'Anomaly'
    | 'Environment'
    | 'RuleExecution'
    | 'Override'
    | 'InputSet'
}

export type GetFilterListProps = Omit<
  GetProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  'path'
>

/**
 * Get Filter
 */
export const GetFilterList = (props: GetFilterListProps) => (
  <Get<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>
    path={`/filters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFilterListProps = Omit<
  UseGetProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  'path'
>

/**
 * Get Filter
 */
export const useGetFilterList = (props: UseGetFilterListProps) =>
  useGet<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>(`/filters`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Filter
 */
export const getFilterListPromise = (
  props: GetUsingFetchProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>(
    getConfig('ng/api'),
    `/filters`,
    props,
    signal
  )

export interface PostFilterQueryParams {
  accountIdentifier: string
}

export type PostFilterProps = Omit<
  MutateProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Filter
 */
export const PostFilter = (props: PostFilterProps) => (
  <Mutate<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>
    verb="POST"
    path={`/filters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostFilterProps = Omit<
  UseMutateProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Filter
 */
export const usePostFilter = (props: UsePostFilterProps) =>
  useMutate<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>('POST', `/filters`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create a Filter
 */
export const postFilterPromise = (
  props: MutateUsingFetchProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/filters`,
    props,
    signal
  )

export interface UpdateFilterQueryParams {
  accountIdentifier: string
}

export type UpdateFilterProps = Omit<
  MutateProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Filter
 */
export const UpdateFilter = (props: UpdateFilterProps) => (
  <Mutate<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>
    verb="PUT"
    path={`/filters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateFilterProps = Omit<
  UseMutateProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Filter
 */
export const useUpdateFilter = (props: UseUpdateFilterProps) =>
  useMutate<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>(
    'PUT',
    `/filters`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update a Filter
 */
export const updateFilterPromise = (
  props: MutateUsingFetchProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/filters`,
    props,
    signal
  )

export interface DeleteFilterQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
    | 'Trigger'
    | 'EnvironmentGroup'
    | 'FileStore'
    | 'CCMRecommendation'
    | 'Anomaly'
    | 'Environment'
    | 'RuleExecution'
    | 'Override'
    | 'InputSet'
}

export type DeleteFilterProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a filter
 */
export const DeleteFilter = (props: DeleteFilterProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>
    verb="DELETE"
    path={`/filters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteFilterProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a filter
 */
export const useDeleteFilter = (props: UseDeleteFilterProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>('DELETE', `/filters`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a filter
 */
export const deleteFilterPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/filters`,
    props,
    signal
  )

export interface GetFilterQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
    | 'Trigger'
    | 'EnvironmentGroup'
    | 'FileStore'
    | 'CCMRecommendation'
    | 'Anomaly'
    | 'Environment'
    | 'RuleExecution'
    | 'Override'
    | 'InputSet'
}

export interface GetFilterPathParams {
  identifier: string
}

export type GetFilterProps = Omit<
  GetProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>,
  'path'
> &
  GetFilterPathParams

/**
 * Get Filter
 */
export const GetFilter = ({ identifier, ...props }: GetFilterProps) => (
  <Get<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>
    path={`/filters/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFilterProps = Omit<
  UseGetProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>,
  'path'
> &
  GetFilterPathParams

/**
 * Get Filter
 */
export const useGetFilter = ({ identifier, ...props }: UseGetFilterProps) =>
  useGet<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>(
    (paramsInPath: GetFilterPathParams) => `/filters/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Filter
 */
export const getFilterPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>(
    getConfig('ng/api'),
    `/filters/${identifier}`,
    props,
    signal
  )

export interface CreateFreezeQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateFreezeProps = Omit<
  MutateProps<
    ResponseFreezeResponse,
    Failure | Error,
    CreateFreezeQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates a Freeze
 */
export const CreateFreeze = (props: CreateFreezeProps) => (
  <Mutate<ResponseFreezeResponse, Failure | Error, CreateFreezeQueryParams, ListTagsForAMIArtifactBodyRequestBody, void>
    verb="POST"
    path={`/freeze`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateFreezeProps = Omit<
  UseMutateProps<
    ResponseFreezeResponse,
    Failure | Error,
    CreateFreezeQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates a Freeze
 */
export const useCreateFreeze = (props: UseCreateFreezeProps) =>
  useMutate<
    ResponseFreezeResponse,
    Failure | Error,
    CreateFreezeQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/freeze`, { base: getConfig('ng/api'), ...props })

/**
 * Creates a Freeze
 */
export const createFreezePromise = (
  props: MutateUsingFetchProps<
    ResponseFreezeResponse,
    Failure | Error,
    CreateFreezeQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseFreezeResponse,
    Failure | Error,
    CreateFreezeQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/freeze`, props, signal)

export interface DeleteManyFreezesQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteManyFreezesProps = Omit<
  MutateProps<
    ResponseFreezeResponseWrapperDTO,
    Failure | Error,
    DeleteManyFreezesQueryParams,
    DeleteManyFreezesBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Deletes many Freezes
 */
export const DeleteManyFreezes = (props: DeleteManyFreezesProps) => (
  <Mutate<
    ResponseFreezeResponseWrapperDTO,
    Failure | Error,
    DeleteManyFreezesQueryParams,
    DeleteManyFreezesBodyRequestBody,
    void
  >
    verb="POST"
    path={`/freeze/delete`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteManyFreezesProps = Omit<
  UseMutateProps<
    ResponseFreezeResponseWrapperDTO,
    Failure | Error,
    DeleteManyFreezesQueryParams,
    DeleteManyFreezesBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Deletes many Freezes
 */
export const useDeleteManyFreezes = (props: UseDeleteManyFreezesProps) =>
  useMutate<
    ResponseFreezeResponseWrapperDTO,
    Failure | Error,
    DeleteManyFreezesQueryParams,
    DeleteManyFreezesBodyRequestBody,
    void
  >('POST', `/freeze/delete`, { base: getConfig('ng/api'), ...props })

/**
 * Deletes many Freezes
 */
export const deleteManyFreezesPromise = (
  props: MutateUsingFetchProps<
    ResponseFreezeResponseWrapperDTO,
    Failure | Error,
    DeleteManyFreezesQueryParams,
    DeleteManyFreezesBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseFreezeResponseWrapperDTO,
    Failure | Error,
    DeleteManyFreezesQueryParams,
    DeleteManyFreezesBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/freeze/delete`, props, signal)

export interface IsGlobalFreezeActiveQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type IsGlobalFreezeActiveProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, IsGlobalFreezeActiveQueryParams, void>,
  'path'
>

/**
 * Get if global freeze is Active
 */
export const IsGlobalFreezeActive = (props: IsGlobalFreezeActiveProps) => (
  <Get<ResponseBoolean, Failure | Error, IsGlobalFreezeActiveQueryParams, void>
    path={`/freeze/evaluate/isGlobalFreezeActive`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseIsGlobalFreezeActiveProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, IsGlobalFreezeActiveQueryParams, void>,
  'path'
>

/**
 * Get if global freeze is Active
 */
export const useIsGlobalFreezeActive = (props: UseIsGlobalFreezeActiveProps) =>
  useGet<ResponseBoolean, Failure | Error, IsGlobalFreezeActiveQueryParams, void>(
    `/freeze/evaluate/isGlobalFreezeActive`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get if global freeze is Active
 */
export const isGlobalFreezeActivePromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, IsGlobalFreezeActiveQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, IsGlobalFreezeActiveQueryParams, void>(
    getConfig('ng/api'),
    `/freeze/evaluate/isGlobalFreezeActive`,
    props,
    signal
  )

export interface ShouldDisableDeploymentQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
}

export type ShouldDisableDeploymentProps = Omit<
  GetProps<ResponseShouldDisableDeploymentFreezeResponseDTO, Failure | Error, ShouldDisableDeploymentQueryParams, void>,
  'path'
>

/**
 * If to disable run button for deployment
 */
export const ShouldDisableDeployment = (props: ShouldDisableDeploymentProps) => (
  <Get<ResponseShouldDisableDeploymentFreezeResponseDTO, Failure | Error, ShouldDisableDeploymentQueryParams, void>
    path={`/freeze/evaluate/shouldDisableDeployment`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseShouldDisableDeploymentProps = Omit<
  UseGetProps<
    ResponseShouldDisableDeploymentFreezeResponseDTO,
    Failure | Error,
    ShouldDisableDeploymentQueryParams,
    void
  >,
  'path'
>

/**
 * If to disable run button for deployment
 */
export const useShouldDisableDeployment = (props: UseShouldDisableDeploymentProps) =>
  useGet<ResponseShouldDisableDeploymentFreezeResponseDTO, Failure | Error, ShouldDisableDeploymentQueryParams, void>(
    `/freeze/evaluate/shouldDisableDeployment`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * If to disable run button for deployment
 */
export const shouldDisableDeploymentPromise = (
  props: GetUsingFetchProps<
    ResponseShouldDisableDeploymentFreezeResponseDTO,
    Failure | Error,
    ShouldDisableDeploymentQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseShouldDisableDeploymentFreezeResponseDTO,
    Failure | Error,
    ShouldDisableDeploymentQueryParams,
    void
  >(getConfig('ng/api'), `/freeze/evaluate/shouldDisableDeployment`, props, signal)

export interface GetFrozenExecutionDetailsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  planExecutionId: string
}

export type GetFrozenExecutionDetailsProps = Omit<
  GetProps<ResponseFrozenExecutionDetails, Failure | Error, GetFrozenExecutionDetailsQueryParams, void>,
  'path'
>

/**
 * Get list of freeze acted on a frozen execution
 */
export const GetFrozenExecutionDetails = (props: GetFrozenExecutionDetailsProps) => (
  <Get<ResponseFrozenExecutionDetails, Failure | Error, GetFrozenExecutionDetailsQueryParams, void>
    path={`/freeze/getFrozenExecutionDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFrozenExecutionDetailsProps = Omit<
  UseGetProps<ResponseFrozenExecutionDetails, Failure | Error, GetFrozenExecutionDetailsQueryParams, void>,
  'path'
>

/**
 * Get list of freeze acted on a frozen execution
 */
export const useGetFrozenExecutionDetails = (props: UseGetFrozenExecutionDetailsProps) =>
  useGet<ResponseFrozenExecutionDetails, Failure | Error, GetFrozenExecutionDetailsQueryParams, void>(
    `/freeze/getFrozenExecutionDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get list of freeze acted on a frozen execution
 */
export const getFrozenExecutionDetailsPromise = (
  props: GetUsingFetchProps<
    ResponseFrozenExecutionDetails,
    Failure | Error,
    GetFrozenExecutionDetailsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseFrozenExecutionDetails, Failure | Error, GetFrozenExecutionDetailsQueryParams, void>(
    getConfig('ng/api'),
    `/freeze/getFrozenExecutionDetails`,
    props,
    signal
  )

export interface GetGlobalFreezeQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetGlobalFreezeProps = Omit<
  GetProps<ResponseFreezeDetailedResponse, Failure | Error, GetGlobalFreezeQueryParams, void>,
  'path'
>

/**
 * Get Global Freeze Yaml
 */
export const GetGlobalFreeze = (props: GetGlobalFreezeProps) => (
  <Get<ResponseFreezeDetailedResponse, Failure | Error, GetGlobalFreezeQueryParams, void>
    path={`/freeze/getGlobalFreeze`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGlobalFreezeProps = Omit<
  UseGetProps<ResponseFreezeDetailedResponse, Failure | Error, GetGlobalFreezeQueryParams, void>,
  'path'
>

/**
 * Get Global Freeze Yaml
 */
export const useGetGlobalFreeze = (props: UseGetGlobalFreezeProps) =>
  useGet<ResponseFreezeDetailedResponse, Failure | Error, GetGlobalFreezeQueryParams, void>(`/freeze/getGlobalFreeze`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Global Freeze Yaml
 */
export const getGlobalFreezePromise = (
  props: GetUsingFetchProps<ResponseFreezeDetailedResponse, Failure | Error, GetGlobalFreezeQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseFreezeDetailedResponse, Failure | Error, GetGlobalFreezeQueryParams, void>(
    getConfig('ng/api'),
    `/freeze/getGlobalFreeze`,
    props,
    signal
  )

export interface GetGlobalFreezeWithBannerDetailsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetGlobalFreezeWithBannerDetailsProps = Omit<
  GetProps<
    ResponseGlobalFreezeBannerDetailsResponseDTO,
    Failure | Error,
    GetGlobalFreezeWithBannerDetailsQueryParams,
    void
  >,
  'path'
>

/**
 * Get Global Freeze Yaml with Banner Details
 */
export const GetGlobalFreezeWithBannerDetails = (props: GetGlobalFreezeWithBannerDetailsProps) => (
  <Get<ResponseGlobalFreezeBannerDetailsResponseDTO, Failure | Error, GetGlobalFreezeWithBannerDetailsQueryParams, void>
    path={`/freeze/getGlobalFreezeWithBannerDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGlobalFreezeWithBannerDetailsProps = Omit<
  UseGetProps<
    ResponseGlobalFreezeBannerDetailsResponseDTO,
    Failure | Error,
    GetGlobalFreezeWithBannerDetailsQueryParams,
    void
  >,
  'path'
>

/**
 * Get Global Freeze Yaml with Banner Details
 */
export const useGetGlobalFreezeWithBannerDetails = (props: UseGetGlobalFreezeWithBannerDetailsProps) =>
  useGet<
    ResponseGlobalFreezeBannerDetailsResponseDTO,
    Failure | Error,
    GetGlobalFreezeWithBannerDetailsQueryParams,
    void
  >(`/freeze/getGlobalFreezeWithBannerDetails`, { base: getConfig('ng/api'), ...props })

/**
 * Get Global Freeze Yaml with Banner Details
 */
export const getGlobalFreezeWithBannerDetailsPromise = (
  props: GetUsingFetchProps<
    ResponseGlobalFreezeBannerDetailsResponseDTO,
    Failure | Error,
    GetGlobalFreezeWithBannerDetailsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseGlobalFreezeBannerDetailsResponseDTO,
    Failure | Error,
    GetGlobalFreezeWithBannerDetailsQueryParams,
    void
  >(getConfig('ng/api'), `/freeze/getGlobalFreezeWithBannerDetails`, props, signal)

export interface GetFreezeListQueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetFreezeListProps = Omit<
  MutateProps<
    ResponsePageFreezeSummaryResponse,
    Failure | Error,
    GetFreezeListQueryParams,
    FreezeFilterPropertiesDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Freeze Configs list
 */
export const GetFreezeList = (props: GetFreezeListProps) => (
  <Mutate<ResponsePageFreezeSummaryResponse, Failure | Error, GetFreezeListQueryParams, FreezeFilterPropertiesDTO, void>
    verb="POST"
    path={`/freeze/list`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFreezeListProps = Omit<
  UseMutateProps<
    ResponsePageFreezeSummaryResponse,
    Failure | Error,
    GetFreezeListQueryParams,
    FreezeFilterPropertiesDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Freeze Configs list
 */
export const useGetFreezeList = (props: UseGetFreezeListProps) =>
  useMutate<
    ResponsePageFreezeSummaryResponse,
    Failure | Error,
    GetFreezeListQueryParams,
    FreezeFilterPropertiesDTO,
    void
  >('POST', `/freeze/list`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Freeze Configs list
 */
export const getFreezeListPromise = (
  props: MutateUsingFetchProps<
    ResponsePageFreezeSummaryResponse,
    Failure | Error,
    GetFreezeListQueryParams,
    FreezeFilterPropertiesDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageFreezeSummaryResponse,
    Failure | Error,
    GetFreezeListQueryParams,
    FreezeFilterPropertiesDTO,
    void
  >('POST', getConfig('ng/api'), `/freeze/list`, props, signal)

export interface GlobalFreezeQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GlobalFreezeProps = Omit<
  MutateProps<
    ResponseFreezeResponse,
    Failure | Error,
    GlobalFreezeQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Manage Global Freeze
 */
export const GlobalFreeze = (props: GlobalFreezeProps) => (
  <Mutate<ResponseFreezeResponse, Failure | Error, GlobalFreezeQueryParams, ListTagsForAMIArtifactBodyRequestBody, void>
    verb="POST"
    path={`/freeze/manageGlobalFreeze`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGlobalFreezeProps = Omit<
  UseMutateProps<
    ResponseFreezeResponse,
    Failure | Error,
    GlobalFreezeQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Manage Global Freeze
 */
export const useGlobalFreeze = (props: UseGlobalFreezeProps) =>
  useMutate<
    ResponseFreezeResponse,
    Failure | Error,
    GlobalFreezeQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/freeze/manageGlobalFreeze`, { base: getConfig('ng/api'), ...props })

/**
 * Manage Global Freeze
 */
export const globalFreezePromise = (
  props: MutateUsingFetchProps<
    ResponseFreezeResponse,
    Failure | Error,
    GlobalFreezeQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseFreezeResponse,
    Failure | Error,
    GlobalFreezeQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/freeze/manageGlobalFreeze`, props, signal)

export interface SendNotificationQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface SendNotificationPathParams {
  freezeIdentifier: string
}

export type SendNotificationProps = Omit<
  MutateProps<boolean, Failure | Error, SendNotificationQueryParams, void, SendNotificationPathParams>,
  'path' | 'verb'
> &
  SendNotificationPathParams

/**
 * Send Notification
 */
export const SendNotification = ({ freezeIdentifier, ...props }: SendNotificationProps) => (
  <Mutate<boolean, Failure | Error, SendNotificationQueryParams, void, SendNotificationPathParams>
    verb="POST"
    path={`/freeze/notification/${freezeIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSendNotificationProps = Omit<
  UseMutateProps<boolean, Failure | Error, SendNotificationQueryParams, void, SendNotificationPathParams>,
  'path' | 'verb'
> &
  SendNotificationPathParams

/**
 * Send Notification
 */
export const useSendNotification = ({ freezeIdentifier, ...props }: UseSendNotificationProps) =>
  useMutate<boolean, Failure | Error, SendNotificationQueryParams, void, SendNotificationPathParams>(
    'POST',
    (paramsInPath: SendNotificationPathParams) => `/freeze/notification/${paramsInPath.freezeIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { freezeIdentifier }, ...props }
  )

/**
 * Send Notification
 */
export const sendNotificationPromise = (
  {
    freezeIdentifier,
    ...props
  }: MutateUsingFetchProps<boolean, Failure | Error, SendNotificationQueryParams, void, SendNotificationPathParams> & {
    freezeIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<boolean, Failure | Error, SendNotificationQueryParams, void, SendNotificationPathParams>(
    'POST',
    getConfig('ng/api'),
    `/freeze/notification/${freezeIdentifier}`,
    props,
    signal
  )

export interface GetFreezeSchemaQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
  accountIdentifier: string
}

export type GetFreezeSchemaProps = Omit<
  GetProps<ResponseJsonNode, Failure | Error, GetFreezeSchemaQueryParams, void>,
  'path'
>

/**
 * Get Freeze Schema
 */
export const GetFreezeSchema = (props: GetFreezeSchemaProps) => (
  <Get<ResponseJsonNode, Failure | Error, GetFreezeSchemaQueryParams, void>
    path={`/freeze/schema`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFreezeSchemaProps = Omit<
  UseGetProps<ResponseJsonNode, Failure | Error, GetFreezeSchemaQueryParams, void>,
  'path'
>

/**
 * Get Freeze Schema
 */
export const useGetFreezeSchema = (props: UseGetFreezeSchemaProps) =>
  useGet<ResponseJsonNode, Failure | Error, GetFreezeSchemaQueryParams, void>(`/freeze/schema`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Freeze Schema
 */
export const getFreezeSchemaPromise = (
  props: GetUsingFetchProps<ResponseJsonNode, Failure | Error, GetFreezeSchemaQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJsonNode, Failure | Error, GetFreezeSchemaQueryParams, void>(
    getConfig('ng/api'),
    `/freeze/schema`,
    props,
    signal
  )

export interface UpdateFreezeStatusQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  status: 'Enabled' | 'Disabled'
}

export type UpdateFreezeStatusProps = Omit<
  MutateProps<
    ResponseFreezeResponseWrapperDTO,
    Failure | Error,
    UpdateFreezeStatusQueryParams,
    DeleteManyFreezesBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update the status of Freeze to active or inactive
 */
export const UpdateFreezeStatus = (props: UpdateFreezeStatusProps) => (
  <Mutate<
    ResponseFreezeResponseWrapperDTO,
    Failure | Error,
    UpdateFreezeStatusQueryParams,
    DeleteManyFreezesBodyRequestBody,
    void
  >
    verb="POST"
    path={`/freeze/updateFreezeStatus`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateFreezeStatusProps = Omit<
  UseMutateProps<
    ResponseFreezeResponseWrapperDTO,
    Failure | Error,
    UpdateFreezeStatusQueryParams,
    DeleteManyFreezesBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update the status of Freeze to active or inactive
 */
export const useUpdateFreezeStatus = (props: UseUpdateFreezeStatusProps) =>
  useMutate<
    ResponseFreezeResponseWrapperDTO,
    Failure | Error,
    UpdateFreezeStatusQueryParams,
    DeleteManyFreezesBodyRequestBody,
    void
  >('POST', `/freeze/updateFreezeStatus`, { base: getConfig('ng/api'), ...props })

/**
 * Update the status of Freeze to active or inactive
 */
export const updateFreezeStatusPromise = (
  props: MutateUsingFetchProps<
    ResponseFreezeResponseWrapperDTO,
    Failure | Error,
    UpdateFreezeStatusQueryParams,
    DeleteManyFreezesBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseFreezeResponseWrapperDTO,
    Failure | Error,
    UpdateFreezeStatusQueryParams,
    DeleteManyFreezesBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/freeze/updateFreezeStatus`, props, signal)

export interface DeleteFreezeQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteFreezeProps = Omit<
  MutateProps<void, Failure | Error, DeleteFreezeQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a Freeze
 */
export const DeleteFreeze = (props: DeleteFreezeProps) => (
  <Mutate<void, Failure | Error, DeleteFreezeQueryParams, string, void>
    verb="DELETE"
    path={`/freeze`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteFreezeProps = Omit<
  UseMutateProps<void, Failure | Error, DeleteFreezeQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a Freeze
 */
export const useDeleteFreeze = (props: UseDeleteFreezeProps) =>
  useMutate<void, Failure | Error, DeleteFreezeQueryParams, string, void>('DELETE', `/freeze`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a Freeze
 */
export const deleteFreezePromise = (
  props: MutateUsingFetchProps<void, Failure | Error, DeleteFreezeQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, Failure | Error, DeleteFreezeQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/freeze`,
    props,
    signal
  )

export interface GetFreezeQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetFreezePathParams {
  freezeIdentifier: string
}

export type GetFreezeProps = Omit<
  GetProps<ResponseFreezeDetailedResponse, Failure | Error, GetFreezeQueryParams, GetFreezePathParams>,
  'path'
> &
  GetFreezePathParams

/**
 * Get a Freeze
 */
export const GetFreeze = ({ freezeIdentifier, ...props }: GetFreezeProps) => (
  <Get<ResponseFreezeDetailedResponse, Failure | Error, GetFreezeQueryParams, GetFreezePathParams>
    path={`/freeze/${freezeIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFreezeProps = Omit<
  UseGetProps<ResponseFreezeDetailedResponse, Failure | Error, GetFreezeQueryParams, GetFreezePathParams>,
  'path'
> &
  GetFreezePathParams

/**
 * Get a Freeze
 */
export const useGetFreeze = ({ freezeIdentifier, ...props }: UseGetFreezeProps) =>
  useGet<ResponseFreezeDetailedResponse, Failure | Error, GetFreezeQueryParams, GetFreezePathParams>(
    (paramsInPath: GetFreezePathParams) => `/freeze/${paramsInPath.freezeIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { freezeIdentifier }, ...props }
  )

/**
 * Get a Freeze
 */
export const getFreezePromise = (
  {
    freezeIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseFreezeDetailedResponse, Failure | Error, GetFreezeQueryParams, GetFreezePathParams> & {
    freezeIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseFreezeDetailedResponse, Failure | Error, GetFreezeQueryParams, GetFreezePathParams>(
    getConfig('ng/api'),
    `/freeze/${freezeIdentifier}`,
    props,
    signal
  )

export interface UpdateFreezeQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface UpdateFreezePathParams {
  freezeIdentifier: string
}

export type UpdateFreezeProps = Omit<
  MutateProps<
    ResponseFreezeResponse,
    Failure | Error,
    UpdateFreezeQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    UpdateFreezePathParams
  >,
  'path' | 'verb'
> &
  UpdateFreezePathParams

/**
 * Updates a Freeze
 */
export const UpdateFreeze = ({ freezeIdentifier, ...props }: UpdateFreezeProps) => (
  <Mutate<
    ResponseFreezeResponse,
    Failure | Error,
    UpdateFreezeQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    UpdateFreezePathParams
  >
    verb="PUT"
    path={`/freeze/${freezeIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateFreezeProps = Omit<
  UseMutateProps<
    ResponseFreezeResponse,
    Failure | Error,
    UpdateFreezeQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    UpdateFreezePathParams
  >,
  'path' | 'verb'
> &
  UpdateFreezePathParams

/**
 * Updates a Freeze
 */
export const useUpdateFreeze = ({ freezeIdentifier, ...props }: UseUpdateFreezeProps) =>
  useMutate<
    ResponseFreezeResponse,
    Failure | Error,
    UpdateFreezeQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    UpdateFreezePathParams
  >('PUT', (paramsInPath: UpdateFreezePathParams) => `/freeze/${paramsInPath.freezeIdentifier}`, {
    base: getConfig('ng/api'),
    pathParams: { freezeIdentifier },
    ...props
  })

/**
 * Updates a Freeze
 */
export const updateFreezePromise = (
  {
    freezeIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseFreezeResponse,
    Failure | Error,
    UpdateFreezeQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    UpdateFreezePathParams
  > & { freezeIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseFreezeResponse,
    Failure | Error,
    UpdateFreezeQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    UpdateFreezePathParams
  >('PUT', getConfig('ng/api'), `/freeze/${freezeIdentifier}`, props, signal)

export interface GetClusterNamesForGcpQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetClusterNamesForGcpProps = Omit<
  GetProps<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>,
  'path'
>

/**
 * Gets gcp cluster names
 */
export const GetClusterNamesForGcp = (props: GetClusterNamesForGcpProps) => (
  <Get<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>
    path={`/gcp/clusters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetClusterNamesForGcpProps = Omit<
  UseGetProps<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>,
  'path'
>

/**
 * Gets gcp cluster names
 */
export const useGetClusterNamesForGcp = (props: UseGetClusterNamesForGcpProps) =>
  useGet<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>(`/gcp/clusters`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets gcp cluster names
 */
export const getClusterNamesForGcpPromise = (
  props: GetUsingFetchProps<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>(
    getConfig('ng/api'),
    `/gcp/clusters`,
    props,
    signal
  )

export interface GetClusterNamesForGcpInfraQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  envId?: string
  infraDefinitionId?: string
}

export type GetClusterNamesForGcpInfraProps = Omit<
  GetProps<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpInfraQueryParams, void>,
  'path'
>

/**
 * Gets gcp cluster names for a gcp infrastructure definition
 */
export const GetClusterNamesForGcpInfra = (props: GetClusterNamesForGcpInfraProps) => (
  <Get<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpInfraQueryParams, void>
    path={`/gcp/clustersV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetClusterNamesForGcpInfraProps = Omit<
  UseGetProps<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpInfraQueryParams, void>,
  'path'
>

/**
 * Gets gcp cluster names for a gcp infrastructure definition
 */
export const useGetClusterNamesForGcpInfra = (props: UseGetClusterNamesForGcpInfraProps) =>
  useGet<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpInfraQueryParams, void>(`/gcp/clustersV2`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets gcp cluster names for a gcp infrastructure definition
 */
export const getClusterNamesForGcpInfraPromise = (
  props: GetUsingFetchProps<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpInfraQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpInfraQueryParams, void>(
    getConfig('ng/api'),
    `/gcp/clustersV2`,
    props,
    signal
  )

export interface GetProjectsQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier?: string
  fqnPath?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  serviceId?: string
  envId?: string
  infraDefinitionId?: string
}

export type GetProjectsProps = Omit<
  MutateProps<
    ResponseGcpProjectResponseDTO,
    Failure | Error,
    GetProjectsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get list of projects from gcp
 */
export const GetProjects = (props: GetProjectsProps) => (
  <Mutate<
    ResponseGcpProjectResponseDTO,
    Failure | Error,
    GetProjectsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/gcp/project`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectsProps = Omit<
  UseMutateProps<
    ResponseGcpProjectResponseDTO,
    Failure | Error,
    GetProjectsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get list of projects from gcp
 */
export const useGetProjects = (props: UseGetProjectsProps) =>
  useMutate<
    ResponseGcpProjectResponseDTO,
    Failure | Error,
    GetProjectsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/gcp/project`, { base: getConfig('ng/api'), ...props })

/**
 * Get list of projects from gcp
 */
export const getProjectsPromise = (
  props: MutateUsingFetchProps<
    ResponseGcpProjectResponseDTO,
    Failure | Error,
    GetProjectsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGcpProjectResponseDTO,
    Failure | Error,
    GetProjectsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/gcp/project`, props, signal)

export interface TriggerFullSyncQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type TriggerFullSyncProps = Omit<
  MutateProps<ResponseTriggerFullSyncResponseDTO, Failure | Error, TriggerFullSyncQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Triggers full sync
 */
export const TriggerFullSync = (props: TriggerFullSyncProps) => (
  <Mutate<ResponseTriggerFullSyncResponseDTO, Failure | Error, TriggerFullSyncQueryParams, void, void>
    verb="POST"
    path={`/git-full-sync`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseTriggerFullSyncProps = Omit<
  UseMutateProps<ResponseTriggerFullSyncResponseDTO, Failure | Error, TriggerFullSyncQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Triggers full sync
 */
export const useTriggerFullSync = (props: UseTriggerFullSyncProps) =>
  useMutate<ResponseTriggerFullSyncResponseDTO, Failure | Error, TriggerFullSyncQueryParams, void, void>(
    'POST',
    `/git-full-sync`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Triggers full sync
 */
export const triggerFullSyncPromise = (
  props: MutateUsingFetchProps<
    ResponseTriggerFullSyncResponseDTO,
    Failure | Error,
    TriggerFullSyncQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseTriggerFullSyncResponseDTO, Failure | Error, TriggerFullSyncQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/git-full-sync`,
    props,
    signal
  )

export interface GetGitFullSyncConfigQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetGitFullSyncConfigProps = Omit<
  GetProps<ResponseGitFullSyncConfigDTO, Failure | Error, GetGitFullSyncConfigQueryParams, void>,
  'path'
>

/**
 * Get full sync configuration
 */
export const GetGitFullSyncConfig = (props: GetGitFullSyncConfigProps) => (
  <Get<ResponseGitFullSyncConfigDTO, Failure | Error, GetGitFullSyncConfigQueryParams, void>
    path={`/git-full-sync/config`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGitFullSyncConfigProps = Omit<
  UseGetProps<ResponseGitFullSyncConfigDTO, Failure | Error, GetGitFullSyncConfigQueryParams, void>,
  'path'
>

/**
 * Get full sync configuration
 */
export const useGetGitFullSyncConfig = (props: UseGetGitFullSyncConfigProps) =>
  useGet<ResponseGitFullSyncConfigDTO, Failure | Error, GetGitFullSyncConfigQueryParams, void>(
    `/git-full-sync/config`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get full sync configuration
 */
export const getGitFullSyncConfigPromise = (
  props: GetUsingFetchProps<ResponseGitFullSyncConfigDTO, Failure | Error, GetGitFullSyncConfigQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGitFullSyncConfigDTO, Failure | Error, GetGitFullSyncConfigQueryParams, void>(
    getConfig('ng/api'),
    `/git-full-sync/config`,
    props,
    signal
  )

export interface CreateGitFullSyncConfigQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateGitFullSyncConfigProps = Omit<
  MutateProps<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    CreateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a full sync configuration
 */
export const CreateGitFullSyncConfig = (props: CreateGitFullSyncConfigProps) => (
  <Mutate<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    CreateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/git-full-sync/config`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateGitFullSyncConfigProps = Omit<
  UseMutateProps<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    CreateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a full sync configuration
 */
export const useCreateGitFullSyncConfig = (props: UseCreateGitFullSyncConfigProps) =>
  useMutate<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    CreateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >('POST', `/git-full-sync/config`, { base: getConfig('ng/api'), ...props })

/**
 * Create a full sync configuration
 */
export const createGitFullSyncConfigPromise = (
  props: MutateUsingFetchProps<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    CreateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    CreateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/git-full-sync/config`, props, signal)

export interface UpdateGitFullSyncConfigQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type UpdateGitFullSyncConfigProps = Omit<
  MutateProps<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    UpdateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a full sync configuration
 */
export const UpdateGitFullSyncConfig = (props: UpdateGitFullSyncConfigProps) => (
  <Mutate<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    UpdateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >
    verb="PUT"
    path={`/git-full-sync/config`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateGitFullSyncConfigProps = Omit<
  UseMutateProps<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    UpdateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a full sync configuration
 */
export const useUpdateGitFullSyncConfig = (props: UseUpdateGitFullSyncConfigProps) =>
  useMutate<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    UpdateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >('PUT', `/git-full-sync/config`, { base: getConfig('ng/api'), ...props })

/**
 * Update a full sync configuration
 */
export const updateGitFullSyncConfigPromise = (
  props: MutateUsingFetchProps<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    UpdateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    UpdateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/git-full-sync/config`, props, signal)

export interface ListFullSyncFilesQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
  searchTerm?: string
}

export type ListFullSyncFilesProps = Omit<
  MutateProps<
    ResponsePageGitFullSyncEntityInfoDTO,
    Failure | Error,
    ListFullSyncFilesQueryParams,
    GitFullSyncEntityInfoFilterKeys,
    void
  >,
  'path' | 'verb'
>

/**
 * Fetches the list of all Git Full Sync Entities and their status
 */
export const ListFullSyncFiles = (props: ListFullSyncFilesProps) => (
  <Mutate<
    ResponsePageGitFullSyncEntityInfoDTO,
    Failure | Error,
    ListFullSyncFilesQueryParams,
    GitFullSyncEntityInfoFilterKeys,
    void
  >
    verb="POST"
    path={`/git-full-sync/files`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListFullSyncFilesProps = Omit<
  UseMutateProps<
    ResponsePageGitFullSyncEntityInfoDTO,
    Failure | Error,
    ListFullSyncFilesQueryParams,
    GitFullSyncEntityInfoFilterKeys,
    void
  >,
  'path' | 'verb'
>

/**
 * Fetches the list of all Git Full Sync Entities and their status
 */
export const useListFullSyncFiles = (props: UseListFullSyncFilesProps) =>
  useMutate<
    ResponsePageGitFullSyncEntityInfoDTO,
    Failure | Error,
    ListFullSyncFilesQueryParams,
    GitFullSyncEntityInfoFilterKeys,
    void
  >('POST', `/git-full-sync/files`, { base: getConfig('ng/api'), ...props })

/**
 * Fetches the list of all Git Full Sync Entities and their status
 */
export const listFullSyncFilesPromise = (
  props: MutateUsingFetchProps<
    ResponsePageGitFullSyncEntityInfoDTO,
    Failure | Error,
    ListFullSyncFilesQueryParams,
    GitFullSyncEntityInfoFilterKeys,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageGitFullSyncEntityInfoDTO,
    Failure | Error,
    ListFullSyncFilesQueryParams,
    GitFullSyncEntityInfoFilterKeys,
    void
  >('POST', getConfig('ng/api'), `/git-full-sync/files`, props, signal)

export interface ClearCacheQueryParams {
  accountIdentifier?: string
}

export type ClearCacheProps = Omit<
  MutateProps<
    ResponseGitDefaultBranchClearCacheResponse,
    Failure | Error,
    ClearCacheQueryParams,
    GitDefaultBranchClearCacheRequest,
    void
  >,
  'path' | 'verb'
>

export const ClearCache = (props: ClearCacheProps) => (
  <Mutate<
    ResponseGitDefaultBranchClearCacheResponse,
    Failure | Error,
    ClearCacheQueryParams,
    GitDefaultBranchClearCacheRequest,
    void
  >
    verb="DELETE"
    path={`/git-service/default-branch-cache`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseClearCacheProps = Omit<
  UseMutateProps<
    ResponseGitDefaultBranchClearCacheResponse,
    Failure | Error,
    ClearCacheQueryParams,
    GitDefaultBranchClearCacheRequest,
    void
  >,
  'path' | 'verb'
>

export const useClearCache = (props: UseClearCacheProps) =>
  useMutate<
    ResponseGitDefaultBranchClearCacheResponse,
    Failure | Error,
    ClearCacheQueryParams,
    GitDefaultBranchClearCacheRequest,
    void
  >('DELETE', `/git-service/default-branch-cache`, { base: getConfig('ng/api'), ...props })

export const clearCachePromise = (
  props: MutateUsingFetchProps<
    ResponseGitDefaultBranchClearCacheResponse,
    Failure | Error,
    ClearCacheQueryParams,
    GitDefaultBranchClearCacheRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitDefaultBranchClearCacheResponse,
    Failure | Error,
    ClearCacheQueryParams,
    GitDefaultBranchClearCacheRequest,
    void
  >('DELETE', getConfig('ng/api'), `/git-service/default-branch-cache`, props, signal)

export interface FetchFromCacheQueryParams {
  accountIdentifier?: string
}

export type FetchFromCacheProps = Omit<
  GetProps<ResponseGitDefaultBranchGetCacheResponse, Failure | Error, FetchFromCacheQueryParams, void>,
  'path'
>

export const FetchFromCache = (props: FetchFromCacheProps) => (
  <Get<ResponseGitDefaultBranchGetCacheResponse, Failure | Error, FetchFromCacheQueryParams, void>
    path={`/git-service/default-branch-cache`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseFetchFromCacheProps = Omit<
  UseGetProps<ResponseGitDefaultBranchGetCacheResponse, Failure | Error, FetchFromCacheQueryParams, void>,
  'path'
>

export const useFetchFromCache = (props: UseFetchFromCacheProps) =>
  useGet<ResponseGitDefaultBranchGetCacheResponse, Failure | Error, FetchFromCacheQueryParams, void>(
    `/git-service/default-branch-cache`,
    { base: getConfig('ng/api'), ...props }
  )

export const fetchFromCachePromise = (
  props: GetUsingFetchProps<ResponseGitDefaultBranchGetCacheResponse, Failure | Error, FetchFromCacheQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGitDefaultBranchGetCacheResponse, Failure | Error, FetchFromCacheQueryParams, void>(
    getConfig('ng/api'),
    `/git-service/default-branch-cache`,
    props,
    signal
  )

export interface ListQueryParams {
  accountIdentifier?: string
}

export type ListProps = Omit<
  MutateProps<
    ResponseGitDefaultBranchCacheListResponse,
    Failure | Error,
    ListQueryParams,
    GitDefaultBranchCacheListRequest,
    void
  >,
  'path' | 'verb'
>

export const List = (props: ListProps) => (
  <Mutate<
    ResponseGitDefaultBranchCacheListResponse,
    Failure | Error,
    ListQueryParams,
    GitDefaultBranchCacheListRequest,
    void
  >
    verb="POST"
    path={`/git-service/default-branch-cache`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListProps = Omit<
  UseMutateProps<
    ResponseGitDefaultBranchCacheListResponse,
    Failure | Error,
    ListQueryParams,
    GitDefaultBranchCacheListRequest,
    void
  >,
  'path' | 'verb'
>

export const useList = (props: UseListProps) =>
  useMutate<
    ResponseGitDefaultBranchCacheListResponse,
    Failure | Error,
    ListQueryParams,
    GitDefaultBranchCacheListRequest,
    void
  >('POST', `/git-service/default-branch-cache`, { base: getConfig('ng/api'), ...props })

export const listPromise = (
  props: MutateUsingFetchProps<
    ResponseGitDefaultBranchCacheListResponse,
    Failure | Error,
    ListQueryParams,
    GitDefaultBranchCacheListRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitDefaultBranchCacheListResponse,
    Failure | Error,
    ListQueryParams,
    GitDefaultBranchCacheListRequest,
    void
  >('POST', getConfig('ng/api'), `/git-service/default-branch-cache`, props, signal)

export interface UpsertCacheQueryParams {
  accountIdentifier?: string
}

export type UpsertCacheProps = Omit<
  MutateProps<
    ResponseGitDefaultBranchUpsertCacheResponse,
    Failure | Error,
    UpsertCacheQueryParams,
    GitDefaultBranchUpsertCacheRequest,
    void
  >,
  'path' | 'verb'
>

export const UpsertCache = (props: UpsertCacheProps) => (
  <Mutate<
    ResponseGitDefaultBranchUpsertCacheResponse,
    Failure | Error,
    UpsertCacheQueryParams,
    GitDefaultBranchUpsertCacheRequest,
    void
  >
    verb="PUT"
    path={`/git-service/default-branch-cache`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertCacheProps = Omit<
  UseMutateProps<
    ResponseGitDefaultBranchUpsertCacheResponse,
    Failure | Error,
    UpsertCacheQueryParams,
    GitDefaultBranchUpsertCacheRequest,
    void
  >,
  'path' | 'verb'
>

export const useUpsertCache = (props: UseUpsertCacheProps) =>
  useMutate<
    ResponseGitDefaultBranchUpsertCacheResponse,
    Failure | Error,
    UpsertCacheQueryParams,
    GitDefaultBranchUpsertCacheRequest,
    void
  >('PUT', `/git-service/default-branch-cache`, { base: getConfig('ng/api'), ...props })

export const upsertCachePromise = (
  props: MutateUsingFetchProps<
    ResponseGitDefaultBranchUpsertCacheResponse,
    Failure | Error,
    UpsertCacheQueryParams,
    GitDefaultBranchUpsertCacheRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitDefaultBranchUpsertCacheResponse,
    Failure | Error,
    UpsertCacheQueryParams,
    GitDefaultBranchUpsertCacheRequest,
    void
  >('PUT', getConfig('ng/api'), `/git-service/default-branch-cache`, props, signal)

export interface ClearCache1QueryParams {
  accountIdentifier?: string
}

export type ClearCache1Props = Omit<
  MutateProps<
    ResponseGitFileCacheClearCacheResponse,
    Failure | Error,
    ClearCache1QueryParams,
    GitFileCacheClearCacheRequest,
    void
  >,
  'path' | 'verb'
>

export const ClearCache1 = (props: ClearCache1Props) => (
  <Mutate<
    ResponseGitFileCacheClearCacheResponse,
    Failure | Error,
    ClearCache1QueryParams,
    GitFileCacheClearCacheRequest,
    void
  >
    verb="DELETE"
    path={`/git-service/git-file-cache`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseClearCache1Props = Omit<
  UseMutateProps<
    ResponseGitFileCacheClearCacheResponse,
    Failure | Error,
    ClearCache1QueryParams,
    GitFileCacheClearCacheRequest,
    void
  >,
  'path' | 'verb'
>

export const useClearCache1 = (props: UseClearCache1Props) =>
  useMutate<
    ResponseGitFileCacheClearCacheResponse,
    Failure | Error,
    ClearCache1QueryParams,
    GitFileCacheClearCacheRequest,
    void
  >('DELETE', `/git-service/git-file-cache`, { base: getConfig('ng/api'), ...props })

export const clearCache1Promise = (
  props: MutateUsingFetchProps<
    ResponseGitFileCacheClearCacheResponse,
    Failure | Error,
    ClearCache1QueryParams,
    GitFileCacheClearCacheRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitFileCacheClearCacheResponse,
    Failure | Error,
    ClearCache1QueryParams,
    GitFileCacheClearCacheRequest,
    void
  >('DELETE', getConfig('ng/api'), `/git-service/git-file-cache`, props, signal)

export interface UpdateCacheQueryParams {
  accountIdentifier?: string
}

export type UpdateCacheProps = Omit<
  MutateProps<
    ResponseGitFileCacheUpdateResponse,
    Failure | Error,
    UpdateCacheQueryParams,
    GitFileCacheUpdateRequest,
    void
  >,
  'path' | 'verb'
>

export const UpdateCache = (props: UpdateCacheProps) => (
  <Mutate<ResponseGitFileCacheUpdateResponse, Failure | Error, UpdateCacheQueryParams, GitFileCacheUpdateRequest, void>
    verb="PUT"
    path={`/git-service/git-file-cache`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateCacheProps = Omit<
  UseMutateProps<
    ResponseGitFileCacheUpdateResponse,
    Failure | Error,
    UpdateCacheQueryParams,
    GitFileCacheUpdateRequest,
    void
  >,
  'path' | 'verb'
>

export const useUpdateCache = (props: UseUpdateCacheProps) =>
  useMutate<
    ResponseGitFileCacheUpdateResponse,
    Failure | Error,
    UpdateCacheQueryParams,
    GitFileCacheUpdateRequest,
    void
  >('PUT', `/git-service/git-file-cache`, { base: getConfig('ng/api'), ...props })

export const updateCachePromise = (
  props: MutateUsingFetchProps<
    ResponseGitFileCacheUpdateResponse,
    Failure | Error,
    UpdateCacheQueryParams,
    GitFileCacheUpdateRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitFileCacheUpdateResponse,
    Failure | Error,
    UpdateCacheQueryParams,
    GitFileCacheUpdateRequest,
    void
  >('PUT', getConfig('ng/api'), `/git-service/git-file-cache`, props, signal)

export interface ListGitSyncQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  accountIdentifier?: string
}

export type ListGitSyncProps = Omit<GetProps<GitSyncConfig[], unknown, ListGitSyncQueryParams, void>, 'path'>

/**
 * List Git Sync
 */
export const ListGitSync = (props: ListGitSyncProps) => (
  <Get<GitSyncConfig[], unknown, ListGitSyncQueryParams, void>
    path={`/git-sync`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncProps = Omit<UseGetProps<GitSyncConfig[], unknown, ListGitSyncQueryParams, void>, 'path'>

/**
 * List Git Sync
 */
export const useListGitSync = (props: UseListGitSyncProps) =>
  useGet<GitSyncConfig[], unknown, ListGitSyncQueryParams, void>(`/git-sync`, { base: getConfig('ng/api'), ...props })

/**
 * List Git Sync
 */
export const listGitSyncPromise = (
  props: GetUsingFetchProps<GitSyncConfig[], unknown, ListGitSyncQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<GitSyncConfig[], unknown, ListGitSyncQueryParams, void>(getConfig('ng/api'), `/git-sync`, props, signal)

export interface PostGitSyncQueryParams {
  accountIdentifier?: string
}

export type PostGitSyncProps = Omit<
  MutateProps<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Git Sync
 */
export const PostGitSync = (props: PostGitSyncProps) => (
  <Mutate<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>
    verb="POST"
    path={`/git-sync`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostGitSyncProps = Omit<
  UseMutateProps<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Git Sync
 */
export const usePostGitSync = (props: UsePostGitSyncProps) =>
  useMutate<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>('POST', `/git-sync`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create a Git Sync
 */
export const postGitSyncPromise = (
  props: MutateUsingFetchProps<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/git-sync`,
    props,
    signal
  )

export interface PutGitSyncQueryParams {
  accountIdentifier?: string
}

export type PutGitSyncProps = Omit<
  MutateProps<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update Git Sync by id
 */
export const PutGitSync = (props: PutGitSyncProps) => (
  <Mutate<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>
    verb="PUT"
    path={`/git-sync`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutGitSyncProps = Omit<
  UseMutateProps<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update Git Sync by id
 */
export const usePutGitSync = (props: UsePutGitSyncProps) =>
  useMutate<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>('PUT', `/git-sync`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Update Git Sync by id
 */
export const putGitSyncPromise = (
  props: MutateUsingFetchProps<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/git-sync`,
    props,
    signal
  )

export interface GetListOfBranchesWithStatusQueryParams {
  yamlGitConfigIdentifier?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  page?: number
  size?: number
  searchTerm?: string
  branchSyncStatus?: 'SYNCED' | 'SYNCING' | 'UNSYNCED'
}

export type GetListOfBranchesWithStatusProps = Omit<
  GetProps<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>,
  'path'
>

/**
 * Gets list of branches with their status by Git Sync Config Id
 */
export const GetListOfBranchesWithStatus = (props: GetListOfBranchesWithStatusProps) => (
  <Get<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>
    path={`/git-sync-branch/listBranchesWithStatus`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetListOfBranchesWithStatusProps = Omit<
  UseGetProps<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>,
  'path'
>

/**
 * Gets list of branches with their status by Git Sync Config Id
 */
export const useGetListOfBranchesWithStatus = (props: UseGetListOfBranchesWithStatusProps) =>
  useGet<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>(
    `/git-sync-branch/listBranchesWithStatus`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets list of branches with their status by Git Sync Config Id
 */
export const getListOfBranchesWithStatusPromise = (
  props: GetUsingFetchProps<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>(
    getConfig('ng/api'),
    `/git-sync-branch/listBranchesWithStatus`,
    props,
    signal
  )

export interface SyncGitBranchQueryParams {
  repoIdentifier?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
}

export type SyncGitBranchProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Sync the new branch into harness
 */
export const SyncGitBranch = (props: SyncGitBranchProps) => (
  <Mutate<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>
    verb="POST"
    path={`/git-sync-branch/sync`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSyncGitBranchProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Sync the new branch into harness
 */
export const useSyncGitBranch = (props: UseSyncGitBranchProps) =>
  useMutate<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>('POST', `/git-sync-branch/sync`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Sync the new branch into harness
 */
export const syncGitBranchPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/git-sync-branch/sync`,
    props,
    signal
  )

export interface ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  accountIdentifier?: string
  size?: number
  gitSyncConfigId?: string
}

export interface ListGitSyncEntitiesSummaryForRepoAndBranchPathParams {
  branch: string
}

export type ListGitSyncEntitiesSummaryForRepoAndBranchProps = Omit<
  MutateProps<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  >,
  'path' | 'verb'
> &
  ListGitSyncEntitiesSummaryForRepoAndBranchPathParams

/**
 * List Git Sync Entity by product for Repo and Branch and List of Entities
 */
export const ListGitSyncEntitiesSummaryForRepoAndBranch = ({
  branch,
  ...props
}: ListGitSyncEntitiesSummaryForRepoAndBranchProps) => (
  <Mutate<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  >
    verb="POST"
    path={`/git-sync-entities/branch/${branch}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncEntitiesSummaryForRepoAndBranchProps = Omit<
  UseMutateProps<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  >,
  'path' | 'verb'
> &
  ListGitSyncEntitiesSummaryForRepoAndBranchPathParams

/**
 * List Git Sync Entity by product for Repo and Branch and List of Entities
 */
export const useListGitSyncEntitiesSummaryForRepoAndBranch = ({
  branch,
  ...props
}: UseListGitSyncEntitiesSummaryForRepoAndBranchProps) =>
  useMutate<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  >(
    'POST',
    (paramsInPath: ListGitSyncEntitiesSummaryForRepoAndBranchPathParams) =>
      `/git-sync-entities/branch/${paramsInPath.branch}`,
    { base: getConfig('ng/api'), pathParams: { branch }, ...props }
  )

/**
 * List Git Sync Entity by product for Repo and Branch and List of Entities
 */
export const listGitSyncEntitiesSummaryForRepoAndBranchPromise = (
  {
    branch,
    ...props
  }: MutateUsingFetchProps<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  > & { branch: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  >('POST', getConfig('ng/api'), `/git-sync-entities/branch/${branch}`, props, signal)

export interface ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  accountIdentifier?: string
  size?: number
}

export type ListGitSyncEntitiesSummaryForRepoAndTypesProps = Omit<
  MutateProps<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * List Git Sync Entity by product for List of Repos and Entities
 */
export const ListGitSyncEntitiesSummaryForRepoAndTypes = (props: ListGitSyncEntitiesSummaryForRepoAndTypesProps) => (
  <Mutate<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >
    verb="POST"
    path={`/git-sync-entities/summary`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncEntitiesSummaryForRepoAndTypesProps = Omit<
  UseMutateProps<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * List Git Sync Entity by product for List of Repos and Entities
 */
export const useListGitSyncEntitiesSummaryForRepoAndTypes = (
  props: UseListGitSyncEntitiesSummaryForRepoAndTypesProps
) =>
  useMutate<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >('POST', `/git-sync-entities/summary`, { base: getConfig('ng/api'), ...props })

/**
 * List Git Sync Entity by product for List of Repos and Entities
 */
export const listGitSyncEntitiesSummaryForRepoAndTypesPromise = (
  props: MutateUsingFetchProps<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >('POST', getConfig('ng/api'), `/git-sync-entities/summary`, props, signal)

export interface ListGitSyncEntitiesByTypeQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  accountIdentifier?: string
  gitSyncConfigId?: string
  branch?: string
  page?: number
  size?: number
  moduleType?: string
}

export interface ListGitSyncEntitiesByTypePathParams {
  entityType:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
}

export type ListGitSyncEntitiesByTypeProps = Omit<
  GetProps<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >,
  'path'
> &
  ListGitSyncEntitiesByTypePathParams

/**
 * Get Git Sync Entity By Type
 */
export const ListGitSyncEntitiesByType = ({ entityType, ...props }: ListGitSyncEntitiesByTypeProps) => (
  <Get<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >
    path={`/git-sync-entities/${entityType}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncEntitiesByTypeProps = Omit<
  UseGetProps<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >,
  'path'
> &
  ListGitSyncEntitiesByTypePathParams

/**
 * Get Git Sync Entity By Type
 */
export const useListGitSyncEntitiesByType = ({ entityType, ...props }: UseListGitSyncEntitiesByTypeProps) =>
  useGet<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >((paramsInPath: ListGitSyncEntitiesByTypePathParams) => `/git-sync-entities/${paramsInPath.entityType}`, {
    base: getConfig('ng/api'),
    pathParams: { entityType },
    ...props
  })

/**
 * Get Git Sync Entity By Type
 */
export const listGitSyncEntitiesByTypePromise = (
  {
    entityType,
    ...props
  }: GetUsingFetchProps<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  > & {
    entityType:
      | 'CreatePR'
      | 'GITOPS_MERGE_PR'
      | 'Projects'
      | 'Pipelines'
      | 'PipelineSteps'
      | 'Http'
      | 'Email'
      | 'JiraCreate'
      | 'JiraUpdate'
      | 'JiraApproval'
      | 'HarnessApproval'
      | 'CustomApproval'
      | 'Barrier'
      | 'Queue'
      | 'FlagConfiguration'
      | 'ShellScript'
      | 'K8sCanaryDeploy'
      | 'K8sApply'
      | 'K8sBlueGreenDeploy'
      | 'K8sRollingDeploy'
      | 'K8sRollingRollback'
      | 'K8sScale'
      | 'K8sDelete'
      | 'K8sBGSwapServices'
      | 'K8sCanaryDelete'
      | 'TerraformApply'
      | 'TerraformPlan'
      | 'TerraformDestroy'
      | 'TerraformRollback'
      | 'HelmDeploy'
      | 'HelmRollback'
      | 'Connectors'
      | 'Secrets'
      | 'Files'
      | 'Service'
      | 'Environment'
      | 'EnvironmentGroup'
      | 'InputSets'
      | 'CvConfig'
      | 'Verify'
      | 'Delegates'
      | 'DelegateConfigurations'
      | 'CvVerificationJob'
      | 'IntegrationStage'
      | 'IntegrationSteps'
      | 'SecurityStage'
      | 'SecuritySteps'
      | 'CvKubernetesActivitySource'
      | 'DeploymentSteps'
      | 'DeploymentStage'
      | 'ApprovalStage'
      | 'PipelineStage'
      | 'FeatureFlagStage'
      | 'Template'
      | 'TemplateStage'
      | 'CustomDeployment'
      | 'Triggers'
      | 'MonitoredService'
      | 'GitRepositories'
      | 'FeatureFlags'
      | 'ServiceNowApproval'
      | 'ServiceNowCreate'
      | 'ServiceNowUpdate'
      | 'ServiceNowImportSet'
      | 'GovernancePolicies'
      | 'POLICY_STEP'
      | 'Run'
      | 'RunTests'
      | 'Plugin'
      | 'RestoreCacheGCS'
      | 'RestoreCacheS3'
      | 'SaveCacheGCS'
      | 'SaveCacheS3'
      | 'Security'
      | 'AquaTrivy'
      | 'AWSECR'
      | 'Bandit'
      | 'BlackDuck'
      | 'Brakeman'
      | 'Burp'
      | 'Checkmarx'
      | 'Clair'
      | 'DataTheorem'
      | 'DockerContentTrust'
      | 'External'
      | 'FortifyOnDemand'
      | 'Grype'
      | 'JfrogXray'
      | 'Mend'
      | 'Metasploit'
      | 'Nessus'
      | 'NexusIQ'
      | 'Nikto'
      | 'Nmap'
      | 'Openvas'
      | 'Owasp'
      | 'PrismaCloud'
      | 'Prowler'
      | 'Qualys'
      | 'Reapsaw'
      | 'ShiftLeft'
      | 'Sniper'
      | 'Snyk'
      | 'Sonarqube'
      | 'Sysdig'
      | 'Tenable'
      | 'Veracode'
      | 'Zap'
      | 'GitClone'
      | 'ArtifactoryUpload'
      | 'GCSUpload'
      | 'S3Upload'
      | 'BuildAndPushGCR'
      | 'BuildAndPushGAR'
      | 'BuildAndPushECR'
      | 'BuildAndPushDockerRegistry'
      | 'CreateStack'
      | 'DeleteStack'
      | 'ServerlessAwsLambdaDeploy'
      | 'ServerlessAwsLambdaRollback'
      | 'CustomStage'
      | 'RollbackStack'
      | 'Infrastructure'
      | 'Command'
      | 'StrategyNode'
      | 'AZURE_SLOT_DEPLOYMENT_STEP'
      | 'AzureTrafficShift'
      | 'FetchInstanceScript'
      | 'AzureSwapSlot'
      | 'AzureWebAppRollback'
      | 'JenkinsBuild'
      | 'EcsRollingDeploy'
      | 'EcsRollingRollback'
      | 'EcsCanaryDeploy'
      | 'EcsCanaryDelete'
      | 'AzureCreateARMResource'
      | 'BuildAndPushACR'
      | 'AzureCreateBPResource'
      | 'AzureARMRollback'
      | 'Background'
      | 'Wait'
      | 'ArtifactSource'
      | 'EcsBlueGreenCreateService'
      | 'EcsBlueGreenSwapTargetGroups'
      | 'EcsBlueGreenRollback'
      | 'ShellScriptProvision'
      | 'Freeze'
      | 'GitOpsUpdateReleaseRepo'
      | 'GitOpsFetchLinkedApps'
      | 'EcsRunTask'
      | 'Chaos'
      | 'ElastigroupDeploy'
      | 'ElastigroupRollback'
      | 'Action'
      | 'ElastigroupSetup'
      | 'Bitrise'
      | 'TerraformPlan'
      | 'TerraformApply'
      | 'TerraformDestroy'
      | 'TerraformRollback'
      | 'IACMStage'
      | 'IACMStep'
      | 'IACM'
      | 'Container'
      | 'IACM'
      | 'IACM'
      | 'ElastigroupBGStageSetup'
      | 'ElastigroupSwapRoute'
      | 'AsgCanaryDeploy'
      | 'AsgCanaryDelete'
      | 'SwapRoutes'
      | 'SwapRollback'
      | 'AppResize'
      | 'AppRollback'
      | 'CanaryAppSetup'
      | 'BGAppSetup'
      | 'BasicAppSetup'
      | 'TanzuCommand'
      | 'AsgRollingDeploy'
      | 'AsgRollingRollback'
      | 'GovernanceRuleAWS'
      | 'TasRollingDeploy'
      | 'TasRollingRollback'
      | 'K8sDryRun'
      | 'AsgBlueGreenSwapService'
      | 'AsgBlueGreenDeploy'
      | 'AsgBlueGreenRollback'
      | 'TerraformCloudRun'
      | 'TerraformCloudRollback'
      | 'DeployCloudFunction'
      | 'DeployCloudFunctionWithNoTraffic'
      | 'CloudFunctionTrafficShift'
      | 'CloudFunctionRollback'
      | 'AwsLambdaDeploy'
      | 'AwsSamDeploy'
      | 'AwsSamRollback'
      | 'SscaOrchestration'
      | 'AwsLambdaRollback'
      | 'GITOPS_SYNC'
      | 'BambooBuild'
      | 'CdSscaOrchestration'
      | 'RouteMapping'
      | 'AWSSecurityHub'
      | 'CustomIngest'
      | 'BackstageEnvironmentVariable'
      | 'Fossa'
      | 'CodeQL'
      | 'Gitleaks'
      | 'DeployCloudFunctionGenOne'
      | 'RollbackCloudFunctionGenOne'
      | 'K8sBlueGreenStageScaleDown'
      | 'AwsSamBuild'
      | 'Semgrep'
      | 'SscaEnforcement'
      | 'IdpConnector'
      | 'CdSscaEnforcement'
      | 'DownloadManifests'
      | 'ServerlessAwsLambdaPrepareRollbackV2'
      | 'ServerlessAwsLambdaRollbackV2'
      | 'Coverity'
      | 'ServerlessAwsLambdaDeployV2'
      | 'AnalyzeDeploymentImpact'
      | 'ServerlessAwsLambdaPackageV2'
      | 'RevertPR'
      | 'AwsCdkBootstrap'
      | 'AwsCdkSynth'
      | 'AwsCdkDiff'
      | 'AwsCdkDeploy'
      | 'AwsCdkDestroy'
      | 'IdpScorecard'
      | 'IdpCheck'
      | 'AwsCdkRollback'
      | 'SlsaVerification'
      | 'UpdateGitOpsApp'
      | 'EcsServiceSetup'
      | 'EcsUpgradeContainer'
      | 'EcsBasicRollback'
      | 'ChaosInfrastructure'
      | 'Anchore'
      | 'Overrides'
      | 'AsgShiftTraffic'
      | 'AquaSecurity'
      | 'IDPStage'
      | 'ChaosHub'
      | 'IdpCookieCutter'
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >(getConfig('ng/api'), `/git-sync-entities/${entityType}`, props, signal)

export interface ListGitSyncErrorsQueryParams {
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  gitToHarness?: boolean
}

export type ListGitSyncErrorsProps = Omit<
  GetProps<ResponsePageGitSyncErrorDTO, Failure | Error, ListGitSyncErrorsQueryParams, void>,
  'path'
>

/**
 * Gets Error list
 */
export const ListGitSyncErrors = (props: ListGitSyncErrorsProps) => (
  <Get<ResponsePageGitSyncErrorDTO, Failure | Error, ListGitSyncErrorsQueryParams, void>
    path={`/git-sync-errors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncErrorsProps = Omit<
  UseGetProps<ResponsePageGitSyncErrorDTO, Failure | Error, ListGitSyncErrorsQueryParams, void>,
  'path'
>

/**
 * Gets Error list
 */
export const useListGitSyncErrors = (props: UseListGitSyncErrorsProps) =>
  useGet<ResponsePageGitSyncErrorDTO, Failure | Error, ListGitSyncErrorsQueryParams, void>(`/git-sync-errors`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Error list
 */
export const listGitSyncErrorsPromise = (
  props: GetUsingFetchProps<ResponsePageGitSyncErrorDTO, Failure | Error, ListGitSyncErrorsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageGitSyncErrorDTO, Failure | Error, ListGitSyncErrorsQueryParams, void>(
    getConfig('ng/api'),
    `/git-sync-errors`,
    props,
    signal
  )

export interface ListGitToHarnessErrorsCommitsQueryParams {
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  numberOfErrorsInSummary?: number
}

export type ListGitToHarnessErrorsCommitsProps = Omit<
  GetProps<
    ResponsePageGitSyncErrorAggregateByCommitDTO,
    Failure | Error,
    ListGitToHarnessErrorsCommitsQueryParams,
    void
  >,
  'path'
>

/**
 * Gets Error list grouped by commit
 */
export const ListGitToHarnessErrorsCommits = (props: ListGitToHarnessErrorsCommitsProps) => (
  <Get<ResponsePageGitSyncErrorAggregateByCommitDTO, Failure | Error, ListGitToHarnessErrorsCommitsQueryParams, void>
    path={`/git-sync-errors/aggregate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitToHarnessErrorsCommitsProps = Omit<
  UseGetProps<
    ResponsePageGitSyncErrorAggregateByCommitDTO,
    Failure | Error,
    ListGitToHarnessErrorsCommitsQueryParams,
    void
  >,
  'path'
>

/**
 * Gets Error list grouped by commit
 */
export const useListGitToHarnessErrorsCommits = (props: UseListGitToHarnessErrorsCommitsProps) =>
  useGet<ResponsePageGitSyncErrorAggregateByCommitDTO, Failure | Error, ListGitToHarnessErrorsCommitsQueryParams, void>(
    `/git-sync-errors/aggregate`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Error list grouped by commit
 */
export const listGitToHarnessErrorsCommitsPromise = (
  props: GetUsingFetchProps<
    ResponsePageGitSyncErrorAggregateByCommitDTO,
    Failure | Error,
    ListGitToHarnessErrorsCommitsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageGitSyncErrorAggregateByCommitDTO,
    Failure | Error,
    ListGitToHarnessErrorsCommitsQueryParams,
    void
  >(getConfig('ng/api'), `/git-sync-errors/aggregate`, props, signal)

export interface ListGitToHarnessErrorsForCommitQueryParams {
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export interface ListGitToHarnessErrorsForCommitPathParams {
  commitId: string
}

export type ListGitToHarnessErrorsForCommitProps = Omit<
  GetProps<
    ResponsePageGitSyncErrorDTO,
    Failure | Error,
    ListGitToHarnessErrorsForCommitQueryParams,
    ListGitToHarnessErrorsForCommitPathParams
  >,
  'path'
> &
  ListGitToHarnessErrorsForCommitPathParams

/**
 * Gets Error list for a particular Commit
 */
export const ListGitToHarnessErrorsForCommit = ({ commitId, ...props }: ListGitToHarnessErrorsForCommitProps) => (
  <Get<
    ResponsePageGitSyncErrorDTO,
    Failure | Error,
    ListGitToHarnessErrorsForCommitQueryParams,
    ListGitToHarnessErrorsForCommitPathParams
  >
    path={`/git-sync-errors/commits/${commitId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitToHarnessErrorsForCommitProps = Omit<
  UseGetProps<
    ResponsePageGitSyncErrorDTO,
    Failure | Error,
    ListGitToHarnessErrorsForCommitQueryParams,
    ListGitToHarnessErrorsForCommitPathParams
  >,
  'path'
> &
  ListGitToHarnessErrorsForCommitPathParams

/**
 * Gets Error list for a particular Commit
 */
export const useListGitToHarnessErrorsForCommit = ({ commitId, ...props }: UseListGitToHarnessErrorsForCommitProps) =>
  useGet<
    ResponsePageGitSyncErrorDTO,
    Failure | Error,
    ListGitToHarnessErrorsForCommitQueryParams,
    ListGitToHarnessErrorsForCommitPathParams
  >((paramsInPath: ListGitToHarnessErrorsForCommitPathParams) => `/git-sync-errors/commits/${paramsInPath.commitId}`, {
    base: getConfig('ng/api'),
    pathParams: { commitId },
    ...props
  })

/**
 * Gets Error list for a particular Commit
 */
export const listGitToHarnessErrorsForCommitPromise = (
  {
    commitId,
    ...props
  }: GetUsingFetchProps<
    ResponsePageGitSyncErrorDTO,
    Failure | Error,
    ListGitToHarnessErrorsForCommitQueryParams,
    ListGitToHarnessErrorsForCommitPathParams
  > & { commitId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageGitSyncErrorDTO,
    Failure | Error,
    ListGitToHarnessErrorsForCommitQueryParams,
    ListGitToHarnessErrorsForCommitPathParams
  >(getConfig('ng/api'), `/git-sync-errors/commits/${commitId}`, props, signal)

export interface GetGitSyncErrorsCountQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetGitSyncErrorsCountProps = Omit<
  GetProps<ResponseGitSyncErrorCountDTO, Failure | Error, GetGitSyncErrorsCountQueryParams, void>,
  'path'
>

/**
 * Gets Error Count
 */
export const GetGitSyncErrorsCount = (props: GetGitSyncErrorsCountProps) => (
  <Get<ResponseGitSyncErrorCountDTO, Failure | Error, GetGitSyncErrorsCountQueryParams, void>
    path={`/git-sync-errors/count`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGitSyncErrorsCountProps = Omit<
  UseGetProps<ResponseGitSyncErrorCountDTO, Failure | Error, GetGitSyncErrorsCountQueryParams, void>,
  'path'
>

/**
 * Gets Error Count
 */
export const useGetGitSyncErrorsCount = (props: UseGetGitSyncErrorsCountProps) =>
  useGet<ResponseGitSyncErrorCountDTO, Failure | Error, GetGitSyncErrorsCountQueryParams, void>(
    `/git-sync-errors/count`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Error Count
 */
export const getGitSyncErrorsCountPromise = (
  props: GetUsingFetchProps<ResponseGitSyncErrorCountDTO, Failure | Error, GetGitSyncErrorsCountQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGitSyncErrorCountDTO, Failure | Error, GetGitSyncErrorsCountQueryParams, void>(
    getConfig('ng/api'),
    `/git-sync-errors/count`,
    props,
    signal
  )

export interface GetGitSyncSettingsQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  accountIdentifier?: string
}

export type GetGitSyncSettingsProps = Omit<
  GetProps<ResponseGitSyncSettingsDTO, unknown, GetGitSyncSettingsQueryParams, void>,
  'path'
>

/**
 * Get git sync settings
 */
export const GetGitSyncSettings = (props: GetGitSyncSettingsProps) => (
  <Get<ResponseGitSyncSettingsDTO, unknown, GetGitSyncSettingsQueryParams, void>
    path={`/git-sync-settings`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGitSyncSettingsProps = Omit<
  UseGetProps<ResponseGitSyncSettingsDTO, unknown, GetGitSyncSettingsQueryParams, void>,
  'path'
>

/**
 * Get git sync settings
 */
export const useGetGitSyncSettings = (props: UseGetGitSyncSettingsProps) =>
  useGet<ResponseGitSyncSettingsDTO, unknown, GetGitSyncSettingsQueryParams, void>(`/git-sync-settings`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get git sync settings
 */
export const getGitSyncSettingsPromise = (
  props: GetUsingFetchProps<ResponseGitSyncSettingsDTO, unknown, GetGitSyncSettingsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGitSyncSettingsDTO, unknown, GetGitSyncSettingsQueryParams, void>(
    getConfig('ng/api'),
    `/git-sync-settings`,
    props,
    signal
  )

export interface PostGitSyncSettingQueryParams {
  accountIdentifier?: string
}

export type PostGitSyncSettingProps = Omit<
  MutateProps<ResponseGitSyncSettingsDTO, unknown, PostGitSyncSettingQueryParams, GitSyncSettingsDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Git Sync Setting
 */
export const PostGitSyncSetting = (props: PostGitSyncSettingProps) => (
  <Mutate<ResponseGitSyncSettingsDTO, unknown, PostGitSyncSettingQueryParams, GitSyncSettingsDTORequestBody, void>
    verb="POST"
    path={`/git-sync-settings`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostGitSyncSettingProps = Omit<
  UseMutateProps<
    ResponseGitSyncSettingsDTO,
    unknown,
    PostGitSyncSettingQueryParams,
    GitSyncSettingsDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Git Sync Setting
 */
export const usePostGitSyncSetting = (props: UsePostGitSyncSettingProps) =>
  useMutate<ResponseGitSyncSettingsDTO, unknown, PostGitSyncSettingQueryParams, GitSyncSettingsDTORequestBody, void>(
    'POST',
    `/git-sync-settings`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a Git Sync Setting
 */
export const postGitSyncSettingPromise = (
  props: MutateUsingFetchProps<
    ResponseGitSyncSettingsDTO,
    unknown,
    PostGitSyncSettingQueryParams,
    GitSyncSettingsDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitSyncSettingsDTO,
    unknown,
    PostGitSyncSettingQueryParams,
    GitSyncSettingsDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/git-sync-settings`, props, signal)

export interface UpdateGitSyncSettingQueryParams {
  accountIdentifier?: string
}

export type UpdateGitSyncSettingProps = Omit<
  MutateProps<
    ResponseGitSyncSettingsDTO,
    unknown,
    UpdateGitSyncSettingQueryParams,
    GitSyncSettingsDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a Git Sync Setting
 */
export const UpdateGitSyncSetting = (props: UpdateGitSyncSettingProps) => (
  <Mutate<ResponseGitSyncSettingsDTO, unknown, UpdateGitSyncSettingQueryParams, GitSyncSettingsDTORequestBody, void>
    verb="PUT"
    path={`/git-sync-settings`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateGitSyncSettingProps = Omit<
  UseMutateProps<
    ResponseGitSyncSettingsDTO,
    unknown,
    UpdateGitSyncSettingQueryParams,
    GitSyncSettingsDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a Git Sync Setting
 */
export const useUpdateGitSyncSetting = (props: UseUpdateGitSyncSettingProps) =>
  useMutate<ResponseGitSyncSettingsDTO, unknown, UpdateGitSyncSettingQueryParams, GitSyncSettingsDTORequestBody, void>(
    'PUT',
    `/git-sync-settings`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update a Git Sync Setting
 */
export const updateGitSyncSettingPromise = (
  props: MutateUsingFetchProps<
    ResponseGitSyncSettingsDTO,
    unknown,
    UpdateGitSyncSettingQueryParams,
    GitSyncSettingsDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitSyncSettingsDTO,
    unknown,
    UpdateGitSyncSettingQueryParams,
    GitSyncSettingsDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/git-sync-settings`, props, signal)

export interface GetGitSimplificationQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetGitSimplificationProps = Omit<
  GetProps<ResponseBoolean, unknown, GetGitSimplificationQueryParams, void>,
  'path'
>

/**
 * Get Git Simplification status for a project
 */
export const GetGitSimplification = (props: GetGitSimplificationProps) => (
  <Get<ResponseBoolean, unknown, GetGitSimplificationQueryParams, void>
    path={`/git-sync-settings/git-simplification`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGitSimplificationProps = Omit<
  UseGetProps<ResponseBoolean, unknown, GetGitSimplificationQueryParams, void>,
  'path'
>

/**
 * Get Git Simplification status for a project
 */
export const useGetGitSimplification = (props: UseGetGitSimplificationProps) =>
  useGet<ResponseBoolean, unknown, GetGitSimplificationQueryParams, void>(`/git-sync-settings/git-simplification`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Git Simplification status for a project
 */
export const getGitSimplificationPromise = (
  props: GetUsingFetchProps<ResponseBoolean, unknown, GetGitSimplificationQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, unknown, GetGitSimplificationQueryParams, void>(
    getConfig('ng/api'),
    `/git-sync-settings/git-simplification`,
    props,
    signal
  )

export interface EnableGitSimplificationQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type EnableGitSimplificationProps = Omit<
  MutateProps<ResponseString, unknown, EnableGitSimplificationQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Enable Git Simplification for a project
 */
export const EnableGitSimplification = (props: EnableGitSimplificationProps) => (
  <Mutate<ResponseString, unknown, EnableGitSimplificationQueryParams, void, void>
    verb="POST"
    path={`/git-sync-settings/git-simplification`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseEnableGitSimplificationProps = Omit<
  UseMutateProps<ResponseString, unknown, EnableGitSimplificationQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Enable Git Simplification for a project
 */
export const useEnableGitSimplification = (props: UseEnableGitSimplificationProps) =>
  useMutate<ResponseString, unknown, EnableGitSimplificationQueryParams, void, void>(
    'POST',
    `/git-sync-settings/git-simplification`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Enable Git Simplification for a project
 */
export const enableGitSimplificationPromise = (
  props: MutateUsingFetchProps<ResponseString, unknown, EnableGitSimplificationQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, unknown, EnableGitSimplificationQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/git-sync-settings/git-simplification`,
    props,
    signal
  )

export interface IsGitSyncEnabledQueryParams {
  accountIdentifier?: string
  projectIdentifier?: string
  orgIdentifier?: string
}

export type IsGitSyncEnabledProps = Omit<GetProps<GitEnabledDTO, unknown, IsGitSyncEnabledQueryParams, void>, 'path'>

/**
 * Is Git Sync EnabledForProject
 */
export const IsGitSyncEnabled = (props: IsGitSyncEnabledProps) => (
  <Get<GitEnabledDTO, unknown, IsGitSyncEnabledQueryParams, void>
    path={`/git-sync/git-sync-enabled`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseIsGitSyncEnabledProps = Omit<
  UseGetProps<GitEnabledDTO, unknown, IsGitSyncEnabledQueryParams, void>,
  'path'
>

/**
 * Is Git Sync EnabledForProject
 */
export const useIsGitSyncEnabled = (props: UseIsGitSyncEnabledProps) =>
  useGet<GitEnabledDTO, unknown, IsGitSyncEnabledQueryParams, void>(`/git-sync/git-sync-enabled`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Is Git Sync EnabledForProject
 */
export const isGitSyncEnabledPromise = (
  props: GetUsingFetchProps<GitEnabledDTO, unknown, IsGitSyncEnabledQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<GitEnabledDTO, unknown, IsGitSyncEnabledQueryParams, void>(
    getConfig('ng/api'),
    `/git-sync/git-sync-enabled`,
    props,
    signal
  )

export interface ResetGitSyncSDKCacheQueryParams {
  targetAccountIdentifier?: string
  targetOrgIdentifier?: string
  targetProjectIdentifier?: string
}

export type ResetGitSyncSDKCacheProps = Omit<
  MutateProps<void, void, ResetGitSyncSDKCacheQueryParams, void, void>,
  'path' | 'verb'
>

export const ResetGitSyncSDKCache = (props: ResetGitSyncSDKCacheProps) => (
  <Mutate<void, void, ResetGitSyncSDKCacheQueryParams, void, void>
    verb="POST"
    path={`/git-sync/reset-cache`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseResetGitSyncSDKCacheProps = Omit<
  UseMutateProps<void, void, ResetGitSyncSDKCacheQueryParams, void, void>,
  'path' | 'verb'
>

export const useResetGitSyncSDKCache = (props: UseResetGitSyncSDKCacheProps) =>
  useMutate<void, void, ResetGitSyncSDKCacheQueryParams, void, void>('POST', `/git-sync/reset-cache`, {
    base: getConfig('ng/api'),
    ...props
  })

export const resetGitSyncSDKCachePromise = (
  props: MutateUsingFetchProps<void, void, ResetGitSyncSDKCacheQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, void, ResetGitSyncSDKCacheQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/git-sync/reset-cache`,
    props,
    signal
  )

export interface PutGitSyncDefaultQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
}

export interface PutGitSyncDefaultPathParams {
  identifier: string
  folderIdentifier: string
}

export type PutGitSyncDefaultProps = Omit<
  MutateProps<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>,
  'path' | 'verb'
> &
  PutGitSyncDefaultPathParams

/**
 * Update Git Sync default by id
 */
export const PutGitSyncDefault = ({ identifier, folderIdentifier, ...props }: PutGitSyncDefaultProps) => (
  <Mutate<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>
    verb="PUT"
    path={`/git-sync/${identifier}/folder/${folderIdentifier}/default`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutGitSyncDefaultProps = Omit<
  UseMutateProps<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>,
  'path' | 'verb'
> &
  PutGitSyncDefaultPathParams

/**
 * Update Git Sync default by id
 */
export const usePutGitSyncDefault = ({ identifier, folderIdentifier, ...props }: UsePutGitSyncDefaultProps) =>
  useMutate<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>(
    'PUT',
    (paramsInPath: PutGitSyncDefaultPathParams) =>
      `/git-sync/${paramsInPath.identifier}/folder/${paramsInPath.folderIdentifier}/default`,
    { base: getConfig('ng/api'), pathParams: { identifier, folderIdentifier }, ...props }
  )

/**
 * Update Git Sync default by id
 */
export const putGitSyncDefaultPromise = (
  {
    identifier,
    folderIdentifier,
    ...props
  }: MutateUsingFetchProps<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams> & {
    identifier: string
    folderIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/git-sync/${identifier}/folder/${folderIdentifier}/default`,
    props,
    signal
  )

export interface GetClusterListQueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  environmentIdentifier: string
  searchTerm?: string
  identifiers?: string[]
  sort?: string[]
}

export type GetClusterListProps = Omit<
  GetProps<ResponsePageClusterResponse, Failure | Error, GetClusterListQueryParams, void>,
  'path'
>

/**
 * Gets cluster list
 */
export const GetClusterList = (props: GetClusterListProps) => (
  <Get<ResponsePageClusterResponse, Failure | Error, GetClusterListQueryParams, void>
    path={`/gitops/clusters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetClusterListProps = Omit<
  UseGetProps<ResponsePageClusterResponse, Failure | Error, GetClusterListQueryParams, void>,
  'path'
>

/**
 * Gets cluster list
 */
export const useGetClusterList = (props: UseGetClusterListProps) =>
  useGet<ResponsePageClusterResponse, Failure | Error, GetClusterListQueryParams, void>(`/gitops/clusters`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets cluster list
 */
export const getClusterListPromise = (
  props: GetUsingFetchProps<ResponsePageClusterResponse, Failure | Error, GetClusterListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageClusterResponse, Failure | Error, GetClusterListQueryParams, void>(
    getConfig('ng/api'),
    `/gitops/clusters`,
    props,
    signal
  )

export interface LinkClusterQueryParams {
  accountIdentifier: string
}

export type LinkClusterProps = Omit<
  MutateProps<ResponseClusterResponse, Failure | Error, LinkClusterQueryParams, ClusterRequest, void>,
  'path' | 'verb'
>

/**
 * Link a gitops cluster to an environment
 */
export const LinkCluster = (props: LinkClusterProps) => (
  <Mutate<ResponseClusterResponse, Failure | Error, LinkClusterQueryParams, ClusterRequest, void>
    verb="POST"
    path={`/gitops/clusters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseLinkClusterProps = Omit<
  UseMutateProps<ResponseClusterResponse, Failure | Error, LinkClusterQueryParams, ClusterRequest, void>,
  'path' | 'verb'
>

/**
 * Link a gitops cluster to an environment
 */
export const useLinkCluster = (props: UseLinkClusterProps) =>
  useMutate<ResponseClusterResponse, Failure | Error, LinkClusterQueryParams, ClusterRequest, void>(
    'POST',
    `/gitops/clusters`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Link a gitops cluster to an environment
 */
export const linkClusterPromise = (
  props: MutateUsingFetchProps<ResponseClusterResponse, Failure | Error, LinkClusterQueryParams, ClusterRequest, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseClusterResponse, Failure | Error, LinkClusterQueryParams, ClusterRequest, void>(
    'POST',
    getConfig('ng/api'),
    `/gitops/clusters`,
    props,
    signal
  )

export interface LinkClustersQueryParams {
  accountIdentifier: string
}

export type LinkClustersProps = Omit<
  MutateProps<
    ResponseClusterBatchResponse,
    Failure | Error,
    LinkClustersQueryParams,
    ClusterBatchRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Link gitops clusters to an environment
 */
export const LinkClusters = (props: LinkClustersProps) => (
  <Mutate<ResponseClusterBatchResponse, Failure | Error, LinkClustersQueryParams, ClusterBatchRequestRequestBody, void>
    verb="POST"
    path={`/gitops/clusters/batch`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseLinkClustersProps = Omit<
  UseMutateProps<
    ResponseClusterBatchResponse,
    Failure | Error,
    LinkClustersQueryParams,
    ClusterBatchRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Link gitops clusters to an environment
 */
export const useLinkClusters = (props: UseLinkClustersProps) =>
  useMutate<
    ResponseClusterBatchResponse,
    Failure | Error,
    LinkClustersQueryParams,
    ClusterBatchRequestRequestBody,
    void
  >('POST', `/gitops/clusters/batch`, { base: getConfig('ng/api'), ...props })

/**
 * Link gitops clusters to an environment
 */
export const linkClustersPromise = (
  props: MutateUsingFetchProps<
    ResponseClusterBatchResponse,
    Failure | Error,
    LinkClustersQueryParams,
    ClusterBatchRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseClusterBatchResponse,
    Failure | Error,
    LinkClustersQueryParams,
    ClusterBatchRequestRequestBody,
    void
  >('POST', getConfig('ng/api'), `/gitops/clusters/batch`, props, signal)

export interface UnlinkClustersInBatchQueryParams {
  accountIdentifier: string
}

export type UnlinkClustersInBatchProps = Omit<
  MutateProps<
    ResponseClusterBatchResponse,
    Failure | Error,
    UnlinkClustersInBatchQueryParams,
    ClusterBatchRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Unlink gitops clusters to an environment
 */
export const UnlinkClustersInBatch = (props: UnlinkClustersInBatchProps) => (
  <Mutate<
    ResponseClusterBatchResponse,
    Failure | Error,
    UnlinkClustersInBatchQueryParams,
    ClusterBatchRequestRequestBody,
    void
  >
    verb="POST"
    path={`/gitops/clusters/batchunlink`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUnlinkClustersInBatchProps = Omit<
  UseMutateProps<
    ResponseClusterBatchResponse,
    Failure | Error,
    UnlinkClustersInBatchQueryParams,
    ClusterBatchRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Unlink gitops clusters to an environment
 */
export const useUnlinkClustersInBatch = (props: UseUnlinkClustersInBatchProps) =>
  useMutate<
    ResponseClusterBatchResponse,
    Failure | Error,
    UnlinkClustersInBatchQueryParams,
    ClusterBatchRequestRequestBody,
    void
  >('POST', `/gitops/clusters/batchunlink`, { base: getConfig('ng/api'), ...props })

/**
 * Unlink gitops clusters to an environment
 */
export const unlinkClustersInBatchPromise = (
  props: MutateUsingFetchProps<
    ResponseClusterBatchResponse,
    Failure | Error,
    UnlinkClustersInBatchQueryParams,
    ClusterBatchRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseClusterBatchResponse,
    Failure | Error,
    UnlinkClustersInBatchQueryParams,
    ClusterBatchRequestRequestBody,
    void
  >('POST', getConfig('ng/api'), `/gitops/clusters/batchunlink`, props, signal)

export interface GetClusterListFromSourceQueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  scoped?: boolean
}

export type GetClusterListFromSourceProps = Omit<
  GetProps<ResponsePageClusterFromGitops, Failure | Error, GetClusterListFromSourceQueryParams, void>,
  'path'
>

/**
 * Gets cluster list from Gitops Service
 */
export const GetClusterListFromSource = (props: GetClusterListFromSourceProps) => (
  <Get<ResponsePageClusterFromGitops, Failure | Error, GetClusterListFromSourceQueryParams, void>
    path={`/gitops/clusters/listFromGitops`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetClusterListFromSourceProps = Omit<
  UseGetProps<ResponsePageClusterFromGitops, Failure | Error, GetClusterListFromSourceQueryParams, void>,
  'path'
>

/**
 * Gets cluster list from Gitops Service
 */
export const useGetClusterListFromSource = (props: UseGetClusterListFromSourceProps) =>
  useGet<ResponsePageClusterFromGitops, Failure | Error, GetClusterListFromSourceQueryParams, void>(
    `/gitops/clusters/listFromGitops`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets cluster list from Gitops Service
 */
export const getClusterListFromSourcePromise = (
  props: GetUsingFetchProps<ResponsePageClusterFromGitops, Failure | Error, GetClusterListFromSourceQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageClusterFromGitops, Failure | Error, GetClusterListFromSourceQueryParams, void>(
    getConfig('ng/api'),
    `/gitops/clusters/listFromGitops`,
    props,
    signal
  )

export interface DeleteClusterQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  environmentIdentifier?: string
  scope?: 'ACCOUNT' | 'ORGANIZATION' | 'PROJECT'
}

export type DeleteClusterProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteClusterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a Cluster by identifier
 */
export const DeleteCluster = (props: DeleteClusterProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteClusterQueryParams, string, void>
    verb="DELETE"
    path={`/gitops/clusters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteClusterProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteClusterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a Cluster by identifier
 */
export const useDeleteCluster = (props: UseDeleteClusterProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteClusterQueryParams, string, void>('DELETE', `/gitops/clusters`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a Cluster by identifier
 */
export const deleteClusterPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteClusterQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteClusterQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/gitops/clusters`,
    props,
    signal
  )

export interface GetClusterQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  environmentIdentifier?: string
  deleted?: boolean
}

export interface GetClusterPathParams {
  identifier: string
}

export type GetClusterProps = Omit<
  GetProps<ResponseClusterResponse, Failure | Error, GetClusterQueryParams, GetClusterPathParams>,
  'path'
> &
  GetClusterPathParams

/**
 * Gets a Cluster by identifier
 */
export const GetCluster = ({ identifier, ...props }: GetClusterProps) => (
  <Get<ResponseClusterResponse, Failure | Error, GetClusterQueryParams, GetClusterPathParams>
    path={`/gitops/clusters/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetClusterProps = Omit<
  UseGetProps<ResponseClusterResponse, Failure | Error, GetClusterQueryParams, GetClusterPathParams>,
  'path'
> &
  GetClusterPathParams

/**
 * Gets a Cluster by identifier
 */
export const useGetCluster = ({ identifier, ...props }: UseGetClusterProps) =>
  useGet<ResponseClusterResponse, Failure | Error, GetClusterQueryParams, GetClusterPathParams>(
    (paramsInPath: GetClusterPathParams) => `/gitops/clusters/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets a Cluster by identifier
 */
export const getClusterPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseClusterResponse, Failure | Error, GetClusterQueryParams, GetClusterPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseClusterResponse, Failure | Error, GetClusterQueryParams, GetClusterPathParams>(
    getConfig('ng/api'),
    `/gitops/clusters/${identifier}`,
    props,
    signal
  )

export interface CreateGitOpsProviderQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  repoName?: string
}

export type CreateGitOpsProviderProps = Omit<
  MutateProps<
    ResponseGitopsProviderResponse,
    Failure | Error,
    CreateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates a GitOpsProvider
 */
export const CreateGitOpsProvider = (props: CreateGitOpsProviderProps) => (
  <Mutate<
    ResponseGitopsProviderResponse,
    Failure | Error,
    CreateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >
    verb="POST"
    path={`/gitopsproviders`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateGitOpsProviderProps = Omit<
  UseMutateProps<
    ResponseGitopsProviderResponse,
    Failure | Error,
    CreateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates a GitOpsProvider
 */
export const useCreateGitOpsProvider = (props: UseCreateGitOpsProviderProps) =>
  useMutate<
    ResponseGitopsProviderResponse,
    Failure | Error,
    CreateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >('POST', `/gitopsproviders`, { base: getConfig('ng/api'), ...props })

/**
 * Creates a GitOpsProvider
 */
export const createGitOpsProviderPromise = (
  props: MutateUsingFetchProps<
    ResponseGitopsProviderResponse,
    Failure | Error,
    CreateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitopsProviderResponse,
    Failure | Error,
    CreateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >('POST', getConfig('ng/api'), `/gitopsproviders`, props, signal)

export interface UpdateGitOpsProviderQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  repoName?: string
}

export type UpdateGitOpsProviderProps = Omit<
  MutateProps<
    ResponseGitopsProviderResponse,
    Failure | Error,
    UpdateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Updates a GitOpsProvider
 */
export const UpdateGitOpsProvider = (props: UpdateGitOpsProviderProps) => (
  <Mutate<
    ResponseGitopsProviderResponse,
    Failure | Error,
    UpdateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >
    verb="PUT"
    path={`/gitopsproviders`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateGitOpsProviderProps = Omit<
  UseMutateProps<
    ResponseGitopsProviderResponse,
    Failure | Error,
    UpdateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Updates a GitOpsProvider
 */
export const useUpdateGitOpsProvider = (props: UseUpdateGitOpsProviderProps) =>
  useMutate<
    ResponseGitopsProviderResponse,
    Failure | Error,
    UpdateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >('PUT', `/gitopsproviders`, { base: getConfig('ng/api'), ...props })

/**
 * Updates a GitOpsProvider
 */
export const updateGitOpsProviderPromise = (
  props: MutateUsingFetchProps<
    ResponseGitopsProviderResponse,
    Failure | Error,
    UpdateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitopsProviderResponse,
    Failure | Error,
    UpdateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >('PUT', getConfig('ng/api'), `/gitopsproviders`, props, signal)

export interface ListGitOpsProvidersQueryParams {
  pageIndex?: number
  pageSize?: number
  sort?: string[]
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  type?: 'CONNECTED_ARGO_PROVIDER' | 'MANAGED_ARGO_PROVIDER'
}

export type ListGitOpsProvidersProps = Omit<
  GetProps<ResponsePageGitopsProviderResponse, Failure | Error, ListGitOpsProvidersQueryParams, void>,
  'path'
>

/**
 * List GitOps Providers
 */
export const ListGitOpsProviders = (props: ListGitOpsProvidersProps) => (
  <Get<ResponsePageGitopsProviderResponse, Failure | Error, ListGitOpsProvidersQueryParams, void>
    path={`/gitopsproviders/list`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitOpsProvidersProps = Omit<
  UseGetProps<ResponsePageGitopsProviderResponse, Failure | Error, ListGitOpsProvidersQueryParams, void>,
  'path'
>

/**
 * List GitOps Providers
 */
export const useListGitOpsProviders = (props: UseListGitOpsProvidersProps) =>
  useGet<ResponsePageGitopsProviderResponse, Failure | Error, ListGitOpsProvidersQueryParams, void>(
    `/gitopsproviders/list`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * List GitOps Providers
 */
export const listGitOpsProvidersPromise = (
  props: GetUsingFetchProps<ResponsePageGitopsProviderResponse, Failure | Error, ListGitOpsProvidersQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageGitopsProviderResponse, Failure | Error, ListGitOpsProvidersQueryParams, void>(
    getConfig('ng/api'),
    `/gitopsproviders/list`,
    props,
    signal
  )

export interface ValidateProviderIdentifierIsUniqueQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
}

export type ValidateProviderIdentifierIsUniqueProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateProviderIdentifierIsUniqueQueryParams, void>,
  'path'
>

/**
 * Validate Identifier is unique
 */
export const ValidateProviderIdentifierIsUnique = (props: ValidateProviderIdentifierIsUniqueProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateProviderIdentifierIsUniqueQueryParams, void>
    path={`/gitopsproviders/validateUniqueIdentifier`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateProviderIdentifierIsUniqueProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateProviderIdentifierIsUniqueQueryParams, void>,
  'path'
>

/**
 * Validate Identifier is unique
 */
export const useValidateProviderIdentifierIsUnique = (props: UseValidateProviderIdentifierIsUniqueProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateProviderIdentifierIsUniqueQueryParams, void>(
    `/gitopsproviders/validateUniqueIdentifier`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate Identifier is unique
 */
export const validateProviderIdentifierIsUniquePromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateProviderIdentifierIsUniqueQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateProviderIdentifierIsUniqueQueryParams, void>(
    getConfig('ng/api'),
    `/gitopsproviders/validateUniqueIdentifier`,
    props,
    signal
  )

export interface DeleteGitOpsProviderQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteGitOpsProviderProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteGitOpsProviderQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes a GitOpsProvider
 */
export const DeleteGitOpsProvider = (props: DeleteGitOpsProviderProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteGitOpsProviderQueryParams, string, void>
    verb="DELETE"
    path={`/gitopsproviders`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteGitOpsProviderProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteGitOpsProviderQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes a GitOpsProvider
 */
export const useDeleteGitOpsProvider = (props: UseDeleteGitOpsProviderProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteGitOpsProviderQueryParams, string, void>(
    'DELETE',
    `/gitopsproviders`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Deletes a GitOpsProvider
 */
export const deleteGitOpsProviderPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteGitOpsProviderQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteGitOpsProviderQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/gitopsproviders`,
    props,
    signal
  )

export interface GetGitOpsProviderQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetGitOpsProviderPathParams {
  identifier: string
}

export type GetGitOpsProviderProps = Omit<
  GetProps<ResponseGitopsProviderResponse, Failure | Error, GetGitOpsProviderQueryParams, GetGitOpsProviderPathParams>,
  'path'
> &
  GetGitOpsProviderPathParams

/**
 * Get GitOps Provider
 */
export const GetGitOpsProvider = ({ identifier, ...props }: GetGitOpsProviderProps) => (
  <Get<ResponseGitopsProviderResponse, Failure | Error, GetGitOpsProviderQueryParams, GetGitOpsProviderPathParams>
    path={`/gitopsproviders/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGitOpsProviderProps = Omit<
  UseGetProps<
    ResponseGitopsProviderResponse,
    Failure | Error,
    GetGitOpsProviderQueryParams,
    GetGitOpsProviderPathParams
  >,
  'path'
> &
  GetGitOpsProviderPathParams

/**
 * Get GitOps Provider
 */
export const useGetGitOpsProvider = ({ identifier, ...props }: UseGetGitOpsProviderProps) =>
  useGet<ResponseGitopsProviderResponse, Failure | Error, GetGitOpsProviderQueryParams, GetGitOpsProviderPathParams>(
    (paramsInPath: GetGitOpsProviderPathParams) => `/gitopsproviders/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get GitOps Provider
 */
export const getGitOpsProviderPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseGitopsProviderResponse,
    Failure | Error,
    GetGitOpsProviderQueryParams,
    GetGitOpsProviderPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseGitopsProviderResponse,
    Failure | Error,
    GetGitOpsProviderQueryParams,
    GetGitOpsProviderPathParams
  >(getConfig('ng/api'), `/gitopsproviders/${identifier}`, props, signal)

export type GetGcpRegionsProps = Omit<GetProps<ResponseListString, Failure | Error, void, void>, 'path'>

/**
 * Get GCP Regions
 */
export const GetGcpRegions = (props: GetGcpRegionsProps) => (
  <Get<ResponseListString, Failure | Error, void, void>
    path={`/google-secret-manager-connector/gcp-regions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGcpRegionsProps = Omit<UseGetProps<ResponseListString, Failure | Error, void, void>, 'path'>

/**
 * Get GCP Regions
 */
export const useGetGcpRegions = (props: UseGetGcpRegionsProps) =>
  useGet<ResponseListString, Failure | Error, void, void>(`/google-secret-manager-connector/gcp-regions`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get GCP Regions
 */
export const getGcpRegionsPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/google-secret-manager-connector/gcp-regions`,
    props,
    signal
  )

export type DoReadinessCheckProps = Omit<GetProps<ResponseString, unknown, void, void>, 'path'>

export const DoReadinessCheck = (props: DoReadinessCheckProps) => (
  <Get<ResponseString, unknown, void, void> path={`/health`} base={getConfig('ng/api')} {...props} />
)

export type UseDoReadinessCheckProps = Omit<UseGetProps<ResponseString, unknown, void, void>, 'path'>

export const useDoReadinessCheck = (props: UseDoReadinessCheckProps) =>
  useGet<ResponseString, unknown, void, void>(`/health`, { base: getConfig('ng/api'), ...props })

export const doReadinessCheckPromise = (
  props: GetUsingFetchProps<ResponseString, unknown, void, void>,
  signal?: RequestInit['signal']
) => getUsingFetch<ResponseString, unknown, void, void>(getConfig('ng/api'), `/health`, props, signal)

export type DoLivenessCheckProps = Omit<GetProps<RestResponseString, unknown, void, void>, 'path'>

export const DoLivenessCheck = (props: DoLivenessCheckProps) => (
  <Get<RestResponseString, unknown, void, void> path={`/health/liveness`} base={getConfig('ng/api')} {...props} />
)

export type UseDoLivenessCheckProps = Omit<UseGetProps<RestResponseString, unknown, void, void>, 'path'>

export const useDoLivenessCheck = (props: UseDoLivenessCheckProps) =>
  useGet<RestResponseString, unknown, void, void>(`/health/liveness`, { base: getConfig('ng/api'), ...props })

export const doLivenessCheckPromise = (
  props: GetUsingFetchProps<RestResponseString, unknown, void, void>,
  signal?: RequestInit['signal']
) => getUsingFetch<RestResponseString, unknown, void, void>(getConfig('ng/api'), `/health/liveness`, props, signal)

export interface ValidateHostsConnectivityQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier: string
}

export type ValidateHostsConnectivityProps = Omit<
  MutateProps<
    ResponseListHostValidationDTO,
    Failure | Error,
    ValidateHostsConnectivityQueryParams,
    HostValidationParamsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate hosts connectivity
 */
export const ValidateHostsConnectivity = (props: ValidateHostsConnectivityProps) => (
  <Mutate<
    ResponseListHostValidationDTO,
    Failure | Error,
    ValidateHostsConnectivityQueryParams,
    HostValidationParamsRequestBody,
    void
  >
    verb="POST"
    path={`/host-validation`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateHostsConnectivityProps = Omit<
  UseMutateProps<
    ResponseListHostValidationDTO,
    Failure | Error,
    ValidateHostsConnectivityQueryParams,
    HostValidationParamsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate hosts connectivity
 */
export const useValidateHostsConnectivity = (props: UseValidateHostsConnectivityProps) =>
  useMutate<
    ResponseListHostValidationDTO,
    Failure | Error,
    ValidateHostsConnectivityQueryParams,
    HostValidationParamsRequestBody,
    void
  >('POST', `/host-validation`, { base: getConfig('ng/api'), ...props })

/**
 * Validate hosts connectivity
 */
export const validateHostsConnectivityPromise = (
  props: MutateUsingFetchProps<
    ResponseListHostValidationDTO,
    Failure | Error,
    ValidateHostsConnectivityQueryParams,
    HostValidationParamsRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListHostValidationDTO,
    Failure | Error,
    ValidateHostsConnectivityQueryParams,
    HostValidationParamsRequestBody,
    void
  >('POST', getConfig('ng/api'), `/host-validation`, props, signal)

export interface FilterHostsByConnectorQueryParams {
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
}

export type FilterHostsByConnectorProps = Omit<
  MutateProps<ResponsePageHostDTO, Failure | Error, FilterHostsByConnectorQueryParams, HostFilterDTO, void>,
  'path' | 'verb'
>

/**
 * Get hosts filtered by connector
 */
export const FilterHostsByConnector = (props: FilterHostsByConnectorProps) => (
  <Mutate<ResponsePageHostDTO, Failure | Error, FilterHostsByConnectorQueryParams, HostFilterDTO, void>
    verb="POST"
    path={`/hosts/filter`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseFilterHostsByConnectorProps = Omit<
  UseMutateProps<ResponsePageHostDTO, Failure | Error, FilterHostsByConnectorQueryParams, HostFilterDTO, void>,
  'path' | 'verb'
>

/**
 * Get hosts filtered by connector
 */
export const useFilterHostsByConnector = (props: UseFilterHostsByConnectorProps) =>
  useMutate<ResponsePageHostDTO, Failure | Error, FilterHostsByConnectorQueryParams, HostFilterDTO, void>(
    'POST',
    `/hosts/filter`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get hosts filtered by connector
 */
export const filterHostsByConnectorPromise = (
  props: MutateUsingFetchProps<
    ResponsePageHostDTO,
    Failure | Error,
    FilterHostsByConnectorQueryParams,
    HostFilterDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponsePageHostDTO, Failure | Error, FilterHostsByConnectorQueryParams, HostFilterDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/hosts/filter`,
    props,
    signal
  )

export interface ValidateHostsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier: string
}

export type ValidateHostsProps = Omit<
  MutateProps<
    ResponseListHostValidationDTO,
    Failure | Error,
    ValidateHostsQueryParams,
    HostValidationParamsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate hosts connectivity
 */
export const ValidateHosts = (props: ValidateHostsProps) => (
  <Mutate<
    ResponseListHostValidationDTO,
    Failure | Error,
    ValidateHostsQueryParams,
    HostValidationParamsRequestBody,
    void
  >
    verb="POST"
    path={`/hosts/validate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateHostsProps = Omit<
  UseMutateProps<
    ResponseListHostValidationDTO,
    Failure | Error,
    ValidateHostsQueryParams,
    HostValidationParamsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate hosts connectivity
 */
export const useValidateHosts = (props: UseValidateHostsProps) =>
  useMutate<
    ResponseListHostValidationDTO,
    Failure | Error,
    ValidateHostsQueryParams,
    HostValidationParamsRequestBody,
    void
  >('POST', `/hosts/validate`, { base: getConfig('ng/api'), ...props })

/**
 * Validate hosts connectivity
 */
export const validateHostsPromise = (
  props: MutateUsingFetchProps<
    ResponseListHostValidationDTO,
    Failure | Error,
    ValidateHostsQueryParams,
    HostValidationParamsRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListHostValidationDTO,
    Failure | Error,
    ValidateHostsQueryParams,
    HostValidationParamsRequestBody,
    void
  >('POST', getConfig('ng/api'), `/hosts/validate`, props, signal)

export interface GetInfrastructureListQueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  environmentIdentifier?: string
  searchTerm?: string
  infraIdentifiers?: string[]
  deploymentType?:
    | 'Kubernetes'
    | 'NativeHelm'
    | 'Ssh'
    | 'WinRm'
    | 'ServerlessAwsLambda'
    | 'AzureWebApp'
    | 'CustomDeployment'
    | 'ECS'
    | 'Elastigroup'
    | 'TAS'
    | 'Asg'
    | 'GoogleCloudFunctions'
    | 'AwsLambda'
    | 'AWS_SAM'
  deploymentTemplateIdentifier?: string
  versionLabel?: string
  sort?: string[]
  serviceRefs?: string[]
  repoName?: string
}

export type GetInfrastructureListProps = Omit<
  GetProps<ResponsePageInfrastructureResponse, Failure | Error, GetInfrastructureListQueryParams, void>,
  'path'
>

/**
 * Gets Infrastructure list
 */
export const GetInfrastructureList = (props: GetInfrastructureListProps) => (
  <Get<ResponsePageInfrastructureResponse, Failure | Error, GetInfrastructureListQueryParams, void>
    path={`/infrastructures`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInfrastructureListProps = Omit<
  UseGetProps<ResponsePageInfrastructureResponse, Failure | Error, GetInfrastructureListQueryParams, void>,
  'path'
>

/**
 * Gets Infrastructure list
 */
export const useGetInfrastructureList = (props: UseGetInfrastructureListProps) =>
  useGet<ResponsePageInfrastructureResponse, Failure | Error, GetInfrastructureListQueryParams, void>(
    `/infrastructures`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Infrastructure list
 */
export const getInfrastructureListPromise = (
  props: GetUsingFetchProps<
    ResponsePageInfrastructureResponse,
    Failure | Error,
    GetInfrastructureListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageInfrastructureResponse, Failure | Error, GetInfrastructureListQueryParams, void>(
    getConfig('ng/api'),
    `/infrastructures`,
    props,
    signal
  )

export interface CreateInfrastructureQueryParams {
  accountIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  repoName?: string
}

export type CreateInfrastructureProps = Omit<
  MutateProps<
    ResponseInfrastructureResponse,
    Failure | Error,
    CreateInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Infrastructure in an Environment
 */
export const CreateInfrastructure = (props: CreateInfrastructureProps) => (
  <Mutate<
    ResponseInfrastructureResponse,
    Failure | Error,
    CreateInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/infrastructures`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateInfrastructureProps = Omit<
  UseMutateProps<
    ResponseInfrastructureResponse,
    Failure | Error,
    CreateInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Infrastructure in an Environment
 */
export const useCreateInfrastructure = (props: UseCreateInfrastructureProps) =>
  useMutate<
    ResponseInfrastructureResponse,
    Failure | Error,
    CreateInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >('POST', `/infrastructures`, { base: getConfig('ng/api'), ...props })

/**
 * Create an Infrastructure in an Environment
 */
export const createInfrastructurePromise = (
  props: MutateUsingFetchProps<
    ResponseInfrastructureResponse,
    Failure | Error,
    CreateInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInfrastructureResponse,
    Failure | Error,
    CreateInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/infrastructures`, props, signal)

export interface UpdateInfrastructureQueryParams {
  accountIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  lastCommitId?: string
  isNewBranch?: boolean
}

export type UpdateInfrastructureProps = Omit<
  MutateProps<
    ResponseInfrastructureResponse,
    Failure | Error,
    UpdateInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an Infrastructure by identifier
 */
export const UpdateInfrastructure = (props: UpdateInfrastructureProps) => (
  <Mutate<
    ResponseInfrastructureResponse,
    Failure | Error,
    UpdateInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >
    verb="PUT"
    path={`/infrastructures`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateInfrastructureProps = Omit<
  UseMutateProps<
    ResponseInfrastructureResponse,
    Failure | Error,
    UpdateInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an Infrastructure by identifier
 */
export const useUpdateInfrastructure = (props: UseUpdateInfrastructureProps) =>
  useMutate<
    ResponseInfrastructureResponse,
    Failure | Error,
    UpdateInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >('PUT', `/infrastructures`, { base: getConfig('ng/api'), ...props })

/**
 * Update an Infrastructure by identifier
 */
export const updateInfrastructurePromise = (
  props: MutateUsingFetchProps<
    ResponseInfrastructureResponse,
    Failure | Error,
    UpdateInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInfrastructureResponse,
    Failure | Error,
    UpdateInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/infrastructures`, props, signal)

export interface CreateInfrastructuresQueryParams {
  accountIdentifier: string
}

export type CreateInfrastructuresProps = Omit<
  MutateProps<
    ResponsePageInfrastructureResponse,
    Failure | Error,
    CreateInfrastructuresQueryParams,
    InfrastructureRequestDTO[],
    void
  >,
  'path' | 'verb'
>

/**
 * Create Infrastructures
 */
export const CreateInfrastructures = (props: CreateInfrastructuresProps) => (
  <Mutate<
    ResponsePageInfrastructureResponse,
    Failure | Error,
    CreateInfrastructuresQueryParams,
    InfrastructureRequestDTO[],
    void
  >
    verb="POST"
    path={`/infrastructures/batch`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateInfrastructuresProps = Omit<
  UseMutateProps<
    ResponsePageInfrastructureResponse,
    Failure | Error,
    CreateInfrastructuresQueryParams,
    InfrastructureRequestDTO[],
    void
  >,
  'path' | 'verb'
>

/**
 * Create Infrastructures
 */
export const useCreateInfrastructures = (props: UseCreateInfrastructuresProps) =>
  useMutate<
    ResponsePageInfrastructureResponse,
    Failure | Error,
    CreateInfrastructuresQueryParams,
    InfrastructureRequestDTO[],
    void
  >('POST', `/infrastructures/batch`, { base: getConfig('ng/api'), ...props })

/**
 * Create Infrastructures
 */
export const createInfrastructuresPromise = (
  props: MutateUsingFetchProps<
    ResponsePageInfrastructureResponse,
    Failure | Error,
    CreateInfrastructuresQueryParams,
    InfrastructureRequestDTO[],
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageInfrastructureResponse,
    Failure | Error,
    CreateInfrastructuresQueryParams,
    InfrastructureRequestDTO[],
    void
  >('POST', getConfig('ng/api'), `/infrastructures/batch`, props, signal)

export type DummyInfraConfigApiProps = Omit<GetProps<ResponseInfrastructureConfig, Failure | Error, void, void>, 'path'>

/**
 * This is dummy api to expose infraConfig
 */
export const DummyInfraConfigApi = (props: DummyInfraConfigApiProps) => (
  <Get<ResponseInfrastructureConfig, Failure | Error, void, void>
    path={`/infrastructures/dummy-infraConfig-api`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDummyInfraConfigApiProps = Omit<
  UseGetProps<ResponseInfrastructureConfig, Failure | Error, void, void>,
  'path'
>

/**
 * This is dummy api to expose infraConfig
 */
export const useDummyInfraConfigApi = (props: UseDummyInfraConfigApiProps) =>
  useGet<ResponseInfrastructureConfig, Failure | Error, void, void>(`/infrastructures/dummy-infraConfig-api`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * This is dummy api to expose infraConfig
 */
export const dummyInfraConfigApiPromise = (
  props: GetUsingFetchProps<ResponseInfrastructureConfig, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseInfrastructureConfig, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/infrastructures/dummy-infraConfig-api`,
    props,
    signal
  )

export interface GetInfrastructureYamlAndRuntimeInputsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  environmentIdentifier: string
}

export type GetInfrastructureYamlAndRuntimeInputsProps = Omit<
  MutateProps<
    ResponseInfrastructureYamlMetadataDTO,
    Failure | Error,
    GetInfrastructureYamlAndRuntimeInputsQueryParams,
    InfrastructureYamlMetadataApiInput,
    void
  >,
  'path' | 'verb'
>

/**
 * This api returns infrastructure YAML and runtime input YAML
 */
export const GetInfrastructureYamlAndRuntimeInputs = (props: GetInfrastructureYamlAndRuntimeInputsProps) => (
  <Mutate<
    ResponseInfrastructureYamlMetadataDTO,
    Failure | Error,
    GetInfrastructureYamlAndRuntimeInputsQueryParams,
    InfrastructureYamlMetadataApiInput,
    void
  >
    verb="POST"
    path={`/infrastructures/infrastructureYamlMetadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInfrastructureYamlAndRuntimeInputsProps = Omit<
  UseMutateProps<
    ResponseInfrastructureYamlMetadataDTO,
    Failure | Error,
    GetInfrastructureYamlAndRuntimeInputsQueryParams,
    InfrastructureYamlMetadataApiInput,
    void
  >,
  'path' | 'verb'
>

/**
 * This api returns infrastructure YAML and runtime input YAML
 */
export const useGetInfrastructureYamlAndRuntimeInputs = (props: UseGetInfrastructureYamlAndRuntimeInputsProps) =>
  useMutate<
    ResponseInfrastructureYamlMetadataDTO,
    Failure | Error,
    GetInfrastructureYamlAndRuntimeInputsQueryParams,
    InfrastructureYamlMetadataApiInput,
    void
  >('POST', `/infrastructures/infrastructureYamlMetadata`, { base: getConfig('ng/api'), ...props })

/**
 * This api returns infrastructure YAML and runtime input YAML
 */
export const getInfrastructureYamlAndRuntimeInputsPromise = (
  props: MutateUsingFetchProps<
    ResponseInfrastructureYamlMetadataDTO,
    Failure | Error,
    GetInfrastructureYamlAndRuntimeInputsQueryParams,
    InfrastructureYamlMetadataApiInput,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInfrastructureYamlMetadataDTO,
    Failure | Error,
    GetInfrastructureYamlAndRuntimeInputsQueryParams,
    InfrastructureYamlMetadataApiInput,
    void
  >('POST', getConfig('ng/api'), `/infrastructures/infrastructureYamlMetadata`, props, signal)

export interface GetInfrastructureAccessListQueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  infraIdentifiers?: string[]
  deploymentType?:
    | 'Kubernetes'
    | 'NativeHelm'
    | 'Ssh'
    | 'WinRm'
    | 'ServerlessAwsLambda'
    | 'AzureWebApp'
    | 'CustomDeployment'
    | 'ECS'
    | 'Elastigroup'
    | 'TAS'
    | 'Asg'
    | 'GoogleCloudFunctions'
    | 'AwsLambda'
    | 'AWS_SAM'
  deploymentTemplateIdentifier?: string
  versionLabel?: string
  sort?: string[]
  serviceRefs?: string[]
  repoName?: string
}

export type GetInfrastructureAccessListProps = Omit<
  GetProps<ResponseListInfrastructureResponse, Failure | Error, GetInfrastructureAccessListQueryParams, void>,
  'path'
>

/**
 * Gets Infrastructure access list
 */
export const GetInfrastructureAccessList = (props: GetInfrastructureAccessListProps) => (
  <Get<ResponseListInfrastructureResponse, Failure | Error, GetInfrastructureAccessListQueryParams, void>
    path={`/infrastructures/list-access`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInfrastructureAccessListProps = Omit<
  UseGetProps<ResponseListInfrastructureResponse, Failure | Error, GetInfrastructureAccessListQueryParams, void>,
  'path'
>

/**
 * Gets Infrastructure access list
 */
export const useGetInfrastructureAccessList = (props: UseGetInfrastructureAccessListProps) =>
  useGet<ResponseListInfrastructureResponse, Failure | Error, GetInfrastructureAccessListQueryParams, void>(
    `/infrastructures/list-access`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Infrastructure access list
 */
export const getInfrastructureAccessListPromise = (
  props: GetUsingFetchProps<
    ResponseListInfrastructureResponse,
    Failure | Error,
    GetInfrastructureAccessListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListInfrastructureResponse, Failure | Error, GetInfrastructureAccessListQueryParams, void>(
    getConfig('ng/api'),
    `/infrastructures/list-access`,
    props,
    signal
  )

export interface MergeInfraInputsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  environmentIdentifier: string
}

export interface MergeInfraInputsPathParams {
  infraIdentifier: string
}

export type MergeInfraInputsProps = Omit<
  MutateProps<
    ResponseInfrastructureInputsMergedResponseDto,
    Failure | Error,
    MergeInfraInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeInfraInputsPathParams
  >,
  'path' | 'verb'
> &
  MergeInfraInputsPathParams

/**
 * This api merges old and new infrastructure inputs YAML
 */
export const MergeInfraInputs = ({ infraIdentifier, ...props }: MergeInfraInputsProps) => (
  <Mutate<
    ResponseInfrastructureInputsMergedResponseDto,
    Failure | Error,
    MergeInfraInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeInfraInputsPathParams
  >
    verb="POST"
    path={`/infrastructures/mergeInfrastructureInputs/${infraIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseMergeInfraInputsProps = Omit<
  UseMutateProps<
    ResponseInfrastructureInputsMergedResponseDto,
    Failure | Error,
    MergeInfraInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeInfraInputsPathParams
  >,
  'path' | 'verb'
> &
  MergeInfraInputsPathParams

/**
 * This api merges old and new infrastructure inputs YAML
 */
export const useMergeInfraInputs = ({ infraIdentifier, ...props }: UseMergeInfraInputsProps) =>
  useMutate<
    ResponseInfrastructureInputsMergedResponseDto,
    Failure | Error,
    MergeInfraInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeInfraInputsPathParams
  >(
    'POST',
    (paramsInPath: MergeInfraInputsPathParams) =>
      `/infrastructures/mergeInfrastructureInputs/${paramsInPath.infraIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { infraIdentifier }, ...props }
  )

/**
 * This api merges old and new infrastructure inputs YAML
 */
export const mergeInfraInputsPromise = (
  {
    infraIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseInfrastructureInputsMergedResponseDto,
    Failure | Error,
    MergeInfraInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeInfraInputsPathParams
  > & { infraIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInfrastructureInputsMergedResponseDto,
    Failure | Error,
    MergeInfraInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeInfraInputsPathParams
  >('POST', getConfig('ng/api'), `/infrastructures/mergeInfrastructureInputs/${infraIdentifier}`, props, signal)

export interface GetInfrastructureInputsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  environmentIdentifier: string
  infraIdentifiers?: string[]
  deployToAll?: boolean
}

export type GetInfrastructureInputsProps = Omit<
  GetProps<ResponseNGEntityTemplateResponseDTO, Failure | Error, GetInfrastructureInputsQueryParams, void>,
  'path'
>

/**
 * This api returns Infrastructure Definition inputs YAML
 */
export const GetInfrastructureInputs = (props: GetInfrastructureInputsProps) => (
  <Get<ResponseNGEntityTemplateResponseDTO, Failure | Error, GetInfrastructureInputsQueryParams, void>
    path={`/infrastructures/runtimeInputs`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInfrastructureInputsProps = Omit<
  UseGetProps<ResponseNGEntityTemplateResponseDTO, Failure | Error, GetInfrastructureInputsQueryParams, void>,
  'path'
>

/**
 * This api returns Infrastructure Definition inputs YAML
 */
export const useGetInfrastructureInputs = (props: UseGetInfrastructureInputsProps) =>
  useGet<ResponseNGEntityTemplateResponseDTO, Failure | Error, GetInfrastructureInputsQueryParams, void>(
    `/infrastructures/runtimeInputs`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * This api returns Infrastructure Definition inputs YAML
 */
export const getInfrastructureInputsPromise = (
  props: GetUsingFetchProps<
    ResponseNGEntityTemplateResponseDTO,
    Failure | Error,
    GetInfrastructureInputsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNGEntityTemplateResponseDTO, Failure | Error, GetInfrastructureInputsQueryParams, void>(
    getConfig('ng/api'),
    `/infrastructures/runtimeInputs`,
    props,
    signal
  )

export interface UpsertInfrastructureQueryParams {
  accountIdentifier: string
}

export type UpsertInfrastructureProps = Omit<
  MutateProps<
    ResponseInfrastructureResponse,
    Failure | Error,
    UpsertInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an Infrastructure by identifier
 */
export const UpsertInfrastructure = (props: UpsertInfrastructureProps) => (
  <Mutate<
    ResponseInfrastructureResponse,
    Failure | Error,
    UpsertInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >
    verb="PUT"
    path={`/infrastructures/upsert`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertInfrastructureProps = Omit<
  UseMutateProps<
    ResponseInfrastructureResponse,
    Failure | Error,
    UpsertInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an Infrastructure by identifier
 */
export const useUpsertInfrastructure = (props: UseUpsertInfrastructureProps) =>
  useMutate<
    ResponseInfrastructureResponse,
    Failure | Error,
    UpsertInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >('PUT', `/infrastructures/upsert`, { base: getConfig('ng/api'), ...props })

/**
 * Upsert an Infrastructure by identifier
 */
export const upsertInfrastructurePromise = (
  props: MutateUsingFetchProps<
    ResponseInfrastructureResponse,
    Failure | Error,
    UpsertInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInfrastructureResponse,
    Failure | Error,
    UpsertInfrastructureQueryParams,
    InfrastructureRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/infrastructures/upsert`, props, signal)

export interface GetInfrastructureYamlAndRuntimeInputsV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  environmentIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetInfrastructureYamlAndRuntimeInputsV2Props = Omit<
  MutateProps<
    ResponseInfrastructureYamlMetadataDTO,
    Failure | Error,
    GetInfrastructureYamlAndRuntimeInputsV2QueryParams,
    InfrastructureYamlMetadataApiInputV2,
    void
  >,
  'path' | 'verb'
>

/**
 * This api returns infrastructure YAML and runtime input YAML
 */
export const GetInfrastructureYamlAndRuntimeInputsV2 = (props: GetInfrastructureYamlAndRuntimeInputsV2Props) => (
  <Mutate<
    ResponseInfrastructureYamlMetadataDTO,
    Failure | Error,
    GetInfrastructureYamlAndRuntimeInputsV2QueryParams,
    InfrastructureYamlMetadataApiInputV2,
    void
  >
    verb="POST"
    path={`/infrastructures/v2/infrastructure-yaml-metadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInfrastructureYamlAndRuntimeInputsV2Props = Omit<
  UseMutateProps<
    ResponseInfrastructureYamlMetadataDTO,
    Failure | Error,
    GetInfrastructureYamlAndRuntimeInputsV2QueryParams,
    InfrastructureYamlMetadataApiInputV2,
    void
  >,
  'path' | 'verb'
>

/**
 * This api returns infrastructure YAML and runtime input YAML
 */
export const useGetInfrastructureYamlAndRuntimeInputsV2 = (props: UseGetInfrastructureYamlAndRuntimeInputsV2Props) =>
  useMutate<
    ResponseInfrastructureYamlMetadataDTO,
    Failure | Error,
    GetInfrastructureYamlAndRuntimeInputsV2QueryParams,
    InfrastructureYamlMetadataApiInputV2,
    void
  >('POST', `/infrastructures/v2/infrastructure-yaml-metadata`, { base: getConfig('ng/api'), ...props })

/**
 * This api returns infrastructure YAML and runtime input YAML
 */
export const getInfrastructureYamlAndRuntimeInputsV2Promise = (
  props: MutateUsingFetchProps<
    ResponseInfrastructureYamlMetadataDTO,
    Failure | Error,
    GetInfrastructureYamlAndRuntimeInputsV2QueryParams,
    InfrastructureYamlMetadataApiInputV2,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInfrastructureYamlMetadataDTO,
    Failure | Error,
    GetInfrastructureYamlAndRuntimeInputsV2QueryParams,
    InfrastructureYamlMetadataApiInputV2,
    void
  >('POST', getConfig('ng/api'), `/infrastructures/v2/infrastructure-yaml-metadata`, props, signal)

export interface DeleteInfrastructureQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  environmentIdentifier?: string
  forceDelete?: boolean
}

export type DeleteInfrastructureProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteInfrastructureQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an infrastructure by identifier
 */
export const DeleteInfrastructure = (props: DeleteInfrastructureProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteInfrastructureQueryParams, string, void>
    verb="DELETE"
    path={`/infrastructures`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteInfrastructureProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteInfrastructureQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an infrastructure by identifier
 */
export const useDeleteInfrastructure = (props: UseDeleteInfrastructureProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteInfrastructureQueryParams, string, void>(
    'DELETE',
    `/infrastructures`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete an infrastructure by identifier
 */
export const deleteInfrastructurePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteInfrastructureQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteInfrastructureQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/infrastructures`,
    props,
    signal
  )

export interface GetInfrastructureQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  environmentIdentifier: string
  deleted?: boolean
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  loadFromFallbackBranch?: boolean
}

export interface GetInfrastructurePathParams {
  infraIdentifier: string
}

export type GetInfrastructureProps = Omit<
  GetProps<ResponseInfrastructureResponse, Failure | Error, GetInfrastructureQueryParams, GetInfrastructurePathParams>,
  'path'
> &
  GetInfrastructurePathParams

/**
 * Gets an Infrastructure by identifier
 */
export const GetInfrastructure = ({ infraIdentifier, ...props }: GetInfrastructureProps) => (
  <Get<ResponseInfrastructureResponse, Failure | Error, GetInfrastructureQueryParams, GetInfrastructurePathParams>
    path={`/infrastructures/${infraIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInfrastructureProps = Omit<
  UseGetProps<
    ResponseInfrastructureResponse,
    Failure | Error,
    GetInfrastructureQueryParams,
    GetInfrastructurePathParams
  >,
  'path'
> &
  GetInfrastructurePathParams

/**
 * Gets an Infrastructure by identifier
 */
export const useGetInfrastructure = ({ infraIdentifier, ...props }: UseGetInfrastructureProps) =>
  useGet<ResponseInfrastructureResponse, Failure | Error, GetInfrastructureQueryParams, GetInfrastructurePathParams>(
    (paramsInPath: GetInfrastructurePathParams) => `/infrastructures/${paramsInPath.infraIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { infraIdentifier }, ...props }
  )

/**
 * Gets an Infrastructure by identifier
 */
export const getInfrastructurePromise = (
  {
    infraIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseInfrastructureResponse,
    Failure | Error,
    GetInfrastructureQueryParams,
    GetInfrastructurePathParams
  > & { infraIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInfrastructureResponse,
    Failure | Error,
    GetInfrastructureQueryParams,
    GetInfrastructurePathParams
  >(getConfig('ng/api'), `/infrastructures/${infraIdentifier}`, props, signal)

export interface GetInstanceNGDataQueryParams {
  accountIdentifier: string
  instanceInfoPodName: string
  instanceInfoNamespace: string
}

export type GetInstanceNGDataProps = Omit<
  GetProps<ResponseOptionalHarnessServiceInfoNG, Failure | Error, GetInstanceNGDataQueryParams, void>,
  'path'
>

/**
 * Get instance NG data
 */
export const GetInstanceNGData = (props: GetInstanceNGDataProps) => (
  <Get<ResponseOptionalHarnessServiceInfoNG, Failure | Error, GetInstanceNGDataQueryParams, void>
    path={`/instanceng`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInstanceNGDataProps = Omit<
  UseGetProps<ResponseOptionalHarnessServiceInfoNG, Failure | Error, GetInstanceNGDataQueryParams, void>,
  'path'
>

/**
 * Get instance NG data
 */
export const useGetInstanceNGData = (props: UseGetInstanceNGDataProps) =>
  useGet<ResponseOptionalHarnessServiceInfoNG, Failure | Error, GetInstanceNGDataQueryParams, void>(`/instanceng`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get instance NG data
 */
export const getInstanceNGDataPromise = (
  props: GetUsingFetchProps<ResponseOptionalHarnessServiceInfoNG, Failure | Error, GetInstanceNGDataQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseOptionalHarnessServiceInfoNG, Failure | Error, GetInstanceNGDataQueryParams, void>(
    getConfig('ng/api'),
    `/instanceng`,
    props,
    signal
  )

export interface GetStageInstanceInfoQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineExecutionId: string
  stageExecutionId: string
}

export type GetStageInstanceInfoProps = Omit<
  GetProps<ResponseListStepExecutionInstanceInfo, Failure | Error, GetStageInstanceInfoQueryParams, void>,
  'path'
>

/**
 * Get instance info deployed in previous steps of stage
 */
export const GetStageInstanceInfo = (props: GetStageInstanceInfoProps) => (
  <Get<ResponseListStepExecutionInstanceInfo, Failure | Error, GetStageInstanceInfoQueryParams, void>
    path={`/instanceng/stage-instance-info`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetStageInstanceInfoProps = Omit<
  UseGetProps<ResponseListStepExecutionInstanceInfo, Failure | Error, GetStageInstanceInfoQueryParams, void>,
  'path'
>

/**
 * Get instance info deployed in previous steps of stage
 */
export const useGetStageInstanceInfo = (props: UseGetStageInstanceInfoProps) =>
  useGet<ResponseListStepExecutionInstanceInfo, Failure | Error, GetStageInstanceInfoQueryParams, void>(
    `/instanceng/stage-instance-info`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get instance info deployed in previous steps of stage
 */
export const getStageInstanceInfoPromise = (
  props: GetUsingFetchProps<
    ResponseListStepExecutionInstanceInfo,
    Failure | Error,
    GetStageInstanceInfoQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListStepExecutionInstanceInfo, Failure | Error, GetStageInstanceInfoQueryParams, void>(
    getConfig('ng/api'),
    `/instanceng/stage-instance-info`,
    props,
    signal
  )

export interface DeleteGitOpsInstancesQueryParams {
  accountIdentifier?: string
}

export type DeleteGitOpsInstancesProps = Omit<
  MutateProps<
    ResponseDeleteInstancesRequest,
    Failure | Error,
    DeleteGitOpsInstancesQueryParams,
    GitOpsInstanceRequestArrayRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Delete instances
 */
export const DeleteGitOpsInstances = (props: DeleteGitOpsInstancesProps) => (
  <Mutate<
    ResponseDeleteInstancesRequest,
    Failure | Error,
    DeleteGitOpsInstancesQueryParams,
    GitOpsInstanceRequestArrayRequestBody,
    void
  >
    verb="DELETE"
    path={`/instancesync/gitops`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteGitOpsInstancesProps = Omit<
  UseMutateProps<
    ResponseDeleteInstancesRequest,
    Failure | Error,
    DeleteGitOpsInstancesQueryParams,
    GitOpsInstanceRequestArrayRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Delete instances
 */
export const useDeleteGitOpsInstances = (props: UseDeleteGitOpsInstancesProps) =>
  useMutate<
    ResponseDeleteInstancesRequest,
    Failure | Error,
    DeleteGitOpsInstancesQueryParams,
    GitOpsInstanceRequestArrayRequestBody,
    void
  >('DELETE', `/instancesync/gitops`, { base: getConfig('ng/api'), ...props })

/**
 * Delete instances
 */
export const deleteGitOpsInstancesPromise = (
  props: MutateUsingFetchProps<
    ResponseDeleteInstancesRequest,
    Failure | Error,
    DeleteGitOpsInstancesQueryParams,
    GitOpsInstanceRequestArrayRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDeleteInstancesRequest,
    Failure | Error,
    DeleteGitOpsInstancesQueryParams,
    GitOpsInstanceRequestArrayRequestBody,
    void
  >('DELETE', getConfig('ng/api'), `/instancesync/gitops`, props, signal)

export interface ProcessGitOpsInstancesQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  agentIdentifier?: string
}

export type ProcessGitOpsInstancesProps = Omit<
  MutateProps<
    ResponseBoolean,
    Failure | Error,
    ProcessGitOpsInstancesQueryParams,
    GitOpsInstanceRequestArrayRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Process Gitops instances
 */
export const ProcessGitOpsInstances = (props: ProcessGitOpsInstancesProps) => (
  <Mutate<
    ResponseBoolean,
    Failure | Error,
    ProcessGitOpsInstancesQueryParams,
    GitOpsInstanceRequestArrayRequestBody,
    void
  >
    verb="POST"
    path={`/instancesync/gitops`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseProcessGitOpsInstancesProps = Omit<
  UseMutateProps<
    ResponseBoolean,
    Failure | Error,
    ProcessGitOpsInstancesQueryParams,
    GitOpsInstanceRequestArrayRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Process Gitops instances
 */
export const useProcessGitOpsInstances = (props: UseProcessGitOpsInstancesProps) =>
  useMutate<
    ResponseBoolean,
    Failure | Error,
    ProcessGitOpsInstancesQueryParams,
    GitOpsInstanceRequestArrayRequestBody,
    void
  >('POST', `/instancesync/gitops`, { base: getConfig('ng/api'), ...props })

/**
 * Process Gitops instances
 */
export const processGitOpsInstancesPromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    ProcessGitOpsInstancesQueryParams,
    GitOpsInstanceRequestArrayRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    Failure | Error,
    ProcessGitOpsInstancesQueryParams,
    GitOpsInstanceRequestArrayRequestBody,
    void
  >('POST', getConfig('ng/api'), `/instancesync/gitops`, props, signal)

export interface GetInstanceSyncPerpetualTaskResponseQueryParams {
  accountIdentifier: string
  perpetualTaskId: string
}

export type GetInstanceSyncPerpetualTaskResponseProps = Omit<
  MutateProps<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskResponseQueryParams,
    DelegateResponseDataRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get instance sync perpetual task response
 */
export const GetInstanceSyncPerpetualTaskResponse = (props: GetInstanceSyncPerpetualTaskResponseProps) => (
  <Mutate<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskResponseQueryParams,
    DelegateResponseDataRequestBody,
    void
  >
    verb="POST"
    path={`/instancesync/response`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInstanceSyncPerpetualTaskResponseProps = Omit<
  UseMutateProps<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskResponseQueryParams,
    DelegateResponseDataRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get instance sync perpetual task response
 */
export const useGetInstanceSyncPerpetualTaskResponse = (props: UseGetInstanceSyncPerpetualTaskResponseProps) =>
  useMutate<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskResponseQueryParams,
    DelegateResponseDataRequestBody,
    void
  >('POST', `/instancesync/response`, { base: getConfig('ng/api'), ...props })

/**
 * Get instance sync perpetual task response
 */
export const getInstanceSyncPerpetualTaskResponsePromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskResponseQueryParams,
    DelegateResponseDataRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskResponseQueryParams,
    DelegateResponseDataRequestBody,
    void
  >('POST', getConfig('ng/api'), `/instancesync/response`, props, signal)

export interface FetchTaskDetailsQueryParams {
  page?: number
  page_size?: number
  accountIdentifier: string
}

export interface FetchTaskDetailsPathParams {
  perpetualTaskId: string
}

export type FetchTaskDetailsProps = Omit<
  GetProps<ResponseInstanceSyncTaskDetails, Failure | Error, FetchTaskDetailsQueryParams, FetchTaskDetailsPathParams>,
  'path'
> &
  FetchTaskDetailsPathParams

/**
 * Get instance sync perpetual task details
 */
export const FetchTaskDetails = ({ perpetualTaskId, ...props }: FetchTaskDetailsProps) => (
  <Get<ResponseInstanceSyncTaskDetails, Failure | Error, FetchTaskDetailsQueryParams, FetchTaskDetailsPathParams>
    path={`/instancesync/task/${perpetualTaskId}/details`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseFetchTaskDetailsProps = Omit<
  UseGetProps<
    ResponseInstanceSyncTaskDetails,
    Failure | Error,
    FetchTaskDetailsQueryParams,
    FetchTaskDetailsPathParams
  >,
  'path'
> &
  FetchTaskDetailsPathParams

/**
 * Get instance sync perpetual task details
 */
export const useFetchTaskDetails = ({ perpetualTaskId, ...props }: UseFetchTaskDetailsProps) =>
  useGet<ResponseInstanceSyncTaskDetails, Failure | Error, FetchTaskDetailsQueryParams, FetchTaskDetailsPathParams>(
    (paramsInPath: FetchTaskDetailsPathParams) => `/instancesync/task/${paramsInPath.perpetualTaskId}/details`,
    { base: getConfig('ng/api'), pathParams: { perpetualTaskId }, ...props }
  )

/**
 * Get instance sync perpetual task details
 */
export const fetchTaskDetailsPromise = (
  {
    perpetualTaskId,
    ...props
  }: GetUsingFetchProps<
    ResponseInstanceSyncTaskDetails,
    Failure | Error,
    FetchTaskDetailsQueryParams,
    FetchTaskDetailsPathParams
  > & { perpetualTaskId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInstanceSyncTaskDetails,
    Failure | Error,
    FetchTaskDetailsQueryParams,
    FetchTaskDetailsPathParams
  >(getConfig('ng/api'), `/instancesync/task/${perpetualTaskId}/details`, props, signal)

export interface GetInstanceSyncPerpetualTaskResponseV2QueryParams {
  accountIdentifier: string
  perpetualTaskId: string
}

export type GetInstanceSyncPerpetualTaskResponseV2Props = Omit<
  MutateProps<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskResponseV2QueryParams,
    DelegateResponseDataRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get instance sync perpetual task response
 */
export const GetInstanceSyncPerpetualTaskResponseV2 = (props: GetInstanceSyncPerpetualTaskResponseV2Props) => (
  <Mutate<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskResponseV2QueryParams,
    DelegateResponseDataRequestBody,
    void
  >
    verb="POST"
    path={`/instancesync/v2/response`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInstanceSyncPerpetualTaskResponseV2Props = Omit<
  UseMutateProps<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskResponseV2QueryParams,
    DelegateResponseDataRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get instance sync perpetual task response
 */
export const useGetInstanceSyncPerpetualTaskResponseV2 = (props: UseGetInstanceSyncPerpetualTaskResponseV2Props) =>
  useMutate<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskResponseV2QueryParams,
    DelegateResponseDataRequestBody,
    void
  >('POST', `/instancesync/v2/response`, { base: getConfig('ng/api'), ...props })

/**
 * Get instance sync perpetual task response
 */
export const getInstanceSyncPerpetualTaskResponseV2Promise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskResponseV2QueryParams,
    DelegateResponseDataRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskResponseV2QueryParams,
    DelegateResponseDataRequestBody,
    void
  >('POST', getConfig('ng/api'), `/instancesync/v2/response`, props, signal)

export interface GetInstanceSyncPerpetualTaskV2ResponseQueryParams {
  accountIdentifier: string
  perpetualTaskId: string
}

export type GetInstanceSyncPerpetualTaskV2ResponseProps = Omit<
  MutateProps<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskV2ResponseQueryParams,
    InstanceSyncResponseV2,
    void
  >,
  'path' | 'verb'
>

/**
 * Get instance sync perpetual task v2 response
 */
export const GetInstanceSyncPerpetualTaskV2Response = (props: GetInstanceSyncPerpetualTaskV2ResponseProps) => (
  <Mutate<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskV2ResponseQueryParams,
    InstanceSyncResponseV2,
    void
  >
    verb="POST"
    path={`/instancesync/v3/response`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInstanceSyncPerpetualTaskV2ResponseProps = Omit<
  UseMutateProps<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskV2ResponseQueryParams,
    InstanceSyncResponseV2,
    void
  >,
  'path' | 'verb'
>

/**
 * Get instance sync perpetual task v2 response
 */
export const useGetInstanceSyncPerpetualTaskV2Response = (props: UseGetInstanceSyncPerpetualTaskV2ResponseProps) =>
  useMutate<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskV2ResponseQueryParams,
    InstanceSyncResponseV2,
    void
  >('POST', `/instancesync/v3/response`, { base: getConfig('ng/api'), ...props })

/**
 * Get instance sync perpetual task v2 response
 */
export const getInstanceSyncPerpetualTaskV2ResponsePromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskV2ResponseQueryParams,
    InstanceSyncResponseV2,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskV2ResponseQueryParams,
    InstanceSyncResponseV2,
    void
  >('POST', getConfig('ng/api'), `/instancesync/v3/response`, props, signal)

export interface GetInvitesQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type GetInvitesProps = Omit<GetProps<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>, 'path'>

/**
 * Get all invites for the queried project/organization
 */
export const GetInvites = (props: GetInvitesProps) => (
  <Get<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>
    path={`/invites`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInvitesProps = Omit<
  UseGetProps<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>,
  'path'
>

/**
 * Get all invites for the queried project/organization
 */
export const useGetInvites = (props: UseGetInvitesProps) =>
  useGet<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>(`/invites`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get all invites for the queried project/organization
 */
export const getInvitesPromise = (
  props: GetUsingFetchProps<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>(
    getConfig('ng/api'),
    `/invites`,
    props,
    signal
  )

export interface GetPendingUsersAggregatedQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type GetPendingUsersAggregatedProps = Omit<
  MutateProps<ResponsePageInvite, Failure | Error, GetPendingUsersAggregatedQueryParams, ACLAggregateFilter, void>,
  'path' | 'verb'
>

/**
 * Get a page of pending users for access control
 */
export const GetPendingUsersAggregated = (props: GetPendingUsersAggregatedProps) => (
  <Mutate<ResponsePageInvite, Failure | Error, GetPendingUsersAggregatedQueryParams, ACLAggregateFilter, void>
    verb="POST"
    path={`/invites/aggregate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPendingUsersAggregatedProps = Omit<
  UseMutateProps<ResponsePageInvite, Failure | Error, GetPendingUsersAggregatedQueryParams, ACLAggregateFilter, void>,
  'path' | 'verb'
>

/**
 * Get a page of pending users for access control
 */
export const useGetPendingUsersAggregated = (props: UseGetPendingUsersAggregatedProps) =>
  useMutate<ResponsePageInvite, Failure | Error, GetPendingUsersAggregatedQueryParams, ACLAggregateFilter, void>(
    'POST',
    `/invites/aggregate`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get a page of pending users for access control
 */
export const getPendingUsersAggregatedPromise = (
  props: MutateUsingFetchProps<
    ResponsePageInvite,
    Failure | Error,
    GetPendingUsersAggregatedQueryParams,
    ACLAggregateFilter,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponsePageInvite, Failure | Error, GetPendingUsersAggregatedQueryParams, ACLAggregateFilter, void>(
    'POST',
    getConfig('ng/api'),
    `/invites/aggregate`,
    props,
    signal
  )

export interface GetInviteQueryParams {
  accountIdentifier?: string
  inviteId?: string
  jwttoken?: string
}

export type GetInviteProps = Omit<GetProps<ResponseInvite, Failure | Error, GetInviteQueryParams, void>, 'path'>

/**
 * Get invite
 */
export const GetInvite = (props: GetInviteProps) => (
  <Get<ResponseInvite, Failure | Error, GetInviteQueryParams, void>
    path={`/invites/invite`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInviteProps = Omit<UseGetProps<ResponseInvite, Failure | Error, GetInviteQueryParams, void>, 'path'>

/**
 * Get invite
 */
export const useGetInvite = (props: UseGetInviteProps) =>
  useGet<ResponseInvite, Failure | Error, GetInviteQueryParams, void>(`/invites/invite`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get invite
 */
export const getInvitePromise = (
  props: GetUsingFetchProps<ResponseInvite, Failure | Error, GetInviteQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseInvite, Failure | Error, GetInviteQueryParams, void>(
    getConfig('ng/api'),
    `/invites/invite`,
    props,
    signal
  )

export interface DeleteInviteQueryParams {
  accountIdentifier?: string
}

export type DeleteInviteProps = Omit<
  MutateProps<ResponseOptionalInvite, Failure | Error, DeleteInviteQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a invite for the specified project/organization
 */
export const DeleteInvite = (props: DeleteInviteProps) => (
  <Mutate<ResponseOptionalInvite, Failure | Error, DeleteInviteQueryParams, string, void>
    verb="DELETE"
    path={`/invites`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteInviteProps = Omit<
  UseMutateProps<ResponseOptionalInvite, Failure | Error, DeleteInviteQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a invite for the specified project/organization
 */
export const useDeleteInvite = (props: UseDeleteInviteProps) =>
  useMutate<ResponseOptionalInvite, Failure | Error, DeleteInviteQueryParams, string, void>('DELETE', `/invites`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a invite for the specified project/organization
 */
export const deleteInvitePromise = (
  props: MutateUsingFetchProps<ResponseOptionalInvite, Failure | Error, DeleteInviteQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseOptionalInvite, Failure | Error, DeleteInviteQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/invites`,
    props,
    signal
  )

export interface UpdateInviteQueryParams {
  accountIdentifier?: string
}

export interface UpdateInvitePathParams {
  inviteId: string
}

export type UpdateInviteProps = Omit<
  MutateProps<ResponseOptionalInvite, Failure | Error, UpdateInviteQueryParams, Invite, UpdateInvitePathParams>,
  'path' | 'verb'
> &
  UpdateInvitePathParams

/**
 * Resend invite mail
 */
export const UpdateInvite = ({ inviteId, ...props }: UpdateInviteProps) => (
  <Mutate<ResponseOptionalInvite, Failure | Error, UpdateInviteQueryParams, Invite, UpdateInvitePathParams>
    verb="PUT"
    path={`/invites/${inviteId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateInviteProps = Omit<
  UseMutateProps<ResponseOptionalInvite, Failure | Error, UpdateInviteQueryParams, Invite, UpdateInvitePathParams>,
  'path' | 'verb'
> &
  UpdateInvitePathParams

/**
 * Resend invite mail
 */
export const useUpdateInvite = ({ inviteId, ...props }: UseUpdateInviteProps) =>
  useMutate<ResponseOptionalInvite, Failure | Error, UpdateInviteQueryParams, Invite, UpdateInvitePathParams>(
    'PUT',
    (paramsInPath: UpdateInvitePathParams) => `/invites/${paramsInPath.inviteId}`,
    { base: getConfig('ng/api'), pathParams: { inviteId }, ...props }
  )

/**
 * Resend invite mail
 */
export const updateInvitePromise = (
  {
    inviteId,
    ...props
  }: MutateUsingFetchProps<
    ResponseOptionalInvite,
    Failure | Error,
    UpdateInviteQueryParams,
    Invite,
    UpdateInvitePathParams
  > & { inviteId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseOptionalInvite, Failure | Error, UpdateInviteQueryParams, Invite, UpdateInvitePathParams>(
    'PUT',
    getConfig('ng/api'),
    `/invites/${inviteId}`,
    props,
    signal
  )

export interface GetJiraIssueCreateMetadataQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  projectKey?: string
  issueType?: string
  expand?: string
  fetchStatus?: boolean
  ignoreComment?: boolean
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetJiraIssueCreateMetadataProps = Omit<
  GetProps<ResponseJiraIssueCreateMetadataNG, Failure | Error, GetJiraIssueCreateMetadataQueryParams, void>,
  'path'
>

/**
 * Get jira issue create metadata
 */
export const GetJiraIssueCreateMetadata = (props: GetJiraIssueCreateMetadataProps) => (
  <Get<ResponseJiraIssueCreateMetadataNG, Failure | Error, GetJiraIssueCreateMetadataQueryParams, void>
    path={`/jira/createMetadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJiraIssueCreateMetadataProps = Omit<
  UseGetProps<ResponseJiraIssueCreateMetadataNG, Failure | Error, GetJiraIssueCreateMetadataQueryParams, void>,
  'path'
>

/**
 * Get jira issue create metadata
 */
export const useGetJiraIssueCreateMetadata = (props: UseGetJiraIssueCreateMetadataProps) =>
  useGet<ResponseJiraIssueCreateMetadataNG, Failure | Error, GetJiraIssueCreateMetadataQueryParams, void>(
    `/jira/createMetadata`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get jira issue create metadata
 */
export const getJiraIssueCreateMetadataPromise = (
  props: GetUsingFetchProps<
    ResponseJiraIssueCreateMetadataNG,
    Failure | Error,
    GetJiraIssueCreateMetadataQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJiraIssueCreateMetadataNG, Failure | Error, GetJiraIssueCreateMetadataQueryParams, void>(
    getConfig('ng/api'),
    `/jira/createMetadata`,
    props,
    signal
  )

export interface GetJiraProjectsQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetJiraProjectsProps = Omit<
  GetProps<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>,
  'path'
>

/**
 * Get jira projects
 */
export const GetJiraProjects = (props: GetJiraProjectsProps) => (
  <Get<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>
    path={`/jira/projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJiraProjectsProps = Omit<
  UseGetProps<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>,
  'path'
>

/**
 * Get jira projects
 */
export const useGetJiraProjects = (props: UseGetJiraProjectsProps) =>
  useGet<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>(`/jira/projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get jira projects
 */
export const getJiraProjectsPromise = (
  props: GetUsingFetchProps<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>(
    getConfig('ng/api'),
    `/jira/projects`,
    props,
    signal
  )

export interface JiraUserSearchQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  accountIdentifier?: string
  connectorIdentifier?: string
  userQuery?: string
  offset?: string
}

export type JiraUserSearchProps = Omit<
  GetProps<ResponseListJiraUserData, Failure | Error, JiraUserSearchQueryParams, void>,
  'path'
>

/**
 * Get jira usernames for the jira connector
 */
export const JiraUserSearch = (props: JiraUserSearchProps) => (
  <Get<ResponseListJiraUserData, Failure | Error, JiraUserSearchQueryParams, void>
    path={`/jira/searchUser`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseJiraUserSearchProps = Omit<
  UseGetProps<ResponseListJiraUserData, Failure | Error, JiraUserSearchQueryParams, void>,
  'path'
>

/**
 * Get jira usernames for the jira connector
 */
export const useJiraUserSearch = (props: UseJiraUserSearchProps) =>
  useGet<ResponseListJiraUserData, Failure | Error, JiraUserSearchQueryParams, void>(`/jira/searchUser`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get jira usernames for the jira connector
 */
export const jiraUserSearchPromise = (
  props: GetUsingFetchProps<ResponseListJiraUserData, Failure | Error, JiraUserSearchQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListJiraUserData, Failure | Error, JiraUserSearchQueryParams, void>(
    getConfig('ng/api'),
    `/jira/searchUser`,
    props,
    signal
  )

export interface GetJiraStatusesQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  projectKey?: string
  issueType?: string
  issueKey?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetJiraStatusesProps = Omit<
  GetProps<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>,
  'path'
>

/**
 * Get jira statuses
 */
export const GetJiraStatuses = (props: GetJiraStatusesProps) => (
  <Get<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>
    path={`/jira/statuses`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJiraStatusesProps = Omit<
  UseGetProps<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>,
  'path'
>

/**
 * Get jira statuses
 */
export const useGetJiraStatuses = (props: UseGetJiraStatusesProps) =>
  useGet<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>(`/jira/statuses`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get jira statuses
 */
export const getJiraStatusesPromise = (
  props: GetUsingFetchProps<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>(
    getConfig('ng/api'),
    `/jira/statuses`,
    props,
    signal
  )

export interface GetIssueTransitionsQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  issueKey: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetIssueTransitionsProps = Omit<
  GetProps<ResponseListJiraIssueTransitionNG, Failure | Error, GetIssueTransitionsQueryParams, void>,
  'path'
>

/**
 * Get issue transitions
 */
export const GetIssueTransitions = (props: GetIssueTransitionsProps) => (
  <Get<ResponseListJiraIssueTransitionNG, Failure | Error, GetIssueTransitionsQueryParams, void>
    path={`/jira/transitions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetIssueTransitionsProps = Omit<
  UseGetProps<ResponseListJiraIssueTransitionNG, Failure | Error, GetIssueTransitionsQueryParams, void>,
  'path'
>

/**
 * Get issue transitions
 */
export const useGetIssueTransitions = (props: UseGetIssueTransitionsProps) =>
  useGet<ResponseListJiraIssueTransitionNG, Failure | Error, GetIssueTransitionsQueryParams, void>(
    `/jira/transitions`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get issue transitions
 */
export const getIssueTransitionsPromise = (
  props: GetUsingFetchProps<ResponseListJiraIssueTransitionNG, Failure | Error, GetIssueTransitionsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListJiraIssueTransitionNG, Failure | Error, GetIssueTransitionsQueryParams, void>(
    getConfig('ng/api'),
    `/jira/transitions`,
    props,
    signal
  )

export interface GetJiraIssueUpdateMetadataQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  issueKey?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetJiraIssueUpdateMetadataProps = Omit<
  GetProps<ResponseJiraIssueUpdateMetadataNG, Failure | Error, GetJiraIssueUpdateMetadataQueryParams, void>,
  'path'
>

/**
 * Get jira issue update metadata
 */
export const GetJiraIssueUpdateMetadata = (props: GetJiraIssueUpdateMetadataProps) => (
  <Get<ResponseJiraIssueUpdateMetadataNG, Failure | Error, GetJiraIssueUpdateMetadataQueryParams, void>
    path={`/jira/updateMetadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJiraIssueUpdateMetadataProps = Omit<
  UseGetProps<ResponseJiraIssueUpdateMetadataNG, Failure | Error, GetJiraIssueUpdateMetadataQueryParams, void>,
  'path'
>

/**
 * Get jira issue update metadata
 */
export const useGetJiraIssueUpdateMetadata = (props: UseGetJiraIssueUpdateMetadataProps) =>
  useGet<ResponseJiraIssueUpdateMetadataNG, Failure | Error, GetJiraIssueUpdateMetadataQueryParams, void>(
    `/jira/updateMetadata`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get jira issue update metadata
 */
export const getJiraIssueUpdateMetadataPromise = (
  props: GetUsingFetchProps<
    ResponseJiraIssueUpdateMetadataNG,
    Failure | Error,
    GetJiraIssueUpdateMetadataQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJiraIssueUpdateMetadataNG, Failure | Error, GetJiraIssueUpdateMetadataQueryParams, void>(
    getConfig('ng/api'),
    `/jira/updateMetadata`,
    props,
    signal
  )

export interface ValidateJiraCredentialsQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type ValidateJiraCredentialsProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>,
  'path'
>

/**
 * Validate jira credentials
 */
export const ValidateJiraCredentials = (props: ValidateJiraCredentialsProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>
    path={`/jira/validate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateJiraCredentialsProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>,
  'path'
>

/**
 * Validate jira credentials
 */
export const useValidateJiraCredentials = (props: UseValidateJiraCredentialsProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>(`/jira/validate`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Validate jira credentials
 */
export const validateJiraCredentialsPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>(
    getConfig('ng/api'),
    `/jira/validate`,
    props,
    signal
  )

export interface GetActiveDeploymentStatsQueryParams {
  accountIdentifier: string
}

export type GetActiveDeploymentStatsProps = Omit<
  MutateProps<
    ResponsePipelinesExecutionDashboardInfo,
    Failure | Error,
    GetActiveDeploymentStatsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get active deployment stats
 */
export const GetActiveDeploymentStats = (props: GetActiveDeploymentStatsProps) => (
  <Mutate<
    ResponsePipelinesExecutionDashboardInfo,
    Failure | Error,
    GetActiveDeploymentStatsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >
    verb="POST"
    path={`/landingDashboards/activeDeploymentStats`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveDeploymentStatsProps = Omit<
  UseMutateProps<
    ResponsePipelinesExecutionDashboardInfo,
    Failure | Error,
    GetActiveDeploymentStatsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get active deployment stats
 */
export const useGetActiveDeploymentStats = (props: UseGetActiveDeploymentStatsProps) =>
  useMutate<
    ResponsePipelinesExecutionDashboardInfo,
    Failure | Error,
    GetActiveDeploymentStatsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', `/landingDashboards/activeDeploymentStats`, { base: getConfig('ng/api'), ...props })

/**
 * Get active deployment stats
 */
export const getActiveDeploymentStatsPromise = (
  props: MutateUsingFetchProps<
    ResponsePipelinesExecutionDashboardInfo,
    Failure | Error,
    GetActiveDeploymentStatsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelinesExecutionDashboardInfo,
    Failure | Error,
    GetActiveDeploymentStatsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', getConfig('ng/api'), `/landingDashboards/activeDeploymentStats`, props, signal)

export interface GetActiveServicesQueryParams {
  accountIdentifier: string
  startTime: number
  endTime: number
  sortBy: 'DEPLOYMENTS' | 'INSTANCES'
}

export type GetActiveServicesProps = Omit<
  MutateProps<
    ResponseServicesDashboardInfo,
    Failure | Error,
    GetActiveServicesQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Most Active Services
 */
export const GetActiveServices = (props: GetActiveServicesProps) => (
  <Mutate<
    ResponseServicesDashboardInfo,
    Failure | Error,
    GetActiveServicesQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >
    verb="POST"
    path={`/landingDashboards/activeServices`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveServicesProps = Omit<
  UseMutateProps<
    ResponseServicesDashboardInfo,
    Failure | Error,
    GetActiveServicesQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Most Active Services
 */
export const useGetActiveServices = (props: UseGetActiveServicesProps) =>
  useMutate<
    ResponseServicesDashboardInfo,
    Failure | Error,
    GetActiveServicesQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', `/landingDashboards/activeServices`, { base: getConfig('ng/api'), ...props })

/**
 * Get Most Active Services
 */
export const getActiveServicesPromise = (
  props: MutateUsingFetchProps<
    ResponseServicesDashboardInfo,
    Failure | Error,
    GetActiveServicesQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServicesDashboardInfo,
    Failure | Error,
    GetActiveServicesQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', getConfig('ng/api'), `/landingDashboards/activeServices`, props, signal)

export interface GetDeploymentStatsSummaryQueryParams {
  accountIdentifier: string
  startTime: number
  endTime: number
  groupBy: 'DAY' | 'WEEK' | 'MONTH'
}

export type GetDeploymentStatsSummaryProps = Omit<
  MutateProps<
    ResponseDeploymentStatsSummary,
    Failure | Error,
    GetDeploymentStatsSummaryQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get deployment stats summary
 */
export const GetDeploymentStatsSummary = (props: GetDeploymentStatsSummaryProps) => (
  <Mutate<
    ResponseDeploymentStatsSummary,
    Failure | Error,
    GetDeploymentStatsSummaryQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >
    verb="POST"
    path={`/landingDashboards/deploymentStatsSummary`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDeploymentStatsSummaryProps = Omit<
  UseMutateProps<
    ResponseDeploymentStatsSummary,
    Failure | Error,
    GetDeploymentStatsSummaryQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get deployment stats summary
 */
export const useGetDeploymentStatsSummary = (props: UseGetDeploymentStatsSummaryProps) =>
  useMutate<
    ResponseDeploymentStatsSummary,
    Failure | Error,
    GetDeploymentStatsSummaryQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', `/landingDashboards/deploymentStatsSummary`, { base: getConfig('ng/api'), ...props })

/**
 * Get deployment stats summary
 */
export const getDeploymentStatsSummaryPromise = (
  props: MutateUsingFetchProps<
    ResponseDeploymentStatsSummary,
    Failure | Error,
    GetDeploymentStatsSummaryQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDeploymentStatsSummary,
    Failure | Error,
    GetDeploymentStatsSummaryQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', getConfig('ng/api'), `/landingDashboards/deploymentStatsSummary`, props, signal)

export interface GetEnvCountQueryParams {
  accountIdentifier: string
  startTime: number
  endTime: number
}

export type GetEnvCountProps = Omit<
  MutateProps<ResponseEnvCount, Failure | Error, GetEnvCountQueryParams, LandingDashboardRequestCDRequestBody, void>,
  'path' | 'verb'
>

/**
 * Get environments count
 */
export const GetEnvCount = (props: GetEnvCountProps) => (
  <Mutate<ResponseEnvCount, Failure | Error, GetEnvCountQueryParams, LandingDashboardRequestCDRequestBody, void>
    verb="POST"
    path={`/landingDashboards/envCount`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvCountProps = Omit<
  UseMutateProps<ResponseEnvCount, Failure | Error, GetEnvCountQueryParams, LandingDashboardRequestCDRequestBody, void>,
  'path' | 'verb'
>

/**
 * Get environments count
 */
export const useGetEnvCount = (props: UseGetEnvCountProps) =>
  useMutate<ResponseEnvCount, Failure | Error, GetEnvCountQueryParams, LandingDashboardRequestCDRequestBody, void>(
    'POST',
    `/landingDashboards/envCount`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get environments count
 */
export const getEnvCountPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvCount,
    Failure | Error,
    GetEnvCountQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvCount,
    Failure | Error,
    GetEnvCountQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', getConfig('ng/api'), `/landingDashboards/envCount`, props, signal)

export interface GetServicesCountQueryParams {
  accountIdentifier: string
  startTime: number
  endTime: number
}

export type GetServicesCountProps = Omit<
  MutateProps<
    ResponseServicesCount,
    Failure | Error,
    GetServicesCountQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get services count
 */
export const GetServicesCount = (props: GetServicesCountProps) => (
  <Mutate<
    ResponseServicesCount,
    Failure | Error,
    GetServicesCountQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >
    verb="POST"
    path={`/landingDashboards/servicesCount`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServicesCountProps = Omit<
  UseMutateProps<
    ResponseServicesCount,
    Failure | Error,
    GetServicesCountQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get services count
 */
export const useGetServicesCount = (props: UseGetServicesCountProps) =>
  useMutate<
    ResponseServicesCount,
    Failure | Error,
    GetServicesCountQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', `/landingDashboards/servicesCount`, { base: getConfig('ng/api'), ...props })

/**
 * Get services count
 */
export const getServicesCountPromise = (
  props: MutateUsingFetchProps<
    ResponseServicesCount,
    Failure | Error,
    GetServicesCountQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServicesCount,
    Failure | Error,
    GetServicesCountQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', getConfig('ng/api'), `/landingDashboards/servicesCount`, props, signal)

export interface GetTopProjectsQueryParams {
  accountIdentifier: string
  startTime: number
  endTime: number
}

export type GetTopProjectsProps = Omit<
  MutateProps<
    ResponseProjectsDashboardInfo,
    Failure | Error,
    GetTopProjectsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Top Projects as per Deployments
 */
export const GetTopProjects = (props: GetTopProjectsProps) => (
  <Mutate<
    ResponseProjectsDashboardInfo,
    Failure | Error,
    GetTopProjectsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >
    verb="POST"
    path={`/landingDashboards/topProjects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTopProjectsProps = Omit<
  UseMutateProps<
    ResponseProjectsDashboardInfo,
    Failure | Error,
    GetTopProjectsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Top Projects as per Deployments
 */
export const useGetTopProjects = (props: UseGetTopProjectsProps) =>
  useMutate<
    ResponseProjectsDashboardInfo,
    Failure | Error,
    GetTopProjectsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', `/landingDashboards/topProjects`, { base: getConfig('ng/api'), ...props })

/**
 * Get Top Projects as per Deployments
 */
export const getTopProjectsPromise = (
  props: MutateUsingFetchProps<
    ResponseProjectsDashboardInfo,
    Failure | Error,
    GetTopProjectsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseProjectsDashboardInfo,
    Failure | Error,
    GetTopProjectsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', getConfig('ng/api'), `/landingDashboards/topProjects`, props, signal)

export type GetDeploymentCountProps = Omit<
  GetProps<ResponseLandingPageDeploymentCount, Failure | Error, void, void>,
  'path'
>

/**
 * Get Total of Deployments
 */
export const GetDeploymentCount = (props: GetDeploymentCountProps) => (
  <Get<ResponseLandingPageDeploymentCount, Failure | Error, void, void>
    path={`/landingPage/deploymentCount`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDeploymentCountProps = Omit<
  UseGetProps<ResponseLandingPageDeploymentCount, Failure | Error, void, void>,
  'path'
>

/**
 * Get Total of Deployments
 */
export const useGetDeploymentCount = (props: UseGetDeploymentCountProps) =>
  useGet<ResponseLandingPageDeploymentCount, Failure | Error, void, void>(`/landingPage/deploymentCount`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Total of Deployments
 */
export const getDeploymentCountPromise = (
  props: GetUsingFetchProps<ResponseLandingPageDeploymentCount, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseLandingPageDeploymentCount, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/landingPage/deploymentCount`,
    props,
    signal
  )

export interface PostLdapAuthenticationTestQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type PostLdapAuthenticationTestProps = Omit<
  MutateProps<RestResponseLdapResponse, Failure | Error, PostLdapAuthenticationTestQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Perform LDAP Login Test
 */
export const PostLdapAuthenticationTest = (props: PostLdapAuthenticationTestProps) => (
  <Mutate<RestResponseLdapResponse, Failure | Error, PostLdapAuthenticationTestQueryParams, void, void>
    verb="POST"
    path={`/ldap/ldap-login-test`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostLdapAuthenticationTestProps = Omit<
  UseMutateProps<RestResponseLdapResponse, Failure | Error, PostLdapAuthenticationTestQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Perform LDAP Login Test
 */
export const usePostLdapAuthenticationTest = (props: UsePostLdapAuthenticationTestProps) =>
  useMutate<RestResponseLdapResponse, Failure | Error, PostLdapAuthenticationTestQueryParams, void, void>(
    'POST',
    `/ldap/ldap-login-test`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Perform LDAP Login Test
 */
export const postLdapAuthenticationTestPromise = (
  props: MutateUsingFetchProps<
    RestResponseLdapResponse,
    Failure | Error,
    PostLdapAuthenticationTestQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseLdapResponse, Failure | Error, PostLdapAuthenticationTestQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/ldap/ldap-login-test`,
    props,
    signal
  )

export interface ValidateLdapConnectionSettingsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateLdapConnectionSettingsProps = Omit<
  MutateProps<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapConnectionSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Validates Ldap Connection Setting
 */
export const ValidateLdapConnectionSettings = (props: ValidateLdapConnectionSettingsProps) => (
  <Mutate<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapConnectionSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >
    verb="POST"
    path={`/ldap/settings/test/connection`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateLdapConnectionSettingsProps = Omit<
  UseMutateProps<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapConnectionSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Validates Ldap Connection Setting
 */
export const useValidateLdapConnectionSettings = (props: UseValidateLdapConnectionSettingsProps) =>
  useMutate<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapConnectionSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >('POST', `/ldap/settings/test/connection`, { base: getConfig('ng/api'), ...props })

/**
 * Validates Ldap Connection Setting
 */
export const validateLdapConnectionSettingsPromise = (
  props: MutateUsingFetchProps<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapConnectionSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapConnectionSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >('POST', getConfig('ng/api'), `/ldap/settings/test/connection`, props, signal)

export interface ValidateLdapGroupSettingsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateLdapGroupSettingsProps = Omit<
  MutateProps<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapGroupSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Validates Ldap Group Setting
 */
export const ValidateLdapGroupSettings = (props: ValidateLdapGroupSettingsProps) => (
  <Mutate<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapGroupSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >
    verb="POST"
    path={`/ldap/settings/test/group`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateLdapGroupSettingsProps = Omit<
  UseMutateProps<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapGroupSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Validates Ldap Group Setting
 */
export const useValidateLdapGroupSettings = (props: UseValidateLdapGroupSettingsProps) =>
  useMutate<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapGroupSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >('POST', `/ldap/settings/test/group`, { base: getConfig('ng/api'), ...props })

/**
 * Validates Ldap Group Setting
 */
export const validateLdapGroupSettingsPromise = (
  props: MutateUsingFetchProps<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapGroupSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapGroupSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >('POST', getConfig('ng/api'), `/ldap/settings/test/group`, props, signal)

export interface ValidateLdapUserSettingsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateLdapUserSettingsProps = Omit<
  MutateProps<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapUserSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Validates Ldap User Setting
 */
export const ValidateLdapUserSettings = (props: ValidateLdapUserSettingsProps) => (
  <Mutate<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapUserSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >
    verb="POST"
    path={`/ldap/settings/test/user`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateLdapUserSettingsProps = Omit<
  UseMutateProps<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapUserSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Validates Ldap User Setting
 */
export const useValidateLdapUserSettings = (props: UseValidateLdapUserSettingsProps) =>
  useMutate<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapUserSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >('POST', `/ldap/settings/test/user`, { base: getConfig('ng/api'), ...props })

/**
 * Validates Ldap User Setting
 */
export const validateLdapUserSettingsPromise = (
  props: MutateUsingFetchProps<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapUserSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseLdapTestResponse,
    Failure | Error,
    ValidateLdapUserSettingsQueryParams,
    LdapSettingsRequestBody,
    void
  >('POST', getConfig('ng/api'), `/ldap/settings/test/user`, props, signal)

export interface SyncUserGroupLinkedToLDAPQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface SyncUserGroupLinkedToLDAPPathParams {
  userGroupId: string
}

export type SyncUserGroupLinkedToLDAPProps = Omit<
  GetProps<
    RestResponseVoid,
    Failure | Error,
    SyncUserGroupLinkedToLDAPQueryParams,
    SyncUserGroupLinkedToLDAPPathParams
  >,
  'path'
> &
  SyncUserGroupLinkedToLDAPPathParams

/**
 * Trigger sync for a harness user group linked to an LDAP user group in an account
 */
export const SyncUserGroupLinkedToLDAP = ({ userGroupId, ...props }: SyncUserGroupLinkedToLDAPProps) => (
  <Get<RestResponseVoid, Failure | Error, SyncUserGroupLinkedToLDAPQueryParams, SyncUserGroupLinkedToLDAPPathParams>
    path={`/ldap/sync-group/${userGroupId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSyncUserGroupLinkedToLDAPProps = Omit<
  UseGetProps<
    RestResponseVoid,
    Failure | Error,
    SyncUserGroupLinkedToLDAPQueryParams,
    SyncUserGroupLinkedToLDAPPathParams
  >,
  'path'
> &
  SyncUserGroupLinkedToLDAPPathParams

/**
 * Trigger sync for a harness user group linked to an LDAP user group in an account
 */
export const useSyncUserGroupLinkedToLDAP = ({ userGroupId, ...props }: UseSyncUserGroupLinkedToLDAPProps) =>
  useGet<RestResponseVoid, Failure | Error, SyncUserGroupLinkedToLDAPQueryParams, SyncUserGroupLinkedToLDAPPathParams>(
    (paramsInPath: SyncUserGroupLinkedToLDAPPathParams) => `/ldap/sync-group/${paramsInPath.userGroupId}`,
    { base: getConfig('ng/api'), pathParams: { userGroupId }, ...props }
  )

/**
 * Trigger sync for a harness user group linked to an LDAP user group in an account
 */
export const syncUserGroupLinkedToLDAPPromise = (
  {
    userGroupId,
    ...props
  }: GetUsingFetchProps<
    RestResponseVoid,
    Failure | Error,
    SyncUserGroupLinkedToLDAPQueryParams,
    SyncUserGroupLinkedToLDAPPathParams
  > & { userGroupId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    RestResponseVoid,
    Failure | Error,
    SyncUserGroupLinkedToLDAPQueryParams,
    SyncUserGroupLinkedToLDAPPathParams
  >(getConfig('ng/api'), `/ldap/sync-group/${userGroupId}`, props, signal)

export interface SyncLdapGroupsQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type SyncLdapGroupsProps = Omit<
  GetProps<RestResponseBoolean, Failure | Error, SyncLdapGroupsQueryParams, void>,
  'path'
>

/**
 * Sync Ldap groups within an account
 */
export const SyncLdapGroups = (props: SyncLdapGroupsProps) => (
  <Get<RestResponseBoolean, Failure | Error, SyncLdapGroupsQueryParams, void>
    path={`/ldap/sync-groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSyncLdapGroupsProps = Omit<
  UseGetProps<RestResponseBoolean, Failure | Error, SyncLdapGroupsQueryParams, void>,
  'path'
>

/**
 * Sync Ldap groups within an account
 */
export const useSyncLdapGroups = (props: UseSyncLdapGroupsProps) =>
  useGet<RestResponseBoolean, Failure | Error, SyncLdapGroupsQueryParams, void>(`/ldap/sync-groups`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Sync Ldap groups within an account
 */
export const syncLdapGroupsPromise = (
  props: GetUsingFetchProps<RestResponseBoolean, Failure | Error, SyncLdapGroupsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseBoolean, Failure | Error, SyncLdapGroupsQueryParams, void>(
    getConfig('ng/api'),
    `/ldap/sync-groups`,
    props,
    signal
  )

export interface SyncLdapGroupsV2QueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type SyncLdapGroupsV2Props = Omit<
  MutateProps<RestResponseBoolean, Failure | Error, SyncLdapGroupsV2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Sync Ldap groups within an account
 */
export const SyncLdapGroupsV2 = (props: SyncLdapGroupsV2Props) => (
  <Mutate<RestResponseBoolean, Failure | Error, SyncLdapGroupsV2QueryParams, void, void>
    verb="PUT"
    path={`/ldap/sync-groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSyncLdapGroupsV2Props = Omit<
  UseMutateProps<RestResponseBoolean, Failure | Error, SyncLdapGroupsV2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Sync Ldap groups within an account
 */
export const useSyncLdapGroupsV2 = (props: UseSyncLdapGroupsV2Props) =>
  useMutate<RestResponseBoolean, Failure | Error, SyncLdapGroupsV2QueryParams, void, void>('PUT', `/ldap/sync-groups`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Sync Ldap groups within an account
 */
export const syncLdapGroupsV2Promise = (
  props: MutateUsingFetchProps<RestResponseBoolean, Failure | Error, SyncLdapGroupsV2QueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseBoolean, Failure | Error, SyncLdapGroupsV2QueryParams, void, void>(
    'PUT',
    getConfig('ng/api'),
    `/ldap/sync-groups`,
    props,
    signal
  )

export interface SearchLdapGroupsQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  name?: string
}

export interface SearchLdapGroupsPathParams {
  ldapId: string
}

export type SearchLdapGroupsProps = Omit<
  GetProps<
    RestResponseCollectionLdapGroupResponse,
    Failure | Error,
    SearchLdapGroupsQueryParams,
    SearchLdapGroupsPathParams
  >,
  'path'
> &
  SearchLdapGroupsPathParams

/**
 * Search Ldap groups with matching name
 */
export const SearchLdapGroups = ({ ldapId, ...props }: SearchLdapGroupsProps) => (
  <Get<
    RestResponseCollectionLdapGroupResponse,
    Failure | Error,
    SearchLdapGroupsQueryParams,
    SearchLdapGroupsPathParams
  >
    path={`/ldap/${ldapId}/search/group`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSearchLdapGroupsProps = Omit<
  UseGetProps<
    RestResponseCollectionLdapGroupResponse,
    Failure | Error,
    SearchLdapGroupsQueryParams,
    SearchLdapGroupsPathParams
  >,
  'path'
> &
  SearchLdapGroupsPathParams

/**
 * Search Ldap groups with matching name
 */
export const useSearchLdapGroups = ({ ldapId, ...props }: UseSearchLdapGroupsProps) =>
  useGet<
    RestResponseCollectionLdapGroupResponse,
    Failure | Error,
    SearchLdapGroupsQueryParams,
    SearchLdapGroupsPathParams
  >((paramsInPath: SearchLdapGroupsPathParams) => `/ldap/${paramsInPath.ldapId}/search/group`, {
    base: getConfig('ng/api'),
    pathParams: { ldapId },
    ...props
  })

/**
 * Search Ldap groups with matching name
 */
export const searchLdapGroupsPromise = (
  {
    ldapId,
    ...props
  }: GetUsingFetchProps<
    RestResponseCollectionLdapGroupResponse,
    Failure | Error,
    SearchLdapGroupsQueryParams,
    SearchLdapGroupsPathParams
  > & { ldapId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    RestResponseCollectionLdapGroupResponse,
    Failure | Error,
    SearchLdapGroupsQueryParams,
    SearchLdapGroupsPathParams
  >(getConfig('ng/api'), `/ldap/${ldapId}/search/group`, props, signal)

export interface GetLicenseDateUsageQueryParams {
  accountIdentifier: string
  licenseType: 'SERVICES' | 'SERVICE_INSTANCES'
}

export type GetLicenseDateUsageProps = Omit<
  MutateProps<
    ResponseLicenseDateUsageDTO,
    Failure | Error,
    GetLicenseDateUsageQueryParams,
    LicenseDateUsageParams,
    void
  >,
  'path' | 'verb'
>

/**
 * Get license date usage in CD Module
 */
export const GetLicenseDateUsage = (props: GetLicenseDateUsageProps) => (
  <Mutate<ResponseLicenseDateUsageDTO, Failure | Error, GetLicenseDateUsageQueryParams, LicenseDateUsageParams, void>
    verb="POST"
    path={`/license-usage-cd/date`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLicenseDateUsageProps = Omit<
  UseMutateProps<
    ResponseLicenseDateUsageDTO,
    Failure | Error,
    GetLicenseDateUsageQueryParams,
    LicenseDateUsageParams,
    void
  >,
  'path' | 'verb'
>

/**
 * Get license date usage in CD Module
 */
export const useGetLicenseDateUsage = (props: UseGetLicenseDateUsageProps) =>
  useMutate<ResponseLicenseDateUsageDTO, Failure | Error, GetLicenseDateUsageQueryParams, LicenseDateUsageParams, void>(
    'POST',
    `/license-usage-cd/date`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get license date usage in CD Module
 */
export const getLicenseDateUsagePromise = (
  props: MutateUsingFetchProps<
    ResponseLicenseDateUsageDTO,
    Failure | Error,
    GetLicenseDateUsageQueryParams,
    LicenseDateUsageParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseLicenseDateUsageDTO,
    Failure | Error,
    GetLicenseDateUsageQueryParams,
    LicenseDateUsageParams,
    void
  >('POST', getConfig('ng/api'), `/license-usage-cd/date`, props, signal)

export interface GetAllServicesQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  page?: number
  size?: number
  sort?: string[]
}

export type GetAllServicesProps = Omit<
  GetProps<ResponsePageServiceResponse, Failure | Error, GetAllServicesQueryParams, void>,
  'path'
>

/**
 * Get all services
 */
export const GetAllServices = (props: GetAllServicesProps) => (
  <Get<ResponsePageServiceResponse, Failure | Error, GetAllServicesQueryParams, void>
    path={`/license-usage-cd/services`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAllServicesProps = Omit<
  UseGetProps<ResponsePageServiceResponse, Failure | Error, GetAllServicesQueryParams, void>,
  'path'
>

/**
 * Get all services
 */
export const useGetAllServices = (props: UseGetAllServicesProps) =>
  useGet<ResponsePageServiceResponse, Failure | Error, GetAllServicesQueryParams, void>(`/license-usage-cd/services`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get all services
 */
export const getAllServicesPromise = (
  props: GetUsingFetchProps<ResponsePageServiceResponse, Failure | Error, GetAllServicesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageServiceResponse, Failure | Error, GetAllServicesQueryParams, void>(
    getConfig('ng/api'),
    `/license-usage-cd/services`,
    props,
    signal
  )

export interface GetAccountLicensesQueryParams {
  accountIdentifier?: string
}

export type GetAccountLicensesProps = Omit<
  GetProps<ResponseAccountLicenseDTO, Failure | Error, GetAccountLicensesQueryParams, void>,
  'path'
>

/**
 * Gets All Module License Information in Account
 */
export const GetAccountLicenses = (props: GetAccountLicensesProps) => (
  <Get<ResponseAccountLicenseDTO, Failure | Error, GetAccountLicensesQueryParams, void>
    path={`/licenses/account`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAccountLicensesProps = Omit<
  UseGetProps<ResponseAccountLicenseDTO, Failure | Error, GetAccountLicensesQueryParams, void>,
  'path'
>

/**
 * Gets All Module License Information in Account
 */
export const useGetAccountLicenses = (props: UseGetAccountLicensesProps) =>
  useGet<ResponseAccountLicenseDTO, Failure | Error, GetAccountLicensesQueryParams, void>(`/licenses/account`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets All Module License Information in Account
 */
export const getAccountLicensesPromise = (
  props: GetUsingFetchProps<ResponseAccountLicenseDTO, Failure | Error, GetAccountLicensesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAccountLicenseDTO, Failure | Error, GetAccountLicensesQueryParams, void>(
    getConfig('ng/api'),
    `/licenses/account`,
    props,
    signal
  )

export interface GetAllAccountModuleLicensesQueryParams {
  accountIdentifier?: string
}

export type GetAllAccountModuleLicensesProps = Omit<
  GetProps<ResponseListModuleLicenseDTO, Failure | Error, GetAllAccountModuleLicensesQueryParams, void>,
  'path'
>

/**
 * Gets All Module Licenses for an Account
 */
export const GetAllAccountModuleLicenses = (props: GetAllAccountModuleLicensesProps) => (
  <Get<ResponseListModuleLicenseDTO, Failure | Error, GetAllAccountModuleLicensesQueryParams, void>
    path={`/licenses/account-license`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAllAccountModuleLicensesProps = Omit<
  UseGetProps<ResponseListModuleLicenseDTO, Failure | Error, GetAllAccountModuleLicensesQueryParams, void>,
  'path'
>

/**
 * Gets All Module Licenses for an Account
 */
export const useGetAllAccountModuleLicenses = (props: UseGetAllAccountModuleLicensesProps) =>
  useGet<ResponseListModuleLicenseDTO, Failure | Error, GetAllAccountModuleLicensesQueryParams, void>(
    `/licenses/account-license`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets All Module Licenses for an Account
 */
export const getAllAccountModuleLicensesPromise = (
  props: GetUsingFetchProps<
    ResponseListModuleLicenseDTO,
    Failure | Error,
    GetAllAccountModuleLicensesQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListModuleLicenseDTO, Failure | Error, GetAllAccountModuleLicensesQueryParams, void>(
    getConfig('ng/api'),
    `/licenses/account-license`,
    props,
    signal
  )

export interface GetEditionActionsQueryParams {
  accountIdentifier: string
  moduleType:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
}

export type GetEditionActionsProps = Omit<
  GetProps<ResponseMapEditionSetEditionActionDTO, Failure | Error, GetEditionActionsQueryParams, void>,
  'path'
>

/**
 * Get Allowed Actions Under Each Edition
 */
export const GetEditionActions = (props: GetEditionActionsProps) => (
  <Get<ResponseMapEditionSetEditionActionDTO, Failure | Error, GetEditionActionsQueryParams, void>
    path={`/licenses/actions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEditionActionsProps = Omit<
  UseGetProps<ResponseMapEditionSetEditionActionDTO, Failure | Error, GetEditionActionsQueryParams, void>,
  'path'
>

/**
 * Get Allowed Actions Under Each Edition
 */
export const useGetEditionActions = (props: UseGetEditionActionsProps) =>
  useGet<ResponseMapEditionSetEditionActionDTO, Failure | Error, GetEditionActionsQueryParams, void>(
    `/licenses/actions`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Allowed Actions Under Each Edition
 */
export const getEditionActionsPromise = (
  props: GetUsingFetchProps<ResponseMapEditionSetEditionActionDTO, Failure | Error, GetEditionActionsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapEditionSetEditionActionDTO, Failure | Error, GetEditionActionsQueryParams, void>(
    getConfig('ng/api'),
    `/licenses/actions`,
    props,
    signal
  )

export interface StartCommunityLicenseQueryParams {
  accountIdentifier: string
  moduleType:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
}

export type StartCommunityLicenseProps = Omit<
  MutateProps<ResponseModuleLicenseDTO, Failure | Error, StartCommunityLicenseQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Starts Community License For A Module
 */
export const StartCommunityLicense = (props: StartCommunityLicenseProps) => (
  <Mutate<ResponseModuleLicenseDTO, Failure | Error, StartCommunityLicenseQueryParams, void, void>
    verb="POST"
    path={`/licenses/community`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseStartCommunityLicenseProps = Omit<
  UseMutateProps<ResponseModuleLicenseDTO, Failure | Error, StartCommunityLicenseQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Starts Community License For A Module
 */
export const useStartCommunityLicense = (props: UseStartCommunityLicenseProps) =>
  useMutate<ResponseModuleLicenseDTO, Failure | Error, StartCommunityLicenseQueryParams, void, void>(
    'POST',
    `/licenses/community`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Starts Community License For A Module
 */
export const startCommunityLicensePromise = (
  props: MutateUsingFetchProps<ResponseModuleLicenseDTO, Failure | Error, StartCommunityLicenseQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseModuleLicenseDTO, Failure | Error, StartCommunityLicenseQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/licenses/community`,
    props,
    signal
  )

export interface ExtendTrialLicenseQueryParams {
  accountIdentifier: string
}

export type ExtendTrialLicenseProps = Omit<
  MutateProps<ResponseModuleLicenseDTO, Failure | Error, ExtendTrialLicenseQueryParams, StartTrialDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Extends Trail License For A Module
 */
export const ExtendTrialLicense = (props: ExtendTrialLicenseProps) => (
  <Mutate<ResponseModuleLicenseDTO, Failure | Error, ExtendTrialLicenseQueryParams, StartTrialDTORequestBody, void>
    verb="POST"
    path={`/licenses/extend-trial`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseExtendTrialLicenseProps = Omit<
  UseMutateProps<
    ResponseModuleLicenseDTO,
    Failure | Error,
    ExtendTrialLicenseQueryParams,
    StartTrialDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Extends Trail License For A Module
 */
export const useExtendTrialLicense = (props: UseExtendTrialLicenseProps) =>
  useMutate<ResponseModuleLicenseDTO, Failure | Error, ExtendTrialLicenseQueryParams, StartTrialDTORequestBody, void>(
    'POST',
    `/licenses/extend-trial`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Extends Trail License For A Module
 */
export const extendTrialLicensePromise = (
  props: MutateUsingFetchProps<
    ResponseModuleLicenseDTO,
    Failure | Error,
    ExtendTrialLicenseQueryParams,
    StartTrialDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseModuleLicenseDTO,
    Failure | Error,
    ExtendTrialLicenseQueryParams,
    StartTrialDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/licenses/extend-trial`, props, signal)

export interface StartFreeLicenseQueryParams {
  accountIdentifier: string
  moduleType:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  referer?: string
  gaClientId?: string
}

export type StartFreeLicenseProps = Omit<
  MutateProps<ResponseModuleLicenseDTO, Failure | Error, StartFreeLicenseQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Starts Free License For A Module
 */
export const StartFreeLicense = (props: StartFreeLicenseProps) => (
  <Mutate<ResponseModuleLicenseDTO, Failure | Error, StartFreeLicenseQueryParams, void, void>
    verb="POST"
    path={`/licenses/free`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseStartFreeLicenseProps = Omit<
  UseMutateProps<ResponseModuleLicenseDTO, Failure | Error, StartFreeLicenseQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Starts Free License For A Module
 */
export const useStartFreeLicense = (props: UseStartFreeLicenseProps) =>
  useMutate<ResponseModuleLicenseDTO, Failure | Error, StartFreeLicenseQueryParams, void, void>(
    'POST',
    `/licenses/free`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Starts Free License For A Module
 */
export const startFreeLicensePromise = (
  props: MutateUsingFetchProps<ResponseModuleLicenseDTO, Failure | Error, StartFreeLicenseQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseModuleLicenseDTO, Failure | Error, StartFreeLicenseQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/licenses/free`,
    props,
    signal
  )

export interface GetModuleLicensesByAccountAndModuleTypeQueryParams {
  moduleType:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
}

export interface GetModuleLicensesByAccountAndModuleTypePathParams {
  accountIdentifier: string
}

export type GetModuleLicensesByAccountAndModuleTypeProps = Omit<
  GetProps<
    ResponseListModuleLicenseDTO,
    Failure | Error,
    GetModuleLicensesByAccountAndModuleTypeQueryParams,
    GetModuleLicensesByAccountAndModuleTypePathParams
  >,
  'path'
> &
  GetModuleLicensesByAccountAndModuleTypePathParams

/**
 * Gets Module Licenses By Account And ModuleType
 */
export const GetModuleLicensesByAccountAndModuleType = ({
  accountIdentifier,
  ...props
}: GetModuleLicensesByAccountAndModuleTypeProps) => (
  <Get<
    ResponseListModuleLicenseDTO,
    Failure | Error,
    GetModuleLicensesByAccountAndModuleTypeQueryParams,
    GetModuleLicensesByAccountAndModuleTypePathParams
  >
    path={`/licenses/modules/${accountIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetModuleLicensesByAccountAndModuleTypeProps = Omit<
  UseGetProps<
    ResponseListModuleLicenseDTO,
    Failure | Error,
    GetModuleLicensesByAccountAndModuleTypeQueryParams,
    GetModuleLicensesByAccountAndModuleTypePathParams
  >,
  'path'
> &
  GetModuleLicensesByAccountAndModuleTypePathParams

/**
 * Gets Module Licenses By Account And ModuleType
 */
export const useGetModuleLicensesByAccountAndModuleType = ({
  accountIdentifier,
  ...props
}: UseGetModuleLicensesByAccountAndModuleTypeProps) =>
  useGet<
    ResponseListModuleLicenseDTO,
    Failure | Error,
    GetModuleLicensesByAccountAndModuleTypeQueryParams,
    GetModuleLicensesByAccountAndModuleTypePathParams
  >(
    (paramsInPath: GetModuleLicensesByAccountAndModuleTypePathParams) =>
      `/licenses/modules/${paramsInPath.accountIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Gets Module Licenses By Account And ModuleType
 */
export const getModuleLicensesByAccountAndModuleTypePromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseListModuleLicenseDTO,
    Failure | Error,
    GetModuleLicensesByAccountAndModuleTypeQueryParams,
    GetModuleLicensesByAccountAndModuleTypePathParams
  > & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseListModuleLicenseDTO,
    Failure | Error,
    GetModuleLicensesByAccountAndModuleTypeQueryParams,
    GetModuleLicensesByAccountAndModuleTypePathParams
  >(getConfig('ng/api'), `/licenses/modules/${accountIdentifier}`, props, signal)

export interface StartTrialLicenseQueryParams {
  accountIdentifier: string
  referer?: string
}

export type StartTrialLicenseProps = Omit<
  MutateProps<ResponseModuleLicenseDTO, Failure | Error, StartTrialLicenseQueryParams, StartTrialDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Starts Trial License For A Module
 */
export const StartTrialLicense = (props: StartTrialLicenseProps) => (
  <Mutate<ResponseModuleLicenseDTO, Failure | Error, StartTrialLicenseQueryParams, StartTrialDTORequestBody, void>
    verb="POST"
    path={`/licenses/trial`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseStartTrialLicenseProps = Omit<
  UseMutateProps<
    ResponseModuleLicenseDTO,
    Failure | Error,
    StartTrialLicenseQueryParams,
    StartTrialDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Starts Trial License For A Module
 */
export const useStartTrialLicense = (props: UseStartTrialLicenseProps) =>
  useMutate<ResponseModuleLicenseDTO, Failure | Error, StartTrialLicenseQueryParams, StartTrialDTORequestBody, void>(
    'POST',
    `/licenses/trial`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Starts Trial License For A Module
 */
export const startTrialLicensePromise = (
  props: MutateUsingFetchProps<
    ResponseModuleLicenseDTO,
    Failure | Error,
    StartTrialLicenseQueryParams,
    StartTrialDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseModuleLicenseDTO,
    Failure | Error,
    StartTrialLicenseQueryParams,
    StartTrialDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/licenses/trial`, props, signal)

export interface GetLastModifiedTimeForAllModuleTypesQueryParams {
  accountIdentifier: string
}

export type GetLastModifiedTimeForAllModuleTypesProps = Omit<
  MutateProps<ResponseMapModuleTypeLong, Failure | Error, GetLastModifiedTimeForAllModuleTypesQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Get Last Modified Time For All Module Types
 */
export const GetLastModifiedTimeForAllModuleTypes = (props: GetLastModifiedTimeForAllModuleTypesProps) => (
  <Mutate<ResponseMapModuleTypeLong, Failure | Error, GetLastModifiedTimeForAllModuleTypesQueryParams, void, void>
    verb="POST"
    path={`/licenses/versions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastModifiedTimeForAllModuleTypesProps = Omit<
  UseMutateProps<
    ResponseMapModuleTypeLong,
    Failure | Error,
    GetLastModifiedTimeForAllModuleTypesQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Last Modified Time For All Module Types
 */
export const useGetLastModifiedTimeForAllModuleTypes = (props: UseGetLastModifiedTimeForAllModuleTypesProps) =>
  useMutate<ResponseMapModuleTypeLong, Failure | Error, GetLastModifiedTimeForAllModuleTypesQueryParams, void, void>(
    'POST',
    `/licenses/versions`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Last Modified Time For All Module Types
 */
export const getLastModifiedTimeForAllModuleTypesPromise = (
  props: MutateUsingFetchProps<
    ResponseMapModuleTypeLong,
    Failure | Error,
    GetLastModifiedTimeForAllModuleTypesQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseMapModuleTypeLong,
    Failure | Error,
    GetLastModifiedTimeForAllModuleTypesQueryParams,
    void,
    void
  >('POST', getConfig('ng/api'), `/licenses/versions`, props, signal)

export interface GetLicensesAndSummaryQueryParams {
  moduleType:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
}

export interface GetLicensesAndSummaryPathParams {
  accountIdentifier: string
}

export type GetLicensesAndSummaryProps = Omit<
  GetProps<
    ResponseLicensesWithSummaryDTO,
    Failure | Error,
    GetLicensesAndSummaryQueryParams,
    GetLicensesAndSummaryPathParams
  >,
  'path'
> &
  GetLicensesAndSummaryPathParams

/**
 * Gets Module Licenses With Summary By Account And ModuleType
 */
export const GetLicensesAndSummary = ({ accountIdentifier, ...props }: GetLicensesAndSummaryProps) => (
  <Get<
    ResponseLicensesWithSummaryDTO,
    Failure | Error,
    GetLicensesAndSummaryQueryParams,
    GetLicensesAndSummaryPathParams
  >
    path={`/licenses/${accountIdentifier}/summary`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLicensesAndSummaryProps = Omit<
  UseGetProps<
    ResponseLicensesWithSummaryDTO,
    Failure | Error,
    GetLicensesAndSummaryQueryParams,
    GetLicensesAndSummaryPathParams
  >,
  'path'
> &
  GetLicensesAndSummaryPathParams

/**
 * Gets Module Licenses With Summary By Account And ModuleType
 */
export const useGetLicensesAndSummary = ({ accountIdentifier, ...props }: UseGetLicensesAndSummaryProps) =>
  useGet<
    ResponseLicensesWithSummaryDTO,
    Failure | Error,
    GetLicensesAndSummaryQueryParams,
    GetLicensesAndSummaryPathParams
  >((paramsInPath: GetLicensesAndSummaryPathParams) => `/licenses/${paramsInPath.accountIdentifier}/summary`, {
    base: getConfig('ng/api'),
    pathParams: { accountIdentifier },
    ...props
  })

/**
 * Gets Module Licenses With Summary By Account And ModuleType
 */
export const getLicensesAndSummaryPromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseLicensesWithSummaryDTO,
    Failure | Error,
    GetLicensesAndSummaryQueryParams,
    GetLicensesAndSummaryPathParams
  > & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseLicensesWithSummaryDTO,
    Failure | Error,
    GetLicensesAndSummaryQueryParams,
    GetLicensesAndSummaryPathParams
  >(getConfig('ng/api'), `/licenses/${accountIdentifier}/summary`, props, signal)

export interface GetModuleLicenseByIdQueryParams {
  accountIdentifier: string
}

export interface GetModuleLicenseByIdPathParams {
  identifier: string
}

export type GetModuleLicenseByIdProps = Omit<
  GetProps<ResponseModuleLicenseDTO, Failure | Error, GetModuleLicenseByIdQueryParams, GetModuleLicenseByIdPathParams>,
  'path'
> &
  GetModuleLicenseByIdPathParams

/**
 * Gets Module License
 */
export const GetModuleLicenseById = ({ identifier, ...props }: GetModuleLicenseByIdProps) => (
  <Get<ResponseModuleLicenseDTO, Failure | Error, GetModuleLicenseByIdQueryParams, GetModuleLicenseByIdPathParams>
    path={`/licenses/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetModuleLicenseByIdProps = Omit<
  UseGetProps<
    ResponseModuleLicenseDTO,
    Failure | Error,
    GetModuleLicenseByIdQueryParams,
    GetModuleLicenseByIdPathParams
  >,
  'path'
> &
  GetModuleLicenseByIdPathParams

/**
 * Gets Module License
 */
export const useGetModuleLicenseById = ({ identifier, ...props }: UseGetModuleLicenseByIdProps) =>
  useGet<ResponseModuleLicenseDTO, Failure | Error, GetModuleLicenseByIdQueryParams, GetModuleLicenseByIdPathParams>(
    (paramsInPath: GetModuleLicenseByIdPathParams) => `/licenses/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets Module License
 */
export const getModuleLicenseByIdPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseModuleLicenseDTO,
    Failure | Error,
    GetModuleLicenseByIdQueryParams,
    GetModuleLicenseByIdPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseModuleLicenseDTO,
    Failure | Error,
    GetModuleLicenseByIdQueryParams,
    GetModuleLicenseByIdPathParams
  >(getConfig('ng/api'), `/licenses/${identifier}`, props, signal)

export interface GetHelmChartVersionDetailsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId?: string
  fqnPath?: string
  connectorRef?: string
  chartName?: string
  region?: string
  bucketName?: string
  folderPath?: string
  lastTag?: string
  registryId?: string
}

export type GetHelmChartVersionDetailsProps = Omit<
  GetProps<ResponseHelmChartResponseDTO, Failure | Error, GetHelmChartVersionDetailsQueryParams, void>,
  'path'
>

/**
 * Gets helm chart version details
 */
export const GetHelmChartVersionDetails = (props: GetHelmChartVersionDetailsProps) => (
  <Get<ResponseHelmChartResponseDTO, Failure | Error, GetHelmChartVersionDetailsQueryParams, void>
    path={`/manifests/helm/chart/version`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetHelmChartVersionDetailsProps = Omit<
  UseGetProps<ResponseHelmChartResponseDTO, Failure | Error, GetHelmChartVersionDetailsQueryParams, void>,
  'path'
>

/**
 * Gets helm chart version details
 */
export const useGetHelmChartVersionDetails = (props: UseGetHelmChartVersionDetailsProps) =>
  useGet<ResponseHelmChartResponseDTO, Failure | Error, GetHelmChartVersionDetailsQueryParams, void>(
    `/manifests/helm/chart/version`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets helm chart version details
 */
export const getHelmChartVersionDetailsPromise = (
  props: GetUsingFetchProps<ResponseHelmChartResponseDTO, Failure | Error, GetHelmChartVersionDetailsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseHelmChartResponseDTO, Failure | Error, GetHelmChartVersionDetailsQueryParams, void>(
    getConfig('ng/api'),
    `/manifests/helm/chart/version`,
    props,
    signal
  )

export interface GetHelmChartVersionDetailsV1QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  connectorRef: string
  chartName: string
  region?: string
  bucketName?: string
  folderPath?: string
  lastTag?: string
  storeType: string
  ociHelmChartStoreConfigType?: string
  helmVersion?: string
  registryId?: string
}

export type GetHelmChartVersionDetailsV1Props = Omit<
  GetProps<ResponseHelmChartResponseDTO, Failure | Error, GetHelmChartVersionDetailsV1QueryParams, void>,
  'path'
>

/**
 * Gets helm chart version details
 */
export const GetHelmChartVersionDetailsV1 = (props: GetHelmChartVersionDetailsV1Props) => (
  <Get<ResponseHelmChartResponseDTO, Failure | Error, GetHelmChartVersionDetailsV1QueryParams, void>
    path={`/manifests/helm/v1/chart/version`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetHelmChartVersionDetailsV1Props = Omit<
  UseGetProps<ResponseHelmChartResponseDTO, Failure | Error, GetHelmChartVersionDetailsV1QueryParams, void>,
  'path'
>

/**
 * Gets helm chart version details
 */
export const useGetHelmChartVersionDetailsV1 = (props: UseGetHelmChartVersionDetailsV1Props) =>
  useGet<ResponseHelmChartResponseDTO, Failure | Error, GetHelmChartVersionDetailsV1QueryParams, void>(
    `/manifests/helm/v1/chart/version`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets helm chart version details
 */
export const getHelmChartVersionDetailsV1Promise = (
  props: GetUsingFetchProps<
    ResponseHelmChartResponseDTO,
    Failure | Error,
    GetHelmChartVersionDetailsV1QueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseHelmChartResponseDTO, Failure | Error, GetHelmChartVersionDetailsV1QueryParams, void>(
    getConfig('ng/api'),
    `/manifests/helm/v1/chart/version`,
    props,
    signal
  )

export interface GetHelmChartVersionDetailsWithYamlQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pipelineIdentifier: string
  serviceId: string
  fqnPath: string
  connectorRef?: string
  chartName?: string
  region?: string
  bucketName?: string
  folderPath?: string
  lastTag?: string
  registryId?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetHelmChartVersionDetailsWithYamlProps = Omit<
  MutateProps<
    ResponseHelmChartResponseDTO,
    Failure | Error,
    GetHelmChartVersionDetailsWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets helm chart version details with yaml input for expression resolution
 */
export const GetHelmChartVersionDetailsWithYaml = (props: GetHelmChartVersionDetailsWithYamlProps) => (
  <Mutate<
    ResponseHelmChartResponseDTO,
    Failure | Error,
    GetHelmChartVersionDetailsWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >
    verb="POST"
    path={`/manifests/helm/v2/chart/version`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetHelmChartVersionDetailsWithYamlProps = Omit<
  UseMutateProps<
    ResponseHelmChartResponseDTO,
    Failure | Error,
    GetHelmChartVersionDetailsWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets helm chart version details with yaml input for expression resolution
 */
export const useGetHelmChartVersionDetailsWithYaml = (props: UseGetHelmChartVersionDetailsWithYamlProps) =>
  useMutate<
    ResponseHelmChartResponseDTO,
    Failure | Error,
    GetHelmChartVersionDetailsWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', `/manifests/helm/v2/chart/version`, { base: getConfig('ng/api'), ...props })

/**
 * Gets helm chart version details with yaml input for expression resolution
 */
export const getHelmChartVersionDetailsWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseHelmChartResponseDTO,
    Failure | Error,
    GetHelmChartVersionDetailsWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseHelmChartResponseDTO,
    Failure | Error,
    GetHelmChartVersionDetailsWithYamlQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/manifests/helm/v2/chart/version`, props, signal)

export interface ConfigureOauthQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  secretManagerIdentifier?: string
  provider?: string
  isPrivateSecret?: boolean
}

export type ConfigureOauthProps = Omit<
  MutateProps<
    RestResponseOauthAccessTokenResponseDTO,
    Failure | Error,
    ConfigureOauthQueryParams,
    OauthAccessTokenDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Setup secret for oauth tokens
 */
export const ConfigureOauth = (props: ConfigureOauthProps) => (
  <Mutate<
    RestResponseOauthAccessTokenResponseDTO,
    Failure | Error,
    ConfigureOauthQueryParams,
    OauthAccessTokenDTO,
    void
  >
    verb="POST"
    path={`/oauth/create-access-token-secret`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseConfigureOauthProps = Omit<
  UseMutateProps<
    RestResponseOauthAccessTokenResponseDTO,
    Failure | Error,
    ConfigureOauthQueryParams,
    OauthAccessTokenDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Setup secret for oauth tokens
 */
export const useConfigureOauth = (props: UseConfigureOauthProps) =>
  useMutate<
    RestResponseOauthAccessTokenResponseDTO,
    Failure | Error,
    ConfigureOauthQueryParams,
    OauthAccessTokenDTO,
    void
  >('POST', `/oauth/create-access-token-secret`, { base: getConfig('ng/api'), ...props })

/**
 * Setup secret for oauth tokens
 */
export const configureOauthPromise = (
  props: MutateUsingFetchProps<
    RestResponseOauthAccessTokenResponseDTO,
    Failure | Error,
    ConfigureOauthQueryParams,
    OauthAccessTokenDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseOauthAccessTokenResponseDTO,
    Failure | Error,
    ConfigureOauthQueryParams,
    OauthAccessTokenDTO,
    void
  >('POST', getConfig('ng/api'), `/oauth/create-access-token-secret`, props, signal)

export type GenerateOidcAccessTokenForGcpProps = Omit<
  MutateProps<ResponseOidcWorkloadAccessTokenResponse, Failure | Error, void, GcpOidcAccessTokenRequestDTO, void>,
  'path' | 'verb'
>

/**
 * Generate an OIDC Access Token for GCP
 */
export const GenerateOidcAccessTokenForGcp = (props: GenerateOidcAccessTokenForGcpProps) => (
  <Mutate<ResponseOidcWorkloadAccessTokenResponse, Failure | Error, void, GcpOidcAccessTokenRequestDTO, void>
    verb="POST"
    path={`/oidc/access-token/gcp/workload-access`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGenerateOidcAccessTokenForGcpProps = Omit<
  UseMutateProps<ResponseOidcWorkloadAccessTokenResponse, Failure | Error, void, GcpOidcAccessTokenRequestDTO, void>,
  'path' | 'verb'
>

/**
 * Generate an OIDC Access Token for GCP
 */
export const useGenerateOidcAccessTokenForGcp = (props: UseGenerateOidcAccessTokenForGcpProps) =>
  useMutate<ResponseOidcWorkloadAccessTokenResponse, Failure | Error, void, GcpOidcAccessTokenRequestDTO, void>(
    'POST',
    `/oidc/access-token/gcp/workload-access`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Generate an OIDC Access Token for GCP
 */
export const generateOidcAccessTokenForGcpPromise = (
  props: MutateUsingFetchProps<
    ResponseOidcWorkloadAccessTokenResponse,
    Failure | Error,
    void,
    GcpOidcAccessTokenRequestDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseOidcWorkloadAccessTokenResponse, Failure | Error, void, GcpOidcAccessTokenRequestDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/oidc/access-token/gcp/workload-access`,
    props,
    signal
  )

export interface GetHarnessOpenIdConfigPathParams {
  accountId: string
}

export type GetHarnessOpenIdConfigProps = Omit<
  GetProps<OidcConfiguration, Failure | Error, void, GetHarnessOpenIdConfigPathParams>,
  'path'
> &
  GetHarnessOpenIdConfigPathParams

/**
 * Gets the openid configuration for Harness
 */
export const GetHarnessOpenIdConfig = ({ accountId, ...props }: GetHarnessOpenIdConfigProps) => (
  <Get<OidcConfiguration, Failure | Error, void, GetHarnessOpenIdConfigPathParams>
    path={`/oidc/account/${accountId}/.well-known/openid-configuration`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetHarnessOpenIdConfigProps = Omit<
  UseGetProps<OidcConfiguration, Failure | Error, void, GetHarnessOpenIdConfigPathParams>,
  'path'
> &
  GetHarnessOpenIdConfigPathParams

/**
 * Gets the openid configuration for Harness
 */
export const useGetHarnessOpenIdConfig = ({ accountId, ...props }: UseGetHarnessOpenIdConfigProps) =>
  useGet<OidcConfiguration, Failure | Error, void, GetHarnessOpenIdConfigPathParams>(
    (paramsInPath: GetHarnessOpenIdConfigPathParams) =>
      `/oidc/account/${paramsInPath.accountId}/.well-known/openid-configuration`,
    { base: getConfig('ng/api'), pathParams: { accountId }, ...props }
  )

/**
 * Gets the openid configuration for Harness
 */
export const getHarnessOpenIdConfigPromise = (
  {
    accountId,
    ...props
  }: GetUsingFetchProps<OidcConfiguration, Failure | Error, void, GetHarnessOpenIdConfigPathParams> & {
    accountId: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<OidcConfiguration, Failure | Error, void, GetHarnessOpenIdConfigPathParams>(
    getConfig('ng/api'),
    `/oidc/account/${accountId}/.well-known/openid-configuration`,
    props,
    signal
  )

export interface GetHarnessOpenIdJwksPathParams {
  accountId: string
}

export type GetHarnessOpenIdJwksProps = Omit<
  GetProps<JwksPublicKeysDTO, Failure | Error, void, GetHarnessOpenIdJwksPathParams>,
  'path'
> &
  GetHarnessOpenIdJwksPathParams

/**
 * Gets the openid configuration for Harness
 */
export const GetHarnessOpenIdJwks = ({ accountId, ...props }: GetHarnessOpenIdJwksProps) => (
  <Get<JwksPublicKeysDTO, Failure | Error, void, GetHarnessOpenIdJwksPathParams>
    path={`/oidc/account/${accountId}/.wellknown/jwks`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetHarnessOpenIdJwksProps = Omit<
  UseGetProps<JwksPublicKeysDTO, Failure | Error, void, GetHarnessOpenIdJwksPathParams>,
  'path'
> &
  GetHarnessOpenIdJwksPathParams

/**
 * Gets the openid configuration for Harness
 */
export const useGetHarnessOpenIdJwks = ({ accountId, ...props }: UseGetHarnessOpenIdJwksProps) =>
  useGet<JwksPublicKeysDTO, Failure | Error, void, GetHarnessOpenIdJwksPathParams>(
    (paramsInPath: GetHarnessOpenIdJwksPathParams) => `/oidc/account/${paramsInPath.accountId}/.wellknown/jwks`,
    { base: getConfig('ng/api'), pathParams: { accountId }, ...props }
  )

/**
 * Gets the openid configuration for Harness
 */
export const getHarnessOpenIdJwksPromise = (
  {
    accountId,
    ...props
  }: GetUsingFetchProps<JwksPublicKeysDTO, Failure | Error, void, GetHarnessOpenIdJwksPathParams> & {
    accountId: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<JwksPublicKeysDTO, Failure | Error, void, GetHarnessOpenIdJwksPathParams>(
    getConfig('ng/api'),
    `/oidc/account/${accountId}/.wellknown/jwks`,
    props,
    signal
  )

export type GenerateOidcIdTokenForGcpProps = Omit<
  MutateProps<ResponseString, Failure | Error, void, GcpOidcTokenRequestDTO, void>,
  'path' | 'verb'
>

/**
 * Generate an OIDC ID Token for GCP
 */
export const GenerateOidcIdTokenForGcp = (props: GenerateOidcIdTokenForGcpProps) => (
  <Mutate<ResponseString, Failure | Error, void, GcpOidcTokenRequestDTO, void>
    verb="POST"
    path={`/oidc/id-token/gcp`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGenerateOidcIdTokenForGcpProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, void, GcpOidcTokenRequestDTO, void>,
  'path' | 'verb'
>

/**
 * Generate an OIDC ID Token for GCP
 */
export const useGenerateOidcIdTokenForGcp = (props: UseGenerateOidcIdTokenForGcpProps) =>
  useMutate<ResponseString, Failure | Error, void, GcpOidcTokenRequestDTO, void>('POST', `/oidc/id-token/gcp`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Generate an OIDC ID Token for GCP
 */
export const generateOidcIdTokenForGcpPromise = (
  props: MutateUsingFetchProps<ResponseString, Failure | Error, void, GcpOidcTokenRequestDTO, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, void, GcpOidcTokenRequestDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/oidc/id-token/gcp`,
    props,
    signal
  )

export interface GetOrganizationListQueryParams {
  accountIdentifier: string
  identifiers?: string[]
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type GetOrganizationListProps = Omit<
  GetProps<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>,
  'path'
>

/**
 * Get Organization list
 */
export const GetOrganizationList = (props: GetOrganizationListProps) => (
  <Get<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>
    path={`/organizations`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationListProps = Omit<
  UseGetProps<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>,
  'path'
>

/**
 * Get Organization list
 */
export const useGetOrganizationList = (props: UseGetOrganizationListProps) =>
  useGet<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>(`/organizations`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Organization list
 */
export const getOrganizationListPromise = (
  props: GetUsingFetchProps<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>(
    getConfig('ng/api'),
    `/organizations`,
    props,
    signal
  )

export interface PostOrganizationQueryParams {
  accountIdentifier: string
}

export type PostOrganizationProps = Omit<
  MutateProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Organization
 */
export const PostOrganization = (props: PostOrganizationProps) => (
  <Mutate<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >
    verb="POST"
    path={`/organizations`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostOrganizationProps = Omit<
  UseMutateProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Organization
 */
export const usePostOrganization = (props: UsePostOrganizationProps) =>
  useMutate<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >('POST', `/organizations`, { base: getConfig('ng/api'), ...props })

/**
 * Create an Organization
 */
export const postOrganizationPromise = (
  props: MutateUsingFetchProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >('POST', getConfig('ng/api'), `/organizations`, props, signal)

export interface DeleteOrganizationQueryParams {
  accountIdentifier: string
}

export type DeleteOrganizationProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an Organization by identifier
 */
export const DeleteOrganization = (props: DeleteOrganizationProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>
    verb="DELETE"
    path={`/organizations`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteOrganizationProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an Organization by identifier
 */
export const useDeleteOrganization = (props: UseDeleteOrganizationProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>('DELETE', `/organizations`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete an Organization by identifier
 */
export const deleteOrganizationPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/organizations`,
    props,
    signal
  )

export interface GetOrganizationQueryParams {
  accountIdentifier: string
}

export interface GetOrganizationPathParams {
  identifier: string
}

export type GetOrganizationProps = Omit<
  GetProps<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>,
  'path'
> &
  GetOrganizationPathParams

/**
 * Get an Organization by identifier
 */
export const GetOrganization = ({ identifier, ...props }: GetOrganizationProps) => (
  <Get<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>
    path={`/organizations/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationProps = Omit<
  UseGetProps<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>,
  'path'
> &
  GetOrganizationPathParams

/**
 * Get an Organization by identifier
 */
export const useGetOrganization = ({ identifier, ...props }: UseGetOrganizationProps) =>
  useGet<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>(
    (paramsInPath: GetOrganizationPathParams) => `/organizations/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get an Organization by identifier
 */
export const getOrganizationPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseOrganizationResponse,
    Failure | Error,
    GetOrganizationQueryParams,
    GetOrganizationPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>(
    getConfig('ng/api'),
    `/organizations/${identifier}`,
    props,
    signal
  )

export interface PutOrganizationQueryParams {
  accountIdentifier: string
}

export interface PutOrganizationPathParams {
  identifier: string
}

export type PutOrganizationProps = Omit<
  MutateProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >,
  'path' | 'verb'
> &
  PutOrganizationPathParams

/**
 * Update an Organization by ID
 */
export const PutOrganization = ({ identifier, ...props }: PutOrganizationProps) => (
  <Mutate<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >
    verb="PUT"
    path={`/organizations/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutOrganizationProps = Omit<
  UseMutateProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >,
  'path' | 'verb'
> &
  PutOrganizationPathParams

/**
 * Update an Organization by ID
 */
export const usePutOrganization = ({ identifier, ...props }: UsePutOrganizationProps) =>
  useMutate<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >('PUT', (paramsInPath: PutOrganizationPathParams) => `/organizations/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update an Organization by ID
 */
export const putOrganizationPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >('PUT', getConfig('ng/api'), `/organizations/${identifier}`, props, signal)

export interface GetPartialYamlSchemaQueryParams {
  accountIdentifier: string
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export type GetPartialYamlSchemaProps = Omit<
  GetProps<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Partial Yaml Schema
 */
export const GetPartialYamlSchema = (props: GetPartialYamlSchemaProps) => (
  <Get<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>
    path={`/partial-yaml-schema`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPartialYamlSchemaProps = Omit<
  UseGetProps<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Partial Yaml Schema
 */
export const useGetPartialYamlSchema = (props: UseGetPartialYamlSchemaProps) =>
  useGet<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>(`/partial-yaml-schema`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Partial Yaml Schema
 */
export const getPartialYamlSchemaPromise = (
  props: GetUsingFetchProps<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>(
    getConfig('ng/api'),
    `/partial-yaml-schema`,
    props,
    signal
  )

export interface GetStepYamlSchemaQueryParams {
  accountIdentifier: string
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
  entityType?:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  yamlGroup?: string
}

export type GetStepYamlSchemaProps = Omit<
  MutateProps<
    ResponseJsonNode,
    Failure | Error,
    GetStepYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get step YAML schema
 */
export const GetStepYamlSchema = (props: GetStepYamlSchemaProps) => (
  <Mutate<ResponseJsonNode, Failure | Error, GetStepYamlSchemaQueryParams, YamlSchemaDetailsWrapperRequestBody, void>
    verb="POST"
    path={`/partial-yaml-schema`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetStepYamlSchemaProps = Omit<
  UseMutateProps<
    ResponseJsonNode,
    Failure | Error,
    GetStepYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get step YAML schema
 */
export const useGetStepYamlSchema = (props: UseGetStepYamlSchemaProps) =>
  useMutate<ResponseJsonNode, Failure | Error, GetStepYamlSchemaQueryParams, YamlSchemaDetailsWrapperRequestBody, void>(
    'POST',
    `/partial-yaml-schema`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get step YAML schema
 */
export const getStepYamlSchemaPromise = (
  props: MutateUsingFetchProps<
    ResponseJsonNode,
    Failure | Error,
    GetStepYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseJsonNode,
    Failure | Error,
    GetStepYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >('POST', getConfig('ng/api'), `/partial-yaml-schema`, props, signal)

export interface GetPartialYamlSchemaWithDetailsQueryParams {
  accountIdentifier: string
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export type GetPartialYamlSchemaWithDetailsProps = Omit<
  GetProps<ResponseYamlSchemaDetailsWrapper, Failure | Error, GetPartialYamlSchemaWithDetailsQueryParams, void>,
  'path'
>

/**
 * Get Partial Yaml Schema with details
 */
export const GetPartialYamlSchemaWithDetails = (props: GetPartialYamlSchemaWithDetailsProps) => (
  <Get<ResponseYamlSchemaDetailsWrapper, Failure | Error, GetPartialYamlSchemaWithDetailsQueryParams, void>
    path={`/partial-yaml-schema/details`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPartialYamlSchemaWithDetailsProps = Omit<
  UseGetProps<ResponseYamlSchemaDetailsWrapper, Failure | Error, GetPartialYamlSchemaWithDetailsQueryParams, void>,
  'path'
>

/**
 * Get Partial Yaml Schema with details
 */
export const useGetPartialYamlSchemaWithDetails = (props: UseGetPartialYamlSchemaWithDetailsProps) =>
  useGet<ResponseYamlSchemaDetailsWrapper, Failure | Error, GetPartialYamlSchemaWithDetailsQueryParams, void>(
    `/partial-yaml-schema/details`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Partial Yaml Schema with details
 */
export const getPartialYamlSchemaWithDetailsPromise = (
  props: GetUsingFetchProps<
    ResponseYamlSchemaDetailsWrapper,
    Failure | Error,
    GetPartialYamlSchemaWithDetailsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseYamlSchemaDetailsWrapper, Failure | Error, GetPartialYamlSchemaWithDetailsQueryParams, void>(
    getConfig('ng/api'),
    `/partial-yaml-schema/details`,
    props,
    signal
  )

export interface GetEntityYamlSchemaQueryParams {
  accountIdentifier: string
  projectIdentifier?: string
  orgIdentifier?: string
  entityType?:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
}

export type GetEntityYamlSchemaProps = Omit<
  GetProps<ResponseJsonNode, Failure | Error, GetEntityYamlSchemaQueryParams, void>,
  'path'
>

export const GetEntityYamlSchema = (props: GetEntityYamlSchemaProps) => (
  <Get<ResponseJsonNode, Failure | Error, GetEntityYamlSchemaQueryParams, void>
    path={`/partial-yaml-schema/entityYaml`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEntityYamlSchemaProps = Omit<
  UseGetProps<ResponseJsonNode, Failure | Error, GetEntityYamlSchemaQueryParams, void>,
  'path'
>

export const useGetEntityYamlSchema = (props: UseGetEntityYamlSchemaProps) =>
  useGet<ResponseJsonNode, Failure | Error, GetEntityYamlSchemaQueryParams, void>(`/partial-yaml-schema/entityYaml`, {
    base: getConfig('ng/api'),
    ...props
  })

export const getEntityYamlSchemaPromise = (
  props: GetUsingFetchProps<ResponseJsonNode, Failure | Error, GetEntityYamlSchemaQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJsonNode, Failure | Error, GetEntityYamlSchemaQueryParams, void>(
    getConfig('ng/api'),
    `/partial-yaml-schema/entityYaml`,
    props,
    signal
  )

export interface GetMergedPartialYamlSchemaQueryParams {
  accountIdentifier: string
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export type GetMergedPartialYamlSchemaProps = Omit<
  MutateProps<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Merged Partial Yaml Schema
 */
export const GetMergedPartialYamlSchema = (props: GetMergedPartialYamlSchemaProps) => (
  <Mutate<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >
    verb="POST"
    path={`/partial-yaml-schema/merged`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetMergedPartialYamlSchemaProps = Omit<
  UseMutateProps<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Merged Partial Yaml Schema
 */
export const useGetMergedPartialYamlSchema = (props: UseGetMergedPartialYamlSchemaProps) =>
  useMutate<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >('POST', `/partial-yaml-schema/merged`, { base: getConfig('ng/api'), ...props })

/**
 * Get Merged Partial Yaml Schema
 */
export const getMergedPartialYamlSchemaPromise = (
  props: MutateUsingFetchProps<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >('POST', getConfig('ng/api'), `/partial-yaml-schema/merged`, props, signal)

export type GetFailureStrategiesYamlProps = Omit<GetProps<ResponseString, Failure | Error, void, void>, 'path'>

/**
 * Gets the failure strategy yaml snippet for CD stage
 */
export const GetFailureStrategiesYaml = (props: GetFailureStrategiesYamlProps) => (
  <Get<ResponseString, Failure | Error, void, void>
    path={`/pipelines/configuration/cd-stage-yaml-snippet`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFailureStrategiesYamlProps = Omit<UseGetProps<ResponseString, Failure | Error, void, void>, 'path'>

/**
 * Gets the failure strategy yaml snippet for CD stage
 */
export const useGetFailureStrategiesYaml = (props: UseGetFailureStrategiesYamlProps) =>
  useGet<ResponseString, Failure | Error, void, void>(`/pipelines/configuration/cd-stage-yaml-snippet`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets the failure strategy yaml snippet for CD stage
 */
export const getFailureStrategiesYamlPromise = (
  props: GetUsingFetchProps<ResponseString, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/cd-stage-yaml-snippet`,
    props,
    signal
  )

export type GetProvisionerStepsProps = Omit<GetProps<ResponseStepCategory, Failure | Error, void, void>, 'path'>

/**
 * get provisioner steps
 */
export const GetProvisionerSteps = (props: GetProvisionerStepsProps) => (
  <Get<ResponseStepCategory, Failure | Error, void, void>
    path={`/pipelines/configuration/provisioner-steps`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProvisionerStepsProps = Omit<UseGetProps<ResponseStepCategory, Failure | Error, void, void>, 'path'>

/**
 * get provisioner steps
 */
export const useGetProvisionerSteps = (props: UseGetProvisionerStepsProps) =>
  useGet<ResponseStepCategory, Failure | Error, void, void>(`/pipelines/configuration/provisioner-steps`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * get provisioner steps
 */
export const getProvisionerStepsPromise = (
  props: GetUsingFetchProps<ResponseStepCategory, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseStepCategory, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/provisioner-steps`,
    props,
    signal
  )

export interface GetServiceDefinitionTypesQueryParams {
  accountId?: string
}

export type GetServiceDefinitionTypesProps = Omit<
  GetProps<ResponseListServiceDefinitionType, Failure | Error, GetServiceDefinitionTypesQueryParams, void>,
  'path'
>

/**
 * Git list of service definition types
 */
export const GetServiceDefinitionTypes = (props: GetServiceDefinitionTypesProps) => (
  <Get<ResponseListServiceDefinitionType, Failure | Error, GetServiceDefinitionTypesQueryParams, void>
    path={`/pipelines/configuration/serviceDefinitionTypes`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceDefinitionTypesProps = Omit<
  UseGetProps<ResponseListServiceDefinitionType, Failure | Error, GetServiceDefinitionTypesQueryParams, void>,
  'path'
>

/**
 * Git list of service definition types
 */
export const useGetServiceDefinitionTypes = (props: UseGetServiceDefinitionTypesProps) =>
  useGet<ResponseListServiceDefinitionType, Failure | Error, GetServiceDefinitionTypesQueryParams, void>(
    `/pipelines/configuration/serviceDefinitionTypes`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Git list of service definition types
 */
export const getServiceDefinitionTypesPromise = (
  props: GetUsingFetchProps<
    ResponseListServiceDefinitionType,
    Failure | Error,
    GetServiceDefinitionTypesQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListServiceDefinitionType, Failure | Error, GetServiceDefinitionTypesQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/serviceDefinitionTypes`,
    props,
    signal
  )

export interface GetStepsQueryParams {
  serviceDefinitionType:
    | 'Kubernetes'
    | 'NativeHelm'
    | 'Ssh'
    | 'WinRm'
    | 'ServerlessAwsLambda'
    | 'AzureWebApp'
    | 'CustomDeployment'
    | 'ECS'
    | 'Elastigroup'
    | 'TAS'
    | 'Asg'
    | 'GoogleCloudFunctions'
    | 'AwsLambda'
    | 'AWS_SAM'
}

export type GetStepsProps = Omit<GetProps<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>, 'path'>

/**
 * get steps for given service definition type
 */
export const GetSteps = (props: GetStepsProps) => (
  <Get<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>
    path={`/pipelines/configuration/steps`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetStepsProps = Omit<
  UseGetProps<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>,
  'path'
>

/**
 * get steps for given service definition type
 */
export const useGetSteps = (props: UseGetStepsProps) =>
  useGet<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>(`/pipelines/configuration/steps`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * get steps for given service definition type
 */
export const getStepsPromise = (
  props: GetUsingFetchProps<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/steps`,
    props,
    signal
  )

export type GetExecutionStrategyListProps = Omit<
  GetProps<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>,
  'path'
>

/**
 * Gets Execution Strategy list
 */
export const GetExecutionStrategyList = (props: GetExecutionStrategyListProps) => (
  <Get<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>
    path={`/pipelines/configuration/strategies`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetExecutionStrategyListProps = Omit<
  UseGetProps<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>,
  'path'
>

/**
 * Gets Execution Strategy list
 */
export const useGetExecutionStrategyList = (props: UseGetExecutionStrategyListProps) =>
  useGet<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>(
    `/pipelines/configuration/strategies`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Execution Strategy list
 */
export const getExecutionStrategyListPromise = (
  props: GetUsingFetchProps<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/strategies`,
    props,
    signal
  )

export interface GetProvisionerExecutionStrategyYamlQueryParams {
  provisionerType:
    | 'TERRAFORM'
    | 'CLOUD_FORMATION'
    | 'AZURE_ARM'
    | 'AZURE_BLUEPRINT'
    | 'SHELL_SCRIPT_PROVISIONER'
    | 'TERRAGRUNT'
    | 'TERRAFORM_CLOUD'
    | 'AWS_CDK'
}

export type GetProvisionerExecutionStrategyYamlProps = Omit<
  GetProps<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>,
  'path'
>

/**
 * Gets Yaml for Execution Strategy based on Provisioner Type
 */
export const GetProvisionerExecutionStrategyYaml = (props: GetProvisionerExecutionStrategyYamlProps) => (
  <Get<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>
    path={`/pipelines/configuration/strategies/provisioner-yaml-snippets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProvisionerExecutionStrategyYamlProps = Omit<
  UseGetProps<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>,
  'path'
>

/**
 * Gets Yaml for Execution Strategy based on Provisioner Type
 */
export const useGetProvisionerExecutionStrategyYaml = (props: UseGetProvisionerExecutionStrategyYamlProps) =>
  useGet<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>(
    `/pipelines/configuration/strategies/provisioner-yaml-snippets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Yaml for Execution Strategy based on Provisioner Type
 */
export const getProvisionerExecutionStrategyYamlPromise = (
  props: GetUsingFetchProps<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/strategies/provisioner-yaml-snippets`,
    props,
    signal
  )

export interface GetExecutionStrategyYamlQueryParams {
  serviceDefinitionType:
    | 'Kubernetes'
    | 'NativeHelm'
    | 'Ssh'
    | 'WinRm'
    | 'ServerlessAwsLambda'
    | 'AzureWebApp'
    | 'CustomDeployment'
    | 'ECS'
    | 'Elastigroup'
    | 'TAS'
    | 'Asg'
    | 'GoogleCloudFunctions'
    | 'AwsLambda'
    | 'AWS_SAM'
  strategyType: 'Basic' | 'Canary' | 'BlueGreen' | 'Rolling' | 'Default' | 'GitOps'
  includeVerify?: boolean
  accountIdentifier?: string
  deploymentMetadataYaml?: string
}

export type GetExecutionStrategyYamlProps = Omit<
  GetProps<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>,
  'path'
>

/**
 * Gets Yaml for Execution Strategy based on deployment type and selected strategy
 */
export const GetExecutionStrategyYaml = (props: GetExecutionStrategyYamlProps) => (
  <Get<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>
    path={`/pipelines/configuration/strategies/yaml-snippets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetExecutionStrategyYamlProps = Omit<
  UseGetProps<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>,
  'path'
>

/**
 * Gets Yaml for Execution Strategy based on deployment type and selected strategy
 */
export const useGetExecutionStrategyYaml = (props: UseGetExecutionStrategyYamlProps) =>
  useGet<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>(
    `/pipelines/configuration/strategies/yaml-snippets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Yaml for Execution Strategy based on deployment type and selected strategy
 */
export const getExecutionStrategyYamlPromise = (
  props: GetUsingFetchProps<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/strategies/yaml-snippets`,
    props,
    signal
  )

export interface PostExecutionStrategyYamlQueryParams {
  accountIdentifier: string
  serviceDefinitionType:
    | 'Kubernetes'
    | 'NativeHelm'
    | 'Ssh'
    | 'WinRm'
    | 'ServerlessAwsLambda'
    | 'AzureWebApp'
    | 'CustomDeployment'
    | 'ECS'
    | 'Elastigroup'
    | 'TAS'
    | 'Asg'
    | 'GoogleCloudFunctions'
    | 'AwsLambda'
    | 'AWS_SAM'
  strategyType: 'Basic' | 'Canary' | 'BlueGreen' | 'Rolling' | 'Default' | 'GitOps'
  includeVerify?: boolean
}

export type PostExecutionStrategyYamlProps = Omit<
  MutateProps<ResponseString, Failure | Error, PostExecutionStrategyYamlQueryParams, StrategyParameters, void>,
  'path' | 'verb'
>

/**
 * Gets generated Yaml snippet based on strategy parameters
 */
export const PostExecutionStrategyYaml = (props: PostExecutionStrategyYamlProps) => (
  <Mutate<ResponseString, Failure | Error, PostExecutionStrategyYamlQueryParams, StrategyParameters, void>
    verb="POST"
    path={`/pipelines/configuration/strategies/yaml-snippets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostExecutionStrategyYamlProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, PostExecutionStrategyYamlQueryParams, StrategyParameters, void>,
  'path' | 'verb'
>

/**
 * Gets generated Yaml snippet based on strategy parameters
 */
export const usePostExecutionStrategyYaml = (props: UsePostExecutionStrategyYamlProps) =>
  useMutate<ResponseString, Failure | Error, PostExecutionStrategyYamlQueryParams, StrategyParameters, void>(
    'POST',
    `/pipelines/configuration/strategies/yaml-snippets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets generated Yaml snippet based on strategy parameters
 */
export const postExecutionStrategyYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseString,
    Failure | Error,
    PostExecutionStrategyYamlQueryParams,
    StrategyParameters,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, PostExecutionStrategyYamlQueryParams, StrategyParameters, void>(
    'POST',
    getConfig('ng/api'),
    `/pipelines/configuration/strategies/yaml-snippets`,
    props,
    signal
  )

export interface GetProjectListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  hasModule?: boolean
  identifiers?: string[]
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  searchTerm?: string
  onlyFavorites?: boolean
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type GetProjectListProps = Omit<
  GetProps<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>,
  'path'
>

/**
 * Get Project list
 */
export const GetProjectList = (props: GetProjectListProps) => (
  <Get<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>
    path={`/projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectListProps = Omit<
  UseGetProps<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>,
  'path'
>

/**
 * Get Project list
 */
export const useGetProjectList = (props: UseGetProjectListProps) =>
  useGet<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>(`/projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Project list
 */
export const getProjectListPromise = (
  props: GetUsingFetchProps<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>(
    getConfig('ng/api'),
    `/projects`,
    props,
    signal
  )

export interface PostProjectQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export type PostProjectProps = Omit<
  MutateProps<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Project
 */
export const PostProject = (props: PostProjectProps) => (
  <Mutate<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>
    verb="POST"
    path={`/projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostProjectProps = Omit<
  UseMutateProps<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Project
 */
export const usePostProject = (props: UsePostProjectProps) =>
  useMutate<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>(
    'POST',
    `/projects`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a Project
 */
export const postProjectPromise = (
  props: MutateUsingFetchProps<
    ResponseProjectResponse,
    Failure | Error,
    PostProjectQueryParams,
    ProjectRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/projects`,
    props,
    signal
  )

export interface GetProjectListWithMultiOrgFilterQueryParams {
  accountIdentifier: string
  orgIdentifiers?: string[]
  hasModule?: boolean
  identifiers?: string[]
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  searchTerm?: string
  onlyFavorites?: boolean
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type GetProjectListWithMultiOrgFilterProps = Omit<
  GetProps<ResponsePageProjectResponse, Failure | Error, GetProjectListWithMultiOrgFilterQueryParams, void>,
  'path'
>

/**
 * Get Project list
 */
export const GetProjectListWithMultiOrgFilter = (props: GetProjectListWithMultiOrgFilterProps) => (
  <Get<ResponsePageProjectResponse, Failure | Error, GetProjectListWithMultiOrgFilterQueryParams, void>
    path={`/projects/list`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectListWithMultiOrgFilterProps = Omit<
  UseGetProps<ResponsePageProjectResponse, Failure | Error, GetProjectListWithMultiOrgFilterQueryParams, void>,
  'path'
>

/**
 * Get Project list
 */
export const useGetProjectListWithMultiOrgFilter = (props: UseGetProjectListWithMultiOrgFilterProps) =>
  useGet<ResponsePageProjectResponse, Failure | Error, GetProjectListWithMultiOrgFilterQueryParams, void>(
    `/projects/list`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Project list
 */
export const getProjectListWithMultiOrgFilterPromise = (
  props: GetUsingFetchProps<
    ResponsePageProjectResponse,
    Failure | Error,
    GetProjectListWithMultiOrgFilterQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageProjectResponse, Failure | Error, GetProjectListWithMultiOrgFilterQueryParams, void>(
    getConfig('ng/api'),
    `/projects/list`,
    props,
    signal
  )

export interface DeleteProjectQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export type DeleteProjectProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a Project by identifier
 */
export const DeleteProject = (props: DeleteProjectProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>
    verb="DELETE"
    path={`/projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteProjectProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a Project by identifier
 */
export const useDeleteProject = (props: UseDeleteProjectProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>('DELETE', `/projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a Project by identifier
 */
export const deleteProjectPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/projects`,
    props,
    signal
  )

export interface GetProjectQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export interface GetProjectPathParams {
  identifier: string
}

export type GetProjectProps = Omit<
  GetProps<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>,
  'path'
> &
  GetProjectPathParams

/**
 * Gets a Project by ID
 */
export const GetProject = ({ identifier, ...props }: GetProjectProps) => (
  <Get<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>
    path={`/projects/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectProps = Omit<
  UseGetProps<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>,
  'path'
> &
  GetProjectPathParams

/**
 * Gets a Project by ID
 */
export const useGetProject = ({ identifier, ...props }: UseGetProjectProps) =>
  useGet<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>(
    (paramsInPath: GetProjectPathParams) => `/projects/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets a Project by ID
 */
export const getProjectPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>(
    getConfig('ng/api'),
    `/projects/${identifier}`,
    props,
    signal
  )

export interface PutProjectQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export interface PutProjectPathParams {
  identifier: string
}

export type PutProjectProps = Omit<
  MutateProps<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >,
  'path' | 'verb'
> &
  PutProjectPathParams

/**
 * Update a Project by ID
 */
export const PutProject = ({ identifier, ...props }: PutProjectProps) => (
  <Mutate<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >
    verb="PUT"
    path={`/projects/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutProjectProps = Omit<
  UseMutateProps<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >,
  'path' | 'verb'
> &
  PutProjectPathParams

/**
 * Update a Project by ID
 */
export const usePutProject = ({ identifier, ...props }: UsePutProjectProps) =>
  useMutate<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >('PUT', (paramsInPath: PutProjectPathParams) => `/projects/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a Project by ID
 */
export const putProjectPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >('PUT', getConfig('ng/api'), `/projects/${identifier}`, props, signal)

export interface GetRefreshedYamlQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetRefreshedYamlProps = Omit<
  MutateProps<
    ResponseRefreshResponse,
    Failure | Error,
    GetRefreshedYamlQueryParams,
    NgManagerRefreshRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * This refreshes and update inputs of entities in given yaml
 */
export const GetRefreshedYaml = (props: GetRefreshedYamlProps) => (
  <Mutate<
    ResponseRefreshResponse,
    Failure | Error,
    GetRefreshedYamlQueryParams,
    NgManagerRefreshRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/refresh-inputs/refreshed-yaml`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetRefreshedYamlProps = Omit<
  UseMutateProps<
    ResponseRefreshResponse,
    Failure | Error,
    GetRefreshedYamlQueryParams,
    NgManagerRefreshRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * This refreshes and update inputs of entities in given yaml
 */
export const useGetRefreshedYaml = (props: UseGetRefreshedYamlProps) =>
  useMutate<
    ResponseRefreshResponse,
    Failure | Error,
    GetRefreshedYamlQueryParams,
    NgManagerRefreshRequestDTORequestBody,
    void
  >('POST', `/refresh-inputs/refreshed-yaml`, { base: getConfig('ng/api'), ...props })

/**
 * This refreshes and update inputs of entities in given yaml
 */
export const getRefreshedYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseRefreshResponse,
    Failure | Error,
    GetRefreshedYamlQueryParams,
    NgManagerRefreshRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseRefreshResponse,
    Failure | Error,
    GetRefreshedYamlQueryParams,
    NgManagerRefreshRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/refresh-inputs/refreshed-yaml`, props, signal)

export interface ValidateInputsForYamlQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ValidateInputsForYamlProps = Omit<
  MutateProps<
    ResponseInputsValidationResponse,
    Failure | Error,
    ValidateInputsForYamlQueryParams,
    NgManagerRefreshRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * This validates whether inputs provided to different references in yaml is valid or not
 */
export const ValidateInputsForYaml = (props: ValidateInputsForYamlProps) => (
  <Mutate<
    ResponseInputsValidationResponse,
    Failure | Error,
    ValidateInputsForYamlQueryParams,
    NgManagerRefreshRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/refresh-inputs/validate-inputs-yaml`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateInputsForYamlProps = Omit<
  UseMutateProps<
    ResponseInputsValidationResponse,
    Failure | Error,
    ValidateInputsForYamlQueryParams,
    NgManagerRefreshRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * This validates whether inputs provided to different references in yaml is valid or not
 */
export const useValidateInputsForYaml = (props: UseValidateInputsForYamlProps) =>
  useMutate<
    ResponseInputsValidationResponse,
    Failure | Error,
    ValidateInputsForYamlQueryParams,
    NgManagerRefreshRequestDTORequestBody,
    void
  >('POST', `/refresh-inputs/validate-inputs-yaml`, { base: getConfig('ng/api'), ...props })

/**
 * This validates whether inputs provided to different references in yaml is valid or not
 */
export const validateInputsForYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseInputsValidationResponse,
    Failure | Error,
    ValidateInputsForYamlQueryParams,
    NgManagerRefreshRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInputsValidationResponse,
    Failure | Error,
    ValidateInputsForYamlQueryParams,
    NgManagerRefreshRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/refresh-inputs/validate-inputs-yaml`, props, signal)

export interface CreateRoleAssignmentQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateRoleAssignmentProps = Omit<
  MutateProps<ResponseRoleAssignmentResponse, Failure | Error, CreateRoleAssignmentQueryParams, RoleAssignment, void>,
  'path' | 'verb'
>

/**
 * (Stub) Create Role Assignment
 */
export const CreateRoleAssignment = (props: CreateRoleAssignmentProps) => (
  <Mutate<ResponseRoleAssignmentResponse, Failure | Error, CreateRoleAssignmentQueryParams, RoleAssignment, void>
    verb="POST"
    path={`/roleassignments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateRoleAssignmentProps = Omit<
  UseMutateProps<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentQueryParams,
    RoleAssignment,
    void
  >,
  'path' | 'verb'
>

/**
 * (Stub) Create Role Assignment
 */
export const useCreateRoleAssignment = (props: UseCreateRoleAssignmentProps) =>
  useMutate<ResponseRoleAssignmentResponse, Failure | Error, CreateRoleAssignmentQueryParams, RoleAssignment, void>(
    'POST',
    `/roleassignments`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * (Stub) Create Role Assignment
 */
export const createRoleAssignmentPromise = (
  props: MutateUsingFetchProps<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentQueryParams,
    RoleAssignment,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentQueryParams,
    RoleAssignment,
    void
  >('POST', getConfig('ng/api'), `/roleassignments`, props, signal)

export interface GetRoleAssignmentsAggregateQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetRoleAssignmentsAggregateProps = Omit<
  MutateProps<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Role Assignments Aggregate
 */
export const GetRoleAssignmentsAggregate = (props: GetRoleAssignmentsAggregateProps) => (
  <Mutate<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >
    verb="POST"
    path={`/roleassignments/aggregate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetRoleAssignmentsAggregateProps = Omit<
  UseMutateProps<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Role Assignments Aggregate
 */
export const useGetRoleAssignmentsAggregate = (props: UseGetRoleAssignmentsAggregateProps) =>
  useMutate<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >('POST', `/roleassignments/aggregate`, { base: getConfig('ng/api'), ...props })

/**
 * Get Role Assignments Aggregate
 */
export const getRoleAssignmentsAggregatePromise = (
  props: MutateUsingFetchProps<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >('POST', getConfig('ng/api'), `/roleassignments/aggregate`, props, signal)

export interface GetFilteredRoleAssignmentListQueryParams {
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetFilteredRoleAssignmentListProps = Omit<
  MutateProps<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * (Stub) Get Filtered Role Assignments
 */
export const GetFilteredRoleAssignmentList = (props: GetFilteredRoleAssignmentListProps) => (
  <Mutate<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >
    verb="POST"
    path={`/roleassignments/filter`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFilteredRoleAssignmentListProps = Omit<
  UseMutateProps<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * (Stub) Get Filtered Role Assignments
 */
export const useGetFilteredRoleAssignmentList = (props: UseGetFilteredRoleAssignmentListProps) =>
  useMutate<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >('POST', `/roleassignments/filter`, { base: getConfig('ng/api'), ...props })

/**
 * (Stub) Get Filtered Role Assignments
 */
export const getFilteredRoleAssignmentListPromise = (
  props: MutateUsingFetchProps<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >('POST', getConfig('ng/api'), `/roleassignments/filter`, props, signal)

export interface CreateRoleAssignmentsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  managed?: boolean
}

export type CreateRoleAssignmentsProps = Omit<
  MutateProps<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    RoleAssignmentCreateRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * (Stub) Create Multiple Role Assignments
 */
export const CreateRoleAssignments = (props: CreateRoleAssignmentsProps) => (
  <Mutate<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    RoleAssignmentCreateRequest,
    void
  >
    verb="POST"
    path={`/roleassignments/multi/internal`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateRoleAssignmentsProps = Omit<
  UseMutateProps<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    RoleAssignmentCreateRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * (Stub) Create Multiple Role Assignments
 */
export const useCreateRoleAssignments = (props: UseCreateRoleAssignmentsProps) =>
  useMutate<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    RoleAssignmentCreateRequest,
    void
  >('POST', `/roleassignments/multi/internal`, { base: getConfig('ng/api'), ...props })

/**
 * (Stub) Create Multiple Role Assignments
 */
export const createRoleAssignmentsPromise = (
  props: MutateUsingFetchProps<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    RoleAssignmentCreateRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    RoleAssignmentCreateRequest,
    void
  >('POST', getConfig('ng/api'), `/roleassignments/multi/internal`, props, signal)

export interface CheckIfInstanceCanBeRolledBackQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CheckIfInstanceCanBeRolledBackProps = Omit<
  MutateProps<
    ResponsePostProdRollbackCheckDTO,
    Failure | Error,
    CheckIfInstanceCanBeRolledBackQueryParams,
    PostProdRollbackRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Check if the post-prod-rollback is possible for the given instanceUuid
 */
export const CheckIfInstanceCanBeRolledBack = (props: CheckIfInstanceCanBeRolledBackProps) => (
  <Mutate<
    ResponsePostProdRollbackCheckDTO,
    Failure | Error,
    CheckIfInstanceCanBeRolledBackQueryParams,
    PostProdRollbackRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/rollback/check`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCheckIfInstanceCanBeRolledBackProps = Omit<
  UseMutateProps<
    ResponsePostProdRollbackCheckDTO,
    Failure | Error,
    CheckIfInstanceCanBeRolledBackQueryParams,
    PostProdRollbackRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Check if the post-prod-rollback is possible for the given instanceUuid
 */
export const useCheckIfInstanceCanBeRolledBack = (props: UseCheckIfInstanceCanBeRolledBackProps) =>
  useMutate<
    ResponsePostProdRollbackCheckDTO,
    Failure | Error,
    CheckIfInstanceCanBeRolledBackQueryParams,
    PostProdRollbackRequestDTORequestBody,
    void
  >('POST', `/rollback/check`, { base: getConfig('ng/api'), ...props })

/**
 * Check if the post-prod-rollback is possible for the given instanceUuid
 */
export const checkIfInstanceCanBeRolledBackPromise = (
  props: MutateUsingFetchProps<
    ResponsePostProdRollbackCheckDTO,
    Failure | Error,
    CheckIfInstanceCanBeRolledBackQueryParams,
    PostProdRollbackRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePostProdRollbackCheckDTO,
    Failure | Error,
    CheckIfInstanceCanBeRolledBackQueryParams,
    PostProdRollbackRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/rollback/check`, props, signal)

export interface TriggerRollbackQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type TriggerRollbackProps = Omit<
  MutateProps<
    ResponsePostProdRollbackResponseDTO,
    Failure | Error,
    TriggerRollbackQueryParams,
    PostProdRollbackRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Trigger the post-prod-rollback for the given instanceUuid
 */
export const TriggerRollback = (props: TriggerRollbackProps) => (
  <Mutate<
    ResponsePostProdRollbackResponseDTO,
    Failure | Error,
    TriggerRollbackQueryParams,
    PostProdRollbackRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/rollback/trigger`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseTriggerRollbackProps = Omit<
  UseMutateProps<
    ResponsePostProdRollbackResponseDTO,
    Failure | Error,
    TriggerRollbackQueryParams,
    PostProdRollbackRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Trigger the post-prod-rollback for the given instanceUuid
 */
export const useTriggerRollback = (props: UseTriggerRollbackProps) =>
  useMutate<
    ResponsePostProdRollbackResponseDTO,
    Failure | Error,
    TriggerRollbackQueryParams,
    PostProdRollbackRequestDTORequestBody,
    void
  >('POST', `/rollback/trigger`, { base: getConfig('ng/api'), ...props })

/**
 * Trigger the post-prod-rollback for the given instanceUuid
 */
export const triggerRollbackPromise = (
  props: MutateUsingFetchProps<
    ResponsePostProdRollbackResponseDTO,
    Failure | Error,
    TriggerRollbackQueryParams,
    PostProdRollbackRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePostProdRollbackResponseDTO,
    Failure | Error,
    TriggerRollbackQueryParams,
    PostProdRollbackRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/rollback/trigger`, props, signal)

export interface SearchScimGroupQueryParams {
  filter?: string
  count?: number
  startIndex?: number
}

export interface SearchScimGroupPathParams {
  accountIdentifier: string
}

export type SearchScimGroupProps = Omit<
  GetProps<void, void, SearchScimGroupQueryParams, SearchScimGroupPathParams>,
  'path'
> &
  SearchScimGroupPathParams

/**
 * Search groups by their name. Supports pagination. If nothing is passed in filter, all results will be returned.
 */
export const SearchScimGroup = ({ accountIdentifier, ...props }: SearchScimGroupProps) => (
  <Get<void, void, SearchScimGroupQueryParams, SearchScimGroupPathParams>
    path={`/scim/account/${accountIdentifier}/Groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSearchScimGroupProps = Omit<
  UseGetProps<void, void, SearchScimGroupQueryParams, SearchScimGroupPathParams>,
  'path'
> &
  SearchScimGroupPathParams

/**
 * Search groups by their name. Supports pagination. If nothing is passed in filter, all results will be returned.
 */
export const useSearchScimGroup = ({ accountIdentifier, ...props }: UseSearchScimGroupProps) =>
  useGet<void, void, SearchScimGroupQueryParams, SearchScimGroupPathParams>(
    (paramsInPath: SearchScimGroupPathParams) => `/scim/account/${paramsInPath.accountIdentifier}/Groups`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Search groups by their name. Supports pagination. If nothing is passed in filter, all results will be returned.
 */
export const searchScimGroupPromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<void, void, SearchScimGroupQueryParams, SearchScimGroupPathParams> & {
    accountIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, void, SearchScimGroupQueryParams, SearchScimGroupPathParams>(
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Groups`,
    props,
    signal
  )

export interface CreateScimGroupPathParams {
  accountIdentifier: string
}

export type CreateScimGroupProps = Omit<
  MutateProps<void, void, void, ScimGroupRequestBody, CreateScimGroupPathParams>,
  'path' | 'verb'
> &
  CreateScimGroupPathParams

/**
 * Create a new group and return uuid in response
 */
export const CreateScimGroup = ({ accountIdentifier, ...props }: CreateScimGroupProps) => (
  <Mutate<void, void, void, ScimGroupRequestBody, CreateScimGroupPathParams>
    verb="POST"
    path={`/scim/account/${accountIdentifier}/Groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateScimGroupProps = Omit<
  UseMutateProps<void, void, void, ScimGroupRequestBody, CreateScimGroupPathParams>,
  'path' | 'verb'
> &
  CreateScimGroupPathParams

/**
 * Create a new group and return uuid in response
 */
export const useCreateScimGroup = ({ accountIdentifier, ...props }: UseCreateScimGroupProps) =>
  useMutate<void, void, void, ScimGroupRequestBody, CreateScimGroupPathParams>(
    'POST',
    (paramsInPath: CreateScimGroupPathParams) => `/scim/account/${paramsInPath.accountIdentifier}/Groups`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Create a new group and return uuid in response
 */
export const createScimGroupPromise = (
  {
    accountIdentifier,
    ...props
  }: MutateUsingFetchProps<void, void, void, ScimGroupRequestBody, CreateScimGroupPathParams> & {
    accountIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, void, void, ScimGroupRequestBody, CreateScimGroupPathParams>(
    'POST',
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Groups`,
    props,
    signal
  )

export interface DeleteScimGroupPathParams {
  accountIdentifier: string
}

export type DeleteScimGroupProps = Omit<
  MutateProps<void, void, void, string, DeleteScimGroupPathParams>,
  'path' | 'verb'
> &
  DeleteScimGroupPathParams

/**
 * Delete an existing user by uuid
 */
export const DeleteScimGroup = ({ accountIdentifier, ...props }: DeleteScimGroupProps) => (
  <Mutate<void, void, void, string, DeleteScimGroupPathParams>
    verb="DELETE"
    path={`/scim/account/${accountIdentifier}/Groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteScimGroupProps = Omit<
  UseMutateProps<void, void, void, string, DeleteScimGroupPathParams>,
  'path' | 'verb'
> &
  DeleteScimGroupPathParams

/**
 * Delete an existing user by uuid
 */
export const useDeleteScimGroup = ({ accountIdentifier, ...props }: UseDeleteScimGroupProps) =>
  useMutate<void, void, void, string, DeleteScimGroupPathParams>(
    'DELETE',
    (paramsInPath: DeleteScimGroupPathParams) => `/scim/account/${paramsInPath.accountIdentifier}/Groups`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Delete an existing user by uuid
 */
export const deleteScimGroupPromise = (
  {
    accountIdentifier,
    ...props
  }: MutateUsingFetchProps<void, void, void, string, DeleteScimGroupPathParams> & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, void, void, string, DeleteScimGroupPathParams>(
    'DELETE',
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Groups`,
    props,
    signal
  )

export interface GetScimGroupPathParams {
  accountIdentifier: string
  groupIdentifier: string
}

export type GetScimGroupProps = Omit<GetProps<void, void, void, GetScimGroupPathParams>, 'path'> &
  GetScimGroupPathParams

/**
 * Fetch an existing user by uuid
 */
export const GetScimGroup = ({ accountIdentifier, groupIdentifier, ...props }: GetScimGroupProps) => (
  <Get<void, void, void, GetScimGroupPathParams>
    path={`/scim/account/${accountIdentifier}/Groups/${groupIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetScimGroupProps = Omit<UseGetProps<void, void, void, GetScimGroupPathParams>, 'path'> &
  GetScimGroupPathParams

/**
 * Fetch an existing user by uuid
 */
export const useGetScimGroup = ({ accountIdentifier, groupIdentifier, ...props }: UseGetScimGroupProps) =>
  useGet<void, void, void, GetScimGroupPathParams>(
    (paramsInPath: GetScimGroupPathParams) =>
      `/scim/account/${paramsInPath.accountIdentifier}/Groups/${paramsInPath.groupIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier, groupIdentifier }, ...props }
  )

/**
 * Fetch an existing user by uuid
 */
export const getScimGroupPromise = (
  {
    accountIdentifier,
    groupIdentifier,
    ...props
  }: GetUsingFetchProps<void, void, void, GetScimGroupPathParams> & {
    accountIdentifier: string
    groupIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, void, void, GetScimGroupPathParams>(
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Groups/${groupIdentifier}`,
    props,
    signal
  )

export interface PatchScimGroupPathParams {
  accountIdentifier: string
  groupIdentifier: string
}

export type PatchScimGroupProps = Omit<
  MutateProps<void, void, void, PatchRequestRequestBody, PatchScimGroupPathParams>,
  'path' | 'verb'
> &
  PatchScimGroupPathParams

/**
 * Update some fields of a groups by uuid. Can update members/name
 */
export const PatchScimGroup = ({ accountIdentifier, groupIdentifier, ...props }: PatchScimGroupProps) => (
  <Mutate<void, void, void, PatchRequestRequestBody, PatchScimGroupPathParams>
    verb="PATCH"
    path={`/scim/account/${accountIdentifier}/Groups/${groupIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePatchScimGroupProps = Omit<
  UseMutateProps<void, void, void, PatchRequestRequestBody, PatchScimGroupPathParams>,
  'path' | 'verb'
> &
  PatchScimGroupPathParams

/**
 * Update some fields of a groups by uuid. Can update members/name
 */
export const usePatchScimGroup = ({ accountIdentifier, groupIdentifier, ...props }: UsePatchScimGroupProps) =>
  useMutate<void, void, void, PatchRequestRequestBody, PatchScimGroupPathParams>(
    'PATCH',
    (paramsInPath: PatchScimGroupPathParams) =>
      `/scim/account/${paramsInPath.accountIdentifier}/Groups/${paramsInPath.groupIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier, groupIdentifier }, ...props }
  )

/**
 * Update some fields of a groups by uuid. Can update members/name
 */
export const patchScimGroupPromise = (
  {
    accountIdentifier,
    groupIdentifier,
    ...props
  }: MutateUsingFetchProps<void, void, void, PatchRequestRequestBody, PatchScimGroupPathParams> & {
    accountIdentifier: string
    groupIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, void, void, PatchRequestRequestBody, PatchScimGroupPathParams>(
    'PATCH',
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Groups/${groupIdentifier}`,
    props,
    signal
  )

export interface UpdateScimGroupPathParams {
  accountIdentifier: string
  groupIdentifier: string
}

export type UpdateScimGroupProps = Omit<
  MutateProps<void, void, void, ScimGroupRequestBody, UpdateScimGroupPathParams>,
  'path' | 'verb'
> &
  UpdateScimGroupPathParams

/**
 * Update a group
 */
export const UpdateScimGroup = ({ accountIdentifier, groupIdentifier, ...props }: UpdateScimGroupProps) => (
  <Mutate<void, void, void, ScimGroupRequestBody, UpdateScimGroupPathParams>
    verb="PUT"
    path={`/scim/account/${accountIdentifier}/Groups/${groupIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateScimGroupProps = Omit<
  UseMutateProps<void, void, void, ScimGroupRequestBody, UpdateScimGroupPathParams>,
  'path' | 'verb'
> &
  UpdateScimGroupPathParams

/**
 * Update a group
 */
export const useUpdateScimGroup = ({ accountIdentifier, groupIdentifier, ...props }: UseUpdateScimGroupProps) =>
  useMutate<void, void, void, ScimGroupRequestBody, UpdateScimGroupPathParams>(
    'PUT',
    (paramsInPath: UpdateScimGroupPathParams) =>
      `/scim/account/${paramsInPath.accountIdentifier}/Groups/${paramsInPath.groupIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier, groupIdentifier }, ...props }
  )

/**
 * Update a group
 */
export const updateScimGroupPromise = (
  {
    accountIdentifier,
    groupIdentifier,
    ...props
  }: MutateUsingFetchProps<void, void, void, ScimGroupRequestBody, UpdateScimGroupPathParams> & {
    accountIdentifier: string
    groupIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, void, void, ScimGroupRequestBody, UpdateScimGroupPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Groups/${groupIdentifier}`,
    props,
    signal
  )

export interface GetResourceTypesPathParams {
  accountIdentifier: string
}

export type GetResourceTypesProps = Omit<GetProps<void, void, void, GetResourceTypesPathParams>, 'path'> &
  GetResourceTypesPathParams

/**
 * Get All ResourceTypes supported by Application's SCIM 2.0 APIs.
 */
export const GetResourceTypes = ({ accountIdentifier, ...props }: GetResourceTypesProps) => (
  <Get<void, void, void, GetResourceTypesPathParams>
    path={`/scim/account/${accountIdentifier}/ResourceTypes`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetResourceTypesProps = Omit<UseGetProps<void, void, void, GetResourceTypesPathParams>, 'path'> &
  GetResourceTypesPathParams

/**
 * Get All ResourceTypes supported by Application's SCIM 2.0 APIs.
 */
export const useGetResourceTypes = ({ accountIdentifier, ...props }: UseGetResourceTypesProps) =>
  useGet<void, void, void, GetResourceTypesPathParams>(
    (paramsInPath: GetResourceTypesPathParams) => `/scim/account/${paramsInPath.accountIdentifier}/ResourceTypes`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Get All ResourceTypes supported by Application's SCIM 2.0 APIs.
 */
export const getResourceTypesPromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<void, void, void, GetResourceTypesPathParams> & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, void, void, GetResourceTypesPathParams>(
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/ResourceTypes`,
    props,
    signal
  )

export interface GetSchemasPathParams {
  accountIdentifier: string
}

export type GetSchemasProps = Omit<GetProps<void, void, void, GetSchemasPathParams>, 'path'> & GetSchemasPathParams

/**
 *  Get All Schemas supported by Application's SCIM 2.0 APIs.
 */
export const GetSchemas = ({ accountIdentifier, ...props }: GetSchemasProps) => (
  <Get<void, void, void, GetSchemasPathParams>
    path={`/scim/account/${accountIdentifier}/Schemas`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSchemasProps = Omit<UseGetProps<void, void, void, GetSchemasPathParams>, 'path'> &
  GetSchemasPathParams

/**
 *  Get All Schemas supported by Application's SCIM 2.0 APIs.
 */
export const useGetSchemas = ({ accountIdentifier, ...props }: UseGetSchemasProps) =>
  useGet<void, void, void, GetSchemasPathParams>(
    (paramsInPath: GetSchemasPathParams) => `/scim/account/${paramsInPath.accountIdentifier}/Schemas`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 *  Get All Schemas supported by Application's SCIM 2.0 APIs.
 */
export const getSchemasPromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<void, void, void, GetSchemasPathParams> & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, void, void, GetSchemasPathParams>(
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Schemas`,
    props,
    signal
  )

export interface GetServiceProviderConfigPathParams {
  accountIdentifier: string
}

export type GetServiceProviderConfigProps = Omit<
  GetProps<void, void, void, GetServiceProviderConfigPathParams>,
  'path'
> &
  GetServiceProviderConfigPathParams

/**
 * Get Service Provider Configuration supported by Application's SCIM 2.0 APIs.
 */
export const GetServiceProviderConfig = ({ accountIdentifier, ...props }: GetServiceProviderConfigProps) => (
  <Get<void, void, void, GetServiceProviderConfigPathParams>
    path={`/scim/account/${accountIdentifier}/ServiceProviderConfig`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceProviderConfigProps = Omit<
  UseGetProps<void, void, void, GetServiceProviderConfigPathParams>,
  'path'
> &
  GetServiceProviderConfigPathParams

/**
 * Get Service Provider Configuration supported by Application's SCIM 2.0 APIs.
 */
export const useGetServiceProviderConfig = ({ accountIdentifier, ...props }: UseGetServiceProviderConfigProps) =>
  useGet<void, void, void, GetServiceProviderConfigPathParams>(
    (paramsInPath: GetServiceProviderConfigPathParams) =>
      `/scim/account/${paramsInPath.accountIdentifier}/ServiceProviderConfig`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Get Service Provider Configuration supported by Application's SCIM 2.0 APIs.
 */
export const getServiceProviderConfigPromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<void, void, void, GetServiceProviderConfigPathParams> & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, void, void, GetServiceProviderConfigPathParams>(
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/ServiceProviderConfig`,
    props,
    signal
  )

export interface SearchScimUserQueryParams {
  filter?: string
  count?: number
  startIndex?: number
}

export interface SearchScimUserPathParams {
  accountIdentifier: string
}

export type SearchScimUserProps = Omit<
  GetProps<void, Failure | Error, SearchScimUserQueryParams, SearchScimUserPathParams>,
  'path'
> &
  SearchScimUserPathParams

/**
 * Search users by their email address. Supports pagination. If nothing is passed in filter, all results will be returned.
 */
export const SearchScimUser = ({ accountIdentifier, ...props }: SearchScimUserProps) => (
  <Get<void, Failure | Error, SearchScimUserQueryParams, SearchScimUserPathParams>
    path={`/scim/account/${accountIdentifier}/Users`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSearchScimUserProps = Omit<
  UseGetProps<void, Failure | Error, SearchScimUserQueryParams, SearchScimUserPathParams>,
  'path'
> &
  SearchScimUserPathParams

/**
 * Search users by their email address. Supports pagination. If nothing is passed in filter, all results will be returned.
 */
export const useSearchScimUser = ({ accountIdentifier, ...props }: UseSearchScimUserProps) =>
  useGet<void, Failure | Error, SearchScimUserQueryParams, SearchScimUserPathParams>(
    (paramsInPath: SearchScimUserPathParams) => `/scim/account/${paramsInPath.accountIdentifier}/Users`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Search users by their email address. Supports pagination. If nothing is passed in filter, all results will be returned.
 */
export const searchScimUserPromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<void, Failure | Error, SearchScimUserQueryParams, SearchScimUserPathParams> & {
    accountIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, Failure | Error, SearchScimUserQueryParams, SearchScimUserPathParams>(
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Users`,
    props,
    signal
  )

export interface CreateScimUserPathParams {
  accountIdentifier: string
}

export type CreateScimUserProps = Omit<
  MutateProps<void, Failure | Error, void, ScimUserRequestBody, CreateScimUserPathParams>,
  'path' | 'verb'
> &
  CreateScimUserPathParams

/**
 * Create a new user
 */
export const CreateScimUser = ({ accountIdentifier, ...props }: CreateScimUserProps) => (
  <Mutate<void, Failure | Error, void, ScimUserRequestBody, CreateScimUserPathParams>
    verb="POST"
    path={`/scim/account/${accountIdentifier}/Users`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateScimUserProps = Omit<
  UseMutateProps<void, Failure | Error, void, ScimUserRequestBody, CreateScimUserPathParams>,
  'path' | 'verb'
> &
  CreateScimUserPathParams

/**
 * Create a new user
 */
export const useCreateScimUser = ({ accountIdentifier, ...props }: UseCreateScimUserProps) =>
  useMutate<void, Failure | Error, void, ScimUserRequestBody, CreateScimUserPathParams>(
    'POST',
    (paramsInPath: CreateScimUserPathParams) => `/scim/account/${paramsInPath.accountIdentifier}/Users`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Create a new user
 */
export const createScimUserPromise = (
  {
    accountIdentifier,
    ...props
  }: MutateUsingFetchProps<void, Failure | Error, void, ScimUserRequestBody, CreateScimUserPathParams> & {
    accountIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, Failure | Error, void, ScimUserRequestBody, CreateScimUserPathParams>(
    'POST',
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Users`,
    props,
    signal
  )

export interface DeleteScimUserPathParams {
  accountIdentifier: string
}

export type DeleteScimUserProps = Omit<
  MutateProps<void, Failure | Error, void, string, DeleteScimUserPathParams>,
  'path' | 'verb'
> &
  DeleteScimUserPathParams

/**
 * Delete an user by uuid
 */
export const DeleteScimUser = ({ accountIdentifier, ...props }: DeleteScimUserProps) => (
  <Mutate<void, Failure | Error, void, string, DeleteScimUserPathParams>
    verb="DELETE"
    path={`/scim/account/${accountIdentifier}/Users`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteScimUserProps = Omit<
  UseMutateProps<void, Failure | Error, void, string, DeleteScimUserPathParams>,
  'path' | 'verb'
> &
  DeleteScimUserPathParams

/**
 * Delete an user by uuid
 */
export const useDeleteScimUser = ({ accountIdentifier, ...props }: UseDeleteScimUserProps) =>
  useMutate<void, Failure | Error, void, string, DeleteScimUserPathParams>(
    'DELETE',
    (paramsInPath: DeleteScimUserPathParams) => `/scim/account/${paramsInPath.accountIdentifier}/Users`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Delete an user by uuid
 */
export const deleteScimUserPromise = (
  {
    accountIdentifier,
    ...props
  }: MutateUsingFetchProps<void, Failure | Error, void, string, DeleteScimUserPathParams> & {
    accountIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, Failure | Error, void, string, DeleteScimUserPathParams>(
    'DELETE',
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Users`,
    props,
    signal
  )

export interface GetScimUserPathParams {
  accountIdentifier: string
  userIdentifier: string
}

export type GetScimUserProps = Omit<GetProps<void, Failure | Error, void, GetScimUserPathParams>, 'path'> &
  GetScimUserPathParams

/**
 * Get an existing user by uuid
 */
export const GetScimUser = ({ accountIdentifier, userIdentifier, ...props }: GetScimUserProps) => (
  <Get<void, Failure | Error, void, GetScimUserPathParams>
    path={`/scim/account/${accountIdentifier}/Users/${userIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetScimUserProps = Omit<UseGetProps<void, Failure | Error, void, GetScimUserPathParams>, 'path'> &
  GetScimUserPathParams

/**
 * Get an existing user by uuid
 */
export const useGetScimUser = ({ accountIdentifier, userIdentifier, ...props }: UseGetScimUserProps) =>
  useGet<void, Failure | Error, void, GetScimUserPathParams>(
    (paramsInPath: GetScimUserPathParams) =>
      `/scim/account/${paramsInPath.accountIdentifier}/Users/${paramsInPath.userIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier, userIdentifier }, ...props }
  )

/**
 * Get an existing user by uuid
 */
export const getScimUserPromise = (
  {
    accountIdentifier,
    userIdentifier,
    ...props
  }: GetUsingFetchProps<void, Failure | Error, void, GetScimUserPathParams> & {
    accountIdentifier: string
    userIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, Failure | Error, void, GetScimUserPathParams>(
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Users/${userIdentifier}`,
    props,
    signal
  )

export interface PatchScimUserPathParams {
  accountIdentifier: string
  userIdentifier: string
}

export type PatchScimUserProps = Omit<
  MutateProps<ScimUser, Failure | Error, void, PatchRequestRequestBody, PatchScimUserPathParams>,
  'path' | 'verb'
> &
  PatchScimUserPathParams

/**
 * Update some fields of a user by uuid
 */
export const PatchScimUser = ({ accountIdentifier, userIdentifier, ...props }: PatchScimUserProps) => (
  <Mutate<ScimUser, Failure | Error, void, PatchRequestRequestBody, PatchScimUserPathParams>
    verb="PATCH"
    path={`/scim/account/${accountIdentifier}/Users/${userIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePatchScimUserProps = Omit<
  UseMutateProps<ScimUser, Failure | Error, void, PatchRequestRequestBody, PatchScimUserPathParams>,
  'path' | 'verb'
> &
  PatchScimUserPathParams

/**
 * Update some fields of a user by uuid
 */
export const usePatchScimUser = ({ accountIdentifier, userIdentifier, ...props }: UsePatchScimUserProps) =>
  useMutate<ScimUser, Failure | Error, void, PatchRequestRequestBody, PatchScimUserPathParams>(
    'PATCH',
    (paramsInPath: PatchScimUserPathParams) =>
      `/scim/account/${paramsInPath.accountIdentifier}/Users/${paramsInPath.userIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier, userIdentifier }, ...props }
  )

/**
 * Update some fields of a user by uuid
 */
export const patchScimUserPromise = (
  {
    accountIdentifier,
    userIdentifier,
    ...props
  }: MutateUsingFetchProps<ScimUser, Failure | Error, void, PatchRequestRequestBody, PatchScimUserPathParams> & {
    accountIdentifier: string
    userIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ScimUser, Failure | Error, void, PatchRequestRequestBody, PatchScimUserPathParams>(
    'PATCH',
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Users/${userIdentifier}`,
    props,
    signal
  )

export interface UpdateScimUserPathParams {
  accountIdentifier: string
  userIdentifier: string
}

export type UpdateScimUserProps = Omit<
  MutateProps<void, Failure | Error, void, ScimUserRequestBody, UpdateScimUserPathParams>,
  'path' | 'verb'
> &
  UpdateScimUserPathParams

/**
 * Update an existing user by uuid
 */
export const UpdateScimUser = ({ accountIdentifier, userIdentifier, ...props }: UpdateScimUserProps) => (
  <Mutate<void, Failure | Error, void, ScimUserRequestBody, UpdateScimUserPathParams>
    verb="PUT"
    path={`/scim/account/${accountIdentifier}/Users/${userIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateScimUserProps = Omit<
  UseMutateProps<void, Failure | Error, void, ScimUserRequestBody, UpdateScimUserPathParams>,
  'path' | 'verb'
> &
  UpdateScimUserPathParams

/**
 * Update an existing user by uuid
 */
export const useUpdateScimUser = ({ accountIdentifier, userIdentifier, ...props }: UseUpdateScimUserProps) =>
  useMutate<void, Failure | Error, void, ScimUserRequestBody, UpdateScimUserPathParams>(
    'PUT',
    (paramsInPath: UpdateScimUserPathParams) =>
      `/scim/account/${paramsInPath.accountIdentifier}/Users/${paramsInPath.userIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier, userIdentifier }, ...props }
  )

/**
 * Update an existing user by uuid
 */
export const updateScimUserPromise = (
  {
    accountIdentifier,
    userIdentifier,
    ...props
  }: MutateUsingFetchProps<void, Failure | Error, void, ScimUserRequestBody, UpdateScimUserPathParams> & {
    accountIdentifier: string
    userIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, Failure | Error, void, ScimUserRequestBody, UpdateScimUserPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Users/${userIdentifier}`,
    props,
    signal
  )

export interface CreatePRV2QueryParams {
  accountIdentifier: string
}

export type CreatePRV2Props = Omit<
  MutateProps<ResponseCreatePRResponse, Failure | Error, CreatePRV2QueryParams, CreatePRRequest, void>,
  'path' | 'verb'
>

/**
 * creates a pull request
 */
export const CreatePRV2 = (props: CreatePRV2Props) => (
  <Mutate<ResponseCreatePRResponse, Failure | Error, CreatePRV2QueryParams, CreatePRRequest, void>
    verb="POST"
    path={`/scm/create-pull-request`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreatePRV2Props = Omit<
  UseMutateProps<ResponseCreatePRResponse, Failure | Error, CreatePRV2QueryParams, CreatePRRequest, void>,
  'path' | 'verb'
>

/**
 * creates a pull request
 */
export const useCreatePRV2 = (props: UseCreatePRV2Props) =>
  useMutate<ResponseCreatePRResponse, Failure | Error, CreatePRV2QueryParams, CreatePRRequest, void>(
    'POST',
    `/scm/create-pull-request`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * creates a pull request
 */
export const createPRV2Promise = (
  props: MutateUsingFetchProps<ResponseCreatePRResponse, Failure | Error, CreatePRV2QueryParams, CreatePRRequest, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseCreatePRResponse, Failure | Error, CreatePRV2QueryParams, CreatePRRequest, void>(
    'POST',
    getConfig('ng/api'),
    `/scm/create-pull-request`,
    props,
    signal
  )

export type CreatePRProps = Omit<
  MutateProps<ResponseCreatePRDTO, Failure | Error, void, GitPRCreateRequest, void>,
  'path' | 'verb'
>

/**
 * creates a pull request
 */
export const CreatePR = (props: CreatePRProps) => (
  <Mutate<ResponseCreatePRDTO, Failure | Error, void, GitPRCreateRequest, void>
    verb="POST"
    path={`/scm/createPR`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreatePRProps = Omit<
  UseMutateProps<ResponseCreatePRDTO, Failure | Error, void, GitPRCreateRequest, void>,
  'path' | 'verb'
>

/**
 * creates a pull request
 */
export const useCreatePR = (props: UseCreatePRProps) =>
  useMutate<ResponseCreatePRDTO, Failure | Error, void, GitPRCreateRequest, void>('POST', `/scm/createPR`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * creates a pull request
 */
export const createPRPromise = (
  props: MutateUsingFetchProps<ResponseCreatePRDTO, Failure | Error, void, GitPRCreateRequest, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseCreatePRDTO, Failure | Error, void, GitPRCreateRequest, void>(
    'POST',
    getConfig('ng/api'),
    `/scm/createPR`,
    props,
    signal
  )

export interface GetFileURLQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repoName?: string
  filePath: string
  branch: string
  connectorRef: string
  commitId: string
}

export type GetFileURLProps = Omit<GetProps<ResponseString, Failure | Error, GetFileURLQueryParams, void>, 'path'>

/**
 * Get file url
 */
export const GetFileURL = (props: GetFileURLProps) => (
  <Get<ResponseString, Failure | Error, GetFileURLQueryParams, void>
    path={`/scm/file-url`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFileURLProps = Omit<UseGetProps<ResponseString, Failure | Error, GetFileURLQueryParams, void>, 'path'>

/**
 * Get file url
 */
export const useGetFileURL = (props: UseGetFileURLProps) =>
  useGet<ResponseString, Failure | Error, GetFileURLQueryParams, void>(`/scm/file-url`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get file url
 */
export const getFileURLPromise = (
  props: GetUsingFetchProps<ResponseString, Failure | Error, GetFileURLQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, Failure | Error, GetFileURLQueryParams, void>(
    getConfig('ng/api'),
    `/scm/file-url`,
    props,
    signal
  )

export interface GetFileContentQueryParams {
  yamlGitConfigIdentifier: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  filePath: string
  branch?: string
  commitId?: string
}

export type GetFileContentProps = Omit<
  GetProps<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>,
  'path'
>

/**
 * Gets file content
 */
export const GetFileContent = (props: GetFileContentProps) => (
  <Get<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>
    path={`/scm/fileContent`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFileContentProps = Omit<
  UseGetProps<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>,
  'path'
>

/**
 * Gets file content
 */
export const useGetFileContent = (props: UseGetFileContentProps) =>
  useGet<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>(`/scm/fileContent`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets file content
 */
export const getFileContentPromise = (
  props: GetUsingFetchProps<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>(
    getConfig('ng/api'),
    `/scm/fileContent`,
    props,
    signal
  )

export interface GetBatchFileQueryParams {
  accountIdentifier?: string
}

export type GetBatchFileProps = Omit<
  MutateProps<
    ResponseScmBatchGetFileResponseDTO,
    Failure | Error,
    GetBatchFileQueryParams,
    ScmBatchGetFileRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Get file url
 */
export const GetBatchFile = (props: GetBatchFileProps) => (
  <Mutate<ResponseScmBatchGetFileResponseDTO, Failure | Error, GetBatchFileQueryParams, ScmBatchGetFileRequestDTO, void>
    verb="POST"
    path={`/scm/get-batch-file`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBatchFileProps = Omit<
  UseMutateProps<
    ResponseScmBatchGetFileResponseDTO,
    Failure | Error,
    GetBatchFileQueryParams,
    ScmBatchGetFileRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Get file url
 */
export const useGetBatchFile = (props: UseGetBatchFileProps) =>
  useMutate<
    ResponseScmBatchGetFileResponseDTO,
    Failure | Error,
    GetBatchFileQueryParams,
    ScmBatchGetFileRequestDTO,
    void
  >('POST', `/scm/get-batch-file`, { base: getConfig('ng/api'), ...props })

/**
 * Get file url
 */
export const getBatchFilePromise = (
  props: MutateUsingFetchProps<
    ResponseScmBatchGetFileResponseDTO,
    Failure | Error,
    GetBatchFileQueryParams,
    ScmBatchGetFileRequestDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseScmBatchGetFileResponseDTO,
    Failure | Error,
    GetBatchFileQueryParams,
    ScmBatchGetFileRequestDTO,
    void
  >('POST', getConfig('ng/api'), `/scm/get-batch-file`, props, signal)

export interface GetFileByBranchQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  connectorRef?: string
  repoName?: string
  branch?: string
  filePath: string
}

export type GetFileByBranchProps = Omit<
  GetProps<ResponseGetFileResponseDTO, Failure | Error, GetFileByBranchQueryParams, void>,
  'path'
>

/**
 * get file by branch
 */
export const GetFileByBranch = (props: GetFileByBranchProps) => (
  <Get<ResponseGetFileResponseDTO, Failure | Error, GetFileByBranchQueryParams, void>
    path={`/scm/get-file-by-branch`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFileByBranchProps = Omit<
  UseGetProps<ResponseGetFileResponseDTO, Failure | Error, GetFileByBranchQueryParams, void>,
  'path'
>

/**
 * get file by branch
 */
export const useGetFileByBranch = (props: UseGetFileByBranchProps) =>
  useGet<ResponseGetFileResponseDTO, Failure | Error, GetFileByBranchQueryParams, void>(`/scm/get-file-by-branch`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * get file by branch
 */
export const getFileByBranchPromise = (
  props: GetUsingFetchProps<ResponseGetFileResponseDTO, Failure | Error, GetFileByBranchQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGetFileResponseDTO, Failure | Error, GetFileByBranchQueryParams, void>(
    getConfig('ng/api'),
    `/scm/get-file-by-branch`,
    props,
    signal
  )

export interface IsSaasGitQueryParams {
  repoURL?: string
}

export type IsSaasGitProps = Omit<
  MutateProps<ResponseSaasGitDTO, Failure | Error, IsSaasGitQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Checks if Saas is possible
 */
export const IsSaasGit = (props: IsSaasGitProps) => (
  <Mutate<ResponseSaasGitDTO, Failure | Error, IsSaasGitQueryParams, void, void>
    verb="POST"
    path={`/scm/isSaasGit`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseIsSaasGitProps = Omit<
  UseMutateProps<ResponseSaasGitDTO, Failure | Error, IsSaasGitQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Checks if Saas is possible
 */
export const useIsSaasGit = (props: UseIsSaasGitProps) =>
  useMutate<ResponseSaasGitDTO, Failure | Error, IsSaasGitQueryParams, void, void>('POST', `/scm/isSaasGit`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Checks if Saas is possible
 */
export const isSaasGitPromise = (
  props: MutateUsingFetchProps<ResponseSaasGitDTO, Failure | Error, IsSaasGitQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseSaasGitDTO, Failure | Error, IsSaasGitQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/scm/isSaasGit`,
    props,
    signal
  )

export interface GetListOfAllReposByRefConnectorQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  connectorRef?: string
}

export type GetListOfAllReposByRefConnectorProps = Omit<
  GetProps<ResponseListUserRepoResponse, Failure | Error, GetListOfAllReposByRefConnectorQueryParams, void>,
  'path'
>

/**
 * Lists All Git Repos corresponding to given reference connector
 */
export const GetListOfAllReposByRefConnector = (props: GetListOfAllReposByRefConnectorProps) => (
  <Get<ResponseListUserRepoResponse, Failure | Error, GetListOfAllReposByRefConnectorQueryParams, void>
    path={`/scm/list-all-repos-by-connector`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetListOfAllReposByRefConnectorProps = Omit<
  UseGetProps<ResponseListUserRepoResponse, Failure | Error, GetListOfAllReposByRefConnectorQueryParams, void>,
  'path'
>

/**
 * Lists All Git Repos corresponding to given reference connector
 */
export const useGetListOfAllReposByRefConnector = (props: UseGetListOfAllReposByRefConnectorProps) =>
  useGet<ResponseListUserRepoResponse, Failure | Error, GetListOfAllReposByRefConnectorQueryParams, void>(
    `/scm/list-all-repos-by-connector`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Lists All Git Repos corresponding to given reference connector
 */
export const getListOfAllReposByRefConnectorPromise = (
  props: GetUsingFetchProps<
    ResponseListUserRepoResponse,
    Failure | Error,
    GetListOfAllReposByRefConnectorQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListUserRepoResponse, Failure | Error, GetListOfAllReposByRefConnectorQueryParams, void>(
    getConfig('ng/api'),
    `/scm/list-all-repos-by-connector`,
    props,
    signal
  )

export interface GetListOfBranchesByRefConnectorV2QueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repoName?: string
  connectorRef?: string
  size?: number
  branchNameSearchTerm?: string
}

export type GetListOfBranchesByRefConnectorV2Props = Omit<
  GetProps<ResponseGitBranchesResponseDTO, Failure | Error, GetListOfBranchesByRefConnectorV2QueryParams, void>,
  'path'
>

/**
 * Lists Git Branches of given repo
 */
export const GetListOfBranchesByRefConnectorV2 = (props: GetListOfBranchesByRefConnectorV2Props) => (
  <Get<ResponseGitBranchesResponseDTO, Failure | Error, GetListOfBranchesByRefConnectorV2QueryParams, void>
    path={`/scm/list-branches`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetListOfBranchesByRefConnectorV2Props = Omit<
  UseGetProps<ResponseGitBranchesResponseDTO, Failure | Error, GetListOfBranchesByRefConnectorV2QueryParams, void>,
  'path'
>

/**
 * Lists Git Branches of given repo
 */
export const useGetListOfBranchesByRefConnectorV2 = (props: UseGetListOfBranchesByRefConnectorV2Props) =>
  useGet<ResponseGitBranchesResponseDTO, Failure | Error, GetListOfBranchesByRefConnectorV2QueryParams, void>(
    `/scm/list-branches`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Lists Git Branches of given repo
 */
export const getListOfBranchesByRefConnectorV2Promise = (
  props: GetUsingFetchProps<
    ResponseGitBranchesResponseDTO,
    Failure | Error,
    GetListOfBranchesByRefConnectorV2QueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGitBranchesResponseDTO, Failure | Error, GetListOfBranchesByRefConnectorV2QueryParams, void>(
    getConfig('ng/api'),
    `/scm/list-branches`,
    props,
    signal
  )

export interface ListFilesQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repoName?: string
  connectorRef?: string
  branch?: string
  filePath?: string
}

export type ListFilesProps = Omit<
  GetProps<ResponseScmListFilesResponseDTO, Failure | Error, ListFilesQueryParams, void>,
  'path'
>

/**
 * List files
 */
export const ListFiles = (props: ListFilesProps) => (
  <Get<ResponseScmListFilesResponseDTO, Failure | Error, ListFilesQueryParams, void>
    path={`/scm/list-files`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListFilesProps = Omit<
  UseGetProps<ResponseScmListFilesResponseDTO, Failure | Error, ListFilesQueryParams, void>,
  'path'
>

/**
 * List files
 */
export const useListFiles = (props: UseListFilesProps) =>
  useGet<ResponseScmListFilesResponseDTO, Failure | Error, ListFilesQueryParams, void>(`/scm/list-files`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * List files
 */
export const listFilesPromise = (
  props: GetUsingFetchProps<ResponseScmListFilesResponseDTO, Failure | Error, ListFilesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseScmListFilesResponseDTO, Failure | Error, ListFilesQueryParams, void>(
    getConfig('ng/api'),
    `/scm/list-files`,
    props,
    signal
  )

export interface GetListOfReposByRefConnectorQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  connectorRef?: string
  page?: number
  size?: number
  repoNameSearchTerm?: string
  userNameSearchTerm?: string
  applyGitXRepoAllowListFilter?: boolean
}

export type GetListOfReposByRefConnectorProps = Omit<
  GetProps<ResponseListGitRepositoryResponseDTO, Failure | Error, GetListOfReposByRefConnectorQueryParams, void>,
  'path'
>

/**
 * Lists Git Repos corresponding to given reference connector
 */
export const GetListOfReposByRefConnector = (props: GetListOfReposByRefConnectorProps) => (
  <Get<ResponseListGitRepositoryResponseDTO, Failure | Error, GetListOfReposByRefConnectorQueryParams, void>
    path={`/scm/list-repos-by-connector`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetListOfReposByRefConnectorProps = Omit<
  UseGetProps<ResponseListGitRepositoryResponseDTO, Failure | Error, GetListOfReposByRefConnectorQueryParams, void>,
  'path'
>

/**
 * Lists Git Repos corresponding to given reference connector
 */
export const useGetListOfReposByRefConnector = (props: UseGetListOfReposByRefConnectorProps) =>
  useGet<ResponseListGitRepositoryResponseDTO, Failure | Error, GetListOfReposByRefConnectorQueryParams, void>(
    `/scm/list-repos-by-connector`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Lists Git Repos corresponding to given reference connector
 */
export const getListOfReposByRefConnectorPromise = (
  props: GetUsingFetchProps<
    ResponseListGitRepositoryResponseDTO,
    Failure | Error,
    GetListOfReposByRefConnectorQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListGitRepositoryResponseDTO, Failure | Error, GetListOfReposByRefConnectorQueryParams, void>(
    getConfig('ng/api'),
    `/scm/list-repos-by-connector`,
    props,
    signal
  )

export interface GetListOfBranchesByGitConfigQueryParams {
  yamlGitConfigIdentifier?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  page?: number
  size?: number
  searchTerm?: string
}

export type GetListOfBranchesByGitConfigProps = Omit<
  GetProps<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>,
  'path'
>

/**
 * Retrieves a list of Git Branches corresponding to a Git Sync Config Id
 */
export const GetListOfBranchesByGitConfig = (props: GetListOfBranchesByGitConfigProps) => (
  <Get<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>
    path={`/scm/listBranchesByGitConfig`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetListOfBranchesByGitConfigProps = Omit<
  UseGetProps<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>,
  'path'
>

/**
 * Retrieves a list of Git Branches corresponding to a Git Sync Config Id
 */
export const useGetListOfBranchesByGitConfig = (props: UseGetListOfBranchesByGitConfigProps) =>
  useGet<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>(
    `/scm/listBranchesByGitConfig`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Retrieves a list of Git Branches corresponding to a Git Sync Config Id
 */
export const getListOfBranchesByGitConfigPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>(
    getConfig('ng/api'),
    `/scm/listBranchesByGitConfig`,
    props,
    signal
  )

export interface GetListOfBranchesByConnectorQueryParams {
  connectorIdentifierRef?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repoURL?: string
  page?: number
  size?: number
  searchTerm?: string
}

export type GetListOfBranchesByConnectorProps = Omit<
  GetProps<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>,
  'path'
>

/**
 * Gets list of branches by Connector Identifier
 */
export const GetListOfBranchesByConnector = (props: GetListOfBranchesByConnectorProps) => (
  <Get<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>
    path={`/scm/listRepoBranches`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetListOfBranchesByConnectorProps = Omit<
  UseGetProps<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>,
  'path'
>

/**
 * Gets list of branches by Connector Identifier
 */
export const useGetListOfBranchesByConnector = (props: UseGetListOfBranchesByConnectorProps) =>
  useGet<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>(`/scm/listRepoBranches`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets list of branches by Connector Identifier
 */
export const getListOfBranchesByConnectorPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>(
    getConfig('ng/api'),
    `/scm/listRepoBranches`,
    props,
    signal
  )

export interface GetRepoURLQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repoName?: string
  connectorRef?: string
}

export type GetRepoURLProps = Omit<GetProps<ResponseString, Failure | Error, GetRepoURLQueryParams, void>, 'path'>

/**
 * Get repo url
 */
export const GetRepoURL = (props: GetRepoURLProps) => (
  <Get<ResponseString, Failure | Error, GetRepoURLQueryParams, void>
    path={`/scm/repo-url`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetRepoURLProps = Omit<UseGetProps<ResponseString, Failure | Error, GetRepoURLQueryParams, void>, 'path'>

/**
 * Get repo url
 */
export const useGetRepoURL = (props: UseGetRepoURLProps) =>
  useGet<ResponseString, Failure | Error, GetRepoURLQueryParams, void>(`/scm/repo-url`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get repo url
 */
export const getRepoURLPromise = (
  props: GetUsingFetchProps<ResponseString, Failure | Error, GetRepoURLQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, Failure | Error, GetRepoURLQueryParams, void>(
    getConfig('ng/api'),
    `/scm/repo-url`,
    props,
    signal
  )

export interface GetPaginatedListOfBranchesByRefConnectorQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repoName?: string
  connectorRef?: string
  size?: number
  branchNameSearchTerm?: string
}

export type GetPaginatedListOfBranchesByRefConnectorProps = Omit<
  GetProps<ResponseGitListBranchesResponse, Failure | Error, GetPaginatedListOfBranchesByRefConnectorQueryParams, void>,
  'path'
>

/**
 * Paginated List Git Branches of given repo
 */
export const GetPaginatedListOfBranchesByRefConnector = (props: GetPaginatedListOfBranchesByRefConnectorProps) => (
  <Get<ResponseGitListBranchesResponse, Failure | Error, GetPaginatedListOfBranchesByRefConnectorQueryParams, void>
    path={`/scm/v2/list-branches`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPaginatedListOfBranchesByRefConnectorProps = Omit<
  UseGetProps<
    ResponseGitListBranchesResponse,
    Failure | Error,
    GetPaginatedListOfBranchesByRefConnectorQueryParams,
    void
  >,
  'path'
>

/**
 * Paginated List Git Branches of given repo
 */
export const useGetPaginatedListOfBranchesByRefConnector = (props: UseGetPaginatedListOfBranchesByRefConnectorProps) =>
  useGet<ResponseGitListBranchesResponse, Failure | Error, GetPaginatedListOfBranchesByRefConnectorQueryParams, void>(
    `/scm/v2/list-branches`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Paginated List Git Branches of given repo
 */
export const getPaginatedListOfBranchesByRefConnectorPromise = (
  props: GetUsingFetchProps<
    ResponseGitListBranchesResponse,
    Failure | Error,
    GetPaginatedListOfBranchesByRefConnectorQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseGitListBranchesResponse,
    Failure | Error,
    GetPaginatedListOfBranchesByRefConnectorQueryParams,
    void
  >(getConfig('ng/api'), `/scm/v2/list-branches`, props, signal)

export interface GetPaginatedListOfReposByRefConnectorQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  connectorRef?: string
  page?: number
  size?: number
  repoNameSearchTerm?: string
  userNameSearchTerm?: string
  applyGitXRepoAllowListFilter?: boolean
}

export type GetPaginatedListOfReposByRefConnectorProps = Omit<
  GetProps<ResponseGitListRepositoryResponse, Failure | Error, GetPaginatedListOfReposByRefConnectorQueryParams, void>,
  'path'
>

/**
 * Paginated List Git Repos corresponding to given reference connector
 */
export const GetPaginatedListOfReposByRefConnector = (props: GetPaginatedListOfReposByRefConnectorProps) => (
  <Get<ResponseGitListRepositoryResponse, Failure | Error, GetPaginatedListOfReposByRefConnectorQueryParams, void>
    path={`/scm/v2/list-repos`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPaginatedListOfReposByRefConnectorProps = Omit<
  UseGetProps<
    ResponseGitListRepositoryResponse,
    Failure | Error,
    GetPaginatedListOfReposByRefConnectorQueryParams,
    void
  >,
  'path'
>

/**
 * Paginated List Git Repos corresponding to given reference connector
 */
export const useGetPaginatedListOfReposByRefConnector = (props: UseGetPaginatedListOfReposByRefConnectorProps) =>
  useGet<ResponseGitListRepositoryResponse, Failure | Error, GetPaginatedListOfReposByRefConnectorQueryParams, void>(
    `/scm/v2/list-repos`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Paginated List Git Repos corresponding to given reference connector
 */
export const getPaginatedListOfReposByRefConnectorPromise = (
  props: GetUsingFetchProps<
    ResponseGitListRepositoryResponse,
    Failure | Error,
    GetPaginatedListOfReposByRefConnectorQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseGitListRepositoryResponse,
    Failure | Error,
    GetPaginatedListOfReposByRefConnectorQueryParams,
    void
  >(getConfig('ng/api'), `/scm/v2/list-repos`, props, signal)

export interface ValidateRepoQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  connectorRef?: string
  repoName?: string
}

export type ValidateRepoProps = Omit<
  GetProps<ResponseRepoValidationResponse, Failure | Error, ValidateRepoQueryParams, void>,
  'path'
>

/**
 * Validates repos on the basis of repoAllowList in default settings
 */
export const ValidateRepo = (props: ValidateRepoProps) => (
  <Get<ResponseRepoValidationResponse, Failure | Error, ValidateRepoQueryParams, void>
    path={`/scm/validate-repo`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateRepoProps = Omit<
  UseGetProps<ResponseRepoValidationResponse, Failure | Error, ValidateRepoQueryParams, void>,
  'path'
>

/**
 * Validates repos on the basis of repoAllowList in default settings
 */
export const useValidateRepo = (props: UseValidateRepoProps) =>
  useGet<ResponseRepoValidationResponse, Failure | Error, ValidateRepoQueryParams, void>(`/scm/validate-repo`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Validates repos on the basis of repoAllowList in default settings
 */
export const validateRepoPromise = (
  props: GetUsingFetchProps<ResponseRepoValidationResponse, Failure | Error, ValidateRepoQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseRepoValidationResponse, Failure | Error, ValidateRepoQueryParams, void>(
    getConfig('ng/api'),
    `/scm/validate-repo`,
    props,
    signal
  )

export interface GetMetadataQueryParams {
  accountIdentifier: string
}

export type GetMetadataProps = Omit<
  MutateProps<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Get metadata of secret manager
 */
export const GetMetadata = (props: GetMetadataProps) => (
  <Mutate<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >
    verb="POST"
    path={`/secret-managers/meta-data`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetMetadataProps = Omit<
  UseMutateProps<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Get metadata of secret manager
 */
export const useGetMetadata = (props: UseGetMetadataProps) =>
  useMutate<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >('POST', `/secret-managers/meta-data`, { base: getConfig('ng/api'), ...props })

/**
 * Get metadata of secret manager
 */
export const getMetadataPromise = (
  props: MutateUsingFetchProps<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >('POST', getConfig('ng/api'), `/secret-managers/meta-data`, props, signal)

export interface MigrateSvcEnvFromPipelineQueryParams {
  accountIdentifier: string
}

export type MigrateSvcEnvFromPipelineProps = Omit<
  MutateProps<
    ResponseSvcEnvMigrationResponseDto,
    Failure | Error,
    MigrateSvcEnvFromPipelineQueryParams,
    SvcEnvMigrationRequestDto,
    void
  >,
  'path' | 'verb'
>

/**
 * Migrate a pipeline to new service and environment framework
 */
export const MigrateSvcEnvFromPipeline = (props: MigrateSvcEnvFromPipelineProps) => (
  <Mutate<
    ResponseSvcEnvMigrationResponseDto,
    Failure | Error,
    MigrateSvcEnvFromPipelineQueryParams,
    SvcEnvMigrationRequestDto,
    void
  >
    verb="POST"
    path={`/service-env-migration/pipeline`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseMigrateSvcEnvFromPipelineProps = Omit<
  UseMutateProps<
    ResponseSvcEnvMigrationResponseDto,
    Failure | Error,
    MigrateSvcEnvFromPipelineQueryParams,
    SvcEnvMigrationRequestDto,
    void
  >,
  'path' | 'verb'
>

/**
 * Migrate a pipeline to new service and environment framework
 */
export const useMigrateSvcEnvFromPipeline = (props: UseMigrateSvcEnvFromPipelineProps) =>
  useMutate<
    ResponseSvcEnvMigrationResponseDto,
    Failure | Error,
    MigrateSvcEnvFromPipelineQueryParams,
    SvcEnvMigrationRequestDto,
    void
  >('POST', `/service-env-migration/pipeline`, { base: getConfig('ng/api'), ...props })

/**
 * Migrate a pipeline to new service and environment framework
 */
export const migrateSvcEnvFromPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseSvcEnvMigrationResponseDto,
    Failure | Error,
    MigrateSvcEnvFromPipelineQueryParams,
    SvcEnvMigrationRequestDto,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSvcEnvMigrationResponseDto,
    Failure | Error,
    MigrateSvcEnvFromPipelineQueryParams,
    SvcEnvMigrationRequestDto,
    void
  >('POST', getConfig('ng/api'), `/service-env-migration/pipeline`, props, signal)

export interface MigrateSvcEnvFromProjectQueryParams {
  accountIdentifier: string
}

export type MigrateSvcEnvFromProjectProps = Omit<
  MutateProps<
    ResponseSvcEnvMigrationProjectWrapperResponseDto,
    Failure | Error,
    MigrateSvcEnvFromProjectQueryParams,
    SvcEnvMigrationProjectWrapperRequestDto,
    void
  >,
  'path' | 'verb'
>

/**
 * Migrate a project to new service and environment framework
 */
export const MigrateSvcEnvFromProject = (props: MigrateSvcEnvFromProjectProps) => (
  <Mutate<
    ResponseSvcEnvMigrationProjectWrapperResponseDto,
    Failure | Error,
    MigrateSvcEnvFromProjectQueryParams,
    SvcEnvMigrationProjectWrapperRequestDto,
    void
  >
    verb="POST"
    path={`/service-env-migration/project`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseMigrateSvcEnvFromProjectProps = Omit<
  UseMutateProps<
    ResponseSvcEnvMigrationProjectWrapperResponseDto,
    Failure | Error,
    MigrateSvcEnvFromProjectQueryParams,
    SvcEnvMigrationProjectWrapperRequestDto,
    void
  >,
  'path' | 'verb'
>

/**
 * Migrate a project to new service and environment framework
 */
export const useMigrateSvcEnvFromProject = (props: UseMigrateSvcEnvFromProjectProps) =>
  useMutate<
    ResponseSvcEnvMigrationProjectWrapperResponseDto,
    Failure | Error,
    MigrateSvcEnvFromProjectQueryParams,
    SvcEnvMigrationProjectWrapperRequestDto,
    void
  >('POST', `/service-env-migration/project`, { base: getConfig('ng/api'), ...props })

/**
 * Migrate a project to new service and environment framework
 */
export const migrateSvcEnvFromProjectPromise = (
  props: MutateUsingFetchProps<
    ResponseSvcEnvMigrationProjectWrapperResponseDto,
    Failure | Error,
    MigrateSvcEnvFromProjectQueryParams,
    SvcEnvMigrationProjectWrapperRequestDto,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSvcEnvMigrationProjectWrapperResponseDto,
    Failure | Error,
    MigrateSvcEnvFromProjectQueryParams,
    SvcEnvMigrationProjectWrapperRequestDto,
    void
  >('POST', getConfig('ng/api'), `/service-env-migration/project`, props, signal)

export interface GetSummaryQueryParams {
  accountIdentifier: string
  getInfrastructuresYaml?: boolean
  getServiceConfigsYaml?: boolean
}

export type GetSummaryProps = Omit<
  GetProps<ResponseAccountSummaryResponseDto, Failure | Error, GetSummaryQueryParams, void>,
  'path'
>

/**
 * Get summary for an account
 */
export const GetSummary = (props: GetSummaryProps) => (
  <Get<ResponseAccountSummaryResponseDto, Failure | Error, GetSummaryQueryParams, void>
    path={`/service-env-migration/summary`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSummaryProps = Omit<
  UseGetProps<ResponseAccountSummaryResponseDto, Failure | Error, GetSummaryQueryParams, void>,
  'path'
>

/**
 * Get summary for an account
 */
export const useGetSummary = (props: UseGetSummaryProps) =>
  useGet<ResponseAccountSummaryResponseDto, Failure | Error, GetSummaryQueryParams, void>(
    `/service-env-migration/summary`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get summary for an account
 */
export const getSummaryPromise = (
  props: GetUsingFetchProps<ResponseAccountSummaryResponseDto, Failure | Error, GetSummaryQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAccountSummaryResponseDto, Failure | Error, GetSummaryQueryParams, void>(
    getConfig('ng/api'),
    `/service-env-migration/summary`,
    props,
    signal
  )

export interface CreateServiceOverrideV2QueryParams {
  accountIdentifier: string
}

export type CreateServiceOverrideV2Props = Omit<
  MutateProps<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    CreateServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an ServiceOverride Entity
 */
export const CreateServiceOverrideV2 = (props: CreateServiceOverrideV2Props) => (
  <Mutate<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    CreateServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >
    verb="POST"
    path={`/serviceOverrides`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServiceOverrideV2Props = Omit<
  UseMutateProps<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    CreateServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an ServiceOverride Entity
 */
export const useCreateServiceOverrideV2 = (props: UseCreateServiceOverrideV2Props) =>
  useMutate<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    CreateServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >('POST', `/serviceOverrides`, { base: getConfig('ng/api'), ...props })

/**
 * Create an ServiceOverride Entity
 */
export const createServiceOverrideV2Promise = (
  props: MutateUsingFetchProps<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    CreateServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    CreateServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >('POST', getConfig('ng/api'), `/serviceOverrides`, props, signal)

export interface UpdateServiceOverrideV2QueryParams {
  accountIdentifier: string
}

export type UpdateServiceOverrideV2Props = Omit<
  MutateProps<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    UpdateServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an ServiceOverride Entity
 */
export const UpdateServiceOverrideV2 = (props: UpdateServiceOverrideV2Props) => (
  <Mutate<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    UpdateServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >
    verb="PUT"
    path={`/serviceOverrides`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateServiceOverrideV2Props = Omit<
  UseMutateProps<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    UpdateServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an ServiceOverride Entity
 */
export const useUpdateServiceOverrideV2 = (props: UseUpdateServiceOverrideV2Props) =>
  useMutate<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    UpdateServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >('PUT', `/serviceOverrides`, { base: getConfig('ng/api'), ...props })

/**
 * Update an ServiceOverride Entity
 */
export const updateServiceOverrideV2Promise = (
  props: MutateUsingFetchProps<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    UpdateServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    UpdateServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >('PUT', getConfig('ng/api'), `/serviceOverrides`, props, signal)

export type MigrateAndEnableServiceOverrideV2Props = Omit<
  MutateProps<
    ResponseListServiceOverrideMigrationResponseDTO,
    Failure | Error,
    void,
    ServiceOverrideBatchMigrationDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Migrate ServiceOverride to V2 and enable setting
 */
export const MigrateAndEnableServiceOverrideV2 = (props: MigrateAndEnableServiceOverrideV2Props) => (
  <Mutate<
    ResponseListServiceOverrideMigrationResponseDTO,
    Failure | Error,
    void,
    ServiceOverrideBatchMigrationDTO,
    void
  >
    verb="POST"
    path={`/serviceOverrides/batch-migrate-and-enable`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseMigrateAndEnableServiceOverrideV2Props = Omit<
  UseMutateProps<
    ResponseListServiceOverrideMigrationResponseDTO,
    Failure | Error,
    void,
    ServiceOverrideBatchMigrationDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Migrate ServiceOverride to V2 and enable setting
 */
export const useMigrateAndEnableServiceOverrideV2 = (props: UseMigrateAndEnableServiceOverrideV2Props) =>
  useMutate<
    ResponseListServiceOverrideMigrationResponseDTO,
    Failure | Error,
    void,
    ServiceOverrideBatchMigrationDTO,
    void
  >('POST', `/serviceOverrides/batch-migrate-and-enable`, { base: getConfig('ng/api'), ...props })

/**
 * Migrate ServiceOverride to V2 and enable setting
 */
export const migrateAndEnableServiceOverrideV2Promise = (
  props: MutateUsingFetchProps<
    ResponseListServiceOverrideMigrationResponseDTO,
    Failure | Error,
    void,
    ServiceOverrideBatchMigrationDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListServiceOverrideMigrationResponseDTO,
    Failure | Error,
    void,
    ServiceOverrideBatchMigrationDTO,
    void
  >('POST', getConfig('ng/api'), `/serviceOverrides/batch-migrate-and-enable`, props, signal)

export interface GetWithYamlServiceOverridesV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetWithYamlServiceOverridesV2PathParams {
  identifier: string
}

export type GetWithYamlServiceOverridesV2Props = Omit<
  GetProps<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    GetWithYamlServiceOverridesV2QueryParams,
    GetWithYamlServiceOverridesV2PathParams
  >,
  'path'
> &
  GetWithYamlServiceOverridesV2PathParams

/**
 * Gets Service Overrides by Identifier including the yaml of spec also in response
 */
export const GetWithYamlServiceOverridesV2 = ({ identifier, ...props }: GetWithYamlServiceOverridesV2Props) => (
  <Get<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    GetWithYamlServiceOverridesV2QueryParams,
    GetWithYamlServiceOverridesV2PathParams
  >
    path={`/serviceOverrides/get-with-yaml/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetWithYamlServiceOverridesV2Props = Omit<
  UseGetProps<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    GetWithYamlServiceOverridesV2QueryParams,
    GetWithYamlServiceOverridesV2PathParams
  >,
  'path'
> &
  GetWithYamlServiceOverridesV2PathParams

/**
 * Gets Service Overrides by Identifier including the yaml of spec also in response
 */
export const useGetWithYamlServiceOverridesV2 = ({ identifier, ...props }: UseGetWithYamlServiceOverridesV2Props) =>
  useGet<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    GetWithYamlServiceOverridesV2QueryParams,
    GetWithYamlServiceOverridesV2PathParams
  >(
    (paramsInPath: GetWithYamlServiceOverridesV2PathParams) =>
      `/serviceOverrides/get-with-yaml/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets Service Overrides by Identifier including the yaml of spec also in response
 */
export const getWithYamlServiceOverridesV2Promise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    GetWithYamlServiceOverridesV2QueryParams,
    GetWithYamlServiceOverridesV2PathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    GetWithYamlServiceOverridesV2QueryParams,
    GetWithYamlServiceOverridesV2PathParams
  >(getConfig('ng/api'), `/serviceOverrides/get-with-yaml/${identifier}`, props, signal)

export interface GetServiceOverrideListV2QueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type?:
    | 'ENV_GLOBAL_OVERRIDE'
    | 'ENV_SERVICE_OVERRIDE'
    | 'INFRA_GLOBAL_OVERRIDE'
    | 'INFRA_SERVICE_OVERRIDE'
    | 'CLUSTER_GLOBAL_OVERRIDE'
    | 'CLUSTER_SERVICE_OVERRIDE'
}

export type GetServiceOverrideListV2Props = Omit<
  GetProps<ResponsePageServiceOverridesResponseDTOV2, Failure | Error, GetServiceOverrideListV2QueryParams, void>,
  'path'
>

/**
 * Gets Service Override List
 */
export const GetServiceOverrideListV2 = (props: GetServiceOverrideListV2Props) => (
  <Get<ResponsePageServiceOverridesResponseDTOV2, Failure | Error, GetServiceOverrideListV2QueryParams, void>
    path={`/serviceOverrides/list`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceOverrideListV2Props = Omit<
  UseGetProps<ResponsePageServiceOverridesResponseDTOV2, Failure | Error, GetServiceOverrideListV2QueryParams, void>,
  'path'
>

/**
 * Gets Service Override List
 */
export const useGetServiceOverrideListV2 = (props: UseGetServiceOverrideListV2Props) =>
  useGet<ResponsePageServiceOverridesResponseDTOV2, Failure | Error, GetServiceOverrideListV2QueryParams, void>(
    `/serviceOverrides/list`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Service Override List
 */
export const getServiceOverrideListV2Promise = (
  props: GetUsingFetchProps<
    ResponsePageServiceOverridesResponseDTOV2,
    Failure | Error,
    GetServiceOverrideListV2QueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageServiceOverridesResponseDTOV2, Failure | Error, GetServiceOverrideListV2QueryParams, void>(
    getConfig('ng/api'),
    `/serviceOverrides/list`,
    props,
    signal
  )

export interface MigrateServiceOverrideQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type MigrateServiceOverrideProps = Omit<
  MutateProps<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    MigrateServiceOverrideQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Migrate ServiceOverride to V2
 */
export const MigrateServiceOverride = (props: MigrateServiceOverrideProps) => (
  <Mutate<ResponseServiceOverrideMigrationResponseDTO, Failure | Error, MigrateServiceOverrideQueryParams, void, void>
    verb="POST"
    path={`/serviceOverrides/migrate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseMigrateServiceOverrideProps = Omit<
  UseMutateProps<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    MigrateServiceOverrideQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Migrate ServiceOverride to V2
 */
export const useMigrateServiceOverride = (props: UseMigrateServiceOverrideProps) =>
  useMutate<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    MigrateServiceOverrideQueryParams,
    void,
    void
  >('POST', `/serviceOverrides/migrate`, { base: getConfig('ng/api'), ...props })

/**
 * Migrate ServiceOverride to V2
 */
export const migrateServiceOverridePromise = (
  props: MutateUsingFetchProps<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    MigrateServiceOverrideQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    MigrateServiceOverrideQueryParams,
    void,
    void
  >('POST', getConfig('ng/api'), `/serviceOverrides/migrate`, props, signal)

export interface MigrateServiceOverrideScopedQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type MigrateServiceOverrideScopedProps = Omit<
  MutateProps<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    MigrateServiceOverrideScopedQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Migrate ServiceOverride to V2 at one scope
 */
export const MigrateServiceOverrideScoped = (props: MigrateServiceOverrideScopedProps) => (
  <Mutate<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    MigrateServiceOverrideScopedQueryParams,
    void,
    void
  >
    verb="POST"
    path={`/serviceOverrides/migrateScope`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseMigrateServiceOverrideScopedProps = Omit<
  UseMutateProps<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    MigrateServiceOverrideScopedQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Migrate ServiceOverride to V2 at one scope
 */
export const useMigrateServiceOverrideScoped = (props: UseMigrateServiceOverrideScopedProps) =>
  useMutate<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    MigrateServiceOverrideScopedQueryParams,
    void,
    void
  >('POST', `/serviceOverrides/migrateScope`, { base: getConfig('ng/api'), ...props })

/**
 * Migrate ServiceOverride to V2 at one scope
 */
export const migrateServiceOverrideScopedPromise = (
  props: MutateUsingFetchProps<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    MigrateServiceOverrideScopedQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    MigrateServiceOverrideScopedQueryParams,
    void,
    void
  >('POST', getConfig('ng/api'), `/serviceOverrides/migrateScope`, props, signal)

export interface RevertMigrationServiceOverrideQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type RevertMigrationServiceOverrideProps = Omit<
  MutateProps<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    RevertMigrationServiceOverrideQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Revert ServiceOverride V2 Migration
 */
export const RevertMigrationServiceOverride = (props: RevertMigrationServiceOverrideProps) => (
  <Mutate<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    RevertMigrationServiceOverrideQueryParams,
    void,
    void
  >
    verb="POST"
    path={`/serviceOverrides/revertMigration`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRevertMigrationServiceOverrideProps = Omit<
  UseMutateProps<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    RevertMigrationServiceOverrideQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Revert ServiceOverride V2 Migration
 */
export const useRevertMigrationServiceOverride = (props: UseRevertMigrationServiceOverrideProps) =>
  useMutate<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    RevertMigrationServiceOverrideQueryParams,
    void,
    void
  >('POST', `/serviceOverrides/revertMigration`, { base: getConfig('ng/api'), ...props })

/**
 * Revert ServiceOverride V2 Migration
 */
export const revertMigrationServiceOverridePromise = (
  props: MutateUsingFetchProps<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    RevertMigrationServiceOverrideQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    RevertMigrationServiceOverrideQueryParams,
    void,
    void
  >('POST', getConfig('ng/api'), `/serviceOverrides/revertMigration`, props, signal)

export interface RevertMigrationServiceOverrideScopedQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type RevertMigrationServiceOverrideScopedProps = Omit<
  MutateProps<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    RevertMigrationServiceOverrideScopedQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Revert ServiceOverride V2 Migration at one scope
 */
export const RevertMigrationServiceOverrideScoped = (props: RevertMigrationServiceOverrideScopedProps) => (
  <Mutate<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    RevertMigrationServiceOverrideScopedQueryParams,
    void,
    void
  >
    verb="POST"
    path={`/serviceOverrides/revertMigrationScope`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRevertMigrationServiceOverrideScopedProps = Omit<
  UseMutateProps<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    RevertMigrationServiceOverrideScopedQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Revert ServiceOverride V2 Migration at one scope
 */
export const useRevertMigrationServiceOverrideScoped = (props: UseRevertMigrationServiceOverrideScopedProps) =>
  useMutate<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    RevertMigrationServiceOverrideScopedQueryParams,
    void,
    void
  >('POST', `/serviceOverrides/revertMigrationScope`, { base: getConfig('ng/api'), ...props })

/**
 * Revert ServiceOverride V2 Migration at one scope
 */
export const revertMigrationServiceOverrideScopedPromise = (
  props: MutateUsingFetchProps<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    RevertMigrationServiceOverrideScopedQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceOverrideMigrationResponseDTO,
    Failure | Error,
    RevertMigrationServiceOverrideScopedQueryParams,
    void,
    void
  >('POST', getConfig('ng/api'), `/serviceOverrides/revertMigrationScope`, props, signal)

export interface SettingsUpdateServiceOverrideQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  updateChildren?: boolean
}

export type SettingsUpdateServiceOverrideProps = Omit<
  MutateProps<
    ResponseOverrideV2SettingsUpdateResponseDTO,
    Failure | Error,
    SettingsUpdateServiceOverrideQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Update Settings to ServiceOverride V2
 */
export const SettingsUpdateServiceOverride = (props: SettingsUpdateServiceOverrideProps) => (
  <Mutate<
    ResponseOverrideV2SettingsUpdateResponseDTO,
    Failure | Error,
    SettingsUpdateServiceOverrideQueryParams,
    void,
    void
  >
    verb="POST"
    path={`/serviceOverrides/settingsUpdate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSettingsUpdateServiceOverrideProps = Omit<
  UseMutateProps<
    ResponseOverrideV2SettingsUpdateResponseDTO,
    Failure | Error,
    SettingsUpdateServiceOverrideQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Update Settings to ServiceOverride V2
 */
export const useSettingsUpdateServiceOverride = (props: UseSettingsUpdateServiceOverrideProps) =>
  useMutate<
    ResponseOverrideV2SettingsUpdateResponseDTO,
    Failure | Error,
    SettingsUpdateServiceOverrideQueryParams,
    void,
    void
  >('POST', `/serviceOverrides/settingsUpdate`, { base: getConfig('ng/api'), ...props })

/**
 * Update Settings to ServiceOverride V2
 */
export const settingsUpdateServiceOverridePromise = (
  props: MutateUsingFetchProps<
    ResponseOverrideV2SettingsUpdateResponseDTO,
    Failure | Error,
    SettingsUpdateServiceOverrideQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOverrideV2SettingsUpdateResponseDTO,
    Failure | Error,
    SettingsUpdateServiceOverrideQueryParams,
    void,
    void
  >('POST', getConfig('ng/api'), `/serviceOverrides/settingsUpdate`, props, signal)

export interface UpsertServiceOverrideV2QueryParams {
  accountIdentifier: string
}

export type UpsertServiceOverrideV2Props = Omit<
  MutateProps<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    UpsertServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an ServiceOverride Entity
 */
export const UpsertServiceOverrideV2 = (props: UpsertServiceOverrideV2Props) => (
  <Mutate<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    UpsertServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >
    verb="POST"
    path={`/serviceOverrides/upsert`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertServiceOverrideV2Props = Omit<
  UseMutateProps<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    UpsertServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an ServiceOverride Entity
 */
export const useUpsertServiceOverrideV2 = (props: UseUpsertServiceOverrideV2Props) =>
  useMutate<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    UpsertServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >('POST', `/serviceOverrides/upsert`, { base: getConfig('ng/api'), ...props })

/**
 * Upsert an ServiceOverride Entity
 */
export const upsertServiceOverrideV2Promise = (
  props: MutateUsingFetchProps<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    UpsertServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    UpsertServiceOverrideV2QueryParams,
    ServiceOverrideRequestDTOV2RequestBody,
    void
  >('POST', getConfig('ng/api'), `/serviceOverrides/upsert`, props, signal)

export interface GetServiceOverrideListV3QueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type?:
    | 'ENV_GLOBAL_OVERRIDE'
    | 'ENV_SERVICE_OVERRIDE'
    | 'INFRA_GLOBAL_OVERRIDE'
    | 'INFRA_SERVICE_OVERRIDE'
    | 'CLUSTER_GLOBAL_OVERRIDE'
    | 'CLUSTER_SERVICE_OVERRIDE'
  searchTerm?: string
  filterIdentifier?: string
}

export type GetServiceOverrideListV3Props = Omit<
  MutateProps<
    ResponsePageServiceOverridesResponseDTOV2,
    Failure | Error,
    GetServiceOverrideListV3QueryParams,
    OverrideFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Service Override List
 */
export const GetServiceOverrideListV3 = (props: GetServiceOverrideListV3Props) => (
  <Mutate<
    ResponsePageServiceOverridesResponseDTOV2,
    Failure | Error,
    GetServiceOverrideListV3QueryParams,
    OverrideFilterProperties,
    void
  >
    verb="POST"
    path={`/serviceOverrides/v2/list`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceOverrideListV3Props = Omit<
  UseMutateProps<
    ResponsePageServiceOverridesResponseDTOV2,
    Failure | Error,
    GetServiceOverrideListV3QueryParams,
    OverrideFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Service Override List
 */
export const useGetServiceOverrideListV3 = (props: UseGetServiceOverrideListV3Props) =>
  useMutate<
    ResponsePageServiceOverridesResponseDTOV2,
    Failure | Error,
    GetServiceOverrideListV3QueryParams,
    OverrideFilterProperties,
    void
  >('POST', `/serviceOverrides/v2/list`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Service Override List
 */
export const getServiceOverrideListV3Promise = (
  props: MutateUsingFetchProps<
    ResponsePageServiceOverridesResponseDTOV2,
    Failure | Error,
    GetServiceOverrideListV3QueryParams,
    OverrideFilterProperties,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageServiceOverridesResponseDTOV2,
    Failure | Error,
    GetServiceOverrideListV3QueryParams,
    OverrideFilterProperties,
    void
  >('POST', getConfig('ng/api'), `/serviceOverrides/v2/list`, props, signal)

export interface DeleteServiceOverrideV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteServiceOverrideV2Props = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteServiceOverrideV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a Service Override entity
 */
export const DeleteServiceOverrideV2 = (props: DeleteServiceOverrideV2Props) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteServiceOverrideV2QueryParams, string, void>
    verb="DELETE"
    path={`/serviceOverrides`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteServiceOverrideV2Props = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteServiceOverrideV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a Service Override entity
 */
export const useDeleteServiceOverrideV2 = (props: UseDeleteServiceOverrideV2Props) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteServiceOverrideV2QueryParams, string, void>(
    'DELETE',
    `/serviceOverrides`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete a Service Override entity
 */
export const deleteServiceOverrideV2Promise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteServiceOverrideV2QueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteServiceOverrideV2QueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/serviceOverrides`,
    props,
    signal
  )

export interface GetServiceOverridesV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetServiceOverridesV2PathParams {
  identifier: string
}

export type GetServiceOverridesV2Props = Omit<
  GetProps<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    GetServiceOverridesV2QueryParams,
    GetServiceOverridesV2PathParams
  >,
  'path'
> &
  GetServiceOverridesV2PathParams

/**
 * Gets Service Overrides by Identifier
 */
export const GetServiceOverridesV2 = ({ identifier, ...props }: GetServiceOverridesV2Props) => (
  <Get<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    GetServiceOverridesV2QueryParams,
    GetServiceOverridesV2PathParams
  >
    path={`/serviceOverrides/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceOverridesV2Props = Omit<
  UseGetProps<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    GetServiceOverridesV2QueryParams,
    GetServiceOverridesV2PathParams
  >,
  'path'
> &
  GetServiceOverridesV2PathParams

/**
 * Gets Service Overrides by Identifier
 */
export const useGetServiceOverridesV2 = ({ identifier, ...props }: UseGetServiceOverridesV2Props) =>
  useGet<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    GetServiceOverridesV2QueryParams,
    GetServiceOverridesV2PathParams
  >((paramsInPath: GetServiceOverridesV2PathParams) => `/serviceOverrides/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Gets Service Overrides by Identifier
 */
export const getServiceOverridesV2Promise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    GetServiceOverridesV2QueryParams,
    GetServiceOverridesV2PathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseServiceOverridesResponseDTOV2,
    Failure | Error,
    GetServiceOverridesV2QueryParams,
    GetServiceOverridesV2PathParams
  >(getConfig('ng/api'), `/serviceOverrides/${identifier}`, props, signal)

export interface CheckIfPipelineUsingV1StageQueryParams {
  accountIdentifier: string
}

export type CheckIfPipelineUsingV1StageProps = Omit<
  MutateProps<
    ResponseEOLBannerResponseDTO,
    Failure | Error,
    CheckIfPipelineUsingV1StageQueryParams,
    EOLBannerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Returns list of stage identifiers using v1 stage
 */
export const CheckIfPipelineUsingV1Stage = (props: CheckIfPipelineUsingV1StageProps) => (
  <Mutate<
    ResponseEOLBannerResponseDTO,
    Failure | Error,
    CheckIfPipelineUsingV1StageQueryParams,
    EOLBannerRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/serviceV1-eol-banner/pipeline`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCheckIfPipelineUsingV1StageProps = Omit<
  UseMutateProps<
    ResponseEOLBannerResponseDTO,
    Failure | Error,
    CheckIfPipelineUsingV1StageQueryParams,
    EOLBannerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Returns list of stage identifiers using v1 stage
 */
export const useCheckIfPipelineUsingV1Stage = (props: UseCheckIfPipelineUsingV1StageProps) =>
  useMutate<
    ResponseEOLBannerResponseDTO,
    Failure | Error,
    CheckIfPipelineUsingV1StageQueryParams,
    EOLBannerRequestDTORequestBody,
    void
  >('POST', `/serviceV1-eol-banner/pipeline`, { base: getConfig('ng/api'), ...props })

/**
 * Returns list of stage identifiers using v1 stage
 */
export const checkIfPipelineUsingV1StagePromise = (
  props: MutateUsingFetchProps<
    ResponseEOLBannerResponseDTO,
    Failure | Error,
    CheckIfPipelineUsingV1StageQueryParams,
    EOLBannerRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEOLBannerResponseDTO,
    Failure | Error,
    CheckIfPipelineUsingV1StageQueryParams,
    EOLBannerRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/serviceV1-eol-banner/pipeline`, props, signal)

export interface CheckIfTemplateUsingV1StageQueryParams {
  accountIdentifier: string
}

export type CheckIfTemplateUsingV1StageProps = Omit<
  MutateProps<
    ResponseEOLBannerResponseDTO,
    Failure | Error,
    CheckIfTemplateUsingV1StageQueryParams,
    EOLBannerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Returns list of stage identifiers using v1 stage
 */
export const CheckIfTemplateUsingV1Stage = (props: CheckIfTemplateUsingV1StageProps) => (
  <Mutate<
    ResponseEOLBannerResponseDTO,
    Failure | Error,
    CheckIfTemplateUsingV1StageQueryParams,
    EOLBannerRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/serviceV1-eol-banner/template`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCheckIfTemplateUsingV1StageProps = Omit<
  UseMutateProps<
    ResponseEOLBannerResponseDTO,
    Failure | Error,
    CheckIfTemplateUsingV1StageQueryParams,
    EOLBannerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Returns list of stage identifiers using v1 stage
 */
export const useCheckIfTemplateUsingV1Stage = (props: UseCheckIfTemplateUsingV1StageProps) =>
  useMutate<
    ResponseEOLBannerResponseDTO,
    Failure | Error,
    CheckIfTemplateUsingV1StageQueryParams,
    EOLBannerRequestDTORequestBody,
    void
  >('POST', `/serviceV1-eol-banner/template`, { base: getConfig('ng/api'), ...props })

/**
 * Returns list of stage identifiers using v1 stage
 */
export const checkIfTemplateUsingV1StagePromise = (
  props: MutateUsingFetchProps<
    ResponseEOLBannerResponseDTO,
    Failure | Error,
    CheckIfTemplateUsingV1StageQueryParams,
    EOLBannerRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEOLBannerResponseDTO,
    Failure | Error,
    CheckIfTemplateUsingV1StageQueryParams,
    EOLBannerRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/serviceV1-eol-banner/template`, props, signal)

export interface ListServiceAccountQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifiers?: string[]
}

export type ListServiceAccountProps = Omit<
  GetProps<ResponseListServiceAccountDTO, Failure | Error, ListServiceAccountQueryParams, void>,
  'path'
>

/**
 * List service account
 */
export const ListServiceAccount = (props: ListServiceAccountProps) => (
  <Get<ResponseListServiceAccountDTO, Failure | Error, ListServiceAccountQueryParams, void>
    path={`/serviceaccount`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListServiceAccountProps = Omit<
  UseGetProps<ResponseListServiceAccountDTO, Failure | Error, ListServiceAccountQueryParams, void>,
  'path'
>

/**
 * List service account
 */
export const useListServiceAccount = (props: UseListServiceAccountProps) =>
  useGet<ResponseListServiceAccountDTO, Failure | Error, ListServiceAccountQueryParams, void>(`/serviceaccount`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * List service account
 */
export const listServiceAccountPromise = (
  props: GetUsingFetchProps<ResponseListServiceAccountDTO, Failure | Error, ListServiceAccountQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListServiceAccountDTO, Failure | Error, ListServiceAccountQueryParams, void>(
    getConfig('ng/api'),
    `/serviceaccount`,
    props,
    signal
  )

export interface CreateServiceAccountQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateServiceAccountProps = Omit<
  MutateProps<
    ResponseServiceAccountDTO,
    Failure | Error,
    CreateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create service account
 */
export const CreateServiceAccount = (props: CreateServiceAccountProps) => (
  <Mutate<
    ResponseServiceAccountDTO,
    Failure | Error,
    CreateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    void
  >
    verb="POST"
    path={`/serviceaccount`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServiceAccountProps = Omit<
  UseMutateProps<
    ResponseServiceAccountDTO,
    Failure | Error,
    CreateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create service account
 */
export const useCreateServiceAccount = (props: UseCreateServiceAccountProps) =>
  useMutate<
    ResponseServiceAccountDTO,
    Failure | Error,
    CreateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    void
  >('POST', `/serviceaccount`, { base: getConfig('ng/api'), ...props })

/**
 * Create service account
 */
export const createServiceAccountPromise = (
  props: MutateUsingFetchProps<
    ResponseServiceAccountDTO,
    Failure | Error,
    CreateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceAccountDTO,
    Failure | Error,
    CreateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/serviceaccount`, props, signal)

export interface ListAggregatedServiceAccountsQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifiers?: string[]
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
  searchTerm?: string
}

export type ListAggregatedServiceAccountsProps = Omit<
  GetProps<ResponsePageServiceAccountAggregateDTO, Failure | Error, ListAggregatedServiceAccountsQueryParams, void>,
  'path'
>

/**
 * List service account
 */
export const ListAggregatedServiceAccounts = (props: ListAggregatedServiceAccountsProps) => (
  <Get<ResponsePageServiceAccountAggregateDTO, Failure | Error, ListAggregatedServiceAccountsQueryParams, void>
    path={`/serviceaccount/aggregate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListAggregatedServiceAccountsProps = Omit<
  UseGetProps<ResponsePageServiceAccountAggregateDTO, Failure | Error, ListAggregatedServiceAccountsQueryParams, void>,
  'path'
>

/**
 * List service account
 */
export const useListAggregatedServiceAccounts = (props: UseListAggregatedServiceAccountsProps) =>
  useGet<ResponsePageServiceAccountAggregateDTO, Failure | Error, ListAggregatedServiceAccountsQueryParams, void>(
    `/serviceaccount/aggregate`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * List service account
 */
export const listAggregatedServiceAccountsPromise = (
  props: GetUsingFetchProps<
    ResponsePageServiceAccountAggregateDTO,
    Failure | Error,
    ListAggregatedServiceAccountsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageServiceAccountAggregateDTO,
    Failure | Error,
    ListAggregatedServiceAccountsQueryParams,
    void
  >(getConfig('ng/api'), `/serviceaccount/aggregate`, props, signal)

export interface GetAggregatedServiceAccountQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetAggregatedServiceAccountPathParams {
  identifier: string
}

export type GetAggregatedServiceAccountProps = Omit<
  GetProps<
    ResponseServiceAccountAggregateDTO,
    Failure | Error,
    GetAggregatedServiceAccountQueryParams,
    GetAggregatedServiceAccountPathParams
  >,
  'path'
> &
  GetAggregatedServiceAccountPathParams

/**
 * Get service account
 */
export const GetAggregatedServiceAccount = ({ identifier, ...props }: GetAggregatedServiceAccountProps) => (
  <Get<
    ResponseServiceAccountAggregateDTO,
    Failure | Error,
    GetAggregatedServiceAccountQueryParams,
    GetAggregatedServiceAccountPathParams
  >
    path={`/serviceaccount/aggregate/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAggregatedServiceAccountProps = Omit<
  UseGetProps<
    ResponseServiceAccountAggregateDTO,
    Failure | Error,
    GetAggregatedServiceAccountQueryParams,
    GetAggregatedServiceAccountPathParams
  >,
  'path'
> &
  GetAggregatedServiceAccountPathParams

/**
 * Get service account
 */
export const useGetAggregatedServiceAccount = ({ identifier, ...props }: UseGetAggregatedServiceAccountProps) =>
  useGet<
    ResponseServiceAccountAggregateDTO,
    Failure | Error,
    GetAggregatedServiceAccountQueryParams,
    GetAggregatedServiceAccountPathParams
  >((paramsInPath: GetAggregatedServiceAccountPathParams) => `/serviceaccount/aggregate/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Get service account
 */
export const getAggregatedServiceAccountPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseServiceAccountAggregateDTO,
    Failure | Error,
    GetAggregatedServiceAccountQueryParams,
    GetAggregatedServiceAccountPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseServiceAccountAggregateDTO,
    Failure | Error,
    GetAggregatedServiceAccountQueryParams,
    GetAggregatedServiceAccountPathParams
  >(getConfig('ng/api'), `/serviceaccount/aggregate/${identifier}`, props, signal)

export interface GetServiceAccountInternalQueryParams {
  accountIdentifier: string
}

export interface GetServiceAccountInternalPathParams {
  identifier: string
}

export type GetServiceAccountInternalProps = Omit<
  GetProps<
    ResponseServiceAccountDTO,
    Failure | Error,
    GetServiceAccountInternalQueryParams,
    GetServiceAccountInternalPathParams
  >,
  'path'
> &
  GetServiceAccountInternalPathParams

/**
 * Get service account by id
 */
export const GetServiceAccountInternal = ({ identifier, ...props }: GetServiceAccountInternalProps) => (
  <Get<
    ResponseServiceAccountDTO,
    Failure | Error,
    GetServiceAccountInternalQueryParams,
    GetServiceAccountInternalPathParams
  >
    path={`/serviceaccount/internal/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceAccountInternalProps = Omit<
  UseGetProps<
    ResponseServiceAccountDTO,
    Failure | Error,
    GetServiceAccountInternalQueryParams,
    GetServiceAccountInternalPathParams
  >,
  'path'
> &
  GetServiceAccountInternalPathParams

/**
 * Get service account by id
 */
export const useGetServiceAccountInternal = ({ identifier, ...props }: UseGetServiceAccountInternalProps) =>
  useGet<
    ResponseServiceAccountDTO,
    Failure | Error,
    GetServiceAccountInternalQueryParams,
    GetServiceAccountInternalPathParams
  >((paramsInPath: GetServiceAccountInternalPathParams) => `/serviceaccount/internal/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Get service account by id
 */
export const getServiceAccountInternalPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseServiceAccountDTO,
    Failure | Error,
    GetServiceAccountInternalQueryParams,
    GetServiceAccountInternalPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseServiceAccountDTO,
    Failure | Error,
    GetServiceAccountInternalQueryParams,
    GetServiceAccountInternalPathParams
  >(getConfig('ng/api'), `/serviceaccount/internal/${identifier}`, props, signal)

export interface DeleteServiceAccountQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteServiceAccountProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteServiceAccountQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete service account
 */
export const DeleteServiceAccount = (props: DeleteServiceAccountProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteServiceAccountQueryParams, string, void>
    verb="DELETE"
    path={`/serviceaccount`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteServiceAccountProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteServiceAccountQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete service account
 */
export const useDeleteServiceAccount = (props: UseDeleteServiceAccountProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteServiceAccountQueryParams, string, void>(
    'DELETE',
    `/serviceaccount`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete service account
 */
export const deleteServiceAccountPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteServiceAccountQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteServiceAccountQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/serviceaccount`,
    props,
    signal
  )

export interface UpdateServiceAccountQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface UpdateServiceAccountPathParams {
  identifier: string
}

export type UpdateServiceAccountProps = Omit<
  MutateProps<
    ResponseServiceAccountDTO,
    Failure | Error,
    UpdateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    UpdateServiceAccountPathParams
  >,
  'path' | 'verb'
> &
  UpdateServiceAccountPathParams

/**
 * Update service account
 */
export const UpdateServiceAccount = ({ identifier, ...props }: UpdateServiceAccountProps) => (
  <Mutate<
    ResponseServiceAccountDTO,
    Failure | Error,
    UpdateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    UpdateServiceAccountPathParams
  >
    verb="PUT"
    path={`/serviceaccount/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateServiceAccountProps = Omit<
  UseMutateProps<
    ResponseServiceAccountDTO,
    Failure | Error,
    UpdateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    UpdateServiceAccountPathParams
  >,
  'path' | 'verb'
> &
  UpdateServiceAccountPathParams

/**
 * Update service account
 */
export const useUpdateServiceAccount = ({ identifier, ...props }: UseUpdateServiceAccountProps) =>
  useMutate<
    ResponseServiceAccountDTO,
    Failure | Error,
    UpdateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    UpdateServiceAccountPathParams
  >('PUT', (paramsInPath: UpdateServiceAccountPathParams) => `/serviceaccount/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update service account
 */
export const updateServiceAccountPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseServiceAccountDTO,
    Failure | Error,
    UpdateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    UpdateServiceAccountPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceAccountDTO,
    Failure | Error,
    UpdateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    UpdateServiceAccountPathParams
  >('PUT', getConfig('ng/api'), `/serviceaccount/${identifier}`, props, signal)

export interface GetServiceNowIssueCreateMetadataQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  ticketType?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetServiceNowIssueCreateMetadataProps = Omit<
  GetProps<ResponseListServiceNowFieldNG, Failure | Error, GetServiceNowIssueCreateMetadataQueryParams, void>,
  'path'
>

/**
 * Get ServiceNow issue create metadata
 */
export const GetServiceNowIssueCreateMetadata = (props: GetServiceNowIssueCreateMetadataProps) => (
  <Get<ResponseListServiceNowFieldNG, Failure | Error, GetServiceNowIssueCreateMetadataQueryParams, void>
    path={`/servicenow/createMetadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceNowIssueCreateMetadataProps = Omit<
  UseGetProps<ResponseListServiceNowFieldNG, Failure | Error, GetServiceNowIssueCreateMetadataQueryParams, void>,
  'path'
>

/**
 * Get ServiceNow issue create metadata
 */
export const useGetServiceNowIssueCreateMetadata = (props: UseGetServiceNowIssueCreateMetadataProps) =>
  useGet<ResponseListServiceNowFieldNG, Failure | Error, GetServiceNowIssueCreateMetadataQueryParams, void>(
    `/servicenow/createMetadata`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get ServiceNow issue create metadata
 */
export const getServiceNowIssueCreateMetadataPromise = (
  props: GetUsingFetchProps<
    ResponseListServiceNowFieldNG,
    Failure | Error,
    GetServiceNowIssueCreateMetadataQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListServiceNowFieldNG, Failure | Error, GetServiceNowIssueCreateMetadataQueryParams, void>(
    getConfig('ng/api'),
    `/servicenow/createMetadata`,
    props,
    signal
  )

export interface GetStandardTemplateReadOnlyFieldsQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetStandardTemplateReadOnlyFieldsProps = Omit<
  GetProps<ResponseListString, Failure | Error, GetStandardTemplateReadOnlyFieldsQueryParams, void>,
  'path'
>

/**
 * Get read-only fields for standard change templates
 */
export const GetStandardTemplateReadOnlyFields = (props: GetStandardTemplateReadOnlyFieldsProps) => (
  <Get<ResponseListString, Failure | Error, GetStandardTemplateReadOnlyFieldsQueryParams, void>
    path={`/servicenow/getStandardTemplateReadOnlyFields`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetStandardTemplateReadOnlyFieldsProps = Omit<
  UseGetProps<ResponseListString, Failure | Error, GetStandardTemplateReadOnlyFieldsQueryParams, void>,
  'path'
>

/**
 * Get read-only fields for standard change templates
 */
export const useGetStandardTemplateReadOnlyFields = (props: UseGetStandardTemplateReadOnlyFieldsProps) =>
  useGet<ResponseListString, Failure | Error, GetStandardTemplateReadOnlyFieldsQueryParams, void>(
    `/servicenow/getStandardTemplateReadOnlyFields`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get read-only fields for standard change templates
 */
export const getStandardTemplateReadOnlyFieldsPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, GetStandardTemplateReadOnlyFieldsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, GetStandardTemplateReadOnlyFieldsQueryParams, void>(
    getConfig('ng/api'),
    `/servicenow/getStandardTemplateReadOnlyFields`,
    props,
    signal
  )

export interface GetServiceNowTemplateMetadataQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  ticketType?: string
  templateName?: string
  limit?: number
  offset?: number
  templateType?: 'Form' | 'Standard'
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  searchTerm?: string
}

export type GetServiceNowTemplateMetadataProps = Omit<
  GetProps<ResponseListServiceNowTemplate, Failure | Error, GetServiceNowTemplateMetadataQueryParams, void>,
  'path'
>

/**
 * Get ServiceNow template metadata
 */
export const GetServiceNowTemplateMetadata = (props: GetServiceNowTemplateMetadataProps) => (
  <Get<ResponseListServiceNowTemplate, Failure | Error, GetServiceNowTemplateMetadataQueryParams, void>
    path={`/servicenow/getTemplate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceNowTemplateMetadataProps = Omit<
  UseGetProps<ResponseListServiceNowTemplate, Failure | Error, GetServiceNowTemplateMetadataQueryParams, void>,
  'path'
>

/**
 * Get ServiceNow template metadata
 */
export const useGetServiceNowTemplateMetadata = (props: UseGetServiceNowTemplateMetadataProps) =>
  useGet<ResponseListServiceNowTemplate, Failure | Error, GetServiceNowTemplateMetadataQueryParams, void>(
    `/servicenow/getTemplate`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get ServiceNow template metadata
 */
export const getServiceNowTemplateMetadataPromise = (
  props: GetUsingFetchProps<
    ResponseListServiceNowTemplate,
    Failure | Error,
    GetServiceNowTemplateMetadataQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListServiceNowTemplate, Failure | Error, GetServiceNowTemplateMetadataQueryParams, void>(
    getConfig('ng/api'),
    `/servicenow/getTemplate`,
    props,
    signal
  )

export interface GetServiceNowTemplateMetadataV2QueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  ticketType: string
  templateName?: string
  size?: number
  page?: number
  templateType?: 'Form' | 'Standard'
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  searchTerm?: string
}

export type GetServiceNowTemplateMetadataV2Props = Omit<
  GetProps<ResponsePageServiceNowTemplate, Failure | Error, GetServiceNowTemplateMetadataV2QueryParams, void>,
  'path'
>

/**
 * Get ServiceNow template metadata
 */
export const GetServiceNowTemplateMetadataV2 = (props: GetServiceNowTemplateMetadataV2Props) => (
  <Get<ResponsePageServiceNowTemplate, Failure | Error, GetServiceNowTemplateMetadataV2QueryParams, void>
    path={`/servicenow/getTemplateV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceNowTemplateMetadataV2Props = Omit<
  UseGetProps<ResponsePageServiceNowTemplate, Failure | Error, GetServiceNowTemplateMetadataV2QueryParams, void>,
  'path'
>

/**
 * Get ServiceNow template metadata
 */
export const useGetServiceNowTemplateMetadataV2 = (props: UseGetServiceNowTemplateMetadataV2Props) =>
  useGet<ResponsePageServiceNowTemplate, Failure | Error, GetServiceNowTemplateMetadataV2QueryParams, void>(
    `/servicenow/getTemplateV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get ServiceNow template metadata
 */
export const getServiceNowTemplateMetadataV2Promise = (
  props: GetUsingFetchProps<
    ResponsePageServiceNowTemplate,
    Failure | Error,
    GetServiceNowTemplateMetadataV2QueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageServiceNowTemplate, Failure | Error, GetServiceNowTemplateMetadataV2QueryParams, void>(
    getConfig('ng/api'),
    `/servicenow/getTemplateV2`,
    props,
    signal
  )

export interface GetTicketDetailsQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  ticketType: string
  ticketNumber: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetTicketDetailsProps = Omit<
  MutateProps<
    ResponseServiceNowTicketNG,
    Failure | Error,
    GetTicketDetailsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get ServiceNow issue details
 */
export const GetTicketDetails = (props: GetTicketDetailsProps) => (
  <Mutate<
    ResponseServiceNowTicketNG,
    Failure | Error,
    GetTicketDetailsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >
    verb="POST"
    path={`/servicenow/getTicketDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTicketDetailsProps = Omit<
  UseMutateProps<
    ResponseServiceNowTicketNG,
    Failure | Error,
    GetTicketDetailsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get ServiceNow issue details
 */
export const useGetTicketDetails = (props: UseGetTicketDetailsProps) =>
  useMutate<
    ResponseServiceNowTicketNG,
    Failure | Error,
    GetTicketDetailsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >('POST', `/servicenow/getTicketDetails`, { base: getConfig('ng/api'), ...props })

/**
 * Get ServiceNow issue details
 */
export const getTicketDetailsPromise = (
  props: MutateUsingFetchProps<
    ResponseServiceNowTicketNG,
    Failure | Error,
    GetTicketDetailsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceNowTicketNG,
    Failure | Error,
    GetTicketDetailsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/servicenow/getTicketDetails`, props, signal)

export interface GetServiceNowIssueMetadataQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  ticketType?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetServiceNowIssueMetadataProps = Omit<
  GetProps<ResponseListServiceNowFieldNG, Failure | Error, GetServiceNowIssueMetadataQueryParams, void>,
  'path'
>

/**
 * Get ServiceNow metadata for ticketType
 */
export const GetServiceNowIssueMetadata = (props: GetServiceNowIssueMetadataProps) => (
  <Get<ResponseListServiceNowFieldNG, Failure | Error, GetServiceNowIssueMetadataQueryParams, void>
    path={`/servicenow/metadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceNowIssueMetadataProps = Omit<
  UseGetProps<ResponseListServiceNowFieldNG, Failure | Error, GetServiceNowIssueMetadataQueryParams, void>,
  'path'
>

/**
 * Get ServiceNow metadata for ticketType
 */
export const useGetServiceNowIssueMetadata = (props: UseGetServiceNowIssueMetadataProps) =>
  useGet<ResponseListServiceNowFieldNG, Failure | Error, GetServiceNowIssueMetadataQueryParams, void>(
    `/servicenow/metadata`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get ServiceNow metadata for ticketType
 */
export const getServiceNowIssueMetadataPromise = (
  props: GetUsingFetchProps<
    ResponseListServiceNowFieldNG,
    Failure | Error,
    GetServiceNowIssueMetadataQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListServiceNowFieldNG, Failure | Error, GetServiceNowIssueMetadataQueryParams, void>(
    getConfig('ng/api'),
    `/servicenow/metadata`,
    props,
    signal
  )

export interface GetServiceNowStagingTablesQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetServiceNowStagingTablesProps = Omit<
  GetProps<ResponseListServiceNowStagingTable, Failure | Error, GetServiceNowStagingTablesQueryParams, void>,
  'path'
>

/**
 * Get serviceNow staging tables
 */
export const GetServiceNowStagingTables = (props: GetServiceNowStagingTablesProps) => (
  <Get<ResponseListServiceNowStagingTable, Failure | Error, GetServiceNowStagingTablesQueryParams, void>
    path={`/servicenow/stagingTable`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceNowStagingTablesProps = Omit<
  UseGetProps<ResponseListServiceNowStagingTable, Failure | Error, GetServiceNowStagingTablesQueryParams, void>,
  'path'
>

/**
 * Get serviceNow staging tables
 */
export const useGetServiceNowStagingTables = (props: UseGetServiceNowStagingTablesProps) =>
  useGet<ResponseListServiceNowStagingTable, Failure | Error, GetServiceNowStagingTablesQueryParams, void>(
    `/servicenow/stagingTable`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get serviceNow staging tables
 */
export const getServiceNowStagingTablesPromise = (
  props: GetUsingFetchProps<
    ResponseListServiceNowStagingTable,
    Failure | Error,
    GetServiceNowStagingTablesQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListServiceNowStagingTable, Failure | Error, GetServiceNowStagingTablesQueryParams, void>(
    getConfig('ng/api'),
    `/servicenow/stagingTable`,
    props,
    signal
  )

export interface GetServiceNowTicketTypesQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetServiceNowTicketTypesProps = Omit<
  GetProps<ResponseListServiceNowTicketTypeDTO, Failure | Error, GetServiceNowTicketTypesQueryParams, void>,
  'path'
>

/**
 * Get serviceNow ticket types
 */
export const GetServiceNowTicketTypes = (props: GetServiceNowTicketTypesProps) => (
  <Get<ResponseListServiceNowTicketTypeDTO, Failure | Error, GetServiceNowTicketTypesQueryParams, void>
    path={`/servicenow/ticketTypes`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceNowTicketTypesProps = Omit<
  UseGetProps<ResponseListServiceNowTicketTypeDTO, Failure | Error, GetServiceNowTicketTypesQueryParams, void>,
  'path'
>

/**
 * Get serviceNow ticket types
 */
export const useGetServiceNowTicketTypes = (props: UseGetServiceNowTicketTypesProps) =>
  useGet<ResponseListServiceNowTicketTypeDTO, Failure | Error, GetServiceNowTicketTypesQueryParams, void>(
    `/servicenow/ticketTypes`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get serviceNow ticket types
 */
export const getServiceNowTicketTypesPromise = (
  props: GetUsingFetchProps<
    ResponseListServiceNowTicketTypeDTO,
    Failure | Error,
    GetServiceNowTicketTypesQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListServiceNowTicketTypeDTO, Failure | Error, GetServiceNowTicketTypesQueryParams, void>(
    getConfig('ng/api'),
    `/servicenow/ticketTypes`,
    props,
    signal
  )

export interface GetServiceNowTicketTypesV2QueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetServiceNowTicketTypesV2Props = Omit<
  GetProps<ResponseListServiceNowTicketTypeDTO, Failure | Error, GetServiceNowTicketTypesV2QueryParams, void>,
  'path'
>

/**
 * Get serviceNow ticket types V2
 */
export const GetServiceNowTicketTypesV2 = (props: GetServiceNowTicketTypesV2Props) => (
  <Get<ResponseListServiceNowTicketTypeDTO, Failure | Error, GetServiceNowTicketTypesV2QueryParams, void>
    path={`/servicenow/ticketTypesV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceNowTicketTypesV2Props = Omit<
  UseGetProps<ResponseListServiceNowTicketTypeDTO, Failure | Error, GetServiceNowTicketTypesV2QueryParams, void>,
  'path'
>

/**
 * Get serviceNow ticket types V2
 */
export const useGetServiceNowTicketTypesV2 = (props: UseGetServiceNowTicketTypesV2Props) =>
  useGet<ResponseListServiceNowTicketTypeDTO, Failure | Error, GetServiceNowTicketTypesV2QueryParams, void>(
    `/servicenow/ticketTypesV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get serviceNow ticket types V2
 */
export const getServiceNowTicketTypesV2Promise = (
  props: GetUsingFetchProps<
    ResponseListServiceNowTicketTypeDTO,
    Failure | Error,
    GetServiceNowTicketTypesV2QueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListServiceNowTicketTypeDTO, Failure | Error, GetServiceNowTicketTypesV2QueryParams, void>(
    getConfig('ng/api'),
    `/servicenow/ticketTypesV2`,
    props,
    signal
  )

export interface GetServiceListForProjectQueryParams {
  page?: number
  size?: number
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceIdentifiers?: string[]
  sort?: string[]
}

export type GetServiceListForProjectProps = Omit<
  GetProps<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>,
  'path'
>

/**
 * Gets Service list for a project
 */
export const GetServiceListForProject = (props: GetServiceListForProjectProps) => (
  <Get<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>
    path={`/services`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceListForProjectProps = Omit<
  UseGetProps<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>,
  'path'
>

/**
 * Gets Service list for a project
 */
export const useGetServiceListForProject = (props: UseGetServiceListForProjectProps) =>
  useGet<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>(`/services`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Service list for a project
 */
export const getServiceListForProjectPromise = (
  props: GetUsingFetchProps<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>(
    getConfig('ng/api'),
    `/services`,
    props,
    signal
  )

export interface CreateServiceQueryParams {
  accountId?: string
}

export type CreateServiceProps = Omit<
  MutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Service
 */
export const CreateService = (props: CreateServiceProps) => (
  <Mutate<ResponseServiceResponseDTO, Failure | Error, CreateServiceQueryParams, ServiceRequestDTORequestBody, void>
    verb="POST"
    path={`/services`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServiceProps = Omit<
  UseMutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Service
 */
export const useCreateService = (props: UseCreateServiceProps) =>
  useMutate<ResponseServiceResponseDTO, Failure | Error, CreateServiceQueryParams, ServiceRequestDTORequestBody, void>(
    'POST',
    `/services`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a Service
 */
export const createServicePromise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponseDTO,
    Failure | Error,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/services`, props, signal)

export interface UpdateServiceQueryParams {
  accountId?: string
}

export type UpdateServiceProps = Omit<
  MutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a service by identifier
 */
export const UpdateService = (props: UpdateServiceProps) => (
  <Mutate<ResponseServiceResponseDTO, Failure | Error, UpdateServiceQueryParams, ServiceRequestDTORequestBody, void>
    verb="PUT"
    path={`/services`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateServiceProps = Omit<
  UseMutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a service by identifier
 */
export const useUpdateService = (props: UseUpdateServiceProps) =>
  useMutate<ResponseServiceResponseDTO, Failure | Error, UpdateServiceQueryParams, ServiceRequestDTORequestBody, void>(
    'PUT',
    `/services`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update a service by identifier
 */
export const updateServicePromise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/services`, props, signal)

export interface CreateServicesQueryParams {
  accountId?: string
}

export type CreateServicesProps = Omit<
  MutateProps<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Services
 */
export const CreateServices = (props: CreateServicesProps) => (
  <Mutate<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >
    verb="POST"
    path={`/services/batch`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServicesProps = Omit<
  UseMutateProps<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Services
 */
export const useCreateServices = (props: UseCreateServicesProps) =>
  useMutate<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >('POST', `/services/batch`, { base: getConfig('ng/api'), ...props })

/**
 * Create Services
 */
export const createServicesPromise = (
  props: MutateUsingFetchProps<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >('POST', getConfig('ng/api'), `/services/batch`, props, signal)

export interface HelmCmdFlagsQueryParams {
  serviceSpecType: string
  version: 'V2' | 'V3' | 'V380'
  storeType: string
}

export type HelmCmdFlagsProps = Omit<
  GetProps<ResponseSetHelmCommandFlagType, Failure | Error, HelmCmdFlagsQueryParams, void>,
  'path'
>

/**
 * Get Command flags based on Deployment Type
 */
export const HelmCmdFlags = (props: HelmCmdFlagsProps) => (
  <Get<ResponseSetHelmCommandFlagType, Failure | Error, HelmCmdFlagsQueryParams, void>
    path={`/services/helmCmdFlags`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseHelmCmdFlagsProps = Omit<
  UseGetProps<ResponseSetHelmCommandFlagType, Failure | Error, HelmCmdFlagsQueryParams, void>,
  'path'
>

/**
 * Get Command flags based on Deployment Type
 */
export const useHelmCmdFlags = (props: UseHelmCmdFlagsProps) =>
  useGet<ResponseSetHelmCommandFlagType, Failure | Error, HelmCmdFlagsQueryParams, void>(`/services/helmCmdFlags`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Command flags based on Deployment Type
 */
export const helmCmdFlagsPromise = (
  props: GetUsingFetchProps<ResponseSetHelmCommandFlagType, Failure | Error, HelmCmdFlagsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSetHelmCommandFlagType, Failure | Error, HelmCmdFlagsQueryParams, void>(
    getConfig('ng/api'),
    `/services/helmCmdFlags`,
    props,
    signal
  )

export interface UpsertServiceQueryParams {
  accountId?: string
}

export type UpsertServiceProps = Omit<
  MutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert a service by identifier
 */
export const UpsertService = (props: UpsertServiceProps) => (
  <Mutate<ResponseServiceResponseDTO, Failure | Error, UpsertServiceQueryParams, ServiceRequestDTORequestBody, void>
    verb="PUT"
    path={`/services/upsert`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertServiceProps = Omit<
  UseMutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert a service by identifier
 */
export const useUpsertService = (props: UseUpsertServiceProps) =>
  useMutate<ResponseServiceResponseDTO, Failure | Error, UpsertServiceQueryParams, ServiceRequestDTORequestBody, void>(
    'PUT',
    `/services/upsert`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Upsert a service by identifier
 */
export const upsertServicePromise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/services/upsert`, props, signal)

export interface DeleteServiceQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteServiceProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a service by identifier
 */
export const DeleteService = (props: DeleteServiceProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>
    verb="DELETE"
    path={`/services`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteServiceProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a service by identifier
 */
export const useDeleteService = (props: UseDeleteServiceProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>('DELETE', `/services`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a service by identifier
 */
export const deleteServicePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/services`,
    props,
    signal
  )

export interface GetServiceQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  deleted?: boolean
}

export interface GetServicePathParams {
  serviceIdentifier: string
}

export type GetServiceProps = Omit<
  GetProps<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>,
  'path'
> &
  GetServicePathParams

/**
 * Gets a Service by identifier
 */
export const GetService = ({ serviceIdentifier, ...props }: GetServiceProps) => (
  <Get<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>
    path={`/services/${serviceIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceProps = Omit<
  UseGetProps<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>,
  'path'
> &
  GetServicePathParams

/**
 * Gets a Service by identifier
 */
export const useGetService = ({ serviceIdentifier, ...props }: UseGetServiceProps) =>
  useGet<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>(
    (paramsInPath: GetServicePathParams) => `/services/${paramsInPath.serviceIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { serviceIdentifier }, ...props }
  )

/**
 * Gets a Service by identifier
 */
export const getServicePromise = (
  {
    serviceIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams> & {
    serviceIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>(
    getConfig('ng/api'),
    `/services/${serviceIdentifier}`,
    props,
    signal
  )

export interface GetServiceListQueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  serviceIdentifiers?: string[]
  sort?: string[]
  type?:
    | 'Kubernetes'
    | 'NativeHelm'
    | 'Ssh'
    | 'WinRm'
    | 'ServerlessAwsLambda'
    | 'AzureWebApp'
    | 'CustomDeployment'
    | 'ECS'
    | 'Elastigroup'
    | 'TAS'
    | 'Asg'
    | 'GoogleCloudFunctions'
    | 'AwsLambda'
    | 'AWS_SAM'
  gitOpsEnabled?: boolean
  deploymentTemplateIdentifier?: string
  versionLabel?: string
  includeAllServicesAccessibleAtScope?: boolean
  includeVersionInfo?: boolean
  repoName?: string
}

export type GetServiceListProps = Omit<
  GetProps<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>,
  'path'
>

/**
 * Gets Service list
 */
export const GetServiceList = (props: GetServiceListProps) => (
  <Get<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>
    path={`/servicesV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceListProps = Omit<
  UseGetProps<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>,
  'path'
>

/**
 * Gets Service list
 */
export const useGetServiceList = (props: UseGetServiceListProps) =>
  useGet<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>(`/servicesV2`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Service list
 */
export const getServiceListPromise = (
  props: GetUsingFetchProps<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>(
    getConfig('ng/api'),
    `/servicesV2`,
    props,
    signal
  )

export interface CreateServiceV2QueryParams {
  accountIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  repoName?: string
}

export type CreateServiceV2Props = Omit<
  MutateProps<ResponseServiceResponse, Failure | Error, CreateServiceV2QueryParams, ServiceRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Service
 */
export const CreateServiceV2 = (props: CreateServiceV2Props) => (
  <Mutate<ResponseServiceResponse, Failure | Error, CreateServiceV2QueryParams, ServiceRequestDTORequestBody, void>
    verb="POST"
    path={`/servicesV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServiceV2Props = Omit<
  UseMutateProps<
    ResponseServiceResponse,
    Failure | Error,
    CreateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Service
 */
export const useCreateServiceV2 = (props: UseCreateServiceV2Props) =>
  useMutate<ResponseServiceResponse, Failure | Error, CreateServiceV2QueryParams, ServiceRequestDTORequestBody, void>(
    'POST',
    `/servicesV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a Service
 */
export const createServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponse,
    Failure | Error,
    CreateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponse,
    Failure | Error,
    CreateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/servicesV2`, props, signal)

export interface UpdateServiceV2QueryParams {
  accountIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  lastCommitId?: string
  isNewBranch?: boolean
}

export type UpdateServiceV2Props = Omit<
  MutateProps<ResponseServiceResponse, Failure | Error, UpdateServiceV2QueryParams, ServiceRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a service by identifier
 */
export const UpdateServiceV2 = (props: UpdateServiceV2Props) => (
  <Mutate<ResponseServiceResponse, Failure | Error, UpdateServiceV2QueryParams, ServiceRequestDTORequestBody, void>
    verb="PUT"
    path={`/servicesV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateServiceV2Props = Omit<
  UseMutateProps<
    ResponseServiceResponse,
    Failure | Error,
    UpdateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a service by identifier
 */
export const useUpdateServiceV2 = (props: UseUpdateServiceV2Props) =>
  useMutate<ResponseServiceResponse, Failure | Error, UpdateServiceV2QueryParams, ServiceRequestDTORequestBody, void>(
    'PUT',
    `/servicesV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update a service by identifier
 */
export const updateServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponse,
    Failure | Error,
    UpdateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponse,
    Failure | Error,
    UpdateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/servicesV2`, props, signal)

export interface GetArtifactSourceTemplateEntityReferencesQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetArtifactSourceTemplateEntityReferencesProps = Omit<
  MutateProps<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetArtifactSourceTemplateEntityReferencesQueryParams,
    ArtifactSourceYamlRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Artifact Source Template entity references
 */
export const GetArtifactSourceTemplateEntityReferences = (props: GetArtifactSourceTemplateEntityReferencesProps) => (
  <Mutate<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetArtifactSourceTemplateEntityReferencesQueryParams,
    ArtifactSourceYamlRequest,
    void
  >
    verb="POST"
    path={`/servicesV2/artifact-source-references`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetArtifactSourceTemplateEntityReferencesProps = Omit<
  UseMutateProps<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetArtifactSourceTemplateEntityReferencesQueryParams,
    ArtifactSourceYamlRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Artifact Source Template entity references
 */
export const useGetArtifactSourceTemplateEntityReferences = (
  props: UseGetArtifactSourceTemplateEntityReferencesProps
) =>
  useMutate<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetArtifactSourceTemplateEntityReferencesQueryParams,
    ArtifactSourceYamlRequest,
    void
  >('POST', `/servicesV2/artifact-source-references`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Artifact Source Template entity references
 */
export const getArtifactSourceTemplateEntityReferencesPromise = (
  props: MutateUsingFetchProps<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetArtifactSourceTemplateEntityReferencesQueryParams,
    ArtifactSourceYamlRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetArtifactSourceTemplateEntityReferencesQueryParams,
    ArtifactSourceYamlRequest,
    void
  >('POST', getConfig('ng/api'), `/servicesV2/artifact-source-references`, props, signal)

export interface GetArtifactSourceInputsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export interface GetArtifactSourceInputsPathParams {
  serviceIdentifier: string
}

export type GetArtifactSourceInputsProps = Omit<
  GetProps<
    ResponseArtifactSourcesResponseDTO,
    Failure | Error,
    GetArtifactSourceInputsQueryParams,
    GetArtifactSourceInputsPathParams
  >,
  'path'
> &
  GetArtifactSourceInputsPathParams

/**
 * This api returns artifact source identifiers and their runtime inputs YAML
 */
export const GetArtifactSourceInputs = ({ serviceIdentifier, ...props }: GetArtifactSourceInputsProps) => (
  <Get<
    ResponseArtifactSourcesResponseDTO,
    Failure | Error,
    GetArtifactSourceInputsQueryParams,
    GetArtifactSourceInputsPathParams
  >
    path={`/servicesV2/artifactSourceInputs/${serviceIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetArtifactSourceInputsProps = Omit<
  UseGetProps<
    ResponseArtifactSourcesResponseDTO,
    Failure | Error,
    GetArtifactSourceInputsQueryParams,
    GetArtifactSourceInputsPathParams
  >,
  'path'
> &
  GetArtifactSourceInputsPathParams

/**
 * This api returns artifact source identifiers and their runtime inputs YAML
 */
export const useGetArtifactSourceInputs = ({ serviceIdentifier, ...props }: UseGetArtifactSourceInputsProps) =>
  useGet<
    ResponseArtifactSourcesResponseDTO,
    Failure | Error,
    GetArtifactSourceInputsQueryParams,
    GetArtifactSourceInputsPathParams
  >(
    (paramsInPath: GetArtifactSourceInputsPathParams) =>
      `/servicesV2/artifactSourceInputs/${paramsInPath.serviceIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { serviceIdentifier }, ...props }
  )

/**
 * This api returns artifact source identifiers and their runtime inputs YAML
 */
export const getArtifactSourceInputsPromise = (
  {
    serviceIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseArtifactSourcesResponseDTO,
    Failure | Error,
    GetArtifactSourceInputsQueryParams,
    GetArtifactSourceInputsPathParams
  > & { serviceIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseArtifactSourcesResponseDTO,
    Failure | Error,
    GetArtifactSourceInputsQueryParams,
    GetArtifactSourceInputsPathParams
  >(getConfig('ng/api'), `/servicesV2/artifactSourceInputs/${serviceIdentifier}`, props, signal)

export interface CreateServicesV2QueryParams {
  accountIdentifier: string
}

export type CreateServicesV2Props = Omit<
  MutateProps<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Services
 */
export const CreateServicesV2 = (props: CreateServicesV2Props) => (
  <Mutate<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >
    verb="POST"
    path={`/servicesV2/batch`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServicesV2Props = Omit<
  UseMutateProps<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Services
 */
export const useCreateServicesV2 = (props: UseCreateServicesV2Props) =>
  useMutate<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >('POST', `/servicesV2/batch`, { base: getConfig('ng/api'), ...props })

/**
 * Create Services
 */
export const createServicesV2Promise = (
  props: MutateUsingFetchProps<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >('POST', getConfig('ng/api'), `/servicesV2/batch`, props, signal)

export type DummyArtifactSourceConfigApiProps = Omit<
  GetProps<ResponseArtifactSourceConfig, Failure | Error, void, void>,
  'path'
>

/**
 * This is dummy api to expose ArtifactSourceConfig
 */
export const DummyArtifactSourceConfigApi = (props: DummyArtifactSourceConfigApiProps) => (
  <Get<ResponseArtifactSourceConfig, Failure | Error, void, void>
    path={`/servicesV2/dummy-artifactSourceConfig-api`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDummyArtifactSourceConfigApiProps = Omit<
  UseGetProps<ResponseArtifactSourceConfig, Failure | Error, void, void>,
  'path'
>

/**
 * This is dummy api to expose ArtifactSourceConfig
 */
export const useDummyArtifactSourceConfigApi = (props: UseDummyArtifactSourceConfigApiProps) =>
  useGet<ResponseArtifactSourceConfig, Failure | Error, void, void>(`/servicesV2/dummy-artifactSourceConfig-api`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * This is dummy api to expose ArtifactSourceConfig
 */
export const dummyArtifactSourceConfigApiPromise = (
  props: GetUsingFetchProps<ResponseArtifactSourceConfig, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseArtifactSourceConfig, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/servicesV2/dummy-artifactSourceConfig-api`,
    props,
    signal
  )

export type DummyArtifactSummaryApiProps = Omit<GetProps<ResponseArtifactSummary, Failure | Error, void, void>, 'path'>

/**
 * This is dummy api to expose ArtifactSummary
 */
export const DummyArtifactSummaryApi = (props: DummyArtifactSummaryApiProps) => (
  <Get<ResponseArtifactSummary, Failure | Error, void, void>
    path={`/servicesV2/dummy-artifactSummary-api`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDummyArtifactSummaryApiProps = Omit<
  UseGetProps<ResponseArtifactSummary, Failure | Error, void, void>,
  'path'
>

/**
 * This is dummy api to expose ArtifactSummary
 */
export const useDummyArtifactSummaryApi = (props: UseDummyArtifactSummaryApiProps) =>
  useGet<ResponseArtifactSummary, Failure | Error, void, void>(`/servicesV2/dummy-artifactSummary-api`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * This is dummy api to expose ArtifactSummary
 */
export const dummyArtifactSummaryApiPromise = (
  props: GetUsingFetchProps<ResponseArtifactSummary, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseArtifactSummary, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/servicesV2/dummy-artifactSummary-api`,
    props,
    signal
  )

export type DummyNGServiceConfigApiProps = Omit<GetProps<ResponseNGServiceConfig, Failure | Error, void, void>, 'path'>

/**
 * This is dummy api to expose NGServiceConfig
 */
export const DummyNGServiceConfigApi = (props: DummyNGServiceConfigApiProps) => (
  <Get<ResponseNGServiceConfig, Failure | Error, void, void>
    path={`/servicesV2/dummy-serviceConfig-api`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDummyNGServiceConfigApiProps = Omit<
  UseGetProps<ResponseNGServiceConfig, Failure | Error, void, void>,
  'path'
>

/**
 * This is dummy api to expose NGServiceConfig
 */
export const useDummyNGServiceConfigApi = (props: UseDummyNGServiceConfigApiProps) =>
  useGet<ResponseNGServiceConfig, Failure | Error, void, void>(`/servicesV2/dummy-serviceConfig-api`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * This is dummy api to expose NGServiceConfig
 */
export const dummyNGServiceConfigApiPromise = (
  props: GetUsingFetchProps<ResponseNGServiceConfig, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNGServiceConfig, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/servicesV2/dummy-serviceConfig-api`,
    props,
    signal
  )

export interface HookActionsQueryParams {
  serviceSpecType: string
}

export type HookActionsProps = Omit<
  GetProps<ResponseSetServiceHookAction, Failure | Error, HookActionsQueryParams, void>,
  'path'
>

/**
 * Get Available Service Hook Actions
 */
export const HookActions = (props: HookActionsProps) => (
  <Get<ResponseSetServiceHookAction, Failure | Error, HookActionsQueryParams, void>
    path={`/servicesV2/hooks/actions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseHookActionsProps = Omit<
  UseGetProps<ResponseSetServiceHookAction, Failure | Error, HookActionsQueryParams, void>,
  'path'
>

/**
 * Get Available Service Hook Actions
 */
export const useHookActions = (props: UseHookActionsProps) =>
  useGet<ResponseSetServiceHookAction, Failure | Error, HookActionsQueryParams, void>(`/servicesV2/hooks/actions`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Available Service Hook Actions
 */
export const hookActionsPromise = (
  props: GetUsingFetchProps<ResponseSetServiceHookAction, Failure | Error, HookActionsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSetServiceHookAction, Failure | Error, HookActionsQueryParams, void>(
    getConfig('ng/api'),
    `/servicesV2/hooks/actions`,
    props,
    signal
  )

export interface K8sCmdFlagsQueryParams {
  serviceSpecType: string
}

export type K8sCmdFlagsProps = Omit<
  GetProps<ResponseSetK8sCommandFlagType, Failure | Error, K8sCmdFlagsQueryParams, void>,
  'path'
>

/**
 * Get Command flags for K8s
 */
export const K8sCmdFlags = (props: K8sCmdFlagsProps) => (
  <Get<ResponseSetK8sCommandFlagType, Failure | Error, K8sCmdFlagsQueryParams, void>
    path={`/servicesV2/k8s/command-flags`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseK8sCmdFlagsProps = Omit<
  UseGetProps<ResponseSetK8sCommandFlagType, Failure | Error, K8sCmdFlagsQueryParams, void>,
  'path'
>

/**
 * Get Command flags for K8s
 */
export const useK8sCmdFlags = (props: UseK8sCmdFlagsProps) =>
  useGet<ResponseSetK8sCommandFlagType, Failure | Error, K8sCmdFlagsQueryParams, void>(
    `/servicesV2/k8s/command-flags`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Command flags for K8s
 */
export const k8sCmdFlagsPromise = (
  props: GetUsingFetchProps<ResponseSetK8sCommandFlagType, Failure | Error, K8sCmdFlagsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSetK8sCommandFlagType, Failure | Error, K8sCmdFlagsQueryParams, void>(
    getConfig('ng/api'),
    `/servicesV2/k8s/command-flags`,
    props,
    signal
  )

export type KustomizeCmdFlagsProps = Omit<
  GetProps<ResponseSetKustomizeCommandFlagType, Failure | Error, void, void>,
  'path'
>

/**
 * Get Command flags for kustomize
 */
export const KustomizeCmdFlags = (props: KustomizeCmdFlagsProps) => (
  <Get<ResponseSetKustomizeCommandFlagType, Failure | Error, void, void>
    path={`/servicesV2/kustomize/command-flags`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseKustomizeCmdFlagsProps = Omit<
  UseGetProps<ResponseSetKustomizeCommandFlagType, Failure | Error, void, void>,
  'path'
>

/**
 * Get Command flags for kustomize
 */
export const useKustomizeCmdFlags = (props: UseKustomizeCmdFlagsProps) =>
  useGet<ResponseSetKustomizeCommandFlagType, Failure | Error, void, void>(`/servicesV2/kustomize/command-flags`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Command flags for kustomize
 */
export const kustomizeCmdFlagsPromise = (
  props: GetUsingFetchProps<ResponseSetKustomizeCommandFlagType, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSetKustomizeCommandFlagType, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/servicesV2/kustomize/command-flags`,
    props,
    signal
  )

export interface GetRepositoryListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  includeAllServicesAccessibleAtScope?: boolean
}

export type GetRepositoryListProps = Omit<
  GetProps<ResponseRepoListResponseDTO, Failure | Error, GetRepositoryListQueryParams, void>,
  'path'
>

/**
 * Gets all repo list
 */
export const GetRepositoryList = (props: GetRepositoryListProps) => (
  <Get<ResponseRepoListResponseDTO, Failure | Error, GetRepositoryListQueryParams, void>
    path={`/servicesV2/list-repo`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetRepositoryListProps = Omit<
  UseGetProps<ResponseRepoListResponseDTO, Failure | Error, GetRepositoryListQueryParams, void>,
  'path'
>

/**
 * Gets all repo list
 */
export const useGetRepositoryList = (props: UseGetRepositoryListProps) =>
  useGet<ResponseRepoListResponseDTO, Failure | Error, GetRepositoryListQueryParams, void>(`/servicesV2/list-repo`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets all repo list
 */
export const getRepositoryListPromise = (
  props: GetUsingFetchProps<ResponseRepoListResponseDTO, Failure | Error, GetRepositoryListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseRepoListResponseDTO, Failure | Error, GetRepositoryListQueryParams, void>(
    getConfig('ng/api'),
    `/servicesV2/list-repo`,
    props,
    signal
  )

export interface GetServiceAccessListQueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  serviceIdentifiers?: string[]
  sort?: string[]
  type?:
    | 'Kubernetes'
    | 'NativeHelm'
    | 'Ssh'
    | 'WinRm'
    | 'ServerlessAwsLambda'
    | 'AzureWebApp'
    | 'CustomDeployment'
    | 'ECS'
    | 'Elastigroup'
    | 'TAS'
    | 'Asg'
    | 'GoogleCloudFunctions'
    | 'AwsLambda'
    | 'AWS_SAM'
  gitOpsEnabled?: boolean
  deploymentTemplateIdentifier?: string
  versionLabel?: string
  deploymentMetadataYaml?: string
  includeAllServicesAccessibleAtScope?: boolean
}

export type GetServiceAccessListProps = Omit<
  GetProps<ResponseListServiceResponse, Failure | Error, GetServiceAccessListQueryParams, void>,
  'path'
>

/**
 * Gets Service Access list
 */
export const GetServiceAccessList = (props: GetServiceAccessListProps) => (
  <Get<ResponseListServiceResponse, Failure | Error, GetServiceAccessListQueryParams, void>
    path={`/servicesV2/list/access`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceAccessListProps = Omit<
  UseGetProps<ResponseListServiceResponse, Failure | Error, GetServiceAccessListQueryParams, void>,
  'path'
>

/**
 * Gets Service Access list
 */
export const useGetServiceAccessList = (props: UseGetServiceAccessListProps) =>
  useGet<ResponseListServiceResponse, Failure | Error, GetServiceAccessListQueryParams, void>(
    `/servicesV2/list/access`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Service Access list
 */
export const getServiceAccessListPromise = (
  props: GetUsingFetchProps<ResponseListServiceResponse, Failure | Error, GetServiceAccessListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListServiceResponse, Failure | Error, GetServiceAccessListQueryParams, void>(
    getConfig('ng/api'),
    `/servicesV2/list/access`,
    props,
    signal
  )

export interface GetAllServicesListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  page?: number
  size?: number
  sort?: string[]
}

export type GetAllServicesListProps = Omit<
  GetProps<ResponsePageServiceResponse, Failure | Error, GetAllServicesListQueryParams, void>,
  'path'
>

/**
 * Get all services list
 */
export const GetAllServicesList = (props: GetAllServicesListProps) => (
  <Get<ResponsePageServiceResponse, Failure | Error, GetAllServicesListQueryParams, void>
    path={`/servicesV2/list/all-services`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAllServicesListProps = Omit<
  UseGetProps<ResponsePageServiceResponse, Failure | Error, GetAllServicesListQueryParams, void>,
  'path'
>

/**
 * Get all services list
 */
export const useGetAllServicesList = (props: UseGetAllServicesListProps) =>
  useGet<ResponsePageServiceResponse, Failure | Error, GetAllServicesListQueryParams, void>(
    `/servicesV2/list/all-services`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get all services list
 */
export const getAllServicesListPromise = (
  props: GetUsingFetchProps<ResponsePageServiceResponse, Failure | Error, GetAllServicesListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageServiceResponse, Failure | Error, GetAllServicesListQueryParams, void>(
    getConfig('ng/api'),
    `/servicesV2/list/all-services`,
    props,
    signal
  )

export interface GetServiceListFilteredQueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceIdentifiers?: string[]
}

export type GetServiceListFilteredProps = Omit<
  GetProps<ResponsePageServiceResponse, Failure | Error, GetServiceListFilteredQueryParams, void>,
  'path'
>

/**
 * Gets Service list filtered by service refs
 */
export const GetServiceListFiltered = (props: GetServiceListFilteredProps) => (
  <Get<ResponsePageServiceResponse, Failure | Error, GetServiceListFilteredQueryParams, void>
    path={`/servicesV2/list/scoped`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceListFilteredProps = Omit<
  UseGetProps<ResponsePageServiceResponse, Failure | Error, GetServiceListFilteredQueryParams, void>,
  'path'
>

/**
 * Gets Service list filtered by service refs
 */
export const useGetServiceListFiltered = (props: UseGetServiceListFilteredProps) =>
  useGet<ResponsePageServiceResponse, Failure | Error, GetServiceListFilteredQueryParams, void>(
    `/servicesV2/list/scoped`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Service list filtered by service refs
 */
export const getServiceListFilteredPromise = (
  props: GetUsingFetchProps<ResponsePageServiceResponse, Failure | Error, GetServiceListFilteredQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageServiceResponse, Failure | Error, GetServiceListFilteredQueryParams, void>(
    getConfig('ng/api'),
    `/servicesV2/list/scoped`,
    props,
    signal
  )

export interface MergeServiceInputsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface MergeServiceInputsPathParams {
  serviceIdentifier: string
}

export type MergeServiceInputsProps = Omit<
  MutateProps<
    ResponseServiceInputsMergedResponseDto,
    Failure | Error,
    MergeServiceInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeServiceInputsPathParams
  >,
  'path' | 'verb'
> &
  MergeServiceInputsPathParams

/**
 * This api merges old and new service inputs YAML
 */
export const MergeServiceInputs = ({ serviceIdentifier, ...props }: MergeServiceInputsProps) => (
  <Mutate<
    ResponseServiceInputsMergedResponseDto,
    Failure | Error,
    MergeServiceInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeServiceInputsPathParams
  >
    verb="POST"
    path={`/servicesV2/mergeServiceInputs/${serviceIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseMergeServiceInputsProps = Omit<
  UseMutateProps<
    ResponseServiceInputsMergedResponseDto,
    Failure | Error,
    MergeServiceInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeServiceInputsPathParams
  >,
  'path' | 'verb'
> &
  MergeServiceInputsPathParams

/**
 * This api merges old and new service inputs YAML
 */
export const useMergeServiceInputs = ({ serviceIdentifier, ...props }: UseMergeServiceInputsProps) =>
  useMutate<
    ResponseServiceInputsMergedResponseDto,
    Failure | Error,
    MergeServiceInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeServiceInputsPathParams
  >(
    'POST',
    (paramsInPath: MergeServiceInputsPathParams) => `/servicesV2/mergeServiceInputs/${paramsInPath.serviceIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { serviceIdentifier }, ...props }
  )

/**
 * This api merges old and new service inputs YAML
 */
export const mergeServiceInputsPromise = (
  {
    serviceIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseServiceInputsMergedResponseDto,
    Failure | Error,
    MergeServiceInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeServiceInputsPathParams
  > & { serviceIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceInputsMergedResponseDto,
    Failure | Error,
    MergeServiceInputsQueryParams,
    ListTagsForAMIArtifactBodyRequestBody,
    MergeServiceInputsPathParams
  >('POST', getConfig('ng/api'), `/servicesV2/mergeServiceInputs/${serviceIdentifier}`, props, signal)

export interface MoveServiceConfigsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  connectorRef?: string
  repoName?: string
  branch?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
  moveConfigType?: 'INLINE_TO_REMOTE' | 'REMOTE_TO_INLINE'
}

export interface MoveServiceConfigsPathParams {
  serviceIdentifier: string
}

export type MoveServiceConfigsProps = Omit<
  MutateProps<
    ResponseServiceMoveConfigResponse,
    Failure | Error,
    MoveServiceConfigsQueryParams,
    void,
    MoveServiceConfigsPathParams
  >,
  'path' | 'verb'
> &
  MoveServiceConfigsPathParams

/**
 * Move Service YAML from inline to remote
 */
export const MoveServiceConfigs = ({ serviceIdentifier, ...props }: MoveServiceConfigsProps) => (
  <Mutate<
    ResponseServiceMoveConfigResponse,
    Failure | Error,
    MoveServiceConfigsQueryParams,
    void,
    MoveServiceConfigsPathParams
  >
    verb="POST"
    path={`/servicesV2/move-config/${serviceIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseMoveServiceConfigsProps = Omit<
  UseMutateProps<
    ResponseServiceMoveConfigResponse,
    Failure | Error,
    MoveServiceConfigsQueryParams,
    void,
    MoveServiceConfigsPathParams
  >,
  'path' | 'verb'
> &
  MoveServiceConfigsPathParams

/**
 * Move Service YAML from inline to remote
 */
export const useMoveServiceConfigs = ({ serviceIdentifier, ...props }: UseMoveServiceConfigsProps) =>
  useMutate<
    ResponseServiceMoveConfigResponse,
    Failure | Error,
    MoveServiceConfigsQueryParams,
    void,
    MoveServiceConfigsPathParams
  >(
    'POST',
    (paramsInPath: MoveServiceConfigsPathParams) => `/servicesV2/move-config/${paramsInPath.serviceIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { serviceIdentifier }, ...props }
  )

/**
 * Move Service YAML from inline to remote
 */
export const moveServiceConfigsPromise = (
  {
    serviceIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseServiceMoveConfigResponse,
    Failure | Error,
    MoveServiceConfigsQueryParams,
    void,
    MoveServiceConfigsPathParams
  > & { serviceIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceMoveConfigResponse,
    Failure | Error,
    MoveServiceConfigsQueryParams,
    void,
    MoveServiceConfigsPathParams
  >('POST', getConfig('ng/api'), `/servicesV2/move-config/${serviceIdentifier}`, props, signal)

export interface GetRuntimeInputsServiceEntityQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetRuntimeInputsServiceEntityPathParams {
  serviceIdentifier: string
}

export type GetRuntimeInputsServiceEntityProps = Omit<
  GetProps<
    ResponseNGEntityTemplateResponseDTO,
    Failure | Error,
    GetRuntimeInputsServiceEntityQueryParams,
    GetRuntimeInputsServiceEntityPathParams
  >,
  'path'
> &
  GetRuntimeInputsServiceEntityPathParams

/**
 * This api returns runtime input YAML
 */
export const GetRuntimeInputsServiceEntity = ({ serviceIdentifier, ...props }: GetRuntimeInputsServiceEntityProps) => (
  <Get<
    ResponseNGEntityTemplateResponseDTO,
    Failure | Error,
    GetRuntimeInputsServiceEntityQueryParams,
    GetRuntimeInputsServiceEntityPathParams
  >
    path={`/servicesV2/runtimeInputs/${serviceIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetRuntimeInputsServiceEntityProps = Omit<
  UseGetProps<
    ResponseNGEntityTemplateResponseDTO,
    Failure | Error,
    GetRuntimeInputsServiceEntityQueryParams,
    GetRuntimeInputsServiceEntityPathParams
  >,
  'path'
> &
  GetRuntimeInputsServiceEntityPathParams

/**
 * This api returns runtime input YAML
 */
export const useGetRuntimeInputsServiceEntity = ({
  serviceIdentifier,
  ...props
}: UseGetRuntimeInputsServiceEntityProps) =>
  useGet<
    ResponseNGEntityTemplateResponseDTO,
    Failure | Error,
    GetRuntimeInputsServiceEntityQueryParams,
    GetRuntimeInputsServiceEntityPathParams
  >(
    (paramsInPath: GetRuntimeInputsServiceEntityPathParams) =>
      `/servicesV2/runtimeInputs/${paramsInPath.serviceIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { serviceIdentifier }, ...props }
  )

/**
 * This api returns runtime input YAML
 */
export const getRuntimeInputsServiceEntityPromise = (
  {
    serviceIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseNGEntityTemplateResponseDTO,
    Failure | Error,
    GetRuntimeInputsServiceEntityQueryParams,
    GetRuntimeInputsServiceEntityPathParams
  > & { serviceIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseNGEntityTemplateResponseDTO,
    Failure | Error,
    GetRuntimeInputsServiceEntityQueryParams,
    GetRuntimeInputsServiceEntityPathParams
  >(getConfig('ng/api'), `/servicesV2/runtimeInputs/${serviceIdentifier}`, props, signal)

export interface GetServicesYamlAndRuntimeInputsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetServicesYamlAndRuntimeInputsProps = Omit<
  MutateProps<
    ResponseServicesV2YamlMetadataDTO,
    Failure | Error,
    GetServicesYamlAndRuntimeInputsQueryParams,
    ServicesYamlMetadataApiInput,
    void
  >,
  'path' | 'verb'
>

/**
 * This api returns service YAML and runtime input YAML
 */
export const GetServicesYamlAndRuntimeInputs = (props: GetServicesYamlAndRuntimeInputsProps) => (
  <Mutate<
    ResponseServicesV2YamlMetadataDTO,
    Failure | Error,
    GetServicesYamlAndRuntimeInputsQueryParams,
    ServicesYamlMetadataApiInput,
    void
  >
    verb="POST"
    path={`/servicesV2/servicesYamlMetadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServicesYamlAndRuntimeInputsProps = Omit<
  UseMutateProps<
    ResponseServicesV2YamlMetadataDTO,
    Failure | Error,
    GetServicesYamlAndRuntimeInputsQueryParams,
    ServicesYamlMetadataApiInput,
    void
  >,
  'path' | 'verb'
>

/**
 * This api returns service YAML and runtime input YAML
 */
export const useGetServicesYamlAndRuntimeInputs = (props: UseGetServicesYamlAndRuntimeInputsProps) =>
  useMutate<
    ResponseServicesV2YamlMetadataDTO,
    Failure | Error,
    GetServicesYamlAndRuntimeInputsQueryParams,
    ServicesYamlMetadataApiInput,
    void
  >('POST', `/servicesV2/servicesYamlMetadata`, { base: getConfig('ng/api'), ...props })

/**
 * This api returns service YAML and runtime input YAML
 */
export const getServicesYamlAndRuntimeInputsPromise = (
  props: MutateUsingFetchProps<
    ResponseServicesV2YamlMetadataDTO,
    Failure | Error,
    GetServicesYamlAndRuntimeInputsQueryParams,
    ServicesYamlMetadataApiInput,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServicesV2YamlMetadataDTO,
    Failure | Error,
    GetServicesYamlAndRuntimeInputsQueryParams,
    ServicesYamlMetadataApiInput,
    void
  >('POST', getConfig('ng/api'), `/servicesV2/servicesYamlMetadata`, props, signal)

export interface UpsertServiceV2QueryParams {
  accountIdentifier: string
}

export type UpsertServiceV2Props = Omit<
  MutateProps<ResponseServiceResponse, Failure | Error, UpsertServiceV2QueryParams, ServiceRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Upsert a service by identifier
 */
export const UpsertServiceV2 = (props: UpsertServiceV2Props) => (
  <Mutate<ResponseServiceResponse, Failure | Error, UpsertServiceV2QueryParams, ServiceRequestDTORequestBody, void>
    verb="PUT"
    path={`/servicesV2/upsert`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertServiceV2Props = Omit<
  UseMutateProps<
    ResponseServiceResponse,
    Failure | Error,
    UpsertServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert a service by identifier
 */
export const useUpsertServiceV2 = (props: UseUpsertServiceV2Props) =>
  useMutate<ResponseServiceResponse, Failure | Error, UpsertServiceV2QueryParams, ServiceRequestDTORequestBody, void>(
    'PUT',
    `/servicesV2/upsert`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Upsert a service by identifier
 */
export const upsertServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponse,
    Failure | Error,
    UpsertServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponse,
    Failure | Error,
    UpsertServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/servicesV2/upsert`, props, signal)

export interface GetServicesYamlAndRuntimeInputsV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetServicesYamlAndRuntimeInputsV2Props = Omit<
  MutateProps<
    ResponseServicesV2YamlMetadataDTO,
    Failure | Error,
    GetServicesYamlAndRuntimeInputsV2QueryParams,
    ServicesYamlMetadataApiInputV2,
    void
  >,
  'path' | 'verb'
>

/**
 * This api returns service YAML and runtime input YAML
 */
export const GetServicesYamlAndRuntimeInputsV2 = (props: GetServicesYamlAndRuntimeInputsV2Props) => (
  <Mutate<
    ResponseServicesV2YamlMetadataDTO,
    Failure | Error,
    GetServicesYamlAndRuntimeInputsV2QueryParams,
    ServicesYamlMetadataApiInputV2,
    void
  >
    verb="POST"
    path={`/servicesV2/v2/services-yaml-metadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServicesYamlAndRuntimeInputsV2Props = Omit<
  UseMutateProps<
    ResponseServicesV2YamlMetadataDTO,
    Failure | Error,
    GetServicesYamlAndRuntimeInputsV2QueryParams,
    ServicesYamlMetadataApiInputV2,
    void
  >,
  'path' | 'verb'
>

/**
 * This api returns service YAML and runtime input YAML
 */
export const useGetServicesYamlAndRuntimeInputsV2 = (props: UseGetServicesYamlAndRuntimeInputsV2Props) =>
  useMutate<
    ResponseServicesV2YamlMetadataDTO,
    Failure | Error,
    GetServicesYamlAndRuntimeInputsV2QueryParams,
    ServicesYamlMetadataApiInputV2,
    void
  >('POST', `/servicesV2/v2/services-yaml-metadata`, { base: getConfig('ng/api'), ...props })

/**
 * This api returns service YAML and runtime input YAML
 */
export const getServicesYamlAndRuntimeInputsV2Promise = (
  props: MutateUsingFetchProps<
    ResponseServicesV2YamlMetadataDTO,
    Failure | Error,
    GetServicesYamlAndRuntimeInputsV2QueryParams,
    ServicesYamlMetadataApiInputV2,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServicesV2YamlMetadataDTO,
    Failure | Error,
    GetServicesYamlAndRuntimeInputsV2QueryParams,
    ServicesYamlMetadataApiInputV2,
    void
  >('POST', getConfig('ng/api'), `/servicesV2/v2/services-yaml-metadata`, props, signal)

export interface ValidateTemplateInputsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type ValidateTemplateInputsProps = Omit<
  GetProps<ResponseValidateTemplateInputsResponseDTO, Failure | Error, ValidateTemplateInputsQueryParams, void>,
  'path'
>

/**
 * This validates inputs for templates like artifact sources for service yaml
 */
export const ValidateTemplateInputs = (props: ValidateTemplateInputsProps) => (
  <Get<ResponseValidateTemplateInputsResponseDTO, Failure | Error, ValidateTemplateInputsQueryParams, void>
    path={`/servicesV2/validate-template-inputs`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateTemplateInputsProps = Omit<
  UseGetProps<ResponseValidateTemplateInputsResponseDTO, Failure | Error, ValidateTemplateInputsQueryParams, void>,
  'path'
>

/**
 * This validates inputs for templates like artifact sources for service yaml
 */
export const useValidateTemplateInputs = (props: UseValidateTemplateInputsProps) =>
  useGet<ResponseValidateTemplateInputsResponseDTO, Failure | Error, ValidateTemplateInputsQueryParams, void>(
    `/servicesV2/validate-template-inputs`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * This validates inputs for templates like artifact sources for service yaml
 */
export const validateTemplateInputsPromise = (
  props: GetUsingFetchProps<
    ResponseValidateTemplateInputsResponseDTO,
    Failure | Error,
    ValidateTemplateInputsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseValidateTemplateInputsResponseDTO, Failure | Error, ValidateTemplateInputsQueryParams, void>(
    getConfig('ng/api'),
    `/servicesV2/validate-template-inputs`,
    props,
    signal
  )

export interface DeleteServiceV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  forceDelete?: boolean
}

export type DeleteServiceV2Props = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a service by identifier
 */
export const DeleteServiceV2 = (props: DeleteServiceV2Props) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>
    verb="DELETE"
    path={`/servicesV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteServiceV2Props = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a service by identifier
 */
export const useDeleteServiceV2 = (props: UseDeleteServiceV2Props) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>('DELETE', `/servicesV2`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a service by identifier
 */
export const deleteServiceV2Promise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/servicesV2`,
    props,
    signal
  )

export interface GetServiceV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  deleted?: boolean
  fetchResolvedYaml?: boolean
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  loadFromFallbackBranch?: boolean
}

export interface GetServiceV2PathParams {
  serviceIdentifier: string
}

export type GetServiceV2Props = Omit<
  GetProps<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams>,
  'path'
> &
  GetServiceV2PathParams

/**
 * Gets a Service by identifier
 */
export const GetServiceV2 = ({ serviceIdentifier, ...props }: GetServiceV2Props) => (
  <Get<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams>
    path={`/servicesV2/${serviceIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceV2Props = Omit<
  UseGetProps<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams>,
  'path'
> &
  GetServiceV2PathParams

/**
 * Gets a Service by identifier
 */
export const useGetServiceV2 = ({ serviceIdentifier, ...props }: UseGetServiceV2Props) =>
  useGet<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams>(
    (paramsInPath: GetServiceV2PathParams) => `/servicesV2/${paramsInPath.serviceIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { serviceIdentifier }, ...props }
  )

/**
 * Gets a Service by identifier
 */
export const getServiceV2Promise = (
  {
    serviceIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams> & {
    serviceIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams>(
    getConfig('ng/api'),
    `/servicesV2/${serviceIdentifier}`,
    props,
    signal
  )

export interface GetSettingsListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  category:
    | 'CD'
    | 'CI'
    | 'CE'
    | 'CV'
    | 'CF'
    | 'STO'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'GOVERNANCE'
    | 'CHAOS'
    | 'SCIM'
    | 'GIT_EXPERIENCE'
    | 'CONNECTORS'
    | 'EULA'
    | 'NOTIFICATIONS'
  group?: string
  includeParentScopes?: boolean
}

export type GetSettingsListProps = Omit<
  GetProps<ResponseListSettingResponseDTO, Failure | Error, GetSettingsListQueryParams, void>,
  'path'
>

/**
 * Get list of settings
 */
export const GetSettingsList = (props: GetSettingsListProps) => (
  <Get<ResponseListSettingResponseDTO, Failure | Error, GetSettingsListQueryParams, void>
    path={`/settings`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSettingsListProps = Omit<
  UseGetProps<ResponseListSettingResponseDTO, Failure | Error, GetSettingsListQueryParams, void>,
  'path'
>

/**
 * Get list of settings
 */
export const useGetSettingsList = (props: UseGetSettingsListProps) =>
  useGet<ResponseListSettingResponseDTO, Failure | Error, GetSettingsListQueryParams, void>(`/settings`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get list of settings
 */
export const getSettingsListPromise = (
  props: GetUsingFetchProps<ResponseListSettingResponseDTO, Failure | Error, GetSettingsListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListSettingResponseDTO, Failure | Error, GetSettingsListQueryParams, void>(
    getConfig('ng/api'),
    `/settings`,
    props,
    signal
  )

export interface UpdateSettingValueQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type UpdateSettingValueProps = Omit<
  MutateProps<
    ResponseListSettingUpdateResponseDTO,
    Failure | Error,
    UpdateSettingValueQueryParams,
    SettingRequestDTO[],
    void
  >,
  'path' | 'verb'
>

/**
 * Updates the settings
 */
export const UpdateSettingValue = (props: UpdateSettingValueProps) => (
  <Mutate<
    ResponseListSettingUpdateResponseDTO,
    Failure | Error,
    UpdateSettingValueQueryParams,
    SettingRequestDTO[],
    void
  >
    verb="PUT"
    path={`/settings`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateSettingValueProps = Omit<
  UseMutateProps<
    ResponseListSettingUpdateResponseDTO,
    Failure | Error,
    UpdateSettingValueQueryParams,
    SettingRequestDTO[],
    void
  >,
  'path' | 'verb'
>

/**
 * Updates the settings
 */
export const useUpdateSettingValue = (props: UseUpdateSettingValueProps) =>
  useMutate<
    ResponseListSettingUpdateResponseDTO,
    Failure | Error,
    UpdateSettingValueQueryParams,
    SettingRequestDTO[],
    void
  >('PUT', `/settings`, { base: getConfig('ng/api'), ...props })

/**
 * Updates the settings
 */
export const updateSettingValuePromise = (
  props: MutateUsingFetchProps<
    ResponseListSettingUpdateResponseDTO,
    Failure | Error,
    UpdateSettingValueQueryParams,
    SettingRequestDTO[],
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListSettingUpdateResponseDTO,
    Failure | Error,
    UpdateSettingValueQueryParams,
    SettingRequestDTO[],
    void
  >('PUT', getConfig('ng/api'), `/settings`, props, signal)

export interface GetSettingValueQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetSettingValuePathParams {
  identifier: string
}

export type GetSettingValueProps = Omit<
  GetProps<ResponseSettingValueResponseDTO, Failure | Error, GetSettingValueQueryParams, GetSettingValuePathParams>,
  'path'
> &
  GetSettingValuePathParams

/**
 * Resolves and gets a setting value by Identifier
 */
export const GetSettingValue = ({ identifier, ...props }: GetSettingValueProps) => (
  <Get<ResponseSettingValueResponseDTO, Failure | Error, GetSettingValueQueryParams, GetSettingValuePathParams>
    path={`/settings/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSettingValueProps = Omit<
  UseGetProps<ResponseSettingValueResponseDTO, Failure | Error, GetSettingValueQueryParams, GetSettingValuePathParams>,
  'path'
> &
  GetSettingValuePathParams

/**
 * Resolves and gets a setting value by Identifier
 */
export const useGetSettingValue = ({ identifier, ...props }: UseGetSettingValueProps) =>
  useGet<ResponseSettingValueResponseDTO, Failure | Error, GetSettingValueQueryParams, GetSettingValuePathParams>(
    (paramsInPath: GetSettingValuePathParams) => `/settings/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Resolves and gets a setting value by Identifier
 */
export const getSettingValuePromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseSettingValueResponseDTO,
    Failure | Error,
    GetSettingValueQueryParams,
    GetSettingValuePathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseSettingValueResponseDTO,
    Failure | Error,
    GetSettingValueQueryParams,
    GetSettingValuePathParams
  >(getConfig('ng/api'), `/settings/${identifier}`, props, signal)

export interface SignupQueryParams {
  captchaToken?: string
}

export type SignupProps = Omit<
  MutateProps<RestResponseVoid, Failure | Error, SignupQueryParams, SignupDTORequestBody, void>,
  'path' | 'verb'
>

export const Signup = (props: SignupProps) => (
  <Mutate<RestResponseVoid, Failure | Error, SignupQueryParams, SignupDTORequestBody, void>
    verb="POST"
    path={`/signup`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSignupProps = Omit<
  UseMutateProps<RestResponseVoid, Failure | Error, SignupQueryParams, SignupDTORequestBody, void>,
  'path' | 'verb'
>

export const useSignup = (props: UseSignupProps) =>
  useMutate<RestResponseVoid, Failure | Error, SignupQueryParams, SignupDTORequestBody, void>('POST', `/signup`, {
    base: getConfig('ng/api'),
    ...props
  })

export const signupPromise = (
  props: MutateUsingFetchProps<RestResponseVoid, Failure | Error, SignupQueryParams, SignupDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseVoid, Failure | Error, SignupQueryParams, SignupDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/signup`,
    props,
    signal
  )

export type CommunitySignupProps = Omit<
  MutateProps<RestResponseUserInfo, Failure | Error, void, SignupDTORequestBody, void>,
  'path' | 'verb'
>

export const CommunitySignup = (props: CommunitySignupProps) => (
  <Mutate<RestResponseUserInfo, Failure | Error, void, SignupDTORequestBody, void>
    verb="POST"
    path={`/signup/community`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCommunitySignupProps = Omit<
  UseMutateProps<RestResponseUserInfo, Failure | Error, void, SignupDTORequestBody, void>,
  'path' | 'verb'
>

export const useCommunitySignup = (props: UseCommunitySignupProps) =>
  useMutate<RestResponseUserInfo, Failure | Error, void, SignupDTORequestBody, void>('POST', `/signup/community`, {
    base: getConfig('ng/api'),
    ...props
  })

export const communitySignupPromise = (
  props: MutateUsingFetchProps<RestResponseUserInfo, Failure | Error, void, SignupDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseUserInfo, Failure | Error, void, SignupDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/signup/community`,
    props,
    signal
  )

export interface CompleteSignupInviteQueryParams {
  referer?: string
  gaClientId?: string
  visitorToken?: string
}

export interface CompleteSignupInvitePathParams {
  token: string
}

export type CompleteSignupInviteProps = Omit<
  MutateProps<
    RestResponseUserInfo,
    Failure | Error,
    CompleteSignupInviteQueryParams,
    void,
    CompleteSignupInvitePathParams
  >,
  'path' | 'verb'
> &
  CompleteSignupInvitePathParams

export const CompleteSignupInvite = ({ token, ...props }: CompleteSignupInviteProps) => (
  <Mutate<RestResponseUserInfo, Failure | Error, CompleteSignupInviteQueryParams, void, CompleteSignupInvitePathParams>
    verb="PUT"
    path={`/signup/complete/${token}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCompleteSignupInviteProps = Omit<
  UseMutateProps<
    RestResponseUserInfo,
    Failure | Error,
    CompleteSignupInviteQueryParams,
    void,
    CompleteSignupInvitePathParams
  >,
  'path' | 'verb'
> &
  CompleteSignupInvitePathParams

export const useCompleteSignupInvite = ({ token, ...props }: UseCompleteSignupInviteProps) =>
  useMutate<
    RestResponseUserInfo,
    Failure | Error,
    CompleteSignupInviteQueryParams,
    void,
    CompleteSignupInvitePathParams
  >('PUT', (paramsInPath: CompleteSignupInvitePathParams) => `/signup/complete/${paramsInPath.token}`, {
    base: getConfig('ng/api'),
    pathParams: { token },
    ...props
  })

export const completeSignupInvitePromise = (
  {
    token,
    ...props
  }: MutateUsingFetchProps<
    RestResponseUserInfo,
    Failure | Error,
    CompleteSignupInviteQueryParams,
    void,
    CompleteSignupInvitePathParams
  > & { token: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseUserInfo,
    Failure | Error,
    CompleteSignupInviteQueryParams,
    void,
    CompleteSignupInvitePathParams
  >('PUT', getConfig('ng/api'), `/signup/complete/${token}`, props, signal)

export interface MarketplaceSignupQueryParams {
  inviteId?: string
  marketPlaceToken?: string
}

export type MarketplaceSignupProps = Omit<
  MutateProps<RestResponseUserInfo, Failure | Error, MarketplaceSignupQueryParams, SignupDTORequestBody, void>,
  'path' | 'verb'
>

export const MarketplaceSignup = (props: MarketplaceSignupProps) => (
  <Mutate<RestResponseUserInfo, Failure | Error, MarketplaceSignupQueryParams, SignupDTORequestBody, void>
    verb="POST"
    path={`/signup/marketplace`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseMarketplaceSignupProps = Omit<
  UseMutateProps<RestResponseUserInfo, Failure | Error, MarketplaceSignupQueryParams, SignupDTORequestBody, void>,
  'path' | 'verb'
>

export const useMarketplaceSignup = (props: UseMarketplaceSignupProps) =>
  useMutate<RestResponseUserInfo, Failure | Error, MarketplaceSignupQueryParams, SignupDTORequestBody, void>(
    'POST',
    `/signup/marketplace`,
    { base: getConfig('ng/api'), ...props }
  )

export const marketplaceSignupPromise = (
  props: MutateUsingFetchProps<
    RestResponseUserInfo,
    Failure | Error,
    MarketplaceSignupQueryParams,
    SignupDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseUserInfo, Failure | Error, MarketplaceSignupQueryParams, SignupDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/signup/marketplace`,
    props,
    signal
  )

export interface SignupOAuthQueryParams {
  accountId?: string
}

export type SignupOAuthProps = Omit<
  MutateProps<RestResponseUserInfo, Failure | Error, SignupOAuthQueryParams, OAuthSignupDTO, void>,
  'path' | 'verb'
>

export const SignupOAuth = (props: SignupOAuthProps) => (
  <Mutate<RestResponseUserInfo, Failure | Error, SignupOAuthQueryParams, OAuthSignupDTO, void>
    verb="POST"
    path={`/signup/oauth`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSignupOAuthProps = Omit<
  UseMutateProps<RestResponseUserInfo, Failure | Error, SignupOAuthQueryParams, OAuthSignupDTO, void>,
  'path' | 'verb'
>

export const useSignupOAuth = (props: UseSignupOAuthProps) =>
  useMutate<RestResponseUserInfo, Failure | Error, SignupOAuthQueryParams, OAuthSignupDTO, void>(
    'POST',
    `/signup/oauth`,
    { base: getConfig('ng/api'), ...props }
  )

export const signupOAuthPromise = (
  props: MutateUsingFetchProps<RestResponseUserInfo, Failure | Error, SignupOAuthQueryParams, OAuthSignupDTO, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseUserInfo, Failure | Error, SignupOAuthQueryParams, OAuthSignupDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/signup/oauth`,
    props,
    signal
  )

export interface ResendVerifyEmailQueryParams {
  email: string
}

export type ResendVerifyEmailProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, ResendVerifyEmailQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Resend user verification email
 */
export const ResendVerifyEmail = (props: ResendVerifyEmailProps) => (
  <Mutate<ResponseBoolean, Failure | Error, ResendVerifyEmailQueryParams, void, void>
    verb="POST"
    path={`/signup/verify-notification`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseResendVerifyEmailProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, ResendVerifyEmailQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Resend user verification email
 */
export const useResendVerifyEmail = (props: UseResendVerifyEmailProps) =>
  useMutate<ResponseBoolean, Failure | Error, ResendVerifyEmailQueryParams, void, void>(
    'POST',
    `/signup/verify-notification`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Resend user verification email
 */
export const resendVerifyEmailPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, ResendVerifyEmailQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, ResendVerifyEmailQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/signup/verify-notification`,
    props,
    signal
  )

export interface VerifyTokenPathParams {
  token: string
}

export type VerifyTokenProps = Omit<
  MutateProps<RestResponseVerifyTokenResponseDTO, Failure | Error, void, void, VerifyTokenPathParams>,
  'path' | 'verb'
> &
  VerifyTokenPathParams

export const VerifyToken = ({ token, ...props }: VerifyTokenProps) => (
  <Mutate<RestResponseVerifyTokenResponseDTO, Failure | Error, void, void, VerifyTokenPathParams>
    verb="POST"
    path={`/signup/verify/${token}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseVerifyTokenProps = Omit<
  UseMutateProps<RestResponseVerifyTokenResponseDTO, Failure | Error, void, void, VerifyTokenPathParams>,
  'path' | 'verb'
> &
  VerifyTokenPathParams

export const useVerifyToken = ({ token, ...props }: UseVerifyTokenProps) =>
  useMutate<RestResponseVerifyTokenResponseDTO, Failure | Error, void, void, VerifyTokenPathParams>(
    'POST',
    (paramsInPath: VerifyTokenPathParams) => `/signup/verify/${paramsInPath.token}`,
    { base: getConfig('ng/api'), pathParams: { token }, ...props }
  )

export const verifyTokenPromise = (
  {
    token,
    ...props
  }: MutateUsingFetchProps<RestResponseVerifyTokenResponseDTO, Failure | Error, void, void, VerifyTokenPathParams> & {
    token: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseVerifyTokenResponseDTO, Failure | Error, void, void, VerifyTokenPathParams>(
    'POST',
    getConfig('ng/api'),
    `/signup/verify/${token}`,
    props,
    signal
  )

export interface GetSmtpConfigQueryParams {
  accountId?: string
}

export type GetSmtpConfigProps = Omit<
  GetProps<ResponseNgSmtpDTO, Failure | Error, GetSmtpConfigQueryParams, void>,
  'path'
>

/**
 * Gets Smtp config by accountId
 */
export const GetSmtpConfig = (props: GetSmtpConfigProps) => (
  <Get<ResponseNgSmtpDTO, Failure | Error, GetSmtpConfigQueryParams, void>
    path={`/smtpConfig`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSmtpConfigProps = Omit<
  UseGetProps<ResponseNgSmtpDTO, Failure | Error, GetSmtpConfigQueryParams, void>,
  'path'
>

/**
 * Gets Smtp config by accountId
 */
export const useGetSmtpConfig = (props: UseGetSmtpConfigProps) =>
  useGet<ResponseNgSmtpDTO, Failure | Error, GetSmtpConfigQueryParams, void>(`/smtpConfig`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Smtp config by accountId
 */
export const getSmtpConfigPromise = (
  props: GetUsingFetchProps<ResponseNgSmtpDTO, Failure | Error, GetSmtpConfigQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNgSmtpDTO, Failure | Error, GetSmtpConfigQueryParams, void>(
    getConfig('ng/api'),
    `/smtpConfig`,
    props,
    signal
  )

export interface CreateSmtpConfigQueryParams {
  accountIdentifier: string
}

export type CreateSmtpConfigProps = Omit<
  MutateProps<ResponseNgSmtpDTO, Failure | Error, CreateSmtpConfigQueryParams, NgSmtpDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create SMTP config
 */
export const CreateSmtpConfig = (props: CreateSmtpConfigProps) => (
  <Mutate<ResponseNgSmtpDTO, Failure | Error, CreateSmtpConfigQueryParams, NgSmtpDTORequestBody, void>
    verb="POST"
    path={`/smtpConfig`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateSmtpConfigProps = Omit<
  UseMutateProps<ResponseNgSmtpDTO, Failure | Error, CreateSmtpConfigQueryParams, NgSmtpDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create SMTP config
 */
export const useCreateSmtpConfig = (props: UseCreateSmtpConfigProps) =>
  useMutate<ResponseNgSmtpDTO, Failure | Error, CreateSmtpConfigQueryParams, NgSmtpDTORequestBody, void>(
    'POST',
    `/smtpConfig`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create SMTP config
 */
export const createSmtpConfigPromise = (
  props: MutateUsingFetchProps<
    ResponseNgSmtpDTO,
    Failure | Error,
    CreateSmtpConfigQueryParams,
    NgSmtpDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseNgSmtpDTO, Failure | Error, CreateSmtpConfigQueryParams, NgSmtpDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/smtpConfig`,
    props,
    signal
  )

export interface UpdateSmtpQueryParams {
  accountIdentifier: string
}

export type UpdateSmtpProps = Omit<
  MutateProps<ResponseNgSmtpDTO, Failure | Error, UpdateSmtpQueryParams, NgSmtpDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update SmtpConfig
 */
export const UpdateSmtp = (props: UpdateSmtpProps) => (
  <Mutate<ResponseNgSmtpDTO, Failure | Error, UpdateSmtpQueryParams, NgSmtpDTORequestBody, void>
    verb="PUT"
    path={`/smtpConfig`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateSmtpProps = Omit<
  UseMutateProps<ResponseNgSmtpDTO, Failure | Error, UpdateSmtpQueryParams, NgSmtpDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update SmtpConfig
 */
export const useUpdateSmtp = (props: UseUpdateSmtpProps) =>
  useMutate<ResponseNgSmtpDTO, Failure | Error, UpdateSmtpQueryParams, NgSmtpDTORequestBody, void>(
    'PUT',
    `/smtpConfig`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update SmtpConfig
 */
export const updateSmtpPromise = (
  props: MutateUsingFetchProps<ResponseNgSmtpDTO, Failure | Error, UpdateSmtpQueryParams, NgSmtpDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseNgSmtpDTO, Failure | Error, UpdateSmtpQueryParams, NgSmtpDTORequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/smtpConfig`,
    props,
    signal
  )

export interface ValidateConnectivityQueryParams {
  identifier: string
  accountId: string
  to: string
  subject: string
  body: string
}

export type ValidateConnectivityProps = Omit<
  MutateProps<ResponseValidationResultDTO, Failure | Error, ValidateConnectivityQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Tests the connectivity
 */
export const ValidateConnectivity = (props: ValidateConnectivityProps) => (
  <Mutate<ResponseValidationResultDTO, Failure | Error, ValidateConnectivityQueryParams, void, void>
    verb="POST"
    path={`/smtpConfig/validate-connectivity`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateConnectivityProps = Omit<
  UseMutateProps<ResponseValidationResultDTO, Failure | Error, ValidateConnectivityQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Tests the connectivity
 */
export const useValidateConnectivity = (props: UseValidateConnectivityProps) =>
  useMutate<ResponseValidationResultDTO, Failure | Error, ValidateConnectivityQueryParams, void, void>(
    'POST',
    `/smtpConfig/validate-connectivity`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Tests the connectivity
 */
export const validateConnectivityPromise = (
  props: MutateUsingFetchProps<
    ResponseValidationResultDTO,
    Failure | Error,
    ValidateConnectivityQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseValidationResultDTO, Failure | Error, ValidateConnectivityQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/smtpConfig/validate-connectivity`,
    props,
    signal
  )

export interface ValidateNameQueryParams {
  name?: string
  accountId?: string
}

export type ValidateNameProps = Omit<
  MutateProps<ResponseValidationResultDTO, Failure | Error, ValidateNameQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Checks whether other connectors exist with the same name
 */
export const ValidateName = (props: ValidateNameProps) => (
  <Mutate<ResponseValidationResultDTO, Failure | Error, ValidateNameQueryParams, void, void>
    verb="POST"
    path={`/smtpConfig/validateName`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateNameProps = Omit<
  UseMutateProps<ResponseValidationResultDTO, Failure | Error, ValidateNameQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Checks whether other connectors exist with the same name
 */
export const useValidateName = (props: UseValidateNameProps) =>
  useMutate<ResponseValidationResultDTO, Failure | Error, ValidateNameQueryParams, void, void>(
    'POST',
    `/smtpConfig/validateName`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Checks whether other connectors exist with the same name
 */
export const validateNamePromise = (
  props: MutateUsingFetchProps<ResponseValidationResultDTO, Failure | Error, ValidateNameQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseValidationResultDTO, Failure | Error, ValidateNameQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/smtpConfig/validateName`,
    props,
    signal
  )

export interface DeleteSmtpConfigQueryParams {
  accountIdentifier: string
}

export type DeleteSmtpConfigProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteSmtpConfigQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete Smtp Config
 */
export const DeleteSmtpConfig = (props: DeleteSmtpConfigProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteSmtpConfigQueryParams, string, void>
    verb="DELETE"
    path={`/smtpConfig`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSmtpConfigProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteSmtpConfigQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete Smtp Config
 */
export const useDeleteSmtpConfig = (props: UseDeleteSmtpConfigProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteSmtpConfigQueryParams, string, void>('DELETE', `/smtpConfig`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete Smtp Config
 */
export const deleteSmtpConfigPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteSmtpConfigQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteSmtpConfigQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/smtpConfig`,
    props,
    signal
  )

export interface GetSourceCodeManagersQueryParams {
  accountIdentifier: string
}

export type GetSourceCodeManagersProps = Omit<
  GetProps<ResponseListSourceCodeManagerDTO, Failure | Error, GetSourceCodeManagersQueryParams, void>,
  'path'
>

/**
 * get source code manager information
 */
export const GetSourceCodeManagers = (props: GetSourceCodeManagersProps) => (
  <Get<ResponseListSourceCodeManagerDTO, Failure | Error, GetSourceCodeManagersQueryParams, void>
    path={`/source-code-manager`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSourceCodeManagersProps = Omit<
  UseGetProps<ResponseListSourceCodeManagerDTO, Failure | Error, GetSourceCodeManagersQueryParams, void>,
  'path'
>

/**
 * get source code manager information
 */
export const useGetSourceCodeManagers = (props: UseGetSourceCodeManagersProps) =>
  useGet<ResponseListSourceCodeManagerDTO, Failure | Error, GetSourceCodeManagersQueryParams, void>(
    `/source-code-manager`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * get source code manager information
 */
export const getSourceCodeManagersPromise = (
  props: GetUsingFetchProps<ResponseListSourceCodeManagerDTO, Failure | Error, GetSourceCodeManagersQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListSourceCodeManagerDTO, Failure | Error, GetSourceCodeManagersQueryParams, void>(
    getConfig('ng/api'),
    `/source-code-manager`,
    props,
    signal
  )

export type SaveSourceCodeManagersProps = Omit<
  MutateProps<ResponseSourceCodeManagerDTO, Failure | Error, void, SourceCodeManagerDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * save source code manager
 */
export const SaveSourceCodeManagers = (props: SaveSourceCodeManagersProps) => (
  <Mutate<ResponseSourceCodeManagerDTO, Failure | Error, void, SourceCodeManagerDTORequestBody, void>
    verb="POST"
    path={`/source-code-manager`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSaveSourceCodeManagersProps = Omit<
  UseMutateProps<ResponseSourceCodeManagerDTO, Failure | Error, void, SourceCodeManagerDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * save source code manager
 */
export const useSaveSourceCodeManagers = (props: UseSaveSourceCodeManagersProps) =>
  useMutate<ResponseSourceCodeManagerDTO, Failure | Error, void, SourceCodeManagerDTORequestBody, void>(
    'POST',
    `/source-code-manager`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * save source code manager
 */
export const saveSourceCodeManagersPromise = (
  props: MutateUsingFetchProps<
    ResponseSourceCodeManagerDTO,
    Failure | Error,
    void,
    SourceCodeManagerDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseSourceCodeManagerDTO, Failure | Error, void, SourceCodeManagerDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/source-code-manager`,
    props,
    signal
  )

export interface DeleteSourceCodeManagersQueryParams {
  accountIdentifier: string
}

export type DeleteSourceCodeManagersProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteSourceCodeManagersQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * delete source code manager
 */
export const DeleteSourceCodeManagers = (props: DeleteSourceCodeManagersProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteSourceCodeManagersQueryParams, string, void>
    verb="DELETE"
    path={`/source-code-manager`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSourceCodeManagersProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteSourceCodeManagersQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * delete source code manager
 */
export const useDeleteSourceCodeManagers = (props: UseDeleteSourceCodeManagersProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteSourceCodeManagersQueryParams, string, void>(
    'DELETE',
    `/source-code-manager`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * delete source code manager
 */
export const deleteSourceCodeManagersPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteSourceCodeManagersQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteSourceCodeManagersQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/source-code-manager`,
    props,
    signal
  )

export interface UpdateSourceCodeManagersPathParams {
  identifier: string
}

export type UpdateSourceCodeManagersProps = Omit<
  MutateProps<
    ResponseSourceCodeManagerDTO,
    Failure | Error,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  >,
  'path' | 'verb'
> &
  UpdateSourceCodeManagersPathParams

/**
 * update source code manager
 */
export const UpdateSourceCodeManagers = ({ identifier, ...props }: UpdateSourceCodeManagersProps) => (
  <Mutate<
    ResponseSourceCodeManagerDTO,
    Failure | Error,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  >
    verb="PUT"
    path={`/source-code-manager/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateSourceCodeManagersProps = Omit<
  UseMutateProps<
    ResponseSourceCodeManagerDTO,
    Failure | Error,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  >,
  'path' | 'verb'
> &
  UpdateSourceCodeManagersPathParams

/**
 * update source code manager
 */
export const useUpdateSourceCodeManagers = ({ identifier, ...props }: UseUpdateSourceCodeManagersProps) =>
  useMutate<
    ResponseSourceCodeManagerDTO,
    Failure | Error,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  >('PUT', (paramsInPath: UpdateSourceCodeManagersPathParams) => `/source-code-manager/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * update source code manager
 */
export const updateSourceCodeManagersPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseSourceCodeManagerDTO,
    Failure | Error,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSourceCodeManagerDTO,
    Failure | Error,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  >('PUT', getConfig('ng/api'), `/source-code-manager/${identifier}`, props, signal)

export interface ListSubscriptionsQueryParams {
  accountIdentifier: string
}

export type ListSubscriptionsProps = Omit<
  GetProps<ResponseListSubscriptionDetailDTO, Failure | Error, ListSubscriptionsQueryParams, void>,
  'path'
>

/**
 * Lists the subscriptions
 */
export const ListSubscriptions = (props: ListSubscriptionsProps) => (
  <Get<ResponseListSubscriptionDetailDTO, Failure | Error, ListSubscriptionsQueryParams, void>
    path={`/subscriptions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListSubscriptionsProps = Omit<
  UseGetProps<ResponseListSubscriptionDetailDTO, Failure | Error, ListSubscriptionsQueryParams, void>,
  'path'
>

/**
 * Lists the subscriptions
 */
export const useListSubscriptions = (props: UseListSubscriptionsProps) =>
  useGet<ResponseListSubscriptionDetailDTO, Failure | Error, ListSubscriptionsQueryParams, void>(`/subscriptions`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Lists the subscriptions
 */
export const listSubscriptionsPromise = (
  props: GetUsingFetchProps<ResponseListSubscriptionDetailDTO, Failure | Error, ListSubscriptionsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListSubscriptionDetailDTO, Failure | Error, ListSubscriptionsQueryParams, void>(
    getConfig('ng/api'),
    `/subscriptions`,
    props,
    signal
  )

export interface CreateSubscriptionQueryParams {
  accountIdentifier: string
}

export type CreateSubscriptionProps = Omit<
  MutateProps<ResponseSubscriptionDetailDTO, Failure | Error, CreateSubscriptionQueryParams, SubscriptionRequest, void>,
  'path' | 'verb'
>

/**
 * Creates a subscription
 */
export const CreateSubscription = (props: CreateSubscriptionProps) => (
  <Mutate<ResponseSubscriptionDetailDTO, Failure | Error, CreateSubscriptionQueryParams, SubscriptionRequest, void>
    verb="POST"
    path={`/subscriptions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateSubscriptionProps = Omit<
  UseMutateProps<
    ResponseSubscriptionDetailDTO,
    Failure | Error,
    CreateSubscriptionQueryParams,
    SubscriptionRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates a subscription
 */
export const useCreateSubscription = (props: UseCreateSubscriptionProps) =>
  useMutate<ResponseSubscriptionDetailDTO, Failure | Error, CreateSubscriptionQueryParams, SubscriptionRequest, void>(
    'POST',
    `/subscriptions`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Creates a subscription
 */
export const createSubscriptionPromise = (
  props: MutateUsingFetchProps<
    ResponseSubscriptionDetailDTO,
    Failure | Error,
    CreateSubscriptionQueryParams,
    SubscriptionRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSubscriptionDetailDTO,
    Failure | Error,
    CreateSubscriptionQueryParams,
    SubscriptionRequest,
    void
  >('POST', getConfig('ng/api'), `/subscriptions`, props, signal)

export interface UpdateBillingQueryParams {
  accountIdentifier: string
}

export type UpdateBillingProps = Omit<
  MutateProps<ResponseCustomerDetailDTO, Failure | Error, UpdateBillingQueryParams, StripeBillingDTO, void>,
  'path' | 'verb'
>

/**
 * Updates the customer's billing information
 */
export const UpdateBilling = (props: UpdateBillingProps) => (
  <Mutate<ResponseCustomerDetailDTO, Failure | Error, UpdateBillingQueryParams, StripeBillingDTO, void>
    verb="PUT"
    path={`/subscriptions/billing`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateBillingProps = Omit<
  UseMutateProps<ResponseCustomerDetailDTO, Failure | Error, UpdateBillingQueryParams, StripeBillingDTO, void>,
  'path' | 'verb'
>

/**
 * Updates the customer's billing information
 */
export const useUpdateBilling = (props: UseUpdateBillingProps) =>
  useMutate<ResponseCustomerDetailDTO, Failure | Error, UpdateBillingQueryParams, StripeBillingDTO, void>(
    'PUT',
    `/subscriptions/billing`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Updates the customer's billing information
 */
export const updateBillingPromise = (
  props: MutateUsingFetchProps<
    ResponseCustomerDetailDTO,
    Failure | Error,
    UpdateBillingQueryParams,
    StripeBillingDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseCustomerDetailDTO, Failure | Error, UpdateBillingQueryParams, StripeBillingDTO, void>(
    'PUT',
    getConfig('ng/api'),
    `/subscriptions/billing`,
    props,
    signal
  )

export interface CreateClientSecretQueryParams {
  accountIdentifier: string
  billingEmail: string
}

export type CreateClientSecretProps = Omit<
  MutateProps<ResponseString, Failure | Error, CreateClientSecretQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Creates a client secret for the Stripe customer
 */
export const CreateClientSecret = (props: CreateClientSecretProps) => (
  <Mutate<ResponseString, Failure | Error, CreateClientSecretQueryParams, void, void>
    verb="POST"
    path={`/subscriptions/client-secret`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateClientSecretProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, CreateClientSecretQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Creates a client secret for the Stripe customer
 */
export const useCreateClientSecret = (props: UseCreateClientSecretProps) =>
  useMutate<ResponseString, Failure | Error, CreateClientSecretQueryParams, void, void>(
    'POST',
    `/subscriptions/client-secret`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Creates a client secret for the Stripe customer
 */
export const createClientSecretPromise = (
  props: MutateUsingFetchProps<ResponseString, Failure | Error, CreateClientSecretQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, CreateClientSecretQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/subscriptions/client-secret`,
    props,
    signal
  )

export interface RetrieveCustomerQueryParams {
  accountIdentifier: string
}

export type RetrieveCustomerProps = Omit<
  GetProps<ResponseCustomerDetailDTO, Failure | Error, RetrieveCustomerQueryParams, void>,
  'path'
>

/**
 * Retrieves the customer
 */
export const RetrieveCustomer = (props: RetrieveCustomerProps) => (
  <Get<ResponseCustomerDetailDTO, Failure | Error, RetrieveCustomerQueryParams, void>
    path={`/subscriptions/customer`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRetrieveCustomerProps = Omit<
  UseGetProps<ResponseCustomerDetailDTO, Failure | Error, RetrieveCustomerQueryParams, void>,
  'path'
>

/**
 * Retrieves the customer
 */
export const useRetrieveCustomer = (props: UseRetrieveCustomerProps) =>
  useGet<ResponseCustomerDetailDTO, Failure | Error, RetrieveCustomerQueryParams, void>(`/subscriptions/customer`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Retrieves the customer
 */
export const retrieveCustomerPromise = (
  props: GetUsingFetchProps<ResponseCustomerDetailDTO, Failure | Error, RetrieveCustomerQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCustomerDetailDTO, Failure | Error, RetrieveCustomerQueryParams, void>(
    getConfig('ng/api'),
    `/subscriptions/customer`,
    props,
    signal
  )

export interface UpdateCustomerQueryParams {
  accountIdentifier: string
}

export type UpdateCustomerProps = Omit<
  MutateProps<ResponseCustomerDetailDTO, Failure | Error, UpdateCustomerQueryParams, CustomerDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Updates the customer
 */
export const UpdateCustomer = (props: UpdateCustomerProps) => (
  <Mutate<ResponseCustomerDetailDTO, Failure | Error, UpdateCustomerQueryParams, CustomerDTORequestBody, void>
    verb="PUT"
    path={`/subscriptions/customer`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateCustomerProps = Omit<
  UseMutateProps<ResponseCustomerDetailDTO, Failure | Error, UpdateCustomerQueryParams, CustomerDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Updates the customer
 */
export const useUpdateCustomer = (props: UseUpdateCustomerProps) =>
  useMutate<ResponseCustomerDetailDTO, Failure | Error, UpdateCustomerQueryParams, CustomerDTORequestBody, void>(
    'PUT',
    `/subscriptions/customer`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Updates the customer
 */
export const updateCustomerPromise = (
  props: MutateUsingFetchProps<
    ResponseCustomerDetailDTO,
    Failure | Error,
    UpdateCustomerQueryParams,
    CustomerDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseCustomerDetailDTO, Failure | Error, UpdateCustomerQueryParams, CustomerDTORequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/subscriptions/customer`,
    props,
    signal
  )

export interface CreateCustomerQueryParams {
  accountIdentifier: string
}

export type CreateCustomerProps = Omit<
  MutateProps<ResponseCustomerDetailDTO, Failure | Error, CreateCustomerQueryParams, CustomerDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Creates the customer
 */
export const CreateCustomer = (props: CreateCustomerProps) => (
  <Mutate<ResponseCustomerDetailDTO, Failure | Error, CreateCustomerQueryParams, CustomerDTORequestBody, void>
    verb="POST"
    path={`/subscriptions/customers`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateCustomerProps = Omit<
  UseMutateProps<ResponseCustomerDetailDTO, Failure | Error, CreateCustomerQueryParams, CustomerDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Creates the customer
 */
export const useCreateCustomer = (props: UseCreateCustomerProps) =>
  useMutate<ResponseCustomerDetailDTO, Failure | Error, CreateCustomerQueryParams, CustomerDTORequestBody, void>(
    'POST',
    `/subscriptions/customers`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Creates the customer
 */
export const createCustomerPromise = (
  props: MutateUsingFetchProps<
    ResponseCustomerDetailDTO,
    Failure | Error,
    CreateCustomerQueryParams,
    CustomerDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseCustomerDetailDTO, Failure | Error, CreateCustomerQueryParams, CustomerDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/subscriptions/customers`,
    props,
    signal
  )

export interface CheckSubscriptionExistsQueryParams {
  subscriptionId: string
}

export type CheckSubscriptionExistsProps = Omit<
  GetProps<RestResponseBoolean, Failure | Error, CheckSubscriptionExistsQueryParams, void>,
  'path'
>

export const CheckSubscriptionExists = (props: CheckSubscriptionExistsProps) => (
  <Get<RestResponseBoolean, Failure | Error, CheckSubscriptionExistsQueryParams, void>
    path={`/subscriptions/exists`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCheckSubscriptionExistsProps = Omit<
  UseGetProps<RestResponseBoolean, Failure | Error, CheckSubscriptionExistsQueryParams, void>,
  'path'
>

export const useCheckSubscriptionExists = (props: UseCheckSubscriptionExistsProps) =>
  useGet<RestResponseBoolean, Failure | Error, CheckSubscriptionExistsQueryParams, void>(`/subscriptions/exists`, {
    base: getConfig('ng/api'),
    ...props
  })

export const checkSubscriptionExistsPromise = (
  props: GetUsingFetchProps<RestResponseBoolean, Failure | Error, CheckSubscriptionExistsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseBoolean, Failure | Error, CheckSubscriptionExistsQueryParams, void>(
    getConfig('ng/api'),
    `/subscriptions/exists`,
    props,
    signal
  )

export interface RetrieveUpcomingInvoiceQueryParams {
  accountIdentifier: string
}

export type RetrieveUpcomingInvoiceProps = Omit<
  MutateProps<
    ResponseInvoiceDetailDTO,
    Failure | Error,
    RetrieveUpcomingInvoiceQueryParams,
    SubscriptionDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Retrieves the upcoming Invoice details
 */
export const RetrieveUpcomingInvoice = (props: RetrieveUpcomingInvoiceProps) => (
  <Mutate<
    ResponseInvoiceDetailDTO,
    Failure | Error,
    RetrieveUpcomingInvoiceQueryParams,
    SubscriptionDTORequestBody,
    void
  >
    verb="POST"
    path={`/subscriptions/invoices/preview`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRetrieveUpcomingInvoiceProps = Omit<
  UseMutateProps<
    ResponseInvoiceDetailDTO,
    Failure | Error,
    RetrieveUpcomingInvoiceQueryParams,
    SubscriptionDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Retrieves the upcoming Invoice details
 */
export const useRetrieveUpcomingInvoice = (props: UseRetrieveUpcomingInvoiceProps) =>
  useMutate<
    ResponseInvoiceDetailDTO,
    Failure | Error,
    RetrieveUpcomingInvoiceQueryParams,
    SubscriptionDTORequestBody,
    void
  >('POST', `/subscriptions/invoices/preview`, { base: getConfig('ng/api'), ...props })

/**
 * Retrieves the upcoming Invoice details
 */
export const retrieveUpcomingInvoicePromise = (
  props: MutateUsingFetchProps<
    ResponseInvoiceDetailDTO,
    Failure | Error,
    RetrieveUpcomingInvoiceQueryParams,
    SubscriptionDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInvoiceDetailDTO,
    Failure | Error,
    RetrieveUpcomingInvoiceQueryParams,
    SubscriptionDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/subscriptions/invoices/preview`, props, signal)

export interface PayInvoiceQueryParams {
  accountIdentifier: string
  invoiceId: string
}

export type PayInvoiceProps = Omit<
  MutateProps<RestResponseVoid, Failure | Error, PayInvoiceQueryParams, void, void>,
  'path' | 'verb'
>

export const PayInvoice = (props: PayInvoiceProps) => (
  <Mutate<RestResponseVoid, Failure | Error, PayInvoiceQueryParams, void, void>
    verb="POST"
    path={`/subscriptions/pay_invoice`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePayInvoiceProps = Omit<
  UseMutateProps<RestResponseVoid, Failure | Error, PayInvoiceQueryParams, void, void>,
  'path' | 'verb'
>

export const usePayInvoice = (props: UsePayInvoiceProps) =>
  useMutate<RestResponseVoid, Failure | Error, PayInvoiceQueryParams, void, void>(
    'POST',
    `/subscriptions/pay_invoice`,
    { base: getConfig('ng/api'), ...props }
  )

export const payInvoicePromise = (
  props: MutateUsingFetchProps<RestResponseVoid, Failure | Error, PayInvoiceQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseVoid, Failure | Error, PayInvoiceQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/subscriptions/pay_invoice`,
    props,
    signal
  )

export interface ListPaymentMethodsQueryParams {
  accountIdentifier: string
}

export type ListPaymentMethodsProps = Omit<
  GetProps<ResponsePaymentMethodCollectionDTO, Failure | Error, ListPaymentMethodsQueryParams, void>,
  'path'
>

/**
 * Lists all payment methods for the customer
 */
export const ListPaymentMethods = (props: ListPaymentMethodsProps) => (
  <Get<ResponsePaymentMethodCollectionDTO, Failure | Error, ListPaymentMethodsQueryParams, void>
    path={`/subscriptions/payment_methods`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListPaymentMethodsProps = Omit<
  UseGetProps<ResponsePaymentMethodCollectionDTO, Failure | Error, ListPaymentMethodsQueryParams, void>,
  'path'
>

/**
 * Lists all payment methods for the customer
 */
export const useListPaymentMethods = (props: UseListPaymentMethodsProps) =>
  useGet<ResponsePaymentMethodCollectionDTO, Failure | Error, ListPaymentMethodsQueryParams, void>(
    `/subscriptions/payment_methods`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Lists all payment methods for the customer
 */
export const listPaymentMethodsPromise = (
  props: GetUsingFetchProps<ResponsePaymentMethodCollectionDTO, Failure | Error, ListPaymentMethodsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePaymentMethodCollectionDTO, Failure | Error, ListPaymentMethodsQueryParams, void>(
    getConfig('ng/api'),
    `/subscriptions/payment_methods`,
    props,
    signal
  )

export interface RetrieveProductPricesQueryParams {
  accountIdentifier: string
  moduleType:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
}

export type RetrieveProductPricesProps = Omit<
  GetProps<ResponsePriceCollectionDTO, Failure | Error, RetrieveProductPricesQueryParams, void>,
  'path'
>

/**
 * Retrieves product prices
 */
export const RetrieveProductPrices = (props: RetrieveProductPricesProps) => (
  <Get<ResponsePriceCollectionDTO, Failure | Error, RetrieveProductPricesQueryParams, void>
    path={`/subscriptions/prices`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRetrieveProductPricesProps = Omit<
  UseGetProps<ResponsePriceCollectionDTO, Failure | Error, RetrieveProductPricesQueryParams, void>,
  'path'
>

/**
 * Retrieves product prices
 */
export const useRetrieveProductPrices = (props: UseRetrieveProductPricesProps) =>
  useGet<ResponsePriceCollectionDTO, Failure | Error, RetrieveProductPricesQueryParams, void>(`/subscriptions/prices`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Retrieves product prices
 */
export const retrieveProductPricesPromise = (
  props: GetUsingFetchProps<ResponsePriceCollectionDTO, Failure | Error, RetrieveProductPricesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePriceCollectionDTO, Failure | Error, RetrieveProductPricesQueryParams, void>(
    getConfig('ng/api'),
    `/subscriptions/prices`,
    props,
    signal
  )

export interface RetrieveRecommendationQueryParams {
  accountIdentifier: string
  numberOfMAUs: number
  numberOfUsers: number
}

export type RetrieveRecommendationProps = Omit<
  GetProps<ResponseEnumMapUsageKeyLong, Failure | Error, RetrieveRecommendationQueryParams, void>,
  'path'
>

/**
 * Retrieves subscription recommendation
 */
export const RetrieveRecommendation = (props: RetrieveRecommendationProps) => (
  <Get<ResponseEnumMapUsageKeyLong, Failure | Error, RetrieveRecommendationQueryParams, void>
    path={`/subscriptions/recommendation`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRetrieveRecommendationProps = Omit<
  UseGetProps<ResponseEnumMapUsageKeyLong, Failure | Error, RetrieveRecommendationQueryParams, void>,
  'path'
>

/**
 * Retrieves subscription recommendation
 */
export const useRetrieveRecommendation = (props: UseRetrieveRecommendationProps) =>
  useGet<ResponseEnumMapUsageKeyLong, Failure | Error, RetrieveRecommendationQueryParams, void>(
    `/subscriptions/recommendation`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Retrieves subscription recommendation
 */
export const retrieveRecommendationPromise = (
  props: GetUsingFetchProps<ResponseEnumMapUsageKeyLong, Failure | Error, RetrieveRecommendationQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEnumMapUsageKeyLong, Failure | Error, RetrieveRecommendationQueryParams, void>(
    getConfig('ng/api'),
    `/subscriptions/recommendation`,
    props,
    signal
  )

export interface RetrieveRecommendationRcQueryParams {
  accountIdentifier: string
}

export type RetrieveRecommendationRcProps = Omit<
  MutateProps<
    ResponseMapUsageKeyLong,
    Failure | Error,
    RetrieveRecommendationRcQueryParams,
    RecommendationRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Retrieves subscription recommendation
 */
export const RetrieveRecommendationRc = (props: RetrieveRecommendationRcProps) => (
  <Mutate<ResponseMapUsageKeyLong, Failure | Error, RetrieveRecommendationRcQueryParams, RecommendationRequest, void>
    verb="POST"
    path={`/subscriptions/recommendation-rc`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRetrieveRecommendationRcProps = Omit<
  UseMutateProps<
    ResponseMapUsageKeyLong,
    Failure | Error,
    RetrieveRecommendationRcQueryParams,
    RecommendationRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Retrieves subscription recommendation
 */
export const useRetrieveRecommendationRc = (props: UseRetrieveRecommendationRcProps) =>
  useMutate<ResponseMapUsageKeyLong, Failure | Error, RetrieveRecommendationRcQueryParams, RecommendationRequest, void>(
    'POST',
    `/subscriptions/recommendation-rc`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Retrieves subscription recommendation
 */
export const retrieveRecommendationRcPromise = (
  props: MutateUsingFetchProps<
    ResponseMapUsageKeyLong,
    Failure | Error,
    RetrieveRecommendationRcQueryParams,
    RecommendationRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseMapUsageKeyLong,
    Failure | Error,
    RetrieveRecommendationRcQueryParams,
    RecommendationRequest,
    void
  >('POST', getConfig('ng/api'), `/subscriptions/recommendation-rc`, props, signal)

export type SyncStripeEventProps = Omit<
  MutateProps<
    RestResponseVoid,
    Failure | Error,
    void,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

export const SyncStripeEvent = (props: SyncStripeEventProps) => (
  <Mutate<RestResponseVoid, Failure | Error, void, GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody, void>
    verb="POST"
    path={`/subscriptions/sync_event`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSyncStripeEventProps = Omit<
  UseMutateProps<
    RestResponseVoid,
    Failure | Error,
    void,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

export const useSyncStripeEvent = (props: UseSyncStripeEventProps) =>
  useMutate<RestResponseVoid, Failure | Error, void, GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody, void>(
    'POST',
    `/subscriptions/sync_event`,
    { base: getConfig('ng/api'), ...props }
  )

export const syncStripeEventPromise = (
  props: MutateUsingFetchProps<
    RestResponseVoid,
    Failure | Error,
    void,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseVoid,
    Failure | Error,
    void,
    GetAzureSubscriptionsForAcrArtifactWithYamlBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/subscriptions/sync_event`, props, signal)

export interface CancelSubscriptionQueryParams {
  accountIdentifier: string
  moduleType:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
}

export type CancelSubscriptionProps = Omit<
  MutateProps<ResponseVoid, Failure | Error, CancelSubscriptionQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Cancel a subscription
 */
export const CancelSubscription = (props: CancelSubscriptionProps) => (
  <Mutate<ResponseVoid, Failure | Error, CancelSubscriptionQueryParams, string, void>
    verb="DELETE"
    path={`/subscriptions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCancelSubscriptionProps = Omit<
  UseMutateProps<ResponseVoid, Failure | Error, CancelSubscriptionQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Cancel a subscription
 */
export const useCancelSubscription = (props: UseCancelSubscriptionProps) =>
  useMutate<ResponseVoid, Failure | Error, CancelSubscriptionQueryParams, string, void>('DELETE', `/subscriptions`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Cancel a subscription
 */
export const cancelSubscriptionPromise = (
  props: MutateUsingFetchProps<ResponseVoid, Failure | Error, CancelSubscriptionQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseVoid, Failure | Error, CancelSubscriptionQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/subscriptions`,
    props,
    signal
  )

export interface RetrieveSubscriptionQueryParams {
  accountIdentifier: string
}

export interface RetrieveSubscriptionPathParams {
  subscriptionId: string
}

export type RetrieveSubscriptionProps = Omit<
  GetProps<
    ResponseSubscriptionDetailDTO,
    Failure | Error,
    RetrieveSubscriptionQueryParams,
    RetrieveSubscriptionPathParams
  >,
  'path'
> &
  RetrieveSubscriptionPathParams

/**
 * Retrieves a subscription
 */
export const RetrieveSubscription = ({ subscriptionId, ...props }: RetrieveSubscriptionProps) => (
  <Get<ResponseSubscriptionDetailDTO, Failure | Error, RetrieveSubscriptionQueryParams, RetrieveSubscriptionPathParams>
    path={`/subscriptions/${subscriptionId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRetrieveSubscriptionProps = Omit<
  UseGetProps<
    ResponseSubscriptionDetailDTO,
    Failure | Error,
    RetrieveSubscriptionQueryParams,
    RetrieveSubscriptionPathParams
  >,
  'path'
> &
  RetrieveSubscriptionPathParams

/**
 * Retrieves a subscription
 */
export const useRetrieveSubscription = ({ subscriptionId, ...props }: UseRetrieveSubscriptionProps) =>
  useGet<
    ResponseSubscriptionDetailDTO,
    Failure | Error,
    RetrieveSubscriptionQueryParams,
    RetrieveSubscriptionPathParams
  >((paramsInPath: RetrieveSubscriptionPathParams) => `/subscriptions/${paramsInPath.subscriptionId}`, {
    base: getConfig('ng/api'),
    pathParams: { subscriptionId },
    ...props
  })

/**
 * Retrieves a subscription
 */
export const retrieveSubscriptionPromise = (
  {
    subscriptionId,
    ...props
  }: GetUsingFetchProps<
    ResponseSubscriptionDetailDTO,
    Failure | Error,
    RetrieveSubscriptionQueryParams,
    RetrieveSubscriptionPathParams
  > & { subscriptionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseSubscriptionDetailDTO,
    Failure | Error,
    RetrieveSubscriptionQueryParams,
    RetrieveSubscriptionPathParams
  >(getConfig('ng/api'), `/subscriptions/${subscriptionId}`, props, signal)

export interface UpdateSubscriptionQueryParams {
  accountIdentifier: string
}

export interface UpdateSubscriptionPathParams {
  subscriptionId: string
}

export type UpdateSubscriptionProps = Omit<
  MutateProps<
    ResponseSubscriptionDetailDTO,
    Failure | Error,
    UpdateSubscriptionQueryParams,
    SubscriptionDTORequestBody,
    UpdateSubscriptionPathParams
  >,
  'path' | 'verb'
> &
  UpdateSubscriptionPathParams

/**
 * Updates a subscription
 */
export const UpdateSubscription = ({ subscriptionId, ...props }: UpdateSubscriptionProps) => (
  <Mutate<
    ResponseSubscriptionDetailDTO,
    Failure | Error,
    UpdateSubscriptionQueryParams,
    SubscriptionDTORequestBody,
    UpdateSubscriptionPathParams
  >
    verb="PUT"
    path={`/subscriptions/${subscriptionId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateSubscriptionProps = Omit<
  UseMutateProps<
    ResponseSubscriptionDetailDTO,
    Failure | Error,
    UpdateSubscriptionQueryParams,
    SubscriptionDTORequestBody,
    UpdateSubscriptionPathParams
  >,
  'path' | 'verb'
> &
  UpdateSubscriptionPathParams

/**
 * Updates a subscription
 */
export const useUpdateSubscription = ({ subscriptionId, ...props }: UseUpdateSubscriptionProps) =>
  useMutate<
    ResponseSubscriptionDetailDTO,
    Failure | Error,
    UpdateSubscriptionQueryParams,
    SubscriptionDTORequestBody,
    UpdateSubscriptionPathParams
  >('PUT', (paramsInPath: UpdateSubscriptionPathParams) => `/subscriptions/${paramsInPath.subscriptionId}`, {
    base: getConfig('ng/api'),
    pathParams: { subscriptionId },
    ...props
  })

/**
 * Updates a subscription
 */
export const updateSubscriptionPromise = (
  {
    subscriptionId,
    ...props
  }: MutateUsingFetchProps<
    ResponseSubscriptionDetailDTO,
    Failure | Error,
    UpdateSubscriptionQueryParams,
    SubscriptionDTORequestBody,
    UpdateSubscriptionPathParams
  > & { subscriptionId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSubscriptionDetailDTO,
    Failure | Error,
    UpdateSubscriptionQueryParams,
    SubscriptionDTORequestBody,
    UpdateSubscriptionPathParams
  >('PUT', getConfig('ng/api'), `/subscriptions/${subscriptionId}`, props, signal)

export interface GetTasOrganizationsQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  envId?: string
  infraDefinitionId?: string
}

export type GetTasOrganizationsProps = Omit<
  GetProps<ResponseListString, Failure | Error, GetTasOrganizationsQueryParams, void>,
  'path'
>

/**
 * Gets tas organizations
 */
export const GetTasOrganizations = (props: GetTasOrganizationsProps) => (
  <Get<ResponseListString, Failure | Error, GetTasOrganizationsQueryParams, void>
    path={`/tas/organizations`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTasOrganizationsProps = Omit<
  UseGetProps<ResponseListString, Failure | Error, GetTasOrganizationsQueryParams, void>,
  'path'
>

/**
 * Gets tas organizations
 */
export const useGetTasOrganizations = (props: UseGetTasOrganizationsProps) =>
  useGet<ResponseListString, Failure | Error, GetTasOrganizationsQueryParams, void>(`/tas/organizations`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets tas organizations
 */
export const getTasOrganizationsPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, GetTasOrganizationsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, GetTasOrganizationsQueryParams, void>(
    getConfig('ng/api'),
    `/tas/organizations`,
    props,
    signal
  )

export interface GetTasSpacesQueryParams {
  connectorRef: string
  organization: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetTasSpacesProps = Omit<
  GetProps<ResponseListString, Failure | Error, GetTasSpacesQueryParams, void>,
  'path'
>

/**
 * Gets tas spaces
 */
export const GetTasSpaces = (props: GetTasSpacesProps) => (
  <Get<ResponseListString, Failure | Error, GetTasSpacesQueryParams, void>
    path={`/tas/space`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTasSpacesProps = Omit<
  UseGetProps<ResponseListString, Failure | Error, GetTasSpacesQueryParams, void>,
  'path'
>

/**
 * Gets tas spaces
 */
export const useGetTasSpaces = (props: UseGetTasSpacesProps) =>
  useGet<ResponseListString, Failure | Error, GetTasSpacesQueryParams, void>(`/tas/space`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets tas spaces
 */
export const getTasSpacesPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, GetTasSpacesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, GetTasSpacesQueryParams, void>(
    getConfig('ng/api'),
    `/tas/space`,
    props,
    signal
  )

export interface GetTasSpacesV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  organization?: string
  envId: string
  infraDefinitionId: string
}

export type GetTasSpacesV2Props = Omit<
  GetProps<ResponseListString, Failure | Error, GetTasSpacesV2QueryParams, void>,
  'path'
>

/**
 * Gets tas spaces V2
 */
export const GetTasSpacesV2 = (props: GetTasSpacesV2Props) => (
  <Get<ResponseListString, Failure | Error, GetTasSpacesV2QueryParams, void>
    path={`/tas/v2/space`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTasSpacesV2Props = Omit<
  UseGetProps<ResponseListString, Failure | Error, GetTasSpacesV2QueryParams, void>,
  'path'
>

/**
 * Gets tas spaces V2
 */
export const useGetTasSpacesV2 = (props: UseGetTasSpacesV2Props) =>
  useGet<ResponseListString, Failure | Error, GetTasSpacesV2QueryParams, void>(`/tas/v2/space`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets tas spaces V2
 */
export const getTasSpacesV2Promise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, GetTasSpacesV2QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, GetTasSpacesV2QueryParams, void>(
    getConfig('ng/api'),
    `/tas/v2/space`,
    props,
    signal
  )

export interface GetTerraformCloudOrganizationsQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetTerraformCloudOrganizationsProps = Omit<
  GetProps<ResponseOrganizationsDTO, Failure | Error, GetTerraformCloudOrganizationsQueryParams, void>,
  'path'
>

/**
 * Gets terraform cloud organizations
 */
export const GetTerraformCloudOrganizations = (props: GetTerraformCloudOrganizationsProps) => (
  <Get<ResponseOrganizationsDTO, Failure | Error, GetTerraformCloudOrganizationsQueryParams, void>
    path={`/terraform-cloud/organizations`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTerraformCloudOrganizationsProps = Omit<
  UseGetProps<ResponseOrganizationsDTO, Failure | Error, GetTerraformCloudOrganizationsQueryParams, void>,
  'path'
>

/**
 * Gets terraform cloud organizations
 */
export const useGetTerraformCloudOrganizations = (props: UseGetTerraformCloudOrganizationsProps) =>
  useGet<ResponseOrganizationsDTO, Failure | Error, GetTerraformCloudOrganizationsQueryParams, void>(
    `/terraform-cloud/organizations`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets terraform cloud organizations
 */
export const getTerraformCloudOrganizationsPromise = (
  props: GetUsingFetchProps<ResponseOrganizationsDTO, Failure | Error, GetTerraformCloudOrganizationsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseOrganizationsDTO, Failure | Error, GetTerraformCloudOrganizationsQueryParams, void>(
    getConfig('ng/api'),
    `/terraform-cloud/organizations`,
    props,
    signal
  )

export interface GetTerraformCloudWorkspacesQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  organization: string
}

export type GetTerraformCloudWorkspacesProps = Omit<
  GetProps<ResponseWorkspacesDTO, Failure | Error, GetTerraformCloudWorkspacesQueryParams, void>,
  'path'
>

/**
 * Gets terraform cloud workspaces
 */
export const GetTerraformCloudWorkspaces = (props: GetTerraformCloudWorkspacesProps) => (
  <Get<ResponseWorkspacesDTO, Failure | Error, GetTerraformCloudWorkspacesQueryParams, void>
    path={`/terraform-cloud/workspaces`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTerraformCloudWorkspacesProps = Omit<
  UseGetProps<ResponseWorkspacesDTO, Failure | Error, GetTerraformCloudWorkspacesQueryParams, void>,
  'path'
>

/**
 * Gets terraform cloud workspaces
 */
export const useGetTerraformCloudWorkspaces = (props: UseGetTerraformCloudWorkspacesProps) =>
  useGet<ResponseWorkspacesDTO, Failure | Error, GetTerraformCloudWorkspacesQueryParams, void>(
    `/terraform-cloud/workspaces`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets terraform cloud workspaces
 */
export const getTerraformCloudWorkspacesPromise = (
  props: GetUsingFetchProps<ResponseWorkspacesDTO, Failure | Error, GetTerraformCloudWorkspacesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseWorkspacesDTO, Failure | Error, GetTerraformCloudWorkspacesQueryParams, void>(
    getConfig('ng/api'),
    `/terraform-cloud/workspaces`,
    props,
    signal
  )

export interface TerraformCmdFlagsQueryParams {
  stepType: string
  configType: string
}

export type TerraformCmdFlagsProps = Omit<
  GetProps<ResponseSetTerraformCommandFlagType, Failure | Error, TerraformCmdFlagsQueryParams, void>,
  'path'
>

/**
 * Get Command flags based on terraform Step Type and Config Type
 */
export const TerraformCmdFlags = (props: TerraformCmdFlagsProps) => (
  <Get<ResponseSetTerraformCommandFlagType, Failure | Error, TerraformCmdFlagsQueryParams, void>
    path={`/terraform/terraformCmdFlags`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseTerraformCmdFlagsProps = Omit<
  UseGetProps<ResponseSetTerraformCommandFlagType, Failure | Error, TerraformCmdFlagsQueryParams, void>,
  'path'
>

/**
 * Get Command flags based on terraform Step Type and Config Type
 */
export const useTerraformCmdFlags = (props: UseTerraformCmdFlagsProps) =>
  useGet<ResponseSetTerraformCommandFlagType, Failure | Error, TerraformCmdFlagsQueryParams, void>(
    `/terraform/terraformCmdFlags`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Command flags based on terraform Step Type and Config Type
 */
export const terraformCmdFlagsPromise = (
  props: GetUsingFetchProps<ResponseSetTerraformCommandFlagType, Failure | Error, TerraformCmdFlagsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSetTerraformCommandFlagType, Failure | Error, TerraformCmdFlagsQueryParams, void>(
    getConfig('ng/api'),
    `/terraform/terraformCmdFlags`,
    props,
    signal
  )

export interface TerragruntCmdFlagsQueryParams {
  stepType?: string
}

export type TerragruntCmdFlagsProps = Omit<
  GetProps<ResponseSetTerragruntCommandFlagType, Failure | Error, TerragruntCmdFlagsQueryParams, void>,
  'path'
>

/**
 * Get Command flags based on terragrunt Step Type
 */
export const TerragruntCmdFlags = (props: TerragruntCmdFlagsProps) => (
  <Get<ResponseSetTerragruntCommandFlagType, Failure | Error, TerragruntCmdFlagsQueryParams, void>
    path={`/terragrunt/terragruntCmdFlags`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseTerragruntCmdFlagsProps = Omit<
  UseGetProps<ResponseSetTerragruntCommandFlagType, Failure | Error, TerragruntCmdFlagsQueryParams, void>,
  'path'
>

/**
 * Get Command flags based on terragrunt Step Type
 */
export const useTerragruntCmdFlags = (props: UseTerragruntCmdFlagsProps) =>
  useGet<ResponseSetTerragruntCommandFlagType, Failure | Error, TerragruntCmdFlagsQueryParams, void>(
    `/terragrunt/terragruntCmdFlags`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Command flags based on terragrunt Step Type
 */
export const terragruntCmdFlagsPromise = (
  props: GetUsingFetchProps<ResponseSetTerragruntCommandFlagType, Failure | Error, TerragruntCmdFlagsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSetTerragruntCommandFlagType, Failure | Error, TerragruntCmdFlagsQueryParams, void>(
    getConfig('ng/api'),
    `/terragrunt/terragruntCmdFlags`,
    props,
    signal
  )

export interface GetTokenQueryParams {
  tokenId?: string
}

export type GetTokenProps = Omit<GetProps<ResponseTokenDTO, Failure | Error, GetTokenQueryParams, void>, 'path'>

/**
 * Get token
 */
export const GetToken = (props: GetTokenProps) => (
  <Get<ResponseTokenDTO, Failure | Error, GetTokenQueryParams, void>
    path={`/token`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTokenProps = Omit<UseGetProps<ResponseTokenDTO, Failure | Error, GetTokenQueryParams, void>, 'path'>

/**
 * Get token
 */
export const useGetToken = (props: UseGetTokenProps) =>
  useGet<ResponseTokenDTO, Failure | Error, GetTokenQueryParams, void>(`/token`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get token
 */
export const getTokenPromise = (
  props: GetUsingFetchProps<ResponseTokenDTO, Failure | Error, GetTokenQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseTokenDTO, Failure | Error, GetTokenQueryParams, void>(
    getConfig('ng/api'),
    `/token`,
    props,
    signal
  )

export interface CreateTokenQueryParams {
  accountIdentifier: string
}

export type CreateTokenProps = Omit<
  MutateProps<ResponseString, Failure | Error, CreateTokenQueryParams, TokenDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create token
 */
export const CreateToken = (props: CreateTokenProps) => (
  <Mutate<ResponseString, Failure | Error, CreateTokenQueryParams, TokenDTORequestBody, void>
    verb="POST"
    path={`/token`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateTokenProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, CreateTokenQueryParams, TokenDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create token
 */
export const useCreateToken = (props: UseCreateTokenProps) =>
  useMutate<ResponseString, Failure | Error, CreateTokenQueryParams, TokenDTORequestBody, void>('POST', `/token`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create token
 */
export const createTokenPromise = (
  props: MutateUsingFetchProps<ResponseString, Failure | Error, CreateTokenQueryParams, TokenDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, CreateTokenQueryParams, TokenDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/token`,
    props,
    signal
  )

export interface ListAggregatedTokensQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  parentIdentifier?: string
  apiKeyIdentifier?: string
  identifiers?: string[]
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
  searchTerm?: string
  includeOnlyActiveTokens?: boolean
}

export type ListAggregatedTokensProps = Omit<
  GetProps<ResponsePageTokenAggregateDTO, Failure | Error, ListAggregatedTokensQueryParams, void>,
  'path'
>

/**
 * List tokens
 */
export const ListAggregatedTokens = (props: ListAggregatedTokensProps) => (
  <Get<ResponsePageTokenAggregateDTO, Failure | Error, ListAggregatedTokensQueryParams, void>
    path={`/token/aggregate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListAggregatedTokensProps = Omit<
  UseGetProps<ResponsePageTokenAggregateDTO, Failure | Error, ListAggregatedTokensQueryParams, void>,
  'path'
>

/**
 * List tokens
 */
export const useListAggregatedTokens = (props: UseListAggregatedTokensProps) =>
  useGet<ResponsePageTokenAggregateDTO, Failure | Error, ListAggregatedTokensQueryParams, void>(`/token/aggregate`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * List tokens
 */
export const listAggregatedTokensPromise = (
  props: GetUsingFetchProps<ResponsePageTokenAggregateDTO, Failure | Error, ListAggregatedTokensQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageTokenAggregateDTO, Failure | Error, ListAggregatedTokensQueryParams, void>(
    getConfig('ng/api'),
    `/token/aggregate`,
    props,
    signal
  )

export interface RotateTokenQueryParams {
  rotateTimestamp?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  parentIdentifier: string
  apiKeyIdentifier: string
}

export interface RotateTokenPathParams {
  identifier: string
}

export type RotateTokenProps = Omit<
  MutateProps<ResponseString, Failure | Error, RotateTokenQueryParams, void, RotateTokenPathParams>,
  'path' | 'verb'
> &
  RotateTokenPathParams

/**
 * Rotate token
 */
export const RotateToken = ({ identifier, ...props }: RotateTokenProps) => (
  <Mutate<ResponseString, Failure | Error, RotateTokenQueryParams, void, RotateTokenPathParams>
    verb="POST"
    path={`/token/rotate/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRotateTokenProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, RotateTokenQueryParams, void, RotateTokenPathParams>,
  'path' | 'verb'
> &
  RotateTokenPathParams

/**
 * Rotate token
 */
export const useRotateToken = ({ identifier, ...props }: UseRotateTokenProps) =>
  useMutate<ResponseString, Failure | Error, RotateTokenQueryParams, void, RotateTokenPathParams>(
    'POST',
    (paramsInPath: RotateTokenPathParams) => `/token/rotate/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Rotate token
 */
export const rotateTokenPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<ResponseString, Failure | Error, RotateTokenQueryParams, void, RotateTokenPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, RotateTokenQueryParams, void, RotateTokenPathParams>(
    'POST',
    getConfig('ng/api'),
    `/token/rotate/${identifier}`,
    props,
    signal
  )

export interface ValidateTokenQueryParams {
  accountIdentifier: string
}

export type ValidateTokenProps = Omit<
  MutateProps<ResponseTokenDTO, Failure | Error, ValidateTokenQueryParams, CFParametersForAwsBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * Validate token
 */
export const ValidateToken = (props: ValidateTokenProps) => (
  <Mutate<ResponseTokenDTO, Failure | Error, ValidateTokenQueryParams, CFParametersForAwsBodyRequestBody, void>
    verb="POST"
    path={`/token/validate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateTokenProps = Omit<
  UseMutateProps<ResponseTokenDTO, Failure | Error, ValidateTokenQueryParams, CFParametersForAwsBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * Validate token
 */
export const useValidateToken = (props: UseValidateTokenProps) =>
  useMutate<ResponseTokenDTO, Failure | Error, ValidateTokenQueryParams, CFParametersForAwsBodyRequestBody, void>(
    'POST',
    `/token/validate`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate token
 */
export const validateTokenPromise = (
  props: MutateUsingFetchProps<
    ResponseTokenDTO,
    Failure | Error,
    ValidateTokenQueryParams,
    CFParametersForAwsBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseTokenDTO,
    Failure | Error,
    ValidateTokenQueryParams,
    CFParametersForAwsBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/token/validate`, props, signal)

export interface DeleteTokenQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  parentIdentifier: string
  apiKeyIdentifier: string
}

export type DeleteTokenProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteTokenQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete token
 */
export const DeleteToken = (props: DeleteTokenProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteTokenQueryParams, string, void>
    verb="DELETE"
    path={`/token`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteTokenProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteTokenQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete token
 */
export const useDeleteToken = (props: UseDeleteTokenProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteTokenQueryParams, string, void>('DELETE', `/token`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete token
 */
export const deleteTokenPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteTokenQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteTokenQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/token`,
    props,
    signal
  )

export interface UpdateTokenQueryParams {
  accountIdentifier: string
}

export interface UpdateTokenPathParams {
  identifier: string
}

export type UpdateTokenProps = Omit<
  MutateProps<ResponseTokenDTO, Failure | Error, UpdateTokenQueryParams, TokenDTORequestBody, UpdateTokenPathParams>,
  'path' | 'verb'
> &
  UpdateTokenPathParams

/**
 * Update token
 */
export const UpdateToken = ({ identifier, ...props }: UpdateTokenProps) => (
  <Mutate<ResponseTokenDTO, Failure | Error, UpdateTokenQueryParams, TokenDTORequestBody, UpdateTokenPathParams>
    verb="PUT"
    path={`/token/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateTokenProps = Omit<
  UseMutateProps<ResponseTokenDTO, Failure | Error, UpdateTokenQueryParams, TokenDTORequestBody, UpdateTokenPathParams>,
  'path' | 'verb'
> &
  UpdateTokenPathParams

/**
 * Update token
 */
export const useUpdateToken = ({ identifier, ...props }: UseUpdateTokenProps) =>
  useMutate<ResponseTokenDTO, Failure | Error, UpdateTokenQueryParams, TokenDTORequestBody, UpdateTokenPathParams>(
    'PUT',
    (paramsInPath: UpdateTokenPathParams) => `/token/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update token
 */
export const updateTokenPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseTokenDTO,
    Failure | Error,
    UpdateTokenQueryParams,
    TokenDTORequestBody,
    UpdateTokenPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseTokenDTO,
    Failure | Error,
    UpdateTokenQueryParams,
    TokenDTORequestBody,
    UpdateTokenPathParams
  >('PUT', getConfig('ng/api'), `/token/${identifier}`, props, signal)

export interface CreateDefaultScmConnectorQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateDefaultScmConnectorProps = Omit<
  MutateProps<
    ResponseScmConnectorResponse,
    Failure | Error,
    CreateDefaultScmConnectorQueryParams,
    ScmConnectorDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates default scm Connector
 */
export const CreateDefaultScmConnector = (props: CreateDefaultScmConnectorProps) => (
  <Mutate<ResponseScmConnectorResponse, Failure | Error, CreateDefaultScmConnectorQueryParams, ScmConnectorDTO, void>
    verb="POST"
    path={`/trial-signup/create-scm-connector`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateDefaultScmConnectorProps = Omit<
  UseMutateProps<
    ResponseScmConnectorResponse,
    Failure | Error,
    CreateDefaultScmConnectorQueryParams,
    ScmConnectorDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates default scm Connector
 */
export const useCreateDefaultScmConnector = (props: UseCreateDefaultScmConnectorProps) =>
  useMutate<ResponseScmConnectorResponse, Failure | Error, CreateDefaultScmConnectorQueryParams, ScmConnectorDTO, void>(
    'POST',
    `/trial-signup/create-scm-connector`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Creates default scm Connector
 */
export const createDefaultScmConnectorPromise = (
  props: MutateUsingFetchProps<
    ResponseScmConnectorResponse,
    Failure | Error,
    CreateDefaultScmConnectorQueryParams,
    ScmConnectorDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseScmConnectorResponse,
    Failure | Error,
    CreateDefaultScmConnectorQueryParams,
    ScmConnectorDTO,
    void
  >('POST', getConfig('ng/api'), `/trial-signup/create-scm-connector`, props, signal)

export interface GetDelegateInstallStatusQueryParams {
  accountIdentifier: string
}

export type GetDelegateInstallStatusProps = Omit<
  GetProps<ResponseDelegateStatus, Failure | Error, GetDelegateInstallStatusQueryParams, void>,
  'path'
>

/**
 * Provision resources for signup
 */
export const GetDelegateInstallStatus = (props: GetDelegateInstallStatusProps) => (
  <Get<ResponseDelegateStatus, Failure | Error, GetDelegateInstallStatusQueryParams, void>
    path={`/trial-signup/delegate-install-status`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDelegateInstallStatusProps = Omit<
  UseGetProps<ResponseDelegateStatus, Failure | Error, GetDelegateInstallStatusQueryParams, void>,
  'path'
>

/**
 * Provision resources for signup
 */
export const useGetDelegateInstallStatus = (props: UseGetDelegateInstallStatusProps) =>
  useGet<ResponseDelegateStatus, Failure | Error, GetDelegateInstallStatusQueryParams, void>(
    `/trial-signup/delegate-install-status`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Provision resources for signup
 */
export const getDelegateInstallStatusPromise = (
  props: GetUsingFetchProps<ResponseDelegateStatus, Failure | Error, GetDelegateInstallStatusQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDelegateStatus, Failure | Error, GetDelegateInstallStatusQueryParams, void>(
    getConfig('ng/api'),
    `/trial-signup/delegate-install-status`,
    props,
    signal
  )

export interface GenerateYamlQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  connectorIdentifier?: string
  repo?: string
  yamlVersion?: string
}

export type GenerateYamlProps = Omit<GetProps<ResponseString, Failure | Error, GenerateYamlQueryParams, void>, 'path'>

/**
 * generate yaml
 */
export const GenerateYaml = (props: GenerateYamlProps) => (
  <Get<ResponseString, Failure | Error, GenerateYamlQueryParams, void>
    path={`/trial-signup/generate-yaml`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGenerateYamlProps = Omit<
  UseGetProps<ResponseString, Failure | Error, GenerateYamlQueryParams, void>,
  'path'
>

/**
 * generate yaml
 */
export const useGenerateYaml = (props: UseGenerateYamlProps) =>
  useGet<ResponseString, Failure | Error, GenerateYamlQueryParams, void>(`/trial-signup/generate-yaml`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * generate yaml
 */
export const generateYamlPromise = (
  props: GetUsingFetchProps<ResponseString, Failure | Error, GenerateYamlQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, Failure | Error, GenerateYamlQueryParams, void>(
    getConfig('ng/api'),
    `/trial-signup/generate-yaml`,
    props,
    signal
  )

export interface ProvisionResourcesForCIQueryParams {
  accountIdentifier: string
}

export type ProvisionResourcesForCIProps = Omit<
  MutateProps<ResponseSetupStatus, Failure | Error, ProvisionResourcesForCIQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Provision resources for signup
 */
export const ProvisionResourcesForCI = (props: ProvisionResourcesForCIProps) => (
  <Mutate<ResponseSetupStatus, Failure | Error, ProvisionResourcesForCIQueryParams, void, void>
    verb="PUT"
    path={`/trial-signup/provision`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseProvisionResourcesForCIProps = Omit<
  UseMutateProps<ResponseSetupStatus, Failure | Error, ProvisionResourcesForCIQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Provision resources for signup
 */
export const useProvisionResourcesForCI = (props: UseProvisionResourcesForCIProps) =>
  useMutate<ResponseSetupStatus, Failure | Error, ProvisionResourcesForCIQueryParams, void, void>(
    'PUT',
    `/trial-signup/provision`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Provision resources for signup
 */
export const provisionResourcesForCIPromise = (
  props: MutateUsingFetchProps<ResponseSetupStatus, Failure | Error, ProvisionResourcesForCIQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseSetupStatus, Failure | Error, ProvisionResourcesForCIQueryParams, void, void>(
    'PUT',
    getConfig('ng/api'),
    `/trial-signup/provision`,
    props,
    signal
  )

export interface GetCDLicenseUsageForServiceInstancesQueryParams {
  accountIdentifier?: string
  timestamp?: number
}

export type GetCDLicenseUsageForServiceInstancesProps = Omit<
  GetProps<ResponseServiceInstanceUsageDTO, Failure | Error, GetCDLicenseUsageForServiceInstancesQueryParams, void>,
  'path'
>

/**
 * Gets License Usage By Timestamp for Service Instances in CD Module
 */
export const GetCDLicenseUsageForServiceInstances = (props: GetCDLicenseUsageForServiceInstancesProps) => (
  <Get<ResponseServiceInstanceUsageDTO, Failure | Error, GetCDLicenseUsageForServiceInstancesQueryParams, void>
    path={`/usage/CD/serviceInstancesLicense`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCDLicenseUsageForServiceInstancesProps = Omit<
  UseGetProps<ResponseServiceInstanceUsageDTO, Failure | Error, GetCDLicenseUsageForServiceInstancesQueryParams, void>,
  'path'
>

/**
 * Gets License Usage By Timestamp for Service Instances in CD Module
 */
export const useGetCDLicenseUsageForServiceInstances = (props: UseGetCDLicenseUsageForServiceInstancesProps) =>
  useGet<ResponseServiceInstanceUsageDTO, Failure | Error, GetCDLicenseUsageForServiceInstancesQueryParams, void>(
    `/usage/CD/serviceInstancesLicense`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets License Usage By Timestamp for Service Instances in CD Module
 */
export const getCDLicenseUsageForServiceInstancesPromise = (
  props: GetUsingFetchProps<
    ResponseServiceInstanceUsageDTO,
    Failure | Error,
    GetCDLicenseUsageForServiceInstancesQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseServiceInstanceUsageDTO,
    Failure | Error,
    GetCDLicenseUsageForServiceInstancesQueryParams,
    void
  >(getConfig('ng/api'), `/usage/CD/serviceInstancesLicense`, props, signal)

export interface GetCDLicenseUsageForServicesQueryParams {
  accountIdentifier?: string
  timestamp?: number
}

export type GetCDLicenseUsageForServicesProps = Omit<
  GetProps<ResponseServiceUsageDTO, Failure | Error, GetCDLicenseUsageForServicesQueryParams, void>,
  'path'
>

/**
 * Gets License Usage By Timestamp for Services in CD Module
 */
export const GetCDLicenseUsageForServices = (props: GetCDLicenseUsageForServicesProps) => (
  <Get<ResponseServiceUsageDTO, Failure | Error, GetCDLicenseUsageForServicesQueryParams, void>
    path={`/usage/CD/servicesLicense`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCDLicenseUsageForServicesProps = Omit<
  UseGetProps<ResponseServiceUsageDTO, Failure | Error, GetCDLicenseUsageForServicesQueryParams, void>,
  'path'
>

/**
 * Gets License Usage By Timestamp for Services in CD Module
 */
export const useGetCDLicenseUsageForServices = (props: UseGetCDLicenseUsageForServicesProps) =>
  useGet<ResponseServiceUsageDTO, Failure | Error, GetCDLicenseUsageForServicesQueryParams, void>(
    `/usage/CD/servicesLicense`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets License Usage By Timestamp for Services in CD Module
 */
export const getCDLicenseUsageForServicesPromise = (
  props: GetUsingFetchProps<ResponseServiceUsageDTO, Failure | Error, GetCDLicenseUsageForServicesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceUsageDTO, Failure | Error, GetCDLicenseUsageForServicesQueryParams, void>(
    getConfig('ng/api'),
    `/usage/CD/servicesLicense`,
    props,
    signal
  )

export interface LisCDActiveServicesQueryParams {
  accountIdentifier?: string
  page?: number
  size?: number
  sort?: string[]
  timestamp?: number
}

export type LisCDActiveServicesProps = Omit<
  MutateProps<
    ResponsePageActiveServiceDTO,
    Failure | Error,
    LisCDActiveServicesQueryParams,
    ActiveServicesFilterParams,
    void
  >,
  'path' | 'verb'
>

/**
 * List Active Services in CD Module
 */
export const LisCDActiveServices = (props: LisCDActiveServicesProps) => (
  <Mutate<
    ResponsePageActiveServiceDTO,
    Failure | Error,
    LisCDActiveServicesQueryParams,
    ActiveServicesFilterParams,
    void
  >
    verb="POST"
    path={`/usage/cd/active-services`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseLisCDActiveServicesProps = Omit<
  UseMutateProps<
    ResponsePageActiveServiceDTO,
    Failure | Error,
    LisCDActiveServicesQueryParams,
    ActiveServicesFilterParams,
    void
  >,
  'path' | 'verb'
>

/**
 * List Active Services in CD Module
 */
export const useLisCDActiveServices = (props: UseLisCDActiveServicesProps) =>
  useMutate<
    ResponsePageActiveServiceDTO,
    Failure | Error,
    LisCDActiveServicesQueryParams,
    ActiveServicesFilterParams,
    void
  >('POST', `/usage/cd/active-services`, { base: getConfig('ng/api'), ...props })

/**
 * List Active Services in CD Module
 */
export const lisCDActiveServicesPromise = (
  props: MutateUsingFetchProps<
    ResponsePageActiveServiceDTO,
    Failure | Error,
    LisCDActiveServicesQueryParams,
    ActiveServicesFilterParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageActiveServiceDTO,
    Failure | Error,
    LisCDActiveServicesQueryParams,
    ActiveServicesFilterParams,
    void
  >('POST', getConfig('ng/api'), `/usage/cd/active-services`, props, signal)

export interface DownloadActiveServiceCSVReportQueryParams {
  accountIdentifier?: string
  timestamp?: number
}

export type DownloadActiveServiceCSVReportProps = Omit<
  GetProps<void, Failure | Error, DownloadActiveServiceCSVReportQueryParams, void>,
  'path'
>

/**
 * Download CSV Active Services report
 */
export const DownloadActiveServiceCSVReport = (props: DownloadActiveServiceCSVReportProps) => (
  <Get<void, Failure | Error, DownloadActiveServiceCSVReportQueryParams, void>
    path={`/usage/cd/active-services/csv/download`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDownloadActiveServiceCSVReportProps = Omit<
  UseGetProps<void, Failure | Error, DownloadActiveServiceCSVReportQueryParams, void>,
  'path'
>

/**
 * Download CSV Active Services report
 */
export const useDownloadActiveServiceCSVReport = (props: UseDownloadActiveServiceCSVReportProps) =>
  useGet<void, Failure | Error, DownloadActiveServiceCSVReportQueryParams, void>(
    `/usage/cd/active-services/csv/download`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Download CSV Active Services report
 */
export const downloadActiveServiceCSVReportPromise = (
  props: GetUsingFetchProps<void, Failure | Error, DownloadActiveServiceCSVReportQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, Failure | Error, DownloadActiveServiceCSVReportQueryParams, void>(
    getConfig('ng/api'),
    `/usage/cd/active-services/csv/download`,
    props,
    signal
  )

export interface GetLicenseUsageQueryParams {
  accountIdentifier?: string
  timestamp?: number
  CDLicenseType?: string
}

export interface GetLicenseUsagePathParams {
  module: string
}

export type GetLicenseUsageProps = Omit<
  GetProps<ResponseLicenseUsageDTO, Failure | Error, GetLicenseUsageQueryParams, GetLicenseUsagePathParams>,
  'path'
> &
  GetLicenseUsagePathParams

/**
 * Gets License Usage By Module and Timestamp
 */
export const GetLicenseUsage = ({ module, ...props }: GetLicenseUsageProps) => (
  <Get<ResponseLicenseUsageDTO, Failure | Error, GetLicenseUsageQueryParams, GetLicenseUsagePathParams>
    path={`/usage/${module}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLicenseUsageProps = Omit<
  UseGetProps<ResponseLicenseUsageDTO, Failure | Error, GetLicenseUsageQueryParams, GetLicenseUsagePathParams>,
  'path'
> &
  GetLicenseUsagePathParams

/**
 * Gets License Usage By Module and Timestamp
 */
export const useGetLicenseUsage = ({ module, ...props }: UseGetLicenseUsageProps) =>
  useGet<ResponseLicenseUsageDTO, Failure | Error, GetLicenseUsageQueryParams, GetLicenseUsagePathParams>(
    (paramsInPath: GetLicenseUsagePathParams) => `/usage/${paramsInPath.module}`,
    { base: getConfig('ng/api'), pathParams: { module }, ...props }
  )

/**
 * Gets License Usage By Module and Timestamp
 */
export const getLicenseUsagePromise = (
  {
    module,
    ...props
  }: GetUsingFetchProps<
    ResponseLicenseUsageDTO,
    Failure | Error,
    GetLicenseUsageQueryParams,
    GetLicenseUsagePathParams
  > & { module: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseLicenseUsageDTO, Failure | Error, GetLicenseUsageQueryParams, GetLicenseUsagePathParams>(
    getConfig('ng/api'),
    `/usage/${module}`,
    props,
    signal
  )

export interface UpdateUserInfoQueryParams {
  accountIdentifier?: string
}

export type UpdateUserInfoProps = Omit<
  MutateProps<ResponseUserInfo, Failure | Error, UpdateUserInfoQueryParams, UserInfo, void>,
  'path' | 'verb'
>

/**
 * update user information
 */
export const UpdateUserInfo = (props: UpdateUserInfoProps) => (
  <Mutate<ResponseUserInfo, Failure | Error, UpdateUserInfoQueryParams, UserInfo, void>
    verb="PUT"
    path={`/user`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateUserInfoProps = Omit<
  UseMutateProps<ResponseUserInfo, Failure | Error, UpdateUserInfoQueryParams, UserInfo, void>,
  'path' | 'verb'
>

/**
 * update user information
 */
export const useUpdateUserInfo = (props: UseUpdateUserInfoProps) =>
  useMutate<ResponseUserInfo, Failure | Error, UpdateUserInfoQueryParams, UserInfo, void>('PUT', `/user`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * update user information
 */
export const updateUserInfoPromise = (
  props: MutateUsingFetchProps<ResponseUserInfo, Failure | Error, UpdateUserInfoQueryParams, UserInfo, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserInfo, Failure | Error, UpdateUserInfoQueryParams, UserInfo, void>(
    'PUT',
    getConfig('ng/api'),
    `/user`,
    props,
    signal
  )

export interface GetUserGroupListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  filterType?: 'INCLUDE_INHERITED_GROUPS' | 'EXCLUDE_INHERITED_GROUPS' | 'INCLUDE_CHILD_SCOPE_GROUPS'
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type GetUserGroupListProps = Omit<
  GetProps<ResponsePageUserGroupDTO, Failure | AccessControlCheckError | Error, GetUserGroupListQueryParams, void>,
  'path'
>

/**
 * Get User Group List
 */
export const GetUserGroupList = (props: GetUserGroupListProps) => (
  <Get<ResponsePageUserGroupDTO, Failure | AccessControlCheckError | Error, GetUserGroupListQueryParams, void>
    path={`/user-groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserGroupListProps = Omit<
  UseGetProps<ResponsePageUserGroupDTO, Failure | AccessControlCheckError | Error, GetUserGroupListQueryParams, void>,
  'path'
>

/**
 * Get User Group List
 */
export const useGetUserGroupList = (props: UseGetUserGroupListProps) =>
  useGet<ResponsePageUserGroupDTO, Failure | AccessControlCheckError | Error, GetUserGroupListQueryParams, void>(
    `/user-groups`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get User Group List
 */
export const getUserGroupListPromise = (
  props: GetUsingFetchProps<
    ResponsePageUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetUserGroupListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageUserGroupDTO, Failure | AccessControlCheckError | Error, GetUserGroupListQueryParams, void>(
    getConfig('ng/api'),
    `/user-groups`,
    props,
    signal
  )

export interface PostUserGroupQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type PostUserGroupProps = Omit<
  MutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a User Group
 */
export const PostUserGroup = (props: PostUserGroupProps) => (
  <Mutate<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >
    verb="POST"
    path={`/user-groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostUserGroupProps = Omit<
  UseMutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a User Group
 */
export const usePostUserGroup = (props: UsePostUserGroupProps) =>
  useMutate<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >('POST', `/user-groups`, { base: getConfig('ng/api'), ...props })

/**
 * Create a User Group
 */
export const postUserGroupPromise = (
  props: MutateUsingFetchProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/user-groups`, props, signal)

export interface PutUserGroupQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type PutUserGroupProps = Omit<
  MutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a User Group
 */
export const PutUserGroup = (props: PutUserGroupProps) => (
  <Mutate<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >
    verb="PUT"
    path={`/user-groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutUserGroupProps = Omit<
  UseMutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a User Group
 */
export const usePutUserGroup = (props: UsePutUserGroupProps) =>
  useMutate<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >('PUT', `/user-groups`, { base: getConfig('ng/api'), ...props })

/**
 * Update a User Group
 */
export const putUserGroupPromise = (
  props: MutateUsingFetchProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/user-groups`, props, signal)

export interface GetBatchUserGroupListQueryParams {
  accountIdentifier?: string
}

export type GetBatchUserGroupListProps = Omit<
  MutateProps<
    ResponseListUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetBatchUserGroupListQueryParams,
    UserGroupFilterDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Batch User Group List
 */
export const GetBatchUserGroupList = (props: GetBatchUserGroupListProps) => (
  <Mutate<
    ResponseListUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetBatchUserGroupListQueryParams,
    UserGroupFilterDTORequestBody,
    void
  >
    verb="POST"
    path={`/user-groups/batch`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBatchUserGroupListProps = Omit<
  UseMutateProps<
    ResponseListUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetBatchUserGroupListQueryParams,
    UserGroupFilterDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Batch User Group List
 */
export const useGetBatchUserGroupList = (props: UseGetBatchUserGroupListProps) =>
  useMutate<
    ResponseListUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetBatchUserGroupListQueryParams,
    UserGroupFilterDTORequestBody,
    void
  >('POST', `/user-groups/batch`, { base: getConfig('ng/api'), ...props })

/**
 * Get Batch User Group List
 */
export const getBatchUserGroupListPromise = (
  props: MutateUsingFetchProps<
    ResponseListUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetBatchUserGroupListQueryParams,
    UserGroupFilterDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetBatchUserGroupListQueryParams,
    UserGroupFilterDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/user-groups/batch`, props, signal)

export interface CopyUserGroupQueryParams {
  accountIdentifier?: string
  groupIdentifier?: string
}

export type CopyUserGroupProps = Omit<
  MutateProps<ResponseBoolean, Failure | AccessControlCheckError | Error, CopyUserGroupQueryParams, Scope[], void>,
  'path' | 'verb'
>

/**
 * Copy a User Group to several scopes
 */
export const CopyUserGroup = (props: CopyUserGroupProps) => (
  <Mutate<ResponseBoolean, Failure | AccessControlCheckError | Error, CopyUserGroupQueryParams, Scope[], void>
    verb="PUT"
    path={`/user-groups/copy`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCopyUserGroupProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | AccessControlCheckError | Error, CopyUserGroupQueryParams, Scope[], void>,
  'path' | 'verb'
>

/**
 * Copy a User Group to several scopes
 */
export const useCopyUserGroup = (props: UseCopyUserGroupProps) =>
  useMutate<ResponseBoolean, Failure | AccessControlCheckError | Error, CopyUserGroupQueryParams, Scope[], void>(
    'PUT',
    `/user-groups/copy`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Copy a User Group to several scopes
 */
export const copyUserGroupPromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | AccessControlCheckError | Error,
    CopyUserGroupQueryParams,
    Scope[],
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | AccessControlCheckError | Error, CopyUserGroupQueryParams, Scope[], void>(
    'PUT',
    getConfig('ng/api'),
    `/user-groups/copy`,
    props,
    signal
  )

export interface GetFilteredUserGroupsListQueryParams {
  accountIdentifier?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type GetFilteredUserGroupsListProps = Omit<
  MutateProps<
    ResponsePageUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetFilteredUserGroupsListQueryParams,
    UserGroupFilterDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get filtered User Groups
 */
export const GetFilteredUserGroupsList = (props: GetFilteredUserGroupsListProps) => (
  <Mutate<
    ResponsePageUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetFilteredUserGroupsListQueryParams,
    UserGroupFilterDTORequestBody,
    void
  >
    verb="POST"
    path={`/user-groups/filter`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFilteredUserGroupsListProps = Omit<
  UseMutateProps<
    ResponsePageUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetFilteredUserGroupsListQueryParams,
    UserGroupFilterDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get filtered User Groups
 */
export const useGetFilteredUserGroupsList = (props: UseGetFilteredUserGroupsListProps) =>
  useMutate<
    ResponsePageUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetFilteredUserGroupsListQueryParams,
    UserGroupFilterDTORequestBody,
    void
  >('POST', `/user-groups/filter`, { base: getConfig('ng/api'), ...props })

/**
 * Get filtered User Groups
 */
export const getFilteredUserGroupsListPromise = (
  props: MutateUsingFetchProps<
    ResponsePageUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetFilteredUserGroupsListQueryParams,
    UserGroupFilterDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetFilteredUserGroupsListQueryParams,
    UserGroupFilterDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/user-groups/filter`, props, signal)

export interface GetSsoLinkedUserGroupsQueryParams {
  accountIdentifier: string
}

export interface GetSsoLinkedUserGroupsPathParams {
  identifier: string
}

export type GetSsoLinkedUserGroupsProps = Omit<
  GetProps<
    ResponseListUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetSsoLinkedUserGroupsQueryParams,
    GetSsoLinkedUserGroupsPathParams
  >,
  'path'
> &
  GetSsoLinkedUserGroupsPathParams

/**
 * Get User Groups List linked to SSO
 */
export const GetSsoLinkedUserGroups = ({ identifier, ...props }: GetSsoLinkedUserGroupsProps) => (
  <Get<
    ResponseListUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetSsoLinkedUserGroupsQueryParams,
    GetSsoLinkedUserGroupsPathParams
  >
    path={`/user-groups/sso/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSsoLinkedUserGroupsProps = Omit<
  UseGetProps<
    ResponseListUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetSsoLinkedUserGroupsQueryParams,
    GetSsoLinkedUserGroupsPathParams
  >,
  'path'
> &
  GetSsoLinkedUserGroupsPathParams

/**
 * Get User Groups List linked to SSO
 */
export const useGetSsoLinkedUserGroups = ({ identifier, ...props }: UseGetSsoLinkedUserGroupsProps) =>
  useGet<
    ResponseListUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetSsoLinkedUserGroupsQueryParams,
    GetSsoLinkedUserGroupsPathParams
  >((paramsInPath: GetSsoLinkedUserGroupsPathParams) => `/user-groups/sso/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Get User Groups List linked to SSO
 */
export const getSsoLinkedUserGroupsPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseListUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetSsoLinkedUserGroupsQueryParams,
    GetSsoLinkedUserGroupsPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseListUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetSsoLinkedUserGroupsQueryParams,
    GetSsoLinkedUserGroupsPathParams
  >(getConfig('ng/api'), `/user-groups/sso/${identifier}`, props, signal)

export interface DeleteUserGroupQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteUserGroupProps = Omit<
  MutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    DeleteUserGroupQueryParams,
    string,
    void
  >,
  'path' | 'verb'
>

/**
 * Delete a User Group
 */
export const DeleteUserGroup = (props: DeleteUserGroupProps) => (
  <Mutate<ResponseUserGroupDTO, Failure | AccessControlCheckError | Error, DeleteUserGroupQueryParams, string, void>
    verb="DELETE"
    path={`/user-groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteUserGroupProps = Omit<
  UseMutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    DeleteUserGroupQueryParams,
    string,
    void
  >,
  'path' | 'verb'
>

/**
 * Delete a User Group
 */
export const useDeleteUserGroup = (props: UseDeleteUserGroupProps) =>
  useMutate<ResponseUserGroupDTO, Failure | AccessControlCheckError | Error, DeleteUserGroupQueryParams, string, void>(
    'DELETE',
    `/user-groups`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete a User Group
 */
export const deleteUserGroupPromise = (
  props: MutateUsingFetchProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    DeleteUserGroupQueryParams,
    string,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    DeleteUserGroupQueryParams,
    string,
    void
  >('DELETE', getConfig('ng/api'), `/user-groups`, props, signal)

export interface GetUserGroupQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetUserGroupPathParams {
  identifier: string
}

export type GetUserGroupProps = Omit<
  GetProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetUserGroupQueryParams,
    GetUserGroupPathParams
  >,
  'path'
> &
  GetUserGroupPathParams

/**
 * Get a User Group
 */
export const GetUserGroup = ({ identifier, ...props }: GetUserGroupProps) => (
  <Get<ResponseUserGroupDTO, Failure | AccessControlCheckError | Error, GetUserGroupQueryParams, GetUserGroupPathParams>
    path={`/user-groups/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserGroupProps = Omit<
  UseGetProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetUserGroupQueryParams,
    GetUserGroupPathParams
  >,
  'path'
> &
  GetUserGroupPathParams

/**
 * Get a User Group
 */
export const useGetUserGroup = ({ identifier, ...props }: UseGetUserGroupProps) =>
  useGet<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetUserGroupQueryParams,
    GetUserGroupPathParams
  >((paramsInPath: GetUserGroupPathParams) => `/user-groups/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Get a User Group
 */
export const getUserGroupPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetUserGroupQueryParams,
    GetUserGroupPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetUserGroupQueryParams,
    GetUserGroupPathParams
  >(getConfig('ng/api'), `/user-groups/${identifier}`, props, signal)

export interface RemoveMemberQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface RemoveMemberPathParams {
  identifier: string
}

export type RemoveMemberProps = Omit<
  MutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    RemoveMemberQueryParams,
    string,
    RemoveMemberPathParams
  >,
  'path' | 'verb'
> &
  RemoveMemberPathParams

/**
 * Remove a user from the user group
 */
export const RemoveMember = ({ identifier, ...props }: RemoveMemberProps) => (
  <Mutate<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    RemoveMemberQueryParams,
    string,
    RemoveMemberPathParams
  >
    verb="DELETE"
    path={`/user-groups/${identifier}/member`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRemoveMemberProps = Omit<
  UseMutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    RemoveMemberQueryParams,
    string,
    RemoveMemberPathParams
  >,
  'path' | 'verb'
> &
  RemoveMemberPathParams

/**
 * Remove a user from the user group
 */
export const useRemoveMember = ({ identifier, ...props }: UseRemoveMemberProps) =>
  useMutate<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    RemoveMemberQueryParams,
    string,
    RemoveMemberPathParams
  >('DELETE', (paramsInPath: RemoveMemberPathParams) => `/user-groups/${paramsInPath.identifier}/member`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Remove a user from the user group
 */
export const removeMemberPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    RemoveMemberQueryParams,
    string,
    RemoveMemberPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    RemoveMemberQueryParams,
    string,
    RemoveMemberPathParams
  >('DELETE', getConfig('ng/api'), `/user-groups/${identifier}/member`, props, signal)

export interface CheckMemberQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface CheckMemberPathParams {
  identifier: string
  userIdentifier: string
}

export type CheckMemberProps = Omit<
  GetProps<ResponseBoolean, Failure | AccessControlCheckError | Error, CheckMemberQueryParams, CheckMemberPathParams>,
  'path'
> &
  CheckMemberPathParams

/**
 * Check if the user is part of the user group
 */
export const CheckMember = ({ identifier, userIdentifier, ...props }: CheckMemberProps) => (
  <Get<ResponseBoolean, Failure | AccessControlCheckError | Error, CheckMemberQueryParams, CheckMemberPathParams>
    path={`/user-groups/${identifier}/member/${userIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCheckMemberProps = Omit<
  UseGetProps<
    ResponseBoolean,
    Failure | AccessControlCheckError | Error,
    CheckMemberQueryParams,
    CheckMemberPathParams
  >,
  'path'
> &
  CheckMemberPathParams

/**
 * Check if the user is part of the user group
 */
export const useCheckMember = ({ identifier, userIdentifier, ...props }: UseCheckMemberProps) =>
  useGet<ResponseBoolean, Failure | AccessControlCheckError | Error, CheckMemberQueryParams, CheckMemberPathParams>(
    (paramsInPath: CheckMemberPathParams) =>
      `/user-groups/${paramsInPath.identifier}/member/${paramsInPath.userIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier, userIdentifier }, ...props }
  )

/**
 * Check if the user is part of the user group
 */
export const checkMemberPromise = (
  {
    identifier,
    userIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseBoolean,
    Failure | AccessControlCheckError | Error,
    CheckMemberQueryParams,
    CheckMemberPathParams
  > & { identifier: string; userIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseBoolean,
    Failure | AccessControlCheckError | Error,
    CheckMemberQueryParams,
    CheckMemberPathParams
  >(getConfig('ng/api'), `/user-groups/${identifier}/member/${userIdentifier}`, props, signal)

export interface AddMemberQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface AddMemberPathParams {
  identifier: string
  userIdentifier: string
}

export type AddMemberProps = Omit<
  MutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    AddMemberQueryParams,
    void,
    AddMemberPathParams
  >,
  'path' | 'verb'
> &
  AddMemberPathParams

/**
 * Add a user to the user group
 */
export const AddMember = ({ identifier, userIdentifier, ...props }: AddMemberProps) => (
  <Mutate<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    AddMemberQueryParams,
    void,
    AddMemberPathParams
  >
    verb="PUT"
    path={`/user-groups/${identifier}/member/${userIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAddMemberProps = Omit<
  UseMutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    AddMemberQueryParams,
    void,
    AddMemberPathParams
  >,
  'path' | 'verb'
> &
  AddMemberPathParams

/**
 * Add a user to the user group
 */
export const useAddMember = ({ identifier, userIdentifier, ...props }: UseAddMemberProps) =>
  useMutate<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    AddMemberQueryParams,
    void,
    AddMemberPathParams
  >(
    'PUT',
    (paramsInPath: AddMemberPathParams) =>
      `/user-groups/${paramsInPath.identifier}/member/${paramsInPath.userIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier, userIdentifier }, ...props }
  )

/**
 * Add a user to the user group
 */
export const addMemberPromise = (
  {
    identifier,
    userIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    AddMemberQueryParams,
    void,
    AddMemberPathParams
  > & { identifier: string; userIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    AddMemberQueryParams,
    void,
    AddMemberPathParams
  >('PUT', getConfig('ng/api'), `/user-groups/${identifier}/member/${userIdentifier}`, props, signal)

export interface GetInheritingChildScopeListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetInheritingChildScopeListPathParams {
  identifier: string
}

export type GetInheritingChildScopeListProps = Omit<
  GetProps<
    ResponseListScopeName,
    Failure | AccessControlCheckError | Error,
    GetInheritingChildScopeListQueryParams,
    GetInheritingChildScopeListPathParams
  >,
  'path'
> &
  GetInheritingChildScopeListPathParams

/**
 * Get Inheriting Child Scope List
 */
export const GetInheritingChildScopeList = ({ identifier, ...props }: GetInheritingChildScopeListProps) => (
  <Get<
    ResponseListScopeName,
    Failure | AccessControlCheckError | Error,
    GetInheritingChildScopeListQueryParams,
    GetInheritingChildScopeListPathParams
  >
    path={`/user-groups/${identifier}/scopes`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInheritingChildScopeListProps = Omit<
  UseGetProps<
    ResponseListScopeName,
    Failure | AccessControlCheckError | Error,
    GetInheritingChildScopeListQueryParams,
    GetInheritingChildScopeListPathParams
  >,
  'path'
> &
  GetInheritingChildScopeListPathParams

/**
 * Get Inheriting Child Scope List
 */
export const useGetInheritingChildScopeList = ({ identifier, ...props }: UseGetInheritingChildScopeListProps) =>
  useGet<
    ResponseListScopeName,
    Failure | AccessControlCheckError | Error,
    GetInheritingChildScopeListQueryParams,
    GetInheritingChildScopeListPathParams
  >((paramsInPath: GetInheritingChildScopeListPathParams) => `/user-groups/${paramsInPath.identifier}/scopes`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Get Inheriting Child Scope List
 */
export const getInheritingChildScopeListPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseListScopeName,
    Failure | AccessControlCheckError | Error,
    GetInheritingChildScopeListQueryParams,
    GetInheritingChildScopeListPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseListScopeName,
    Failure | AccessControlCheckError | Error,
    GetInheritingChildScopeListQueryParams,
    GetInheritingChildScopeListPathParams
  >(getConfig('ng/api'), `/user-groups/${identifier}/scopes`, props, signal)

export interface GetUsersInUserGroupQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export interface GetUsersInUserGroupPathParams {
  identifier: string
}

export type GetUsersInUserGroupProps = Omit<
  MutateProps<
    ResponsePageUserMetadataDTO,
    Failure | AccessControlCheckError | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  >,
  'path' | 'verb'
> &
  GetUsersInUserGroupPathParams

/**
 * List users in a user group
 */
export const GetUsersInUserGroup = ({ identifier, ...props }: GetUsersInUserGroupProps) => (
  <Mutate<
    ResponsePageUserMetadataDTO,
    Failure | AccessControlCheckError | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  >
    verb="POST"
    path={`/user-groups/${identifier}/users`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUsersInUserGroupProps = Omit<
  UseMutateProps<
    ResponsePageUserMetadataDTO,
    Failure | AccessControlCheckError | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  >,
  'path' | 'verb'
> &
  GetUsersInUserGroupPathParams

/**
 * List users in a user group
 */
export const useGetUsersInUserGroup = ({ identifier, ...props }: UseGetUsersInUserGroupProps) =>
  useMutate<
    ResponsePageUserMetadataDTO,
    Failure | AccessControlCheckError | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  >('POST', (paramsInPath: GetUsersInUserGroupPathParams) => `/user-groups/${paramsInPath.identifier}/users`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * List users in a user group
 */
export const getUsersInUserGroupPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePageUserMetadataDTO,
    Failure | AccessControlCheckError | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageUserMetadataDTO,
    Failure | AccessControlCheckError | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  >('POST', getConfig('ng/api'), `/user-groups/${identifier}/users`, props, signal)

export interface LinkToLdapGroupQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface LinkToLdapGroupPathParams {
  userGroupId: string
  ldapId: string
}

export type LinkToLdapGroupProps = Omit<
  MutateProps<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToLdapGroupQueryParams,
    LdapLinkGroupRequest,
    LinkToLdapGroupPathParams
  >,
  'path' | 'verb'
> &
  LinkToLdapGroupPathParams

/**
 * Link to an LDAP group
 */
export const LinkToLdapGroup = ({ userGroupId, ldapId, ...props }: LinkToLdapGroupProps) => (
  <Mutate<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToLdapGroupQueryParams,
    LdapLinkGroupRequest,
    LinkToLdapGroupPathParams
  >
    verb="PUT"
    path={`/user-groups/${userGroupId}/link/ldap/${ldapId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseLinkToLdapGroupProps = Omit<
  UseMutateProps<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToLdapGroupQueryParams,
    LdapLinkGroupRequest,
    LinkToLdapGroupPathParams
  >,
  'path' | 'verb'
> &
  LinkToLdapGroupPathParams

/**
 * Link to an LDAP group
 */
export const useLinkToLdapGroup = ({ userGroupId, ldapId, ...props }: UseLinkToLdapGroupProps) =>
  useMutate<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToLdapGroupQueryParams,
    LdapLinkGroupRequest,
    LinkToLdapGroupPathParams
  >(
    'PUT',
    (paramsInPath: LinkToLdapGroupPathParams) =>
      `/user-groups/${paramsInPath.userGroupId}/link/ldap/${paramsInPath.ldapId}`,
    { base: getConfig('ng/api'), pathParams: { userGroupId, ldapId }, ...props }
  )

/**
 * Link to an LDAP group
 */
export const linkToLdapGroupPromise = (
  {
    userGroupId,
    ldapId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToLdapGroupQueryParams,
    LdapLinkGroupRequest,
    LinkToLdapGroupPathParams
  > & { userGroupId: string; ldapId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToLdapGroupQueryParams,
    LdapLinkGroupRequest,
    LinkToLdapGroupPathParams
  >('PUT', getConfig('ng/api'), `/user-groups/${userGroupId}/link/ldap/${ldapId}`, props, signal)

export interface LinkToSamlGroupQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface LinkToSamlGroupPathParams {
  userGroupId: string
  samlId: string
}

export type LinkToSamlGroupProps = Omit<
  MutateProps<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToSamlGroupQueryParams,
    SamlLinkGroupRequest,
    LinkToSamlGroupPathParams
  >,
  'path' | 'verb'
> &
  LinkToSamlGroupPathParams

/**
 * Link to SAML group
 */
export const LinkToSamlGroup = ({ userGroupId, samlId, ...props }: LinkToSamlGroupProps) => (
  <Mutate<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToSamlGroupQueryParams,
    SamlLinkGroupRequest,
    LinkToSamlGroupPathParams
  >
    verb="PUT"
    path={`/user-groups/${userGroupId}/link/saml/${samlId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseLinkToSamlGroupProps = Omit<
  UseMutateProps<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToSamlGroupQueryParams,
    SamlLinkGroupRequest,
    LinkToSamlGroupPathParams
  >,
  'path' | 'verb'
> &
  LinkToSamlGroupPathParams

/**
 * Link to SAML group
 */
export const useLinkToSamlGroup = ({ userGroupId, samlId, ...props }: UseLinkToSamlGroupProps) =>
  useMutate<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToSamlGroupQueryParams,
    SamlLinkGroupRequest,
    LinkToSamlGroupPathParams
  >(
    'PUT',
    (paramsInPath: LinkToSamlGroupPathParams) =>
      `/user-groups/${paramsInPath.userGroupId}/link/saml/${paramsInPath.samlId}`,
    { base: getConfig('ng/api'), pathParams: { userGroupId, samlId }, ...props }
  )

/**
 * Link to SAML group
 */
export const linkToSamlGroupPromise = (
  {
    userGroupId,
    samlId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToSamlGroupQueryParams,
    SamlLinkGroupRequest,
    LinkToSamlGroupPathParams
  > & { userGroupId: string; samlId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToSamlGroupQueryParams,
    SamlLinkGroupRequest,
    LinkToSamlGroupPathParams
  >('PUT', getConfig('ng/api'), `/user-groups/${userGroupId}/link/saml/${samlId}`, props, signal)

export interface UnlinkSsoGroupQueryParams {
  retainMembers?: boolean
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface UnlinkSsoGroupPathParams {
  userGroupId: string
}

export type UnlinkSsoGroupProps = Omit<
  MutateProps<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    UnlinkSsoGroupQueryParams,
    void,
    UnlinkSsoGroupPathParams
  >,
  'path' | 'verb'
> &
  UnlinkSsoGroupPathParams

/**
 * API to unlink the harness user group from SSO group
 */
export const UnlinkSsoGroup = ({ userGroupId, ...props }: UnlinkSsoGroupProps) => (
  <Mutate<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    UnlinkSsoGroupQueryParams,
    void,
    UnlinkSsoGroupPathParams
  >
    verb="PUT"
    path={`/user-groups/${userGroupId}/unlink`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUnlinkSsoGroupProps = Omit<
  UseMutateProps<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    UnlinkSsoGroupQueryParams,
    void,
    UnlinkSsoGroupPathParams
  >,
  'path' | 'verb'
> &
  UnlinkSsoGroupPathParams

/**
 * API to unlink the harness user group from SSO group
 */
export const useUnlinkSsoGroup = ({ userGroupId, ...props }: UseUnlinkSsoGroupProps) =>
  useMutate<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    UnlinkSsoGroupQueryParams,
    void,
    UnlinkSsoGroupPathParams
  >('PUT', (paramsInPath: UnlinkSsoGroupPathParams) => `/user-groups/${paramsInPath.userGroupId}/unlink`, {
    base: getConfig('ng/api'),
    pathParams: { userGroupId },
    ...props
  })

/**
 * API to unlink the harness user group from SSO group
 */
export const unlinkSsoGroupPromise = (
  {
    userGroupId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    UnlinkSsoGroupQueryParams,
    void,
    UnlinkSsoGroupPathParams
  > & { userGroupId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    UnlinkSsoGroupQueryParams,
    void,
    UnlinkSsoGroupPathParams
  >('PUT', getConfig('ng/api'), `/user-groups/${userGroupId}/unlink`, props, signal)

export interface DeleteUserSourceCodeManagerQueryParams {
  accountIdentifier: string
  userIdentifier: string
  type: 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'AWS_CODE_COMMIT' | 'AZURE_REPO'
}

export type DeleteUserSourceCodeManagerProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteUserSourceCodeManagerQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * delete user source code manager
 */
export const DeleteUserSourceCodeManager = (props: DeleteUserSourceCodeManagerProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteUserSourceCodeManagerQueryParams, void, void>
    verb="DELETE"
    path={`/user-source-code-manager`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteUserSourceCodeManagerProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteUserSourceCodeManagerQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * delete user source code manager
 */
export const useDeleteUserSourceCodeManager = (props: UseDeleteUserSourceCodeManagerProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteUserSourceCodeManagerQueryParams, void, void>(
    'DELETE',
    `/user-source-code-manager`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * delete user source code manager
 */
export const deleteUserSourceCodeManagerPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteUserSourceCodeManagerQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteUserSourceCodeManagerQueryParams, void, void>(
    'DELETE',
    getConfig('ng/api'),
    `/user-source-code-manager`,
    props,
    signal
  )

export interface GetUserSourceCodeManagersQueryParams {
  accountIdentifier: string
  userIdentifier: string
  type?: 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'AWS_CODE_COMMIT' | 'AZURE_REPO'
}

export type GetUserSourceCodeManagersProps = Omit<
  GetProps<ResponseUserSourceCodeManagerResponseDTOList, Failure | Error, GetUserSourceCodeManagersQueryParams, void>,
  'path'
>

/**
 * get user source code manager information
 */
export const GetUserSourceCodeManagers = (props: GetUserSourceCodeManagersProps) => (
  <Get<ResponseUserSourceCodeManagerResponseDTOList, Failure | Error, GetUserSourceCodeManagersQueryParams, void>
    path={`/user-source-code-manager`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserSourceCodeManagersProps = Omit<
  UseGetProps<
    ResponseUserSourceCodeManagerResponseDTOList,
    Failure | Error,
    GetUserSourceCodeManagersQueryParams,
    void
  >,
  'path'
>

/**
 * get user source code manager information
 */
export const useGetUserSourceCodeManagers = (props: UseGetUserSourceCodeManagersProps) =>
  useGet<ResponseUserSourceCodeManagerResponseDTOList, Failure | Error, GetUserSourceCodeManagersQueryParams, void>(
    `/user-source-code-manager`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * get user source code manager information
 */
export const getUserSourceCodeManagersPromise = (
  props: GetUsingFetchProps<
    ResponseUserSourceCodeManagerResponseDTOList,
    Failure | Error,
    GetUserSourceCodeManagersQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseUserSourceCodeManagerResponseDTOList,
    Failure | Error,
    GetUserSourceCodeManagersQueryParams,
    void
  >(getConfig('ng/api'), `/user-source-code-manager`, props, signal)

export type SaveUserSourceCodeManagerProps = Omit<
  MutateProps<
    ResponseUserSourceCodeManagerResponseDTO,
    Failure | Error,
    void,
    UserSourceCodeManagerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * save user source code manager
 */
export const SaveUserSourceCodeManager = (props: SaveUserSourceCodeManagerProps) => (
  <Mutate<
    ResponseUserSourceCodeManagerResponseDTO,
    Failure | Error,
    void,
    UserSourceCodeManagerRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/user-source-code-manager`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSaveUserSourceCodeManagerProps = Omit<
  UseMutateProps<
    ResponseUserSourceCodeManagerResponseDTO,
    Failure | Error,
    void,
    UserSourceCodeManagerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * save user source code manager
 */
export const useSaveUserSourceCodeManager = (props: UseSaveUserSourceCodeManagerProps) =>
  useMutate<
    ResponseUserSourceCodeManagerResponseDTO,
    Failure | Error,
    void,
    UserSourceCodeManagerRequestDTORequestBody,
    void
  >('POST', `/user-source-code-manager`, { base: getConfig('ng/api'), ...props })

/**
 * save user source code manager
 */
export const saveUserSourceCodeManagerPromise = (
  props: MutateUsingFetchProps<
    ResponseUserSourceCodeManagerResponseDTO,
    Failure | Error,
    void,
    UserSourceCodeManagerRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseUserSourceCodeManagerResponseDTO,
    Failure | Error,
    void,
    UserSourceCodeManagerRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/user-source-code-manager`, props, signal)

export type UpdateUserSourceCodeManagerProps = Omit<
  MutateProps<
    ResponseUserSourceCodeManagerResponseDTO,
    Failure | Error,
    void,
    UserSourceCodeManagerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * update user source code manager
 */
export const UpdateUserSourceCodeManager = (props: UpdateUserSourceCodeManagerProps) => (
  <Mutate<
    ResponseUserSourceCodeManagerResponseDTO,
    Failure | Error,
    void,
    UserSourceCodeManagerRequestDTORequestBody,
    void
  >
    verb="PUT"
    path={`/user-source-code-manager`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateUserSourceCodeManagerProps = Omit<
  UseMutateProps<
    ResponseUserSourceCodeManagerResponseDTO,
    Failure | Error,
    void,
    UserSourceCodeManagerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * update user source code manager
 */
export const useUpdateUserSourceCodeManager = (props: UseUpdateUserSourceCodeManagerProps) =>
  useMutate<
    ResponseUserSourceCodeManagerResponseDTO,
    Failure | Error,
    void,
    UserSourceCodeManagerRequestDTORequestBody,
    void
  >('PUT', `/user-source-code-manager`, { base: getConfig('ng/api'), ...props })

/**
 * update user source code manager
 */
export const updateUserSourceCodeManagerPromise = (
  props: MutateUsingFetchProps<
    ResponseUserSourceCodeManagerResponseDTO,
    Failure | Error,
    void,
    UserSourceCodeManagerRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseUserSourceCodeManagerResponseDTO,
    Failure | Error,
    void,
    UserSourceCodeManagerRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/user-source-code-manager`, props, signal)

export interface GetAggregatedUsersQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type GetAggregatedUsersProps = Omit<
  MutateProps<ResponsePageUserAggregate, Failure | Error, GetAggregatedUsersQueryParams, ACLAggregateFilter, void>,
  'path' | 'verb'
>

/**
 * Get a page of active users for access control
 */
export const GetAggregatedUsers = (props: GetAggregatedUsersProps) => (
  <Mutate<ResponsePageUserAggregate, Failure | Error, GetAggregatedUsersQueryParams, ACLAggregateFilter, void>
    verb="POST"
    path={`/user/aggregate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAggregatedUsersProps = Omit<
  UseMutateProps<ResponsePageUserAggregate, Failure | Error, GetAggregatedUsersQueryParams, ACLAggregateFilter, void>,
  'path' | 'verb'
>

/**
 * Get a page of active users for access control
 */
export const useGetAggregatedUsers = (props: UseGetAggregatedUsersProps) =>
  useMutate<ResponsePageUserAggregate, Failure | Error, GetAggregatedUsersQueryParams, ACLAggregateFilter, void>(
    'POST',
    `/user/aggregate`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get a page of active users for access control
 */
export const getAggregatedUsersPromise = (
  props: MutateUsingFetchProps<
    ResponsePageUserAggregate,
    Failure | Error,
    GetAggregatedUsersQueryParams,
    ACLAggregateFilter,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponsePageUserAggregate, Failure | Error, GetAggregatedUsersQueryParams, ACLAggregateFilter, void>(
    'POST',
    getConfig('ng/api'),
    `/user/aggregate`,
    props,
    signal
  )

export interface GetAggregatedUserQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetAggregatedUserPathParams {
  userId: string
}

export type GetAggregatedUserProps = Omit<
  GetProps<ResponseUserAggregate, Failure | Error, GetAggregatedUserQueryParams, GetAggregatedUserPathParams>,
  'path'
> &
  GetAggregatedUserPathParams

/**
 * Get a user by userId for access control
 */
export const GetAggregatedUser = ({ userId, ...props }: GetAggregatedUserProps) => (
  <Get<ResponseUserAggregate, Failure | Error, GetAggregatedUserQueryParams, GetAggregatedUserPathParams>
    path={`/user/aggregate/${userId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAggregatedUserProps = Omit<
  UseGetProps<ResponseUserAggregate, Failure | Error, GetAggregatedUserQueryParams, GetAggregatedUserPathParams>,
  'path'
> &
  GetAggregatedUserPathParams

/**
 * Get a user by userId for access control
 */
export const useGetAggregatedUser = ({ userId, ...props }: UseGetAggregatedUserProps) =>
  useGet<ResponseUserAggregate, Failure | Error, GetAggregatedUserQueryParams, GetAggregatedUserPathParams>(
    (paramsInPath: GetAggregatedUserPathParams) => `/user/aggregate/${paramsInPath.userId}`,
    { base: getConfig('ng/api'), pathParams: { userId }, ...props }
  )

/**
 * Get a user by userId for access control
 */
export const getAggregatedUserPromise = (
  {
    userId,
    ...props
  }: GetUsingFetchProps<
    ResponseUserAggregate,
    Failure | Error,
    GetAggregatedUserQueryParams,
    GetAggregatedUserPathParams
  > & { userId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseUserAggregate, Failure | Error, GetAggregatedUserQueryParams, GetAggregatedUserPathParams>(
    getConfig('ng/api'),
    `/user/aggregate/${userId}`,
    props,
    signal
  )

export interface GetUserAllProjectsInfoQueryParams {
  accountId?: string
  userId?: string
}

export type GetUserAllProjectsInfoProps = Omit<
  GetProps<ResponseListProject, Failure | Error, GetUserAllProjectsInfoQueryParams, void>,
  'path'
>

/**
 * get user all projects information
 */
export const GetUserAllProjectsInfo = (props: GetUserAllProjectsInfoProps) => (
  <Get<ResponseListProject, Failure | Error, GetUserAllProjectsInfoQueryParams, void>
    path={`/user/all-projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserAllProjectsInfoProps = Omit<
  UseGetProps<ResponseListProject, Failure | Error, GetUserAllProjectsInfoQueryParams, void>,
  'path'
>

/**
 * get user all projects information
 */
export const useGetUserAllProjectsInfo = (props: UseGetUserAllProjectsInfoProps) =>
  useGet<ResponseListProject, Failure | Error, GetUserAllProjectsInfoQueryParams, void>(`/user/all-projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * get user all projects information
 */
export const getUserAllProjectsInfoPromise = (
  props: GetUsingFetchProps<ResponseListProject, Failure | Error, GetUserAllProjectsInfoQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListProject, Failure | Error, GetUserAllProjectsInfoQueryParams, void>(
    getConfig('ng/api'),
    `/user/all-projects`,
    props,
    signal
  )

export interface GetUsersQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type GetUsersProps = Omit<
  MutateProps<ResponsePageUserMetadataDTO, Failure | Error, GetUsersQueryParams, UserFilterRequestBody, void>,
  'path' | 'verb'
>

/**
 * Get a list of users
 */
export const GetUsers = (props: GetUsersProps) => (
  <Mutate<ResponsePageUserMetadataDTO, Failure | Error, GetUsersQueryParams, UserFilterRequestBody, void>
    verb="POST"
    path={`/user/batch`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUsersProps = Omit<
  UseMutateProps<ResponsePageUserMetadataDTO, Failure | Error, GetUsersQueryParams, UserFilterRequestBody, void>,
  'path' | 'verb'
>

/**
 * Get a list of users
 */
export const useGetUsers = (props: UseGetUsersProps) =>
  useMutate<ResponsePageUserMetadataDTO, Failure | Error, GetUsersQueryParams, UserFilterRequestBody, void>(
    'POST',
    `/user/batch`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get a list of users
 */
export const getUsersPromise = (
  props: MutateUsingFetchProps<
    ResponsePageUserMetadataDTO,
    Failure | Error,
    GetUsersQueryParams,
    UserFilterRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponsePageUserMetadataDTO, Failure | Error, GetUsersQueryParams, UserFilterRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/user/batch`,
    props,
    signal
  )

export interface GetCurrentUserInfoQueryParams {
  accountIdentifier: string
}

export type GetCurrentUserInfoProps = Omit<
  GetProps<ResponseUserInfo, Failure | Error, GetCurrentUserInfoQueryParams, void>,
  'path'
>

/**
 * get current user information
 */
export const GetCurrentUserInfo = (props: GetCurrentUserInfoProps) => (
  <Get<ResponseUserInfo, Failure | Error, GetCurrentUserInfoQueryParams, void>
    path={`/user/currentUser`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCurrentUserInfoProps = Omit<
  UseGetProps<ResponseUserInfo, Failure | Error, GetCurrentUserInfoQueryParams, void>,
  'path'
>

/**
 * get current user information
 */
export const useGetCurrentUserInfo = (props: UseGetCurrentUserInfoProps) =>
  useGet<ResponseUserInfo, Failure | Error, GetCurrentUserInfoQueryParams, void>(`/user/currentUser`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * get current user information
 */
export const getCurrentUserInfoPromise = (
  props: GetUsingFetchProps<ResponseUserInfo, Failure | Error, GetCurrentUserInfoQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseUserInfo, Failure | Error, GetCurrentUserInfoQueryParams, void>(
    getConfig('ng/api'),
    `/user/currentUser`,
    props,
    signal
  )

export interface GetCurrentGenUsersQueryParams {
  accountIdentifier: string
  searchString?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type GetCurrentGenUsersProps = Omit<
  GetProps<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>,
  'path'
>

/**
 * Get users from current gen for an account
 */
export const GetCurrentGenUsers = (props: GetCurrentGenUsersProps) => (
  <Get<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>
    path={`/user/currentgen`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCurrentGenUsersProps = Omit<
  UseGetProps<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>,
  'path'
>

/**
 * Get users from current gen for an account
 */
export const useGetCurrentGenUsers = (props: UseGetCurrentGenUsersProps) =>
  useGet<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>(`/user/currentgen`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get users from current gen for an account
 */
export const getCurrentGenUsersPromise = (
  props: GetUsingFetchProps<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>(
    getConfig('ng/api'),
    `/user/currentgen`,
    props,
    signal
  )

export interface DisableTwoFactorAuthQueryParams {
  accountIdentifier?: string
}

export type DisableTwoFactorAuthProps = Omit<
  MutateProps<ResponseUserInfo, Failure | Error, DisableTwoFactorAuthQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * disable two factor auth settings
 */
export const DisableTwoFactorAuth = (props: DisableTwoFactorAuthProps) => (
  <Mutate<ResponseUserInfo, Failure | Error, DisableTwoFactorAuthQueryParams, void, void>
    verb="PUT"
    path={`/user/disable-two-factor-auth`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDisableTwoFactorAuthProps = Omit<
  UseMutateProps<ResponseUserInfo, Failure | Error, DisableTwoFactorAuthQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * disable two factor auth settings
 */
export const useDisableTwoFactorAuth = (props: UseDisableTwoFactorAuthProps) =>
  useMutate<ResponseUserInfo, Failure | Error, DisableTwoFactorAuthQueryParams, void, void>(
    'PUT',
    `/user/disable-two-factor-auth`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * disable two factor auth settings
 */
export const disableTwoFactorAuthPromise = (
  props: MutateUsingFetchProps<ResponseUserInfo, Failure | Error, DisableTwoFactorAuthQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserInfo, Failure | Error, DisableTwoFactorAuthQueryParams, void, void>(
    'PUT',
    getConfig('ng/api'),
    `/user/disable-two-factor-auth`,
    props,
    signal
  )

export interface EnableTwoFactorAuthQueryParams {
  accountIdentifier?: string
}

export type EnableTwoFactorAuthProps = Omit<
  MutateProps<ResponseUserInfo, Failure | Error, EnableTwoFactorAuthQueryParams, TwoFactorAuthSettingsInfo, void>,
  'path' | 'verb'
>

/**
 * enable two factor auth settings
 */
export const EnableTwoFactorAuth = (props: EnableTwoFactorAuthProps) => (
  <Mutate<ResponseUserInfo, Failure | Error, EnableTwoFactorAuthQueryParams, TwoFactorAuthSettingsInfo, void>
    verb="PUT"
    path={`/user/enable-two-factor-auth`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseEnableTwoFactorAuthProps = Omit<
  UseMutateProps<ResponseUserInfo, Failure | Error, EnableTwoFactorAuthQueryParams, TwoFactorAuthSettingsInfo, void>,
  'path' | 'verb'
>

/**
 * enable two factor auth settings
 */
export const useEnableTwoFactorAuth = (props: UseEnableTwoFactorAuthProps) =>
  useMutate<ResponseUserInfo, Failure | Error, EnableTwoFactorAuthQueryParams, TwoFactorAuthSettingsInfo, void>(
    'PUT',
    `/user/enable-two-factor-auth`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * enable two factor auth settings
 */
export const enableTwoFactorAuthPromise = (
  props: MutateUsingFetchProps<
    ResponseUserInfo,
    Failure | Error,
    EnableTwoFactorAuthQueryParams,
    TwoFactorAuthSettingsInfo,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserInfo, Failure | Error, EnableTwoFactorAuthQueryParams, TwoFactorAuthSettingsInfo, void>(
    'PUT',
    getConfig('ng/api'),
    `/user/enable-two-factor-auth`,
    props,
    signal
  )

export interface IsEmailRegisteredQueryParams {
  email: string
}

export type IsEmailRegisteredProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, IsEmailRegisteredQueryParams, void>,
  'path'
>

/**
 * checks if email is already registered
 */
export const IsEmailRegistered = (props: IsEmailRegisteredProps) => (
  <Get<ResponseBoolean, Failure | Error, IsEmailRegisteredQueryParams, void>
    path={`/user/is-email-registered`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseIsEmailRegisteredProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, IsEmailRegisteredQueryParams, void>,
  'path'
>

/**
 * checks if email is already registered
 */
export const useIsEmailRegistered = (props: UseIsEmailRegisteredProps) =>
  useGet<ResponseBoolean, Failure | Error, IsEmailRegisteredQueryParams, void>(`/user/is-email-registered`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * checks if email is already registered
 */
export const isEmailRegisteredPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, IsEmailRegisteredQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, IsEmailRegisteredQueryParams, void>(
    getConfig('ng/api'),
    `/user/is-email-registered`,
    props,
    signal
  )

export interface CheckIfLastAdminQueryParams {
  userId?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CheckIfLastAdminProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, CheckIfLastAdminQueryParams, void>,
  'path'
>

/**
 * check if user is last admin at the scope
 */
export const CheckIfLastAdmin = (props: CheckIfLastAdminProps) => (
  <Get<ResponseBoolean, Failure | Error, CheckIfLastAdminQueryParams, void>
    path={`/user/last-admin`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCheckIfLastAdminProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, CheckIfLastAdminQueryParams, void>,
  'path'
>

/**
 * check if user is last admin at the scope
 */
export const useCheckIfLastAdmin = (props: UseCheckIfLastAdminProps) =>
  useGet<ResponseBoolean, Failure | Error, CheckIfLastAdminQueryParams, void>(`/user/last-admin`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * check if user is last admin at the scope
 */
export const checkIfLastAdminPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, CheckIfLastAdminQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, CheckIfLastAdminQueryParams, void>(
    getConfig('ng/api'),
    `/user/last-admin`,
    props,
    signal
  )

export interface ChangeUserPasswordQueryParams {
  accountIdentifier?: string
}

export type ChangeUserPasswordProps = Omit<
  MutateProps<ResponsePasswordChangeResponse, Failure | Error, ChangeUserPasswordQueryParams, PasswordChangeDTO, void>,
  'path' | 'verb'
>

/**
 * Change user password
 */
export const ChangeUserPassword = (props: ChangeUserPasswordProps) => (
  <Mutate<ResponsePasswordChangeResponse, Failure | Error, ChangeUserPasswordQueryParams, PasswordChangeDTO, void>
    verb="PUT"
    path={`/user/password`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseChangeUserPasswordProps = Omit<
  UseMutateProps<
    ResponsePasswordChangeResponse,
    Failure | Error,
    ChangeUserPasswordQueryParams,
    PasswordChangeDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Change user password
 */
export const useChangeUserPassword = (props: UseChangeUserPasswordProps) =>
  useMutate<ResponsePasswordChangeResponse, Failure | Error, ChangeUserPasswordQueryParams, PasswordChangeDTO, void>(
    'PUT',
    `/user/password`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Change user password
 */
export const changeUserPasswordPromise = (
  props: MutateUsingFetchProps<
    ResponsePasswordChangeResponse,
    Failure | Error,
    ChangeUserPasswordQueryParams,
    PasswordChangeDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePasswordChangeResponse,
    Failure | Error,
    ChangeUserPasswordQueryParams,
    PasswordChangeDTO,
    void
  >('PUT', getConfig('ng/api'), `/user/password`, props, signal)

export interface GetUserProjectInfoQueryParams {
  accountId?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type GetUserProjectInfoProps = Omit<
  GetProps<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>,
  'path'
>

/**
 * get user project information
 */
export const GetUserProjectInfo = (props: GetUserProjectInfoProps) => (
  <Get<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>
    path={`/user/projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserProjectInfoProps = Omit<
  UseGetProps<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>,
  'path'
>

/**
 * get user project information
 */
export const useGetUserProjectInfo = (props: UseGetUserProjectInfoProps) =>
  useGet<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>(`/user/projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * get user project information
 */
export const getUserProjectInfoPromise = (
  props: GetUsingFetchProps<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>(
    getConfig('ng/api'),
    `/user/projects`,
    props,
    signal
  )

export interface GetAccessibleProjectsCountQueryParams {
  accountIdentifier?: string
  userId?: string
  startTime?: number
  endTime?: number
}

export type GetAccessibleProjectsCountProps = Omit<
  GetProps<ResponseActiveProjectsCountDTO, Failure | Error, GetAccessibleProjectsCountQueryParams, void>,
  'path'
>

/**
 * Get count of projects accessible to a user
 */
export const GetAccessibleProjectsCount = (props: GetAccessibleProjectsCountProps) => (
  <Get<ResponseActiveProjectsCountDTO, Failure | Error, GetAccessibleProjectsCountQueryParams, void>
    path={`/user/projects-count`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAccessibleProjectsCountProps = Omit<
  UseGetProps<ResponseActiveProjectsCountDTO, Failure | Error, GetAccessibleProjectsCountQueryParams, void>,
  'path'
>

/**
 * Get count of projects accessible to a user
 */
export const useGetAccessibleProjectsCount = (props: UseGetAccessibleProjectsCountProps) =>
  useGet<ResponseActiveProjectsCountDTO, Failure | Error, GetAccessibleProjectsCountQueryParams, void>(
    `/user/projects-count`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get count of projects accessible to a user
 */
export const getAccessibleProjectsCountPromise = (
  props: GetUsingFetchProps<
    ResponseActiveProjectsCountDTO,
    Failure | Error,
    GetAccessibleProjectsCountQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseActiveProjectsCountDTO, Failure | Error, GetAccessibleProjectsCountQueryParams, void>(
    getConfig('ng/api'),
    `/user/projects-count`,
    props,
    signal
  )

export interface ResetTwoFactorAuthQueryParams {
  accountIdentifier?: string
}

export interface ResetTwoFactorAuthPathParams {
  userId: string
}

export type ResetTwoFactorAuthProps = Omit<
  GetProps<RestResponseBoolean, Failure | Error, ResetTwoFactorAuthQueryParams, ResetTwoFactorAuthPathParams>,
  'path'
> &
  ResetTwoFactorAuthPathParams

/**
 * resend email for two factor authorization
 */
export const ResetTwoFactorAuth = ({ userId, ...props }: ResetTwoFactorAuthProps) => (
  <Get<RestResponseBoolean, Failure | Error, ResetTwoFactorAuthQueryParams, ResetTwoFactorAuthPathParams>
    path={`/user/reset-two-factor-auth/${userId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseResetTwoFactorAuthProps = Omit<
  UseGetProps<RestResponseBoolean, Failure | Error, ResetTwoFactorAuthQueryParams, ResetTwoFactorAuthPathParams>,
  'path'
> &
  ResetTwoFactorAuthPathParams

/**
 * resend email for two factor authorization
 */
export const useResetTwoFactorAuth = ({ userId, ...props }: UseResetTwoFactorAuthProps) =>
  useGet<RestResponseBoolean, Failure | Error, ResetTwoFactorAuthQueryParams, ResetTwoFactorAuthPathParams>(
    (paramsInPath: ResetTwoFactorAuthPathParams) => `/user/reset-two-factor-auth/${paramsInPath.userId}`,
    { base: getConfig('ng/api'), pathParams: { userId }, ...props }
  )

/**
 * resend email for two factor authorization
 */
export const resetTwoFactorAuthPromise = (
  {
    userId,
    ...props
  }: GetUsingFetchProps<
    RestResponseBoolean,
    Failure | Error,
    ResetTwoFactorAuthQueryParams,
    ResetTwoFactorAuthPathParams
  > & { userId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseBoolean, Failure | Error, ResetTwoFactorAuthQueryParams, ResetTwoFactorAuthPathParams>(
    getConfig('ng/api'),
    `/user/reset-two-factor-auth/${userId}`,
    props,
    signal
  )

export interface GetTwoFactorAuthSettingsQueryParams {
  accountIdentifier?: string
}

export interface GetTwoFactorAuthSettingsPathParams {
  authMechanism: 'TOTP'
}

export type GetTwoFactorAuthSettingsProps = Omit<
  GetProps<
    ResponseTwoFactorAuthSettingsInfo,
    Failure | Error,
    GetTwoFactorAuthSettingsQueryParams,
    GetTwoFactorAuthSettingsPathParams
  >,
  'path'
> &
  GetTwoFactorAuthSettingsPathParams

/**
 * get two factor auth settings
 */
export const GetTwoFactorAuthSettings = ({ authMechanism, ...props }: GetTwoFactorAuthSettingsProps) => (
  <Get<
    ResponseTwoFactorAuthSettingsInfo,
    Failure | Error,
    GetTwoFactorAuthSettingsQueryParams,
    GetTwoFactorAuthSettingsPathParams
  >
    path={`/user/two-factor-auth/${authMechanism}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTwoFactorAuthSettingsProps = Omit<
  UseGetProps<
    ResponseTwoFactorAuthSettingsInfo,
    Failure | Error,
    GetTwoFactorAuthSettingsQueryParams,
    GetTwoFactorAuthSettingsPathParams
  >,
  'path'
> &
  GetTwoFactorAuthSettingsPathParams

/**
 * get two factor auth settings
 */
export const useGetTwoFactorAuthSettings = ({ authMechanism, ...props }: UseGetTwoFactorAuthSettingsProps) =>
  useGet<
    ResponseTwoFactorAuthSettingsInfo,
    Failure | Error,
    GetTwoFactorAuthSettingsQueryParams,
    GetTwoFactorAuthSettingsPathParams
  >((paramsInPath: GetTwoFactorAuthSettingsPathParams) => `/user/two-factor-auth/${paramsInPath.authMechanism}`, {
    base: getConfig('ng/api'),
    pathParams: { authMechanism },
    ...props
  })

/**
 * get two factor auth settings
 */
export const getTwoFactorAuthSettingsPromise = (
  {
    authMechanism,
    ...props
  }: GetUsingFetchProps<
    ResponseTwoFactorAuthSettingsInfo,
    Failure | Error,
    GetTwoFactorAuthSettingsQueryParams,
    GetTwoFactorAuthSettingsPathParams
  > & { authMechanism: 'TOTP' },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseTwoFactorAuthSettingsInfo,
    Failure | Error,
    GetTwoFactorAuthSettingsQueryParams,
    GetTwoFactorAuthSettingsPathParams
  >(getConfig('ng/api'), `/user/two-factor-auth/${authMechanism}`, props, signal)

export interface UnlockUserQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface UnlockUserPathParams {
  userId: string
}

export type UnlockUserProps = Omit<
  MutateProps<ResponseUserInfo, Failure | Error, UnlockUserQueryParams, void, UnlockUserPathParams>,
  'path' | 'verb'
> &
  UnlockUserPathParams

/**
 * unlock user
 */
export const UnlockUser = ({ userId, ...props }: UnlockUserProps) => (
  <Mutate<ResponseUserInfo, Failure | Error, UnlockUserQueryParams, void, UnlockUserPathParams>
    verb="PUT"
    path={`/user/unlock-user/${userId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUnlockUserProps = Omit<
  UseMutateProps<ResponseUserInfo, Failure | Error, UnlockUserQueryParams, void, UnlockUserPathParams>,
  'path' | 'verb'
> &
  UnlockUserPathParams

/**
 * unlock user
 */
export const useUnlockUser = ({ userId, ...props }: UseUnlockUserProps) =>
  useMutate<ResponseUserInfo, Failure | Error, UnlockUserQueryParams, void, UnlockUserPathParams>(
    'PUT',
    (paramsInPath: UnlockUserPathParams) => `/user/unlock-user/${paramsInPath.userId}`,
    { base: getConfig('ng/api'), pathParams: { userId }, ...props }
  )

/**
 * unlock user
 */
export const unlockUserPromise = (
  {
    userId,
    ...props
  }: MutateUsingFetchProps<ResponseUserInfo, Failure | Error, UnlockUserQueryParams, void, UnlockUserPathParams> & {
    userId: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserInfo, Failure | Error, UnlockUserQueryParams, void, UnlockUserPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/user/unlock-user/${userId}`,
    props,
    signal
  )

export interface UpdateUserMetadataPathParams {
  userId: string
}

export type UpdateUserMetadataProps = Omit<
  MutateProps<ResponseUserMetadata, Failure | Error, void, UserMetadataDTO, UpdateUserMetadataPathParams>,
  'path' | 'verb'
> &
  UpdateUserMetadataPathParams

/**
 * update user metadata
 */
export const UpdateUserMetadata = ({ userId, ...props }: UpdateUserMetadataProps) => (
  <Mutate<ResponseUserMetadata, Failure | Error, void, UserMetadataDTO, UpdateUserMetadataPathParams>
    verb="PUT"
    path={`/user/update-user-metadata/${userId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateUserMetadataProps = Omit<
  UseMutateProps<ResponseUserMetadata, Failure | Error, void, UserMetadataDTO, UpdateUserMetadataPathParams>,
  'path' | 'verb'
> &
  UpdateUserMetadataPathParams

/**
 * update user metadata
 */
export const useUpdateUserMetadata = ({ userId, ...props }: UseUpdateUserMetadataProps) =>
  useMutate<ResponseUserMetadata, Failure | Error, void, UserMetadataDTO, UpdateUserMetadataPathParams>(
    'PUT',
    (paramsInPath: UpdateUserMetadataPathParams) => `/user/update-user-metadata/${paramsInPath.userId}`,
    { base: getConfig('ng/api'), pathParams: { userId }, ...props }
  )

/**
 * update user metadata
 */
export const updateUserMetadataPromise = (
  {
    userId,
    ...props
  }: MutateUsingFetchProps<
    ResponseUserMetadata,
    Failure | Error,
    void,
    UserMetadataDTO,
    UpdateUserMetadataPathParams
  > & { userId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserMetadata, Failure | Error, void, UserMetadataDTO, UpdateUserMetadataPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/user/update-user-metadata/${userId}`,
    props,
    signal
  )

export interface AddUsersQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type AddUsersProps = Omit<
  MutateProps<ResponseAddUsersResponse, Failure | Error, AddUsersQueryParams, AddUsers, void>,
  'path' | 'verb'
>

/**
 * Add users to a scope
 */
export const AddUsers = (props: AddUsersProps) => (
  <Mutate<ResponseAddUsersResponse, Failure | Error, AddUsersQueryParams, AddUsers, void>
    verb="POST"
    path={`/user/users`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAddUsersProps = Omit<
  UseMutateProps<ResponseAddUsersResponse, Failure | Error, AddUsersQueryParams, AddUsers, void>,
  'path' | 'verb'
>

/**
 * Add users to a scope
 */
export const useAddUsers = (props: UseAddUsersProps) =>
  useMutate<ResponseAddUsersResponse, Failure | Error, AddUsersQueryParams, AddUsers, void>('POST', `/user/users`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Add users to a scope
 */
export const addUsersPromise = (
  props: MutateUsingFetchProps<ResponseAddUsersResponse, Failure | Error, AddUsersQueryParams, AddUsers, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseAddUsersResponse, Failure | Error, AddUsersQueryParams, AddUsers, void>(
    'POST',
    getConfig('ng/api'),
    `/user/users`,
    props,
    signal
  )

export interface RemoveUserQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type RemoveUserProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Remove user as the collaborator from the scope
 */
export const RemoveUser = (props: RemoveUserProps) => (
  <Mutate<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>
    verb="DELETE"
    path={`/user`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRemoveUserProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Remove user as the collaborator from the scope
 */
export const useRemoveUser = (props: UseRemoveUserProps) =>
  useMutate<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>('DELETE', `/user`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Remove user as the collaborator from the scope
 */
export const removeUserPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/user`,
    props,
    signal
  )

export interface UpdateUserNameQueryParams {
  accountIdentifier?: string
}

export interface UpdateUserNamePathParams {
  userId: string
}

export type UpdateUserNameProps = Omit<
  MutateProps<
    ResponseUserInfo,
    Failure | Error,
    UpdateUserNameQueryParams,
    UserInfoUpdateDTO,
    UpdateUserNamePathParams
  >,
  'path' | 'verb'
> &
  UpdateUserNamePathParams

/**
 * update user information
 */
export const UpdateUserName = ({ userId, ...props }: UpdateUserNameProps) => (
  <Mutate<ResponseUserInfo, Failure | Error, UpdateUserNameQueryParams, UserInfoUpdateDTO, UpdateUserNamePathParams>
    verb="PUT"
    path={`/user/${userId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateUserNameProps = Omit<
  UseMutateProps<
    ResponseUserInfo,
    Failure | Error,
    UpdateUserNameQueryParams,
    UserInfoUpdateDTO,
    UpdateUserNamePathParams
  >,
  'path' | 'verb'
> &
  UpdateUserNamePathParams

/**
 * update user information
 */
export const useUpdateUserName = ({ userId, ...props }: UseUpdateUserNameProps) =>
  useMutate<ResponseUserInfo, Failure | Error, UpdateUserNameQueryParams, UserInfoUpdateDTO, UpdateUserNamePathParams>(
    'PUT',
    (paramsInPath: UpdateUserNamePathParams) => `/user/${paramsInPath.userId}`,
    { base: getConfig('ng/api'), pathParams: { userId }, ...props }
  )

/**
 * update user information
 */
export const updateUserNamePromise = (
  {
    userId,
    ...props
  }: MutateUsingFetchProps<
    ResponseUserInfo,
    Failure | Error,
    UpdateUserNameQueryParams,
    UserInfoUpdateDTO,
    UpdateUserNamePathParams
  > & { userId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseUserInfo,
    Failure | Error,
    UpdateUserNameQueryParams,
    UserInfoUpdateDTO,
    UpdateUserNamePathParams
  >('PUT', getConfig('ng/api'), `/user/${userId}`, props, signal)

export interface ListDelegateConfigsNgV2QueryParams {
  offset?: string
  limit?: string
  fieldsIncluded?: string[]
  fieldsExcluded?: string[]
  orgId?: string
  projectId?: string
}

export interface ListDelegateConfigsNgV2PathParams {
  accountId: string
}

export type ListDelegateConfigsNgV2Props = Omit<
  GetProps<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2QueryParams,
    ListDelegateConfigsNgV2PathParams
  >,
  'path'
> &
  ListDelegateConfigsNgV2PathParams

/**
 * Lists the Delegate Configurations
 */
export const ListDelegateConfigsNgV2 = ({ accountId, ...props }: ListDelegateConfigsNgV2Props) => (
  <Get<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2QueryParams,
    ListDelegateConfigsNgV2PathParams
  >
    path={`/v2/accounts/${accountId}/delegate-configs`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListDelegateConfigsNgV2Props = Omit<
  UseGetProps<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2QueryParams,
    ListDelegateConfigsNgV2PathParams
  >,
  'path'
> &
  ListDelegateConfigsNgV2PathParams

/**
 * Lists the Delegate Configurations
 */
export const useListDelegateConfigsNgV2 = ({ accountId, ...props }: UseListDelegateConfigsNgV2Props) =>
  useGet<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2QueryParams,
    ListDelegateConfigsNgV2PathParams
  >((paramsInPath: ListDelegateConfigsNgV2PathParams) => `/v2/accounts/${paramsInPath.accountId}/delegate-configs`, {
    base: getConfig('ng/api'),
    pathParams: { accountId },
    ...props
  })

/**
 * Lists the Delegate Configurations
 */
export const listDelegateConfigsNgV2Promise = (
  {
    accountId,
    ...props
  }: GetUsingFetchProps<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2QueryParams,
    ListDelegateConfigsNgV2PathParams
  > & { accountId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2QueryParams,
    ListDelegateConfigsNgV2PathParams
  >(getConfig('ng/api'), `/v2/accounts/${accountId}/delegate-configs`, props, signal)

export interface AddDelegateProfileNgV2PathParams {
  accountId: string
}

export type AddDelegateProfileNgV2Props = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    void,
    DelegateProfileDetailsNgRequestBody,
    AddDelegateProfileNgV2PathParams
  >,
  'path' | 'verb'
> &
  AddDelegateProfileNgV2PathParams

/**
 * Adds a Delegate profile
 */
export const AddDelegateProfileNgV2 = ({ accountId, ...props }: AddDelegateProfileNgV2Props) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    void,
    DelegateProfileDetailsNgRequestBody,
    AddDelegateProfileNgV2PathParams
  >
    verb="POST"
    path={`/v2/accounts/${accountId}/delegate-configs`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAddDelegateProfileNgV2Props = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    void,
    DelegateProfileDetailsNgRequestBody,
    AddDelegateProfileNgV2PathParams
  >,
  'path' | 'verb'
> &
  AddDelegateProfileNgV2PathParams

/**
 * Adds a Delegate profile
 */
export const useAddDelegateProfileNgV2 = ({ accountId, ...props }: UseAddDelegateProfileNgV2Props) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    void,
    DelegateProfileDetailsNgRequestBody,
    AddDelegateProfileNgV2PathParams
  >(
    'POST',
    (paramsInPath: AddDelegateProfileNgV2PathParams) => `/v2/accounts/${paramsInPath.accountId}/delegate-configs`,
    { base: getConfig('ng/api'), pathParams: { accountId }, ...props }
  )

/**
 * Adds a Delegate profile
 */
export const addDelegateProfileNgV2Promise = (
  {
    accountId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    void,
    DelegateProfileDetailsNgRequestBody,
    AddDelegateProfileNgV2PathParams
  > & { accountId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    void,
    DelegateProfileDetailsNgRequestBody,
    AddDelegateProfileNgV2PathParams
  >('POST', getConfig('ng/api'), `/v2/accounts/${accountId}/delegate-configs`, props, signal)

export interface ListDelegateConfigsNgV2WithFilterQueryParams {
  orgId?: string
  projectId?: string
  filterIdentifier?: string
  searchTerm?: string
  offset?: string
  limit?: string
  fieldsIncluded?: string[]
  fieldsExcluded?: string[]
}

export interface ListDelegateConfigsNgV2WithFilterPathParams {
  accountId: string
}

export type ListDelegateConfigsNgV2WithFilterProps = Omit<
  MutateProps<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2WithFilterQueryParams,
    DelegateProfileFilterProperties,
    ListDelegateConfigsNgV2WithFilterPathParams
  >,
  'path' | 'verb'
> &
  ListDelegateConfigsNgV2WithFilterPathParams

/**
 * Lists the Delegate configs with filter
 */
export const ListDelegateConfigsNgV2WithFilter = ({ accountId, ...props }: ListDelegateConfigsNgV2WithFilterProps) => (
  <Mutate<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2WithFilterQueryParams,
    DelegateProfileFilterProperties,
    ListDelegateConfigsNgV2WithFilterPathParams
  >
    verb="POST"
    path={`/v2/accounts/${accountId}/delegate-configs/listV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListDelegateConfigsNgV2WithFilterProps = Omit<
  UseMutateProps<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2WithFilterQueryParams,
    DelegateProfileFilterProperties,
    ListDelegateConfigsNgV2WithFilterPathParams
  >,
  'path' | 'verb'
> &
  ListDelegateConfigsNgV2WithFilterPathParams

/**
 * Lists the Delegate configs with filter
 */
export const useListDelegateConfigsNgV2WithFilter = ({
  accountId,
  ...props
}: UseListDelegateConfigsNgV2WithFilterProps) =>
  useMutate<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2WithFilterQueryParams,
    DelegateProfileFilterProperties,
    ListDelegateConfigsNgV2WithFilterPathParams
  >(
    'POST',
    (paramsInPath: ListDelegateConfigsNgV2WithFilterPathParams) =>
      `/v2/accounts/${paramsInPath.accountId}/delegate-configs/listV2`,
    { base: getConfig('ng/api'), pathParams: { accountId }, ...props }
  )

/**
 * Lists the Delegate configs with filter
 */
export const listDelegateConfigsNgV2WithFilterPromise = (
  {
    accountId,
    ...props
  }: MutateUsingFetchProps<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2WithFilterQueryParams,
    DelegateProfileFilterProperties,
    ListDelegateConfigsNgV2WithFilterPathParams
  > & { accountId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2WithFilterQueryParams,
    DelegateProfileFilterProperties,
    ListDelegateConfigsNgV2WithFilterPathParams
  >('POST', getConfig('ng/api'), `/v2/accounts/${accountId}/delegate-configs/listV2`, props, signal)

export interface DeleteDelegateConfigNgV2QueryParams {
  orgId?: string
  projectId?: string
}

export interface DeleteDelegateConfigNgV2PathParams {
  accountId: string
}

export type DeleteDelegateConfigNgV2Props = Omit<
  MutateProps<
    ResponseBoolean,
    unknown,
    DeleteDelegateConfigNgV2QueryParams,
    string,
    DeleteDelegateConfigNgV2PathParams
  >,
  'path' | 'verb'
> &
  DeleteDelegateConfigNgV2PathParams

/**
 * Deletes a Delegate config by identifier
 */
export const DeleteDelegateConfigNgV2 = ({ accountId, ...props }: DeleteDelegateConfigNgV2Props) => (
  <Mutate<ResponseBoolean, unknown, DeleteDelegateConfigNgV2QueryParams, string, DeleteDelegateConfigNgV2PathParams>
    verb="DELETE"
    path={`/v2/accounts/${accountId}/delegate-configs`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteDelegateConfigNgV2Props = Omit<
  UseMutateProps<
    ResponseBoolean,
    unknown,
    DeleteDelegateConfigNgV2QueryParams,
    string,
    DeleteDelegateConfigNgV2PathParams
  >,
  'path' | 'verb'
> &
  DeleteDelegateConfigNgV2PathParams

/**
 * Deletes a Delegate config by identifier
 */
export const useDeleteDelegateConfigNgV2 = ({ accountId, ...props }: UseDeleteDelegateConfigNgV2Props) =>
  useMutate<ResponseBoolean, unknown, DeleteDelegateConfigNgV2QueryParams, string, DeleteDelegateConfigNgV2PathParams>(
    'DELETE',
    (paramsInPath: DeleteDelegateConfigNgV2PathParams) => `/v2/accounts/${paramsInPath.accountId}/delegate-configs`,
    { base: getConfig('ng/api'), pathParams: { accountId }, ...props }
  )

/**
 * Deletes a Delegate config by identifier
 */
export const deleteDelegateConfigNgV2Promise = (
  {
    accountId,
    ...props
  }: MutateUsingFetchProps<
    ResponseBoolean,
    unknown,
    DeleteDelegateConfigNgV2QueryParams,
    string,
    DeleteDelegateConfigNgV2PathParams
  > & { accountId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    unknown,
    DeleteDelegateConfigNgV2QueryParams,
    string,
    DeleteDelegateConfigNgV2PathParams
  >('DELETE', getConfig('ng/api'), `/v2/accounts/${accountId}/delegate-configs`, props, signal)

export interface GetDelegateConfigNgV2QueryParams {
  orgId?: string
  projectId?: string
}

export interface GetDelegateConfigNgV2PathParams {
  accountId: string
  delegateConfigIdentifier: string
}

export type GetDelegateConfigNgV2Props = Omit<
  GetProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateConfigNgV2QueryParams,
    GetDelegateConfigNgV2PathParams
  >,
  'path'
> &
  GetDelegateConfigNgV2PathParams

/**
 * Gets Delegate config by identifier
 */
export const GetDelegateConfigNgV2 = ({
  accountId,
  delegateConfigIdentifier,
  ...props
}: GetDelegateConfigNgV2Props) => (
  <Get<RestResponseDelegateProfileDetailsNg, unknown, GetDelegateConfigNgV2QueryParams, GetDelegateConfigNgV2PathParams>
    path={`/v2/accounts/${accountId}/delegate-configs/${delegateConfigIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDelegateConfigNgV2Props = Omit<
  UseGetProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateConfigNgV2QueryParams,
    GetDelegateConfigNgV2PathParams
  >,
  'path'
> &
  GetDelegateConfigNgV2PathParams

/**
 * Gets Delegate config by identifier
 */
export const useGetDelegateConfigNgV2 = ({
  accountId,
  delegateConfigIdentifier,
  ...props
}: UseGetDelegateConfigNgV2Props) =>
  useGet<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateConfigNgV2QueryParams,
    GetDelegateConfigNgV2PathParams
  >(
    (paramsInPath: GetDelegateConfigNgV2PathParams) =>
      `/v2/accounts/${paramsInPath.accountId}/delegate-configs/${paramsInPath.delegateConfigIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountId, delegateConfigIdentifier }, ...props }
  )

/**
 * Gets Delegate config by identifier
 */
export const getDelegateConfigNgV2Promise = (
  {
    accountId,
    delegateConfigIdentifier,
    ...props
  }: GetUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateConfigNgV2QueryParams,
    GetDelegateConfigNgV2PathParams
  > & { accountId: string; delegateConfigIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateConfigNgV2QueryParams,
    GetDelegateConfigNgV2PathParams
  >(getConfig('ng/api'), `/v2/accounts/${accountId}/delegate-configs/${delegateConfigIdentifier}`, props, signal)

export interface UpdateDelegateConfigNgV2QueryParams {
  orgId?: string
  projectId?: string
}

export interface UpdateDelegateConfigNgV2PathParams {
  accountId: string
  delegateConfigIdentifier: string
}

export type UpdateDelegateConfigNgV2Props = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateConfigNgV2QueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateConfigNgV2PathParams
  >,
  'path' | 'verb'
> &
  UpdateDelegateConfigNgV2PathParams

/**
 * Updates a Delegate Configuration
 */
export const UpdateDelegateConfigNgV2 = ({
  accountId,
  delegateConfigIdentifier,
  ...props
}: UpdateDelegateConfigNgV2Props) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateConfigNgV2QueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateConfigNgV2PathParams
  >
    verb="PUT"
    path={`/v2/accounts/${accountId}/delegate-configs/${delegateConfigIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateDelegateConfigNgV2Props = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateConfigNgV2QueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateConfigNgV2PathParams
  >,
  'path' | 'verb'
> &
  UpdateDelegateConfigNgV2PathParams

/**
 * Updates a Delegate Configuration
 */
export const useUpdateDelegateConfigNgV2 = ({
  accountId,
  delegateConfigIdentifier,
  ...props
}: UseUpdateDelegateConfigNgV2Props) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateConfigNgV2QueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateConfigNgV2PathParams
  >(
    'PUT',
    (paramsInPath: UpdateDelegateConfigNgV2PathParams) =>
      `/v2/accounts/${paramsInPath.accountId}/delegate-configs/${paramsInPath.delegateConfigIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountId, delegateConfigIdentifier }, ...props }
  )

/**
 * Updates a Delegate Configuration
 */
export const updateDelegateConfigNgV2Promise = (
  {
    accountId,
    delegateConfigIdentifier,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateConfigNgV2QueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateConfigNgV2PathParams
  > & { accountId: string; delegateConfigIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateConfigNgV2QueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateConfigNgV2PathParams
  >('PUT', getConfig('ng/api'), `/v2/accounts/${accountId}/delegate-configs/${delegateConfigIdentifier}`, props, signal)

export interface UpdateScopingRulesNgV2QueryParams {
  orgId?: string
  projectId?: string
}

export interface UpdateScopingRulesNgV2PathParams {
  accountId: string
  delegateConfigIdentifier: string
}

export type UpdateScopingRulesNgV2Props = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgV2QueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgV2PathParams
  >,
  'path' | 'verb'
> &
  UpdateScopingRulesNgV2PathParams

/**
 * Updates the Scoping Rules inside the Delegate config
 */
export const UpdateScopingRulesNgV2 = ({
  accountId,
  delegateConfigIdentifier,
  ...props
}: UpdateScopingRulesNgV2Props) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgV2QueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgV2PathParams
  >
    verb="PUT"
    path={`/v2/accounts/${accountId}/delegate-configs/${delegateConfigIdentifier}/scoping-rules`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateScopingRulesNgV2Props = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgV2QueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgV2PathParams
  >,
  'path' | 'verb'
> &
  UpdateScopingRulesNgV2PathParams

/**
 * Updates the Scoping Rules inside the Delegate config
 */
export const useUpdateScopingRulesNgV2 = ({
  accountId,
  delegateConfigIdentifier,
  ...props
}: UseUpdateScopingRulesNgV2Props) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgV2QueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgV2PathParams
  >(
    'PUT',
    (paramsInPath: UpdateScopingRulesNgV2PathParams) =>
      `/v2/accounts/${paramsInPath.accountId}/delegate-configs/${paramsInPath.delegateConfigIdentifier}/scoping-rules`,
    { base: getConfig('ng/api'), pathParams: { accountId, delegateConfigIdentifier }, ...props }
  )

/**
 * Updates the Scoping Rules inside the Delegate config
 */
export const updateScopingRulesNgV2Promise = (
  {
    accountId,
    delegateConfigIdentifier,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgV2QueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgV2PathParams
  > & { accountId: string; delegateConfigIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgV2QueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgV2PathParams
  >(
    'PUT',
    getConfig('ng/api'),
    `/v2/accounts/${accountId}/delegate-configs/${delegateConfigIdentifier}/scoping-rules`,
    props,
    signal
  )

export interface UpdateSelectorsNgV2QueryParams {
  orgId?: string
  projectId?: string
}

export interface UpdateSelectorsNgV2PathParams {
  accountId: string
  delegateConfigIdentifier: string
}

export type UpdateSelectorsNgV2Props = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgV2QueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgV2PathParams
  >,
  'path' | 'verb'
> &
  UpdateSelectorsNgV2PathParams

/**
 * Updates the selectors inside the Delegate config
 */
export const UpdateSelectorsNgV2 = ({ accountId, delegateConfigIdentifier, ...props }: UpdateSelectorsNgV2Props) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgV2QueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgV2PathParams
  >
    verb="PUT"
    path={`/v2/accounts/${accountId}/delegate-configs/${delegateConfigIdentifier}/selectors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateSelectorsNgV2Props = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgV2QueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgV2PathParams
  >,
  'path' | 'verb'
> &
  UpdateSelectorsNgV2PathParams

/**
 * Updates the selectors inside the Delegate config
 */
export const useUpdateSelectorsNgV2 = ({
  accountId,
  delegateConfigIdentifier,
  ...props
}: UseUpdateSelectorsNgV2Props) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgV2QueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgV2PathParams
  >(
    'PUT',
    (paramsInPath: UpdateSelectorsNgV2PathParams) =>
      `/v2/accounts/${paramsInPath.accountId}/delegate-configs/${paramsInPath.delegateConfigIdentifier}/selectors`,
    { base: getConfig('ng/api'), pathParams: { accountId, delegateConfigIdentifier }, ...props }
  )

/**
 * Updates the selectors inside the Delegate config
 */
export const updateSelectorsNgV2Promise = (
  {
    accountId,
    delegateConfigIdentifier,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgV2QueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgV2PathParams
  > & { accountId: string; delegateConfigIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgV2QueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgV2PathParams
  >(
    'PUT',
    getConfig('ng/api'),
    `/v2/accounts/${accountId}/delegate-configs/${delegateConfigIdentifier}/selectors`,
    props,
    signal
  )

export type AddDelegateProfileNgV2noQueryParamsV2Props = Omit<
  MutateProps<RestResponseDelegateProfileDetailsNg, unknown, void, DelegateProfileDetailsNgRequestBody, void>,
  'path' | 'verb'
>

/**
 * Adds a Delegate profile
 */
export const AddDelegateProfileNgV2noQueryParamsV2 = (props: AddDelegateProfileNgV2noQueryParamsV2Props) => (
  <Mutate<RestResponseDelegateProfileDetailsNg, unknown, void, DelegateProfileDetailsNgRequestBody, void>
    verb="POST"
    path={`/v2/delegate-configs`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAddDelegateProfileNgV2noQueryParamsV2Props = Omit<
  UseMutateProps<RestResponseDelegateProfileDetailsNg, unknown, void, DelegateProfileDetailsNgRequestBody, void>,
  'path' | 'verb'
>

/**
 * Adds a Delegate profile
 */
export const useAddDelegateProfileNgV2noQueryParamsV2 = (props: UseAddDelegateProfileNgV2noQueryParamsV2Props) =>
  useMutate<RestResponseDelegateProfileDetailsNg, unknown, void, DelegateProfileDetailsNgRequestBody, void>(
    'POST',
    `/v2/delegate-configs`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Adds a Delegate profile
 */
export const addDelegateProfileNgV2noQueryParamsV2Promise = (
  props: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    void,
    DelegateProfileDetailsNgRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseDelegateProfileDetailsNg, unknown, void, DelegateProfileDetailsNgRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/v2/delegate-configs`,
    props,
    signal
  )

export interface ListSecretsV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifiers?: string[]
  type?: 'SecretFile' | 'SecretText' | 'SSHKey' | 'WinRmCredentials'
  searchTerm?: string
  types?: ('SecretFile' | 'SecretText' | 'SSHKey' | 'WinRmCredentials')[]
  source_category?:
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  includeSecretsFromEverySubScope?: boolean
  includeAllSecretsAccessibleAtScope?: boolean
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type ListSecretsV2Props = Omit<
  GetProps<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>,
  'path'
>

/**
 * Get secrets
 */
export const ListSecretsV2 = (props: ListSecretsV2Props) => (
  <Get<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>
    path={`/v2/secrets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListSecretsV2Props = Omit<
  UseGetProps<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>,
  'path'
>

/**
 * Get secrets
 */
export const useListSecretsV2 = (props: UseListSecretsV2Props) =>
  useGet<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>(`/v2/secrets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get secrets
 */
export const listSecretsV2Promise = (
  props: GetUsingFetchProps<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>(
    getConfig('ng/api'),
    `/v2/secrets`,
    props,
    signal
  )

export interface PostSecretQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  privateSecret?: boolean
}

export type PostSecretProps = Omit<
  MutateProps<ResponseSecretResponseWrapper, Failure | Error, PostSecretQueryParams, SecretRequestWrapper, void>,
  'path' | 'verb'
>

/**
 * Create a secret
 */
export const PostSecret = (props: PostSecretProps) => (
  <Mutate<ResponseSecretResponseWrapper, Failure | Error, PostSecretQueryParams, SecretRequestWrapper, void>
    verb="POST"
    path={`/v2/secrets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretProps = Omit<
  UseMutateProps<ResponseSecretResponseWrapper, Failure | Error, PostSecretQueryParams, SecretRequestWrapper, void>,
  'path' | 'verb'
>

/**
 * Create a secret
 */
export const usePostSecret = (props: UsePostSecretProps) =>
  useMutate<ResponseSecretResponseWrapper, Failure | Error, PostSecretQueryParams, SecretRequestWrapper, void>(
    'POST',
    `/v2/secrets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a secret
 */
export const postSecretPromise = (
  props: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretQueryParams,
    SecretRequestWrapper,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseSecretResponseWrapper, Failure | Error, PostSecretQueryParams, SecretRequestWrapper, void>(
    'POST',
    getConfig('ng/api'),
    `/v2/secrets`,
    props,
    signal
  )

export interface PostSecretFileV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  privateSecret?: boolean
}

export type PostSecretFileV2Props = Omit<
  MutateProps<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create a secret file
 */
export const PostSecretFileV2 = (props: PostSecretFileV2Props) => (
  <Mutate<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>
    verb="POST"
    path={`/v2/secrets/files`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretFileV2Props = Omit<
  UseMutateProps<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create a secret file
 */
export const usePostSecretFileV2 = (props: UsePostSecretFileV2Props) =>
  useMutate<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>(
    'POST',
    `/v2/secrets/files`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a secret file
 */
export const postSecretFileV2Promise = (
  props: MutateUsingFetchProps<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/v2/secrets/files`,
    props,
    signal
  )

export interface PutSecretFileV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface PutSecretFileV2PathParams {
  identifier: string
}

export type PutSecretFileV2Props = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  >,
  'path' | 'verb'
> &
  PutSecretFileV2PathParams

/**
 * Update a secret file
 */
export const PutSecretFileV2 = ({ identifier, ...props }: PutSecretFileV2Props) => (
  <Mutate<ResponseSecretResponseWrapper, Failure | Error, PutSecretFileV2QueryParams, void, PutSecretFileV2PathParams>
    verb="PUT"
    path={`/v2/secrets/files/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretFileV2Props = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  >,
  'path' | 'verb'
> &
  PutSecretFileV2PathParams

/**
 * Update a secret file
 */
export const usePutSecretFileV2 = ({ identifier, ...props }: UsePutSecretFileV2Props) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  >('PUT', (paramsInPath: PutSecretFileV2PathParams) => `/v2/secrets/files/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a secret file
 */
export const putSecretFileV2Promise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  >('PUT', getConfig('ng/api'), `/v2/secrets/files/${identifier}`, props, signal)

export interface ListSecretsV3QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type ListSecretsV3Props = Omit<
  MutateProps<
    ResponsePageSecretResponseWrapper,
    Failure | Error,
    ListSecretsV3QueryParams,
    SecretResourceFilterDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * List secrets
 */
export const ListSecretsV3 = (props: ListSecretsV3Props) => (
  <Mutate<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV3QueryParams, SecretResourceFilterDTO, void>
    verb="POST"
    path={`/v2/secrets/list`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListSecretsV3Props = Omit<
  UseMutateProps<
    ResponsePageSecretResponseWrapper,
    Failure | Error,
    ListSecretsV3QueryParams,
    SecretResourceFilterDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * List secrets
 */
export const useListSecretsV3 = (props: UseListSecretsV3Props) =>
  useMutate<
    ResponsePageSecretResponseWrapper,
    Failure | Error,
    ListSecretsV3QueryParams,
    SecretResourceFilterDTO,
    void
  >('POST', `/v2/secrets/list`, { base: getConfig('ng/api'), ...props })

/**
 * List secrets
 */
export const listSecretsV3Promise = (
  props: MutateUsingFetchProps<
    ResponsePageSecretResponseWrapper,
    Failure | Error,
    ListSecretsV3QueryParams,
    SecretResourceFilterDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageSecretResponseWrapper,
    Failure | Error,
    ListSecretsV3QueryParams,
    SecretResourceFilterDTO,
    void
  >('POST', getConfig('ng/api'), `/v2/secrets/list`, props, signal)

export interface ValidateSecretQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
}

export type ValidateSecretProps = Omit<
  MutateProps<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate a secret
 */
export const ValidateSecret = (props: ValidateSecretProps) => (
  <Mutate<ResponseSecretValidationResultDTO, Failure | Error, ValidateSecretQueryParams, SecretValidationMetaData, void>
    verb="POST"
    path={`/v2/secrets/validate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateSecretProps = Omit<
  UseMutateProps<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate a secret
 */
export const useValidateSecret = (props: UseValidateSecretProps) =>
  useMutate<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >('POST', `/v2/secrets/validate`, { base: getConfig('ng/api'), ...props })

/**
 * Validate a secret
 */
export const validateSecretPromise = (
  props: MutateUsingFetchProps<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >('POST', getConfig('ng/api'), `/v2/secrets/validate`, props, signal)

export interface ValidateSecretIdentifierIsUniqueQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface ValidateSecretIdentifierIsUniquePathParams {
  identifier: string
}

export type ValidateSecretIdentifierIsUniqueProps = Omit<
  GetProps<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  >,
  'path'
> &
  ValidateSecretIdentifierIsUniquePathParams

/**
 * Validate Secret Identifier is unique
 */
export const ValidateSecretIdentifierIsUnique = ({ identifier, ...props }: ValidateSecretIdentifierIsUniqueProps) => (
  <Get<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  >
    path={`/v2/secrets/validateUniqueIdentifier/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateSecretIdentifierIsUniqueProps = Omit<
  UseGetProps<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  >,
  'path'
> &
  ValidateSecretIdentifierIsUniquePathParams

/**
 * Validate Secret Identifier is unique
 */
export const useValidateSecretIdentifierIsUnique = ({
  identifier,
  ...props
}: UseValidateSecretIdentifierIsUniqueProps) =>
  useGet<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  >(
    (paramsInPath: ValidateSecretIdentifierIsUniquePathParams) =>
      `/v2/secrets/validateUniqueIdentifier/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Validate Secret Identifier is unique
 */
export const validateSecretIdentifierIsUniquePromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  >(getConfig('ng/api'), `/v2/secrets/validateUniqueIdentifier/${identifier}`, props, signal)

export interface PostSecretViaYamlQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  privateSecret?: boolean
}

export type PostSecretViaYamlProps = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret via yaml
 */
export const PostSecretViaYaml = (props: PostSecretViaYamlProps) => (
  <Mutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >
    verb="POST"
    path={`/v2/secrets/yaml`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretViaYamlProps = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret via yaml
 */
export const usePostSecretViaYaml = (props: UsePostSecretViaYamlProps) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >('POST', `/v2/secrets/yaml`, { base: getConfig('ng/api'), ...props })

/**
 * Create a secret via yaml
 */
export const postSecretViaYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >('POST', getConfig('ng/api'), `/v2/secrets/yaml`, props, signal)

export interface DeleteSecretV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  forceDelete?: boolean
}

export type DeleteSecretV2Props = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete secret
 */
export const DeleteSecretV2 = (props: DeleteSecretV2Props) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>
    verb="DELETE"
    path={`/v2/secrets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSecretV2Props = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete secret
 */
export const useDeleteSecretV2 = (props: UseDeleteSecretV2Props) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>('DELETE', `/v2/secrets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete secret
 */
export const deleteSecretV2Promise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/v2/secrets`,
    props,
    signal
  )

export interface GetSecretV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetSecretV2PathParams {
  identifier: string
}

export type GetSecretV2Props = Omit<
  GetProps<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>,
  'path'
> &
  GetSecretV2PathParams

/**
 * Gets secret
 */
export const GetSecretV2 = ({ identifier, ...props }: GetSecretV2Props) => (
  <Get<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>
    path={`/v2/secrets/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSecretV2Props = Omit<
  UseGetProps<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>,
  'path'
> &
  GetSecretV2PathParams

/**
 * Gets secret
 */
export const useGetSecretV2 = ({ identifier, ...props }: UseGetSecretV2Props) =>
  useGet<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>(
    (paramsInPath: GetSecretV2PathParams) => `/v2/secrets/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets secret
 */
export const getSecretV2Promise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    GetSecretV2QueryParams,
    GetSecretV2PathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>(
    getConfig('ng/api'),
    `/v2/secrets/${identifier}`,
    props,
    signal
  )

export interface PutSecretQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface PutSecretPathParams {
  identifier: string
}

export type PutSecretProps = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapper,
    PutSecretPathParams
  >,
  'path' | 'verb'
> &
  PutSecretPathParams

/**
 * Update a secret
 */
export const PutSecret = ({ identifier, ...props }: PutSecretProps) => (
  <Mutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapper,
    PutSecretPathParams
  >
    verb="PUT"
    path={`/v2/secrets/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretProps = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapper,
    PutSecretPathParams
  >,
  'path' | 'verb'
> &
  PutSecretPathParams

/**
 * Update a secret
 */
export const usePutSecret = ({ identifier, ...props }: UsePutSecretProps) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapper,
    PutSecretPathParams
  >('PUT', (paramsInPath: PutSecretPathParams) => `/v2/secrets/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a secret
 */
export const putSecretPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapper,
    PutSecretPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapper,
    PutSecretPathParams
  >('PUT', getConfig('ng/api'), `/v2/secrets/${identifier}`, props, signal)

export interface PutSecretViaYamlQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface PutSecretViaYamlPathParams {
  identifier: string
}

export type PutSecretViaYamlProps = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretViaYamlPathParams
  >,
  'path' | 'verb'
> &
  PutSecretViaYamlPathParams

/**
 * Update a secret via yaml
 */
export const PutSecretViaYaml = ({ identifier, ...props }: PutSecretViaYamlProps) => (
  <Mutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretViaYamlPathParams
  >
    verb="PUT"
    path={`/v2/secrets/${identifier}/yaml`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretViaYamlProps = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretViaYamlPathParams
  >,
  'path' | 'verb'
> &
  PutSecretViaYamlPathParams

/**
 * Update a secret via yaml
 */
export const usePutSecretViaYaml = ({ identifier, ...props }: UsePutSecretViaYamlProps) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretViaYamlPathParams
  >('PUT', (paramsInPath: PutSecretViaYamlPathParams) => `/v2/secrets/${paramsInPath.identifier}/yaml`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a secret via yaml
 */
export const putSecretViaYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretViaYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretViaYamlPathParams
  >('PUT', getConfig('ng/api'), `/v2/secrets/${identifier}/yaml`, props, signal)

export interface PostUserGroupV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type PostUserGroupV2Props = Omit<
  MutateProps<
    ResponseUserGroupResponseV2DTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupV2QueryParams,
    UserGroupRequestV2DTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a User Group
 */
export const PostUserGroupV2 = (props: PostUserGroupV2Props) => (
  <Mutate<
    ResponseUserGroupResponseV2DTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupV2QueryParams,
    UserGroupRequestV2DTORequestBody,
    void
  >
    verb="POST"
    path={`/v2/user-groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostUserGroupV2Props = Omit<
  UseMutateProps<
    ResponseUserGroupResponseV2DTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupV2QueryParams,
    UserGroupRequestV2DTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a User Group
 */
export const usePostUserGroupV2 = (props: UsePostUserGroupV2Props) =>
  useMutate<
    ResponseUserGroupResponseV2DTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupV2QueryParams,
    UserGroupRequestV2DTORequestBody,
    void
  >('POST', `/v2/user-groups`, { base: getConfig('ng/api'), ...props })

/**
 * Create a User Group
 */
export const postUserGroupV2Promise = (
  props: MutateUsingFetchProps<
    ResponseUserGroupResponseV2DTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupV2QueryParams,
    UserGroupRequestV2DTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseUserGroupResponseV2DTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupV2QueryParams,
    UserGroupRequestV2DTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/v2/user-groups`, props, signal)

export interface PutUserGroupV2QueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type PutUserGroupV2Props = Omit<
  MutateProps<
    ResponseUserGroupResponseV2DTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupV2QueryParams,
    UserGroupRequestV2DTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a User Group
 */
export const PutUserGroupV2 = (props: PutUserGroupV2Props) => (
  <Mutate<
    ResponseUserGroupResponseV2DTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupV2QueryParams,
    UserGroupRequestV2DTORequestBody,
    void
  >
    verb="PUT"
    path={`/v2/user-groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutUserGroupV2Props = Omit<
  UseMutateProps<
    ResponseUserGroupResponseV2DTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupV2QueryParams,
    UserGroupRequestV2DTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a User Group
 */
export const usePutUserGroupV2 = (props: UsePutUserGroupV2Props) =>
  useMutate<
    ResponseUserGroupResponseV2DTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupV2QueryParams,
    UserGroupRequestV2DTORequestBody,
    void
  >('PUT', `/v2/user-groups`, { base: getConfig('ng/api'), ...props })

/**
 * Update a User Group
 */
export const putUserGroupV2Promise = (
  props: MutateUsingFetchProps<
    ResponseUserGroupResponseV2DTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupV2QueryParams,
    UserGroupRequestV2DTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseUserGroupResponseV2DTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupV2QueryParams,
    UserGroupRequestV2DTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/v2/user-groups`, props, signal)

export interface UpdateTagsForDelegateGroupQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface UpdateTagsForDelegateGroupPathParams {
  identifier: string
}

export type UpdateTagsForDelegateGroupProps = Omit<
  MutateProps<
    RestResponseDelegateGroup,
    unknown,
    UpdateTagsForDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    UpdateTagsForDelegateGroupPathParams
  >,
  'path' | 'verb'
> &
  UpdateTagsForDelegateGroupPathParams

/**
 * Update tags for the Delegate group
 */
export const UpdateTagsForDelegateGroup = ({ identifier, ...props }: UpdateTagsForDelegateGroupProps) => (
  <Mutate<
    RestResponseDelegateGroup,
    unknown,
    UpdateTagsForDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    UpdateTagsForDelegateGroupPathParams
  >
    verb="PUT"
    path={`/v2/${identifier}/tags`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateTagsForDelegateGroupProps = Omit<
  UseMutateProps<
    RestResponseDelegateGroup,
    unknown,
    UpdateTagsForDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    UpdateTagsForDelegateGroupPathParams
  >,
  'path' | 'verb'
> &
  UpdateTagsForDelegateGroupPathParams

/**
 * Update tags for the Delegate group
 */
export const useUpdateTagsForDelegateGroup = ({ identifier, ...props }: UseUpdateTagsForDelegateGroupProps) =>
  useMutate<
    RestResponseDelegateGroup,
    unknown,
    UpdateTagsForDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    UpdateTagsForDelegateGroupPathParams
  >('PUT', (paramsInPath: UpdateTagsForDelegateGroupPathParams) => `/v2/${paramsInPath.identifier}/tags`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update tags for the Delegate group
 */
export const updateTagsForDelegateGroupPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateGroup,
    unknown,
    UpdateTagsForDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    UpdateTagsForDelegateGroupPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateGroup,
    unknown,
    UpdateTagsForDelegateGroupQueryParams,
    DelegateGroupTagsRequestBody,
    UpdateTagsForDelegateGroupPathParams
  >('PUT', getConfig('ng/api'), `/v2/${identifier}/tags`, props, signal)

export interface GetVariablesListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  includeVariablesFromEverySubScope?: boolean
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  pageToken?: string
}

export type GetVariablesListProps = Omit<
  GetProps<ResponsePageVariableResponseDTO, Failure | Error, GetVariablesListQueryParams, void>,
  'path'
>

/**
 * Gets Variable list
 */
export const GetVariablesList = (props: GetVariablesListProps) => (
  <Get<ResponsePageVariableResponseDTO, Failure | Error, GetVariablesListQueryParams, void>
    path={`/variables`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetVariablesListProps = Omit<
  UseGetProps<ResponsePageVariableResponseDTO, Failure | Error, GetVariablesListQueryParams, void>,
  'path'
>

/**
 * Gets Variable list
 */
export const useGetVariablesList = (props: UseGetVariablesListProps) =>
  useGet<ResponsePageVariableResponseDTO, Failure | Error, GetVariablesListQueryParams, void>(`/variables`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Variable list
 */
export const getVariablesListPromise = (
  props: GetUsingFetchProps<ResponsePageVariableResponseDTO, Failure | Error, GetVariablesListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageVariableResponseDTO, Failure | Error, GetVariablesListQueryParams, void>(
    getConfig('ng/api'),
    `/variables`,
    props,
    signal
  )

export interface CreateVariableQueryParams {
  accountIdentifier: string
}

export type CreateVariableProps = Omit<
  MutateProps<
    ResponseVariableResponseDTO,
    Failure | Error,
    CreateVariableQueryParams,
    VariableRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Variable
 */
export const CreateVariable = (props: CreateVariableProps) => (
  <Mutate<ResponseVariableResponseDTO, Failure | Error, CreateVariableQueryParams, VariableRequestDTORequestBody, void>
    verb="POST"
    path={`/variables`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateVariableProps = Omit<
  UseMutateProps<
    ResponseVariableResponseDTO,
    Failure | Error,
    CreateVariableQueryParams,
    VariableRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Variable
 */
export const useCreateVariable = (props: UseCreateVariableProps) =>
  useMutate<
    ResponseVariableResponseDTO,
    Failure | Error,
    CreateVariableQueryParams,
    VariableRequestDTORequestBody,
    void
  >('POST', `/variables`, { base: getConfig('ng/api'), ...props })

/**
 * Create a Variable
 */
export const createVariablePromise = (
  props: MutateUsingFetchProps<
    ResponseVariableResponseDTO,
    Failure | Error,
    CreateVariableQueryParams,
    VariableRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseVariableResponseDTO,
    Failure | Error,
    CreateVariableQueryParams,
    VariableRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/variables`, props, signal)

export interface UpdateVariableQueryParams {
  accountIdentifier: string
}

export type UpdateVariableProps = Omit<
  MutateProps<
    ResponseVariableResponseDTO,
    Failure | Error,
    UpdateVariableQueryParams,
    VariableRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a Variable
 */
export const UpdateVariable = (props: UpdateVariableProps) => (
  <Mutate<ResponseVariableResponseDTO, Failure | Error, UpdateVariableQueryParams, VariableRequestDTORequestBody, void>
    verb="PUT"
    path={`/variables`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateVariableProps = Omit<
  UseMutateProps<
    ResponseVariableResponseDTO,
    Failure | Error,
    UpdateVariableQueryParams,
    VariableRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a Variable
 */
export const useUpdateVariable = (props: UseUpdateVariableProps) =>
  useMutate<
    ResponseVariableResponseDTO,
    Failure | Error,
    UpdateVariableQueryParams,
    VariableRequestDTORequestBody,
    void
  >('PUT', `/variables`, { base: getConfig('ng/api'), ...props })

/**
 * Update a Variable
 */
export const updateVariablePromise = (
  props: MutateUsingFetchProps<
    ResponseVariableResponseDTO,
    Failure | Error,
    UpdateVariableQueryParams,
    VariableRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseVariableResponseDTO,
    Failure | Error,
    UpdateVariableQueryParams,
    VariableRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/variables`, props, signal)

export interface ListVariablesExpressionQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ListVariablesExpressionProps = Omit<
  GetProps<ResponseListString, Failure | Error, ListVariablesExpressionQueryParams, void>,
  'path'
>

/**
 * Gets a map of variable expressions
 */
export const ListVariablesExpression = (props: ListVariablesExpressionProps) => (
  <Get<ResponseListString, Failure | Error, ListVariablesExpressionQueryParams, void>
    path={`/variables/expressions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListVariablesExpressionProps = Omit<
  UseGetProps<ResponseListString, Failure | Error, ListVariablesExpressionQueryParams, void>,
  'path'
>

/**
 * Gets a map of variable expressions
 */
export const useListVariablesExpression = (props: UseListVariablesExpressionProps) =>
  useGet<ResponseListString, Failure | Error, ListVariablesExpressionQueryParams, void>(`/variables/expressions`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets a map of variable expressions
 */
export const listVariablesExpressionPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, ListVariablesExpressionQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, ListVariablesExpressionQueryParams, void>(
    getConfig('ng/api'),
    `/variables/expressions`,
    props,
    signal
  )

export interface DeleteVariableQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteVariableProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteVariableQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a Variable
 */
export const DeleteVariable = (props: DeleteVariableProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteVariableQueryParams, string, void>
    verb="DELETE"
    path={`/variables`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteVariableProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteVariableQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a Variable
 */
export const useDeleteVariable = (props: UseDeleteVariableProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteVariableQueryParams, string, void>('DELETE', `/variables`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a Variable
 */
export const deleteVariablePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteVariableQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteVariableQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/variables`,
    props,
    signal
  )

export interface GetVariableQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetVariablePathParams {
  identifier: string
}

export type GetVariableProps = Omit<
  GetProps<ResponseVariableResponseDTO, Failure | Error, GetVariableQueryParams, GetVariablePathParams>,
  'path'
> &
  GetVariablePathParams

/**
 * Get a Variable
 */
export const GetVariable = ({ identifier, ...props }: GetVariableProps) => (
  <Get<ResponseVariableResponseDTO, Failure | Error, GetVariableQueryParams, GetVariablePathParams>
    path={`/variables/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetVariableProps = Omit<
  UseGetProps<ResponseVariableResponseDTO, Failure | Error, GetVariableQueryParams, GetVariablePathParams>,
  'path'
> &
  GetVariablePathParams

/**
 * Get a Variable
 */
export const useGetVariable = ({ identifier, ...props }: UseGetVariableProps) =>
  useGet<ResponseVariableResponseDTO, Failure | Error, GetVariableQueryParams, GetVariablePathParams>(
    (paramsInPath: GetVariablePathParams) => `/variables/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get a Variable
 */
export const getVariablePromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseVariableResponseDTO, Failure | Error, GetVariableQueryParams, GetVariablePathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseVariableResponseDTO, Failure | Error, GetVariableQueryParams, GetVariablePathParams>(
    getConfig('ng/api'),
    `/variables/${identifier}`,
    props,
    signal
  )

export interface WebhookEndpointQueryParams {
  accountIdentifier: string
}

export type WebhookEndpointProps = Omit<
  MutateProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, CFParametersForAwsBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * accept webhook event
 */
export const WebhookEndpoint = (props: WebhookEndpointProps) => (
  <Mutate<ResponseString, Failure | Error, WebhookEndpointQueryParams, CFParametersForAwsBodyRequestBody, void>
    verb="POST"
    path={`/webhook`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseWebhookEndpointProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, CFParametersForAwsBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * accept webhook event
 */
export const useWebhookEndpoint = (props: UseWebhookEndpointProps) =>
  useMutate<ResponseString, Failure | Error, WebhookEndpointQueryParams, CFParametersForAwsBodyRequestBody, void>(
    'POST',
    `/webhook`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * accept webhook event
 */
export const webhookEndpointPromise = (
  props: MutateUsingFetchProps<
    ResponseString,
    Failure | Error,
    WebhookEndpointQueryParams,
    CFParametersForAwsBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseString,
    Failure | Error,
    WebhookEndpointQueryParams,
    CFParametersForAwsBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/webhook`, props, signal)

export interface GetYamlSchemaQueryParams {
  entityType:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
    | 'IdpCookieCutter'
  subtype?:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Azure'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
    | 'ErrorTracking'
    | 'Pdc'
    | 'AzureRepo'
    | 'Jenkins'
    | 'OciHelmRepo'
    | 'CustomSecretManager'
    | 'ElasticSearch'
    | 'GcpSecretManager'
    | 'AzureArtifacts'
    | 'Tas'
    | 'Spot'
    | 'Bamboo'
    | 'TerraformCloud'
    | 'SignalFX'
    | 'Harness'
    | 'Rancher'
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
  identifier?: string
  accountIdentifier: string
}

export type GetYamlSchemaProps = Omit<
  GetProps<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Yaml Schema
 */
export const GetYamlSchema = (props: GetYamlSchemaProps) => (
  <Get<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>
    path={`/yaml-schema`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetYamlSchemaProps = Omit<
  UseGetProps<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Yaml Schema
 */
export const useGetYamlSchema = (props: UseGetYamlSchemaProps) =>
  useGet<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>(`/yaml-schema`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Yaml Schema
 */
export const getYamlSchemaPromise = (
  props: GetUsingFetchProps<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>(
    getConfig('ng/api'),
    `/yaml-schema`,
    props,
    signal
  )

export interface GetYamlSnippetMetadataQueryParams {
  tags: (
    | 'k8s'
    | 'git'
    | 'docker'
    | 'connector'
    | 'secretmanager'
    | 'secret'
    | 'secretText'
    | 'secretFile'
    | 'sshKey'
    | 'service'
    | 'infra'
    | 'steps'
    | 'pipeline'
    | 'http'
    | 'splunk'
    | 'appdynamics'
    | 'vault'
    | 'azurekeyvault'
    | 'local'
    | 'gcpkms'
    | 'gcp'
    | 'aws'
    | 'awskms'
    | 'awssecretmanager'
    | 'artifactory'
    | 'jira'
    | 'nexus'
    | 'github'
    | 'gitlab'
    | 'bitbucket'
    | 'ceaws'
    | 'ceazure'
    | 'cek8s'
    | 'codecommit'
    | 'httphelmrepo'
    | 'newrelic'
    | 'gcpcloudcost'
    | 'prometheus'
    | 'datadog'
    | 'sumologic'
    | 'dynatrace'
    | 'pagerduty'
    | 'customhealth'
    | 'servicenow'
    | 'errortracking'
    | 'azure'
    | 'pdc'
    | 'azurerepo'
    | 'ocihelmrepo'
  )[]
}

export type GetYamlSnippetMetadataProps = Omit<
  GetProps<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>,
  'path'
>

/**
 * Get Yaml Snippet Metadata
 */
export const GetYamlSnippetMetadata = (props: GetYamlSnippetMetadataProps) => (
  <Get<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>
    path={`/yaml-snippet`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetYamlSnippetMetadataProps = Omit<
  UseGetProps<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>,
  'path'
>

/**
 * Get Yaml Snippet Metadata
 */
export const useGetYamlSnippetMetadata = (props: UseGetYamlSnippetMetadataProps) =>
  useGet<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>(`/yaml-snippet`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Yaml Snippet Metadata
 */
export const getYamlSnippetMetadataPromise = (
  props: GetUsingFetchProps<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>(
    getConfig('ng/api'),
    `/yaml-snippet`,
    props,
    signal
  )

export interface GetYamlSnippetQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export interface GetYamlSnippetPathParams {
  identifier: string
}

export type GetYamlSnippetProps = Omit<
  GetProps<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams>,
  'path'
> &
  GetYamlSnippetPathParams

/**
 * Get Yaml Snippet
 */
export const GetYamlSnippet = ({ identifier, ...props }: GetYamlSnippetProps) => (
  <Get<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams>
    path={`/yaml-snippet/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetYamlSnippetProps = Omit<
  UseGetProps<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams>,
  'path'
> &
  GetYamlSnippetPathParams

/**
 * Get Yaml Snippet
 */
export const useGetYamlSnippet = ({ identifier, ...props }: UseGetYamlSnippetProps) =>
  useGet<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams>(
    (paramsInPath: GetYamlSnippetPathParams) => `/yaml-snippet/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Yaml Snippet
 */
export const getYamlSnippetPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams>(
    getConfig('ng/api'),
    `/yaml-snippet/${identifier}`,
    props,
    signal
  )

export interface SchemafileQueryParams {
  filename?: string
}

export type SchemafileProps = Omit<GetProps<void, void, SchemafileQueryParams, void>, 'path'>

/**
 * Get Schema for the given entity type
 */
export const Schemafile = (props: SchemafileProps) => (
  <Get<void, void, SchemafileQueryParams, void> path={`/yamlschema/schemafile`} base={getConfig('ng/api')} {...props} />
)

export type UseSchemafileProps = Omit<UseGetProps<void, void, SchemafileQueryParams, void>, 'path'>

/**
 * Get Schema for the given entity type
 */
export const useSchemafile = (props: UseSchemafileProps) =>
  useGet<void, void, SchemafileQueryParams, void>(`/yamlschema/schemafile`, { base: getConfig('ng/api'), ...props })

/**
 * Get Schema for the given entity type
 */
export const schemafilePromise = (
  props: GetUsingFetchProps<void, void, SchemafileQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, void, SchemafileQueryParams, void>(getConfig('ng/api'), `/yamlschema/schemafile`, props, signal)
