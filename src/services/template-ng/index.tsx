/*
 * Copyright 2023 Harness Inc. All rights reserved.
 * Use of this source code is governed by the PolyForm Shield 1.0.0 license
 * that can be found in the licenses directory at the root of this repository, also available at
 * https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt.
 */

/* Generated by restful-react */

import React from 'react'
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'

import { getConfig, getUsingFetch, mutateUsingFetch, GetUsingFetchProps, MutateUsingFetchProps } from '../config'
export const SPEC_VERSION = '2.0'
export type AuditFilterProperties = FilterProperties & {
  actions?: (
    | 'CREATE'
    | 'UPDATE'
    | 'RESTORE'
    | 'DELETE'
    | 'FORCE_DELETE'
    | 'UPSERT'
    | 'INVITE'
    | 'RESEND_INVITE'
    | 'REVOKE_INVITE'
    | 'ADD_COLLABORATOR'
    | 'REMOVE_COLLABORATOR'
    | 'CREATE_TOKEN'
    | 'REVOKE_TOKEN'
    | 'LOGIN'
    | 'LOGIN2FA'
    | 'UNSUCCESSFUL_LOGIN'
    | 'ADD_MEMBERSHIP'
    | 'REMOVE_MEMBERSHIP'
    | 'ERROR_BUDGET_RESET'
    | 'START'
    | 'END'
    | 'STAGE_START'
    | 'STAGE_END'
    | 'PAUSE'
    | 'RESUME'
    | 'ABORT'
    | 'TIMEOUT'
    | 'SIGNED_EULA'
    | 'ROLE_ASSIGNMENT_CREATED'
    | 'ROLE_ASSIGNMENT_UPDATED'
    | 'ROLE_ASSIGNMENT_DELETED'
  )[]
  endTime?: number
  environments?: Environment[]
  modules?: (
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  )[]
  principals?: Principal[]
  resources?: ResourceDTO[]
  scopes?: ResourceScopeDTO[]
  startTime?: number
  staticFilter?: 'EXCLUDE_LOGIN_EVENTS' | 'EXCLUDE_SYSTEM_EVENTS'
}

export interface CacheResponseMetadata {
  cacheState: 'VALID_CACHE' | 'STALE_CACHE' | 'UNKNOWN'
  isSyncEnabled: boolean
  lastUpdatedAt: number
  ttlLeft: number
}

export interface CcmConnectorFilter {
  awsAccountId?: string
  awsAccountIds?: string[]
  azureSubscriptionId?: string
  azureTenantId?: string
  featuresDisabled?: (
    | 'BILLING'
    | 'OPTIMIZATION'
    | 'VISIBILITY'
    | 'GOVERNANCE'
    | 'COMMITMENT_ORCHESTRATOR'
    | 'CLUSTER_ORCHESTRATOR'
  )[]
  featuresEnabled?: (
    | 'BILLING'
    | 'OPTIMIZATION'
    | 'VISIBILITY'
    | 'GOVERNANCE'
    | 'COMMITMENT_ORCHESTRATOR'
    | 'CLUSTER_ORCHESTRATOR'
  )[]
  gcpProjectId?: string
  k8sConnectorRef?: string[]
}

export type ConnectorFilterProperties = FilterProperties & {
  categories?: (
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  )[]
  ccmConnectorFilter?: CcmConnectorFilter
  connectivityStatuses?: ('SUCCESS' | 'FAILURE' | 'PARTIAL' | 'UNKNOWN')[]
  connectorConnectivityModes?: ('DELEGATE' | 'MANAGER')[]
  connectorIdentifiers?: string[]
  connectorIds?: string[]
  connectorNames?: string[]
  description?: string
  inheritingCredentialsFromDelegate?: boolean
  types?: (
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Azure'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
    | 'ErrorTracking'
    | 'Pdc'
    | 'AzureRepo'
    | 'Jenkins'
    | 'OciHelmRepo'
    | 'CustomSecretManager'
    | 'ElasticSearch'
    | 'GcpSecretManager'
    | 'AzureArtifacts'
    | 'Tas'
    | 'Spot'
    | 'Bamboo'
    | 'TerraformCloud'
    | 'SignalFX'
    | 'Harness'
    | 'Rancher'
  )[]
}

export type ConnectorInternalFilterProperties = FilterProperties & {
  accountIdentifiers?: string[]
  ccmConnectorFilter?: CcmConnectorFilter
  connectivityStatuses?: ('SUCCESS' | 'FAILURE' | 'PARTIAL' | 'UNKNOWN')[]
  types?: (
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Azure'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
    | 'ErrorTracking'
    | 'Pdc'
    | 'AzureRepo'
    | 'Jenkins'
    | 'OciHelmRepo'
    | 'CustomSecretManager'
    | 'ElasticSearch'
    | 'GcpSecretManager'
    | 'AzureArtifacts'
    | 'Tas'
    | 'Spot'
    | 'Bamboo'
    | 'TerraformCloud'
    | 'SignalFX'
    | 'Harness'
    | 'Rancher'
  )[]
}

export type ConnectorValidationErrorMetadataDTO = ErrorMetadataDTO & {
  taskId?: string
}

export interface EntityDetail {
  entityGitMetadata?: EntityGitMetadata
  entityRef?: EntityReference
  name?: string
  type?:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
}

export interface EntityDetailProtoDTO {
  [key: string]: any
}

export interface EntityGitDetails {
  branch?: string
  commitId?: string
  filePath?: string
  fileUrl?: string
  objectId?: string
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  repoIdentifier?: string
  repoName?: string
  repoUrl?: string
  rootFolder?: string
}

export interface EntityGitMetadata {
  branch?: string
  repo?: string
}

export interface EntityReference {
  accountIdentifier?: string
  branch?: string
  default?: boolean
  identifier?: string
  metadata?: {
    [key: string]: string
  }
  orgIdentifier?: string
  projectIdentifier?: string
  repoIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export type EntityReferredByInfraSetupUsageDetail = SetupUsageDetail & {
  environmentIdentifier?: string
  environmentName?: string
}

export type EntityReferredByPipelineSetupUsageDetail = SetupUsageDetail & {
  identifier?: string
  referenceType?: string
}

export interface EntitySetupUsageDTO {
  accountIdentifier?: string
  createdAt?: number
  detail?: SetupUsageDetail
  referredByEntity: EntityDetail
  referredEntity?: EntityDetail
}

export interface EntityValidityDetails {
  invalidYaml?: string
  valid?: boolean
}

export interface Environment {
  identifier: string
  type: 'PreProduction' | 'Production'
}

export interface Error {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'ACCOUNT_MIGRATED_TO_NEXT_GEN'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'SCM_REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SPOTNIST_REST_EXCEPTION'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'MISSING_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
    | 'ABORT_ALL_ALREADY_NG'
  correlationId?: string
  detailedMessage?: string
  message?: string
  metadata?: ErrorMetadataDTO
  responseMessages?: ResponseMessage[]
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ErrorMetadata {
  errorCode?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'ACCOUNT_MIGRATED_TO_NEXT_GEN'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'SCM_REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SPOTNIST_REST_EXCEPTION'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'MISSING_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
    | 'ABORT_ALL_ALREADY_NG'
  errorMessage?: string
}

export interface ErrorMetadataDTO {
  type?: string
}

export interface ErrorNodeSummary {
  childrenErrorNodes?: ErrorNodeSummary[]
  nodeInfo?: NodeInfo
  templateInfo?: TemplateInfo
  templateResponse?: TemplateResponse
}

export interface Failure {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'ACCOUNT_MIGRATED_TO_NEXT_GEN'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'SCM_REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SPOTNIST_REST_EXCEPTION'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'MISSING_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
    | 'ABORT_ALL_ALREADY_NG'
  correlationId?: string
  errors?: ValidationError[]
  message?: string
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export type FilterCreatorErrorResponse = ErrorMetadataDTO & {
  errorMetadataList?: ErrorMetadata[]
}

export interface FilterDTO {
  filterProperties: FilterProperties
  filterVisibility?: 'EveryOne' | 'OnlyCreator'
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface FilterProperties {
  filterType?:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
    | 'Trigger'
    | 'EnvironmentGroup'
    | 'FileStore'
    | 'CCMRecommendation'
    | 'Anomaly'
    | 'Environment'
    | 'RuleExecution'
    | 'Override'
    | 'InputSet'
  labels?: {
    [key: string]: string
  }
  tags?: {
    [key: string]: string
  }
}

export type GitErrorMetadataDTO = ErrorMetadataDTO & {
  branch?: string
  repo?: string
}

export interface GovernanceMetadata {
  [key: string]: any
}

export type IdentifierRef = EntityReference & {
  fullyQualifiedScopeIdentifier?: string
  isDefault?: boolean
}

export interface InputSetError {
  fieldName?: string
  identifierOfErrorSource?: string
  message?: string
}

export interface InputSetErrorResponse {
  errors?: InputSetError[]
}

export type InputSetErrorWrapper = ErrorMetadataDTO & {
  errorPipelineYaml?: string
  invalidInputSetReferences?: string[]
  uuidToErrorResponseMap?: {
    [key: string]: InputSetErrorResponse
  }
}

export type InputSetFilterProperties = FilterProperties & {
  inputSetIdsWithPipelineIds?: string[]
}

export type InputSetReference = EntityReference & {
  isDefault?: boolean
  pipelineIdentifier?: string
}

export type InvalidFieldsDTO = ErrorMetadataDTO & {}

export interface JsonNode {
  [key: string]: any
}

export interface NGTag {
  key: string
  value?: string
}

export interface NGTemplateConfig {
  template?: NGTemplateInfoConfig
}

export interface NGTemplateInfoConfig {
  description?: string
  icon?: string
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  spec?: JsonNode
  tags?: {
    [key: string]: string
  }
  type:
    | 'Step'
    | 'Stage'
    | 'Pipeline'
    | 'CustomDeployment'
    | 'MonitoredService'
    | 'SecretManager'
    | 'ArtifactSource'
    | 'StepGroup'
  variables?: NGVariable[]
  versionLabel: string
}

export type NGTemplateReference = EntityReference & {
  isDefault?: boolean
  versionLabel?: string
}

export interface NGVariable {
  description?: string
  metadata?: string
  name?: string
  required?: boolean
  type?: 'String' | 'Number' | 'Secret'
}

export interface NodeErrorInfo {
  fqn?: string
  identifier?: string
  name?: string
  type?: string
}

export interface NodeInfo {
  identifier?: string
  localFqn?: string
  name?: string
}

export type NumberNGVariable = NGVariable & {
  default?: number
  name?: string
  type?: 'Number'
  value: number
}

export type OverlayInputSetErrorWrapper = ErrorMetadataDTO & {
  invalidReferences?: {
    [key: string]: string
  }
}

export interface Page {
  content?: { [key: string]: any }[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageEntitySetupUsageDTO {
  content?: EntitySetupUsageDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageFilterDTO {
  content?: FilterDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageTemplateMetadataSummaryResponse {
  content?: TemplateMetadataSummaryResponse[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface PageTemplateSummaryResponse {
  content?: TemplateSummaryResponse[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface Pageable {
  offset?: number
  pageNumber?: number
  pageSize?: number
  paged?: boolean
  sort?: Sort
  unpaged?: boolean
}

export type PipelineFilterProperties = FilterProperties & {
  description?: string
  moduleProperties?: {
    [key: string]: { [key: string]: any }
  }
  name?: string
  pipelineIdentifiers?: string[]
  pipelineTags?: NGTag[]
  repoName?: string
}

export interface Principal {
  identifier: string
  type: 'USER' | 'SYSTEM' | 'API_KEY' | 'SERVICE_ACCOUNT'
}

export interface RefreshRequest {
  yaml: string
}

export interface RefreshResponse {
  refreshedYaml?: string
}

export interface ResourceDTO {
  identifier: string
  labels?: {
    [key: string]: string
  }
  type:
    | 'ORGANIZATION'
    | 'PROJECT'
    | 'USER_GROUP'
    | 'SECRET'
    | 'RESOURCE_GROUP'
    | 'USER'
    | 'ROLE'
    | 'PIPELINE'
    | 'TRIGGER'
    | 'TEMPLATE'
    | 'INPUT_SET'
    | 'DELEGATE_CONFIGURATION'
    | 'DELEGATE_GROUPS'
    | 'SERVICE'
    | 'ENVIRONMENT'
    | 'ENVIRONMENT_GROUP'
    | 'DELEGATE'
    | 'SERVICE_ACCOUNT'
    | 'CONNECTOR'
    | 'API_KEY'
    | 'TOKEN'
    | 'DELEGATE_TOKEN'
    | 'GOVERNANCE_POLICY'
    | 'GOVERNANCE_POLICY_SET'
    | 'VARIABLE'
    | 'CHAOS_HUB'
    | 'MONITORED_SERVICE'
    | 'CHAOS_INFRASTRUCTURE'
    | 'CHAOS_EXPERIMENT'
    | 'CHAOS_GAMEDAY'
    | 'STO_TARGET'
    | 'STO_EXEMPTION'
    | 'SERVICE_LEVEL_OBJECTIVE'
    | 'PERSPECTIVE'
    | 'PERSPECTIVE_BUDGET'
    | 'PERSPECTIVE_REPORT'
    | 'COST_CATEGORY'
    | 'SMTP'
    | 'PERSPECTIVE_FOLDER'
    | 'AUTOSTOPPING_RULE'
    | 'AUTOSTOPPING_LB'
    | 'AUTOSTOPPING_STARTSTOP'
    | 'SETTING'
    | 'NG_LOGIN_SETTINGS'
    | 'DEPLOYMENT_FREEZE'
    | 'CLOUD_ASSET_GOVERNANCE_RULE'
    | 'CLOUD_ASSET_GOVERNANCE_RULE_SET'
    | 'CLOUD_ASSET_GOVERNANCE_RULE_ENFORCEMENT'
    | 'TARGET_GROUP'
    | 'FEATURE_FLAG'
    | 'NG_ACCOUNT_DETAILS'
    | 'BUDGET_GROUP'
    | 'IP_ALLOWLIST_CONFIG'
    | 'NETWORK_MAP'
    | 'CET_AGENT_TOKEN'
    | 'CET_CRITICAL_EVENT'
    | 'CHAOS_SECURITY_GOVERNANCE'
    | 'END_USER_LICENSE_AGREEMENT'
    | 'WORKSPACE'
    | 'SEI_CONFIGURATION_SETTINGS'
    | 'SEI_COLLECTIONS'
    | 'SEI_INSIGHTS'
    | 'CET_SAVED_FILTER'
    | 'GITOPS_AGENT'
    | 'GITOPS_REPOSITORY'
    | 'GITOPS_CLUSTER'
    | 'GITOPS_CREDENTIAL_TEMPLATE'
    | 'GITOPS_REPOSITORY_CERTIFICATE'
    | 'GITOPS_GNUPG_KEY'
    | 'GITOPS_PROJECT_MAPPING'
    | 'GITOPS_APPLICATION'
    | 'CODE_REPOSITORY'
  uniqueId?: string
}

export interface ResourceScopeDTO {
  accountIdentifier?: string
  labels?: {
    [key: string]: string
  }
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface Response {
  correlationId?: string
  data?: { [key: string]: any }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseBoolean {
  correlationId?: string
  data?: boolean
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFilterDTO {
  correlationId?: string
  data?: FilterDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseJsonNode {
  correlationId?: string
  data?: JsonNode
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListEntityDetailProtoDTO {
  correlationId?: string
  data?: EntityDetailProtoDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListTemplateWrapperResponse {
  correlationId?: string
  data?: TemplateWrapperResponse[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMessage {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'ACCOUNT_MIGRATED_TO_NEXT_GEN'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'SCM_REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SPOTNIST_REST_EXCEPTION'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'MISSING_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
    | 'ABORT_ALL_ALREADY_NG'
  exception?: Throwable
  failureTypes?: (
    | 'EXPIRED'
    | 'DELEGATE_PROVISIONING'
    | 'CONNECTIVITY'
    | 'AUTHENTICATION'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'TIMEOUT_ERROR'
    | 'POLICY_EVALUATION_FAILURE'
    | 'INPUT_TIMEOUT_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'DELEGATE_RESTART'
    | 'USER_MARKED_FAILURE'
  )[]
  level?: 'INFO' | 'ERROR'
  message?: string
}

export interface ResponseNGTemplateConfig {
  correlationId?: string
  data?: NGTemplateConfig
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageEntitySetupUsageDTO {
  correlationId?: string
  data?: PageEntitySetupUsageDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageFilterDTO {
  correlationId?: string
  data?: PageFilterDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageTemplateMetadataSummaryResponse {
  correlationId?: string
  data?: PageTemplateMetadataSummaryResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageTemplateSummaryResponse {
  correlationId?: string
  data?: PageTemplateSummaryResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseRefreshResponse {
  correlationId?: string
  data?: RefreshResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseString {
  correlationId?: string
  data?: string
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTemplateImportSaveResponse {
  correlationId?: string
  data?: TemplateImportSaveResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTemplateListRepoResponse {
  correlationId?: string
  data?: TemplateListRepoResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTemplateMergeResponse {
  correlationId?: string
  data?: TemplateMergeResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTemplateMoveConfigResponse {
  correlationId?: string
  data?: TemplateMoveConfigResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTemplateResponse {
  correlationId?: string
  data?: TemplateResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTemplateRetainVariablesResponse {
  correlationId?: string
  data?: TemplateRetainVariablesResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTemplateUpdateGitDetailsResponse {
  correlationId?: string
  data?: TemplateUpdateGitDetailsResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTemplateWithInputsResponse {
  correlationId?: string
  data?: TemplateWithInputsResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTemplateWrapperResponse {
  correlationId?: string
  data?: TemplateWrapperResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseValidateTemplateInputsResponseDTO {
  correlationId?: string
  data?: ValidateTemplateInputsResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseVariableMergeServiceResponse {
  correlationId?: string
  data?: VariableMergeServiceResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseYamlDiffResponseDTO {
  correlationId?: string
  data?: YamlDiffResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export type SampleErrorMetadataDTO = ErrorMetadataDTO & {
  sampleMap?: {
    [key: string]: string
  }
}

export type ScmErrorMetadataDTO = ErrorMetadataDTO & {
  conflictCommitId?: string
}

export type SecretNGVariable = NGVariable & {
  default?: string
  name?: string
  type?: 'Secret'
  value: string
}

export type SecretReferredByConnectorSetupUsageDetail = SetupUsageDetail & {
  fieldName?: string
}

export interface ServiceExpressionProperties {
  expression?: string
  serviceName?: string
}

export interface SetupUsageDetail {
  [key: string]: any
}

export interface Sort {
  empty?: boolean
  sorted?: boolean
  unsorted?: boolean
}

export interface StackTraceElement {
  classLoaderName?: string
  className?: string
  fileName?: string
  lineNumber?: number
  methodName?: string
  moduleName?: string
  moduleVersion?: string
  nativeMethod?: boolean
}

export type StringNGVariable = NGVariable & {
  default?: string
  name?: string
  type?: 'String'
  value: string
}

export interface TemplateApplyRequest {
  checkForAccess?: boolean
  getMergedYamlWithTemplateField?: boolean
  getOnlyFileContent?: boolean
  originalEntityYaml: string
  yamlVersion?: string
}

export interface TemplateDeleteListRequest {
  templateVersionLabels?: string[]
}

export interface TemplateFilterProperties {
  childTypes?: string[]
  description?: string
  filterType?:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
    | 'Trigger'
    | 'EnvironmentGroup'
    | 'FileStore'
    | 'CCMRecommendation'
    | 'Anomaly'
    | 'Environment'
    | 'RuleExecution'
    | 'Override'
    | 'InputSet'
  labels?: {
    [key: string]: string
  }
  listingScope?: TemplateScope
  repoName?: string
  tags?: {
    [key: string]: string
  }
  templateEntityTypes?: (
    | 'Step'
    | 'Stage'
    | 'Pipeline'
    | 'CustomDeployment'
    | 'MonitoredService'
    | 'SecretManager'
    | 'ArtifactSource'
    | 'StepGroup'
  )[]
  templateIdentifiers?: string[]
  templateNames?: string[]
}

export interface TemplateImportRequest {
  templateDescription?: string
  templateName?: string
  templateVersion?: string
}

export interface TemplateImportSaveResponse {
  templateIdentifier?: string
  templateVersion?: string
}

export interface TemplateInfo {
  templateEntityType?:
    | 'Step'
    | 'Stage'
    | 'Pipeline'
    | 'CustomDeployment'
    | 'MonitoredService'
    | 'SecretManager'
    | 'ArtifactSource'
    | 'StepGroup'
  templateIdentifier?: string
  versionLabel?: string
}

export interface TemplateInputsErrorDTO {
  fieldName?: string
  identifierOfErrorSource?: string
  message?: string
}

export type TemplateInputsErrorMetadataDTO = ErrorMetadataDTO & {
  errorMap?: {
    [key: string]: TemplateInputsErrorDTO
  }
  errorYaml?: string
}

export interface TemplateListRepoResponse {
  repositories?: string[]
}

export interface TemplateMergeResponse {
  cacheResponseMetadata?: CacheResponseMetadata
  mergedPipelineYaml?: string
  mergedPipelineYamlWithTemplateRef?: string
  processedYamlVersion?: string
  templateReferenceSummaries?: TemplateReferenceSummary[]
}

export interface TemplateMetadataSummaryResponse {
  accountId?: string
  childType?: string
  connectorRef?: string
  createdAt?: number
  description?: string
  gitDetails?: EntityGitDetails
  icon?: string
  identifier?: string
  lastUpdatedAt?: number
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  stableTemplate?: boolean
  storeType?: 'INLINE' | 'REMOTE'
  tags?: {
    [key: string]: string
  }
  templateEntityType?:
    | 'Step'
    | 'Stage'
    | 'Pipeline'
    | 'CustomDeployment'
    | 'MonitoredService'
    | 'SecretManager'
    | 'ArtifactSource'
    | 'StepGroup'
  templateScope?: 'account' | 'org' | 'project' | 'unknown'
  version?: number
  versionLabel?: string
  yamlVersion?: string
}

export interface TemplateMoveConfigResponse {
  templateIdentifier?: string
  versionLabel?: string
}

export interface TemplateReferenceRequest {
  yaml: string
}

export interface TemplateReferenceSummary {
  fqn?: string
  moduleInfo?: string[]
  scope?: 'account' | 'org' | 'project' | 'unknown'
  stableTemplate?: boolean
  templateIdentifier?: string
  versionLabel?: string
}

export interface TemplateResponse {
  accountId: string
  cacheResponseMetadata?: CacheResponseMetadata
  childType?: string
  connectorRef?: string
  description?: string
  entityValidityDetails?: EntityValidityDetails
  gitDetails?: EntityGitDetails
  icon?: string
  identifier: string
  lastUpdatedAt?: number
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  stableTemplate?: boolean
  storeType?: 'INLINE' | 'REMOTE'
  tags?: {
    [key: string]: string
  }
  templateEntityType?:
    | 'Step'
    | 'Stage'
    | 'Pipeline'
    | 'CustomDeployment'
    | 'MonitoredService'
    | 'SecretManager'
    | 'ArtifactSource'
    | 'StepGroup'
  templateScope?: 'account' | 'org' | 'project' | 'unknown'
  version?: number
  versionLabel?: string
  yaml?: string
  yamlVersion?: string
}

export interface TemplateRetainVariablesRequestDTO {
  newTemplateInputs?: string
  oldTemplateInputs?: string
}

export interface TemplateRetainVariablesResponse {
  mergedTemplateInputs?: string
}

export interface TemplateScope {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface TemplateSummaryResponse {
  accountId?: string
  childType?: string
  createdAt?: number
  description?: string
  entityValidityDetails?: EntityValidityDetails
  gitDetails?: EntityGitDetails
  icon?: string
  identifier?: string
  lastUpdatedAt?: number
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  stableTemplate?: boolean
  tags?: {
    [key: string]: string
  }
  templateEntityType?:
    | 'Step'
    | 'Stage'
    | 'Pipeline'
    | 'CustomDeployment'
    | 'MonitoredService'
    | 'SecretManager'
    | 'ArtifactSource'
    | 'StepGroup'
  templateScope?: 'account' | 'org' | 'project' | 'unknown'
  version?: number
  versionLabel?: string
  yaml?: string
  yamlVersion?: string
}

export interface TemplateUpdateGitDetailsRequest {
  connectorRef?: string
  filePath?: string
  repoName?: string
}

export interface TemplateUpdateGitDetailsResponse {
  status?: boolean
}

export interface TemplateWithInputsResponse {
  templateInputs?: string
  templateResponseDTO?: TemplateResponse
}

export interface TemplateWrapperResponse {
  governanceMetadata?: GovernanceMetadata
  templateResponseDTO?: TemplateResponse
  valid?: boolean
}

export interface Throwable {
  cause?: Throwable
  localizedMessage?: string
  message?: string
  stackTrace?: StackTraceElement[]
  suppressed?: Throwable[]
}

export type TriggerReference = EntityReference & {
  isDefault?: boolean
  pipelineIdentifier?: string
}

export type ValidateTemplateInputsResponseDTO = ErrorMetadataDTO & {
  errorNodeSummary?: ErrorNodeSummary
  validYaml?: boolean
}

export interface ValidationError {
  error?: string
  fieldId?: string
}

export interface VariableMergeServiceResponse {
  errorResponses?: string[]
  metadataMap?: {
    [key: string]: VariableResponseMapValue
  }
  serviceExpressionPropertiesList?: ServiceExpressionProperties[]
  yaml?: string
}

export interface VariableResponseMapValue {
  yamlExtraProperties?: YamlExtraProperties
  yamlOutputProperties?: YamlOutputProperties
  yamlProperties?: YamlProperties
}

export interface YamlDiffResponseDTO {
  originalYaml?: string
  refreshedYaml?: string
}

export interface YamlExtraProperties {
  [key: string]: any
}

export interface YamlOutputProperties {
  [key: string]: any
}

export interface YamlProperties {
  [key: string]: any
}

export interface YamlSchemaErrorDTO {
  fqn?: string
  hintMessage?: string
  message?: string
  messageWithFQN?: string
  stageInfo?: NodeErrorInfo
  stepInfo?: NodeErrorInfo
}

export type YamlSchemaErrorWrapperDTO = ErrorMetadataDTO & {
  schemaErrors?: YamlSchemaErrorDTO[]
}

export type FilterDTORequestBody = FilterDTO

export type TemplateApplyRequestRequestBody = TemplateApplyRequest

export type TemplateFilterPropertiesRequestBody = TemplateFilterProperties

export type RefreshAndUpdateTemplateInputsBodyRequestBody = string

export interface GetFilterListQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
    | 'Trigger'
    | 'EnvironmentGroup'
    | 'FileStore'
    | 'CCMRecommendation'
    | 'Anomaly'
    | 'Environment'
    | 'RuleExecution'
    | 'Override'
    | 'InputSet'
}

export type GetFilterListProps = Omit<
  GetProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  'path'
>

/**
 * Get Filter
 */
export const GetFilterList = (props: GetFilterListProps) => (
  <Get<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>
    path={`/filters`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseGetFilterListProps = Omit<
  UseGetProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  'path'
>

/**
 * Get Filter
 */
export const useGetFilterList = (props: UseGetFilterListProps) =>
  useGet<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>(`/filters`, {
    base: getConfig('template/api'),
    ...props
  })

/**
 * Get Filter
 */
export const getFilterListPromise = (
  props: GetUsingFetchProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>(
    getConfig('template/api'),
    `/filters`,
    props,
    signal
  )

export interface PostFilterQueryParams {
  accountIdentifier: string
}

export type PostFilterProps = Omit<
  MutateProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Filter
 */
export const PostFilter = (props: PostFilterProps) => (
  <Mutate<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>
    verb="POST"
    path={`/filters`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UsePostFilterProps = Omit<
  UseMutateProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Filter
 */
export const usePostFilter = (props: UsePostFilterProps) =>
  useMutate<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>('POST', `/filters`, {
    base: getConfig('template/api'),
    ...props
  })

/**
 * Create a Filter
 */
export const postFilterPromise = (
  props: MutateUsingFetchProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>(
    'POST',
    getConfig('template/api'),
    `/filters`,
    props,
    signal
  )

export interface UpdateFilterQueryParams {
  accountIdentifier: string
}

export type UpdateFilterProps = Omit<
  MutateProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Filter
 */
export const UpdateFilter = (props: UpdateFilterProps) => (
  <Mutate<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>
    verb="PUT"
    path={`/filters`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseUpdateFilterProps = Omit<
  UseMutateProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Filter
 */
export const useUpdateFilter = (props: UseUpdateFilterProps) =>
  useMutate<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>(
    'PUT',
    `/filters`,
    { base: getConfig('template/api'), ...props }
  )

/**
 * Update a Filter
 */
export const updateFilterPromise = (
  props: MutateUsingFetchProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>(
    'PUT',
    getConfig('template/api'),
    `/filters`,
    props,
    signal
  )

export interface DeleteFilterQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
    | 'Trigger'
    | 'EnvironmentGroup'
    | 'FileStore'
    | 'CCMRecommendation'
    | 'Anomaly'
    | 'Environment'
    | 'RuleExecution'
    | 'Override'
    | 'InputSet'
}

export type DeleteFilterProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a filter
 */
export const DeleteFilter = (props: DeleteFilterProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>
    verb="DELETE"
    path={`/filters`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseDeleteFilterProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a filter
 */
export const useDeleteFilter = (props: UseDeleteFilterProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>('DELETE', `/filters`, {
    base: getConfig('template/api'),
    ...props
  })

/**
 * Delete a filter
 */
export const deleteFilterPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>(
    'DELETE',
    getConfig('template/api'),
    `/filters`,
    props,
    signal
  )

export interface GetFilterQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
    | 'Trigger'
    | 'EnvironmentGroup'
    | 'FileStore'
    | 'CCMRecommendation'
    | 'Anomaly'
    | 'Environment'
    | 'RuleExecution'
    | 'Override'
    | 'InputSet'
}

export interface GetFilterPathParams {
  identifier: string
}

export type GetFilterProps = Omit<
  GetProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>,
  'path'
> &
  GetFilterPathParams

/**
 * Get Filter
 */
export const GetFilter = ({ identifier, ...props }: GetFilterProps) => (
  <Get<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>
    path={`/filters/${identifier}`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseGetFilterProps = Omit<
  UseGetProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>,
  'path'
> &
  GetFilterPathParams

/**
 * Get Filter
 */
export const useGetFilter = ({ identifier, ...props }: UseGetFilterProps) =>
  useGet<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>(
    (paramsInPath: GetFilterPathParams) => `/filters/${paramsInPath.identifier}`,
    { base: getConfig('template/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Filter
 */
export const getFilterPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>(
    getConfig('template/api'),
    `/filters/${identifier}`,
    props,
    signal
  )

export interface CreateGlobalTemplateQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  connectorIdentifier?: string
  comments?: string
}

export interface CreateGlobalTemplateRequestBody {
  [key: string]: { [key: string]: any }
}

export type CreateGlobalTemplateProps = Omit<
  MutateProps<
    ResponseListTemplateWrapperResponse,
    Failure | Error,
    CreateGlobalTemplateQueryParams,
    CreateGlobalTemplateRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates a Global Template
 */
export const CreateGlobalTemplate = (props: CreateGlobalTemplateProps) => (
  <Mutate<
    ResponseListTemplateWrapperResponse,
    Failure | Error,
    CreateGlobalTemplateQueryParams,
    CreateGlobalTemplateRequestBody,
    void
  >
    verb="POST"
    path={`/globalTemplates`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseCreateGlobalTemplateProps = Omit<
  UseMutateProps<
    ResponseListTemplateWrapperResponse,
    Failure | Error,
    CreateGlobalTemplateQueryParams,
    CreateGlobalTemplateRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates a Global Template
 */
export const useCreateGlobalTemplate = (props: UseCreateGlobalTemplateProps) =>
  useMutate<
    ResponseListTemplateWrapperResponse,
    Failure | Error,
    CreateGlobalTemplateQueryParams,
    CreateGlobalTemplateRequestBody,
    void
  >('POST', `/globalTemplates`, { base: getConfig('template/api'), ...props })

/**
 * Creates a Global Template
 */
export const createGlobalTemplatePromise = (
  props: MutateUsingFetchProps<
    ResponseListTemplateWrapperResponse,
    Failure | Error,
    CreateGlobalTemplateQueryParams,
    CreateGlobalTemplateRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListTemplateWrapperResponse,
    Failure | Error,
    CreateGlobalTemplateQueryParams,
    CreateGlobalTemplateRequestBody,
    void
  >('POST', getConfig('template/api'), `/globalTemplates`, props, signal)

export interface GetGlobalTemplateInputSetYamlQueryParams {
  accountIdentifier: string
  versionLabel: string
}

export interface GetGlobalTemplateInputSetYamlPathParams {
  globalTemplateIdentifier: string
}

export type GetGlobalTemplateInputSetYamlProps = Omit<
  GetProps<
    ResponseString,
    Failure | Error,
    GetGlobalTemplateInputSetYamlQueryParams,
    GetGlobalTemplateInputSetYamlPathParams
  >,
  'path'
> &
  GetGlobalTemplateInputSetYamlPathParams

/**
 * Gets global template input set yaml
 */
export const GetGlobalTemplateInputSetYaml = ({
  globalTemplateIdentifier,
  ...props
}: GetGlobalTemplateInputSetYamlProps) => (
  <Get<
    ResponseString,
    Failure | Error,
    GetGlobalTemplateInputSetYamlQueryParams,
    GetGlobalTemplateInputSetYamlPathParams
  >
    path={`/globalTemplates/inputs/${globalTemplateIdentifier}`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseGetGlobalTemplateInputSetYamlProps = Omit<
  UseGetProps<
    ResponseString,
    Failure | Error,
    GetGlobalTemplateInputSetYamlQueryParams,
    GetGlobalTemplateInputSetYamlPathParams
  >,
  'path'
> &
  GetGlobalTemplateInputSetYamlPathParams

/**
 * Gets global template input set yaml
 */
export const useGetGlobalTemplateInputSetYaml = ({
  globalTemplateIdentifier,
  ...props
}: UseGetGlobalTemplateInputSetYamlProps) =>
  useGet<
    ResponseString,
    Failure | Error,
    GetGlobalTemplateInputSetYamlQueryParams,
    GetGlobalTemplateInputSetYamlPathParams
  >(
    (paramsInPath: GetGlobalTemplateInputSetYamlPathParams) =>
      `/globalTemplates/inputs/${paramsInPath.globalTemplateIdentifier}`,
    { base: getConfig('template/api'), pathParams: { globalTemplateIdentifier }, ...props }
  )

/**
 * Gets global template input set yaml
 */
export const getGlobalTemplateInputSetYamlPromise = (
  {
    globalTemplateIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseString,
    Failure | Error,
    GetGlobalTemplateInputSetYamlQueryParams,
    GetGlobalTemplateInputSetYamlPathParams
  > & { globalTemplateIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseString,
    Failure | Error,
    GetGlobalTemplateInputSetYamlQueryParams,
    GetGlobalTemplateInputSetYamlPathParams
  >(getConfig('template/api'), `/globalTemplates/inputs/${globalTemplateIdentifier}`, props, signal)

export interface GetGlobalTemplateListQueryParams {
  page?: number
  size?: number
  sort?: string[]
  searchTerm?: string
  filterIdentifier?: string
  templateListType: 'Stable' | 'LastUpdated' | 'All'
}

export type GetGlobalTemplateListProps = Omit<
  MutateProps<
    ResponsePageTemplateSummaryResponse,
    Failure | Error,
    GetGlobalTemplateListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets all Global template list
 */
export const GetGlobalTemplateList = (props: GetGlobalTemplateListProps) => (
  <Mutate<
    ResponsePageTemplateSummaryResponse,
    Failure | Error,
    GetGlobalTemplateListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >
    verb="POST"
    path={`/globalTemplates/list`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseGetGlobalTemplateListProps = Omit<
  UseMutateProps<
    ResponsePageTemplateSummaryResponse,
    Failure | Error,
    GetGlobalTemplateListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets all Global template list
 */
export const useGetGlobalTemplateList = (props: UseGetGlobalTemplateListProps) =>
  useMutate<
    ResponsePageTemplateSummaryResponse,
    Failure | Error,
    GetGlobalTemplateListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >('POST', `/globalTemplates/list`, { base: getConfig('template/api'), ...props })

/**
 * Gets all Global template list
 */
export const getGlobalTemplateListPromise = (
  props: MutateUsingFetchProps<
    ResponsePageTemplateSummaryResponse,
    Failure | Error,
    GetGlobalTemplateListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageTemplateSummaryResponse,
    Failure | Error,
    GetGlobalTemplateListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >('POST', getConfig('template/api'), `/globalTemplates/list`, props, signal)

export type GetTemplateHealthStatusProps = Omit<GetProps<ResponseString, unknown, void, void>, 'path'>

/**
 * get health for Template service
 */
export const GetTemplateHealthStatus = (props: GetTemplateHealthStatusProps) => (
  <Get<ResponseString, unknown, void, void> path={`/health`} base={getConfig('template/api')} {...props} />
)

export type UseGetTemplateHealthStatusProps = Omit<UseGetProps<ResponseString, unknown, void, void>, 'path'>

/**
 * get health for Template service
 */
export const useGetTemplateHealthStatus = (props: UseGetTemplateHealthStatusProps) =>
  useGet<ResponseString, unknown, void, void>(`/health`, { base: getConfig('template/api'), ...props })

/**
 * get health for Template service
 */
export const getTemplateHealthStatusPromise = (
  props: GetUsingFetchProps<ResponseString, unknown, void, void>,
  signal?: RequestInit['signal']
) => getUsingFetch<ResponseString, unknown, void, void>(getConfig('template/api'), `/health`, props, signal)

export interface RefreshAndUpdateTemplateInputsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  templateIdentifier: string
  versionLabel: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  lastCommitId?: string
  isNewBranch?: boolean
}

export type RefreshAndUpdateTemplateInputsProps = Omit<
  MutateProps<
    ResponseBoolean,
    Failure | Error,
    RefreshAndUpdateTemplateInputsQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * This refreshes and update template inputs in template
 */
export const RefreshAndUpdateTemplateInputs = (props: RefreshAndUpdateTemplateInputsProps) => (
  <Mutate<
    ResponseBoolean,
    Failure | Error,
    RefreshAndUpdateTemplateInputsQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    void
  >
    verb="POST"
    path={`/refresh-template`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseRefreshAndUpdateTemplateInputsProps = Omit<
  UseMutateProps<
    ResponseBoolean,
    Failure | Error,
    RefreshAndUpdateTemplateInputsQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * This refreshes and update template inputs in template
 */
export const useRefreshAndUpdateTemplateInputs = (props: UseRefreshAndUpdateTemplateInputsProps) =>
  useMutate<
    ResponseBoolean,
    Failure | Error,
    RefreshAndUpdateTemplateInputsQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    void
  >('POST', `/refresh-template`, { base: getConfig('template/api'), ...props })

/**
 * This refreshes and update template inputs in template
 */
export const refreshAndUpdateTemplateInputsPromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    RefreshAndUpdateTemplateInputsQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    Failure | Error,
    RefreshAndUpdateTemplateInputsQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    void
  >('POST', getConfig('template/api'), `/refresh-template`, props, signal)

export interface RefreshAllQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  templateIdentifier: string
  versionLabel: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  lastCommitId?: string
  isNewBranch?: boolean
}

export type RefreshAllProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, RefreshAllQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * This does recursive refresh and update template inputs in template
 */
export const RefreshAll = (props: RefreshAllProps) => (
  <Mutate<ResponseBoolean, Failure | Error, RefreshAllQueryParams, void, void>
    verb="POST"
    path={`/refresh-template/refresh-all`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseRefreshAllProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, RefreshAllQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * This does recursive refresh and update template inputs in template
 */
export const useRefreshAll = (props: UseRefreshAllProps) =>
  useMutate<ResponseBoolean, Failure | Error, RefreshAllQueryParams, void, void>(
    'POST',
    `/refresh-template/refresh-all`,
    { base: getConfig('template/api'), ...props }
  )

/**
 * This does recursive refresh and update template inputs in template
 */
export const refreshAllPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, RefreshAllQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, RefreshAllQueryParams, void, void>(
    'POST',
    getConfig('template/api'),
    `/refresh-template/refresh-all`,
    props,
    signal
  )

export interface GetRefreshedYamlQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetRefreshedYamlProps = Omit<
  MutateProps<ResponseRefreshResponse, Failure | Error, GetRefreshedYamlQueryParams, RefreshRequest, void>,
  'path' | 'verb'
>

/**
 * This refreshes Template Inputs in given yaml
 */
export const GetRefreshedYaml = (props: GetRefreshedYamlProps) => (
  <Mutate<ResponseRefreshResponse, Failure | Error, GetRefreshedYamlQueryParams, RefreshRequest, void>
    verb="POST"
    path={`/refresh-template/refreshed-yaml`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseGetRefreshedYamlProps = Omit<
  UseMutateProps<ResponseRefreshResponse, Failure | Error, GetRefreshedYamlQueryParams, RefreshRequest, void>,
  'path' | 'verb'
>

/**
 * This refreshes Template Inputs in given yaml
 */
export const useGetRefreshedYaml = (props: UseGetRefreshedYamlProps) =>
  useMutate<ResponseRefreshResponse, Failure | Error, GetRefreshedYamlQueryParams, RefreshRequest, void>(
    'POST',
    `/refresh-template/refreshed-yaml`,
    { base: getConfig('template/api'), ...props }
  )

/**
 * This refreshes Template Inputs in given yaml
 */
export const getRefreshedYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseRefreshResponse,
    Failure | Error,
    GetRefreshedYamlQueryParams,
    RefreshRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseRefreshResponse, Failure | Error, GetRefreshedYamlQueryParams, RefreshRequest, void>(
    'POST',
    getConfig('template/api'),
    `/refresh-template/refreshed-yaml`,
    props,
    signal
  )

export interface GetYamlDiffQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  templateIdentifier: string
  versionLabel: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetYamlDiffProps = Omit<
  GetProps<ResponseYamlDiffResponseDTO, Failure | Error, GetYamlDiffQueryParams, void>,
  'path'
>

/**
 * This returns original yaml and refresh yaml of template
 */
export const GetYamlDiff = (props: GetYamlDiffProps) => (
  <Get<ResponseYamlDiffResponseDTO, Failure | Error, GetYamlDiffQueryParams, void>
    path={`/refresh-template/show-diff`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseGetYamlDiffProps = Omit<
  UseGetProps<ResponseYamlDiffResponseDTO, Failure | Error, GetYamlDiffQueryParams, void>,
  'path'
>

/**
 * This returns original yaml and refresh yaml of template
 */
export const useGetYamlDiff = (props: UseGetYamlDiffProps) =>
  useGet<ResponseYamlDiffResponseDTO, Failure | Error, GetYamlDiffQueryParams, void>(`/refresh-template/show-diff`, {
    base: getConfig('template/api'),
    ...props
  })

/**
 * This returns original yaml and refresh yaml of template
 */
export const getYamlDiffPromise = (
  props: GetUsingFetchProps<ResponseYamlDiffResponseDTO, Failure | Error, GetYamlDiffQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseYamlDiffResponseDTO, Failure | Error, GetYamlDiffQueryParams, void>(
    getConfig('template/api'),
    `/refresh-template/show-diff`,
    props,
    signal
  )

export interface ValidateTemplateInputsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  templateIdentifier: string
  versionLabel: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type ValidateTemplateInputsProps = Omit<
  GetProps<ResponseValidateTemplateInputsResponseDTO, Failure | Error, ValidateTemplateInputsQueryParams, void>,
  'path'
>

/**
 * This validates whether yaml of template is valid or not
 */
export const ValidateTemplateInputs = (props: ValidateTemplateInputsProps) => (
  <Get<ResponseValidateTemplateInputsResponseDTO, Failure | Error, ValidateTemplateInputsQueryParams, void>
    path={`/refresh-template/validate-template-inputs`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseValidateTemplateInputsProps = Omit<
  UseGetProps<ResponseValidateTemplateInputsResponseDTO, Failure | Error, ValidateTemplateInputsQueryParams, void>,
  'path'
>

/**
 * This validates whether yaml of template is valid or not
 */
export const useValidateTemplateInputs = (props: UseValidateTemplateInputsProps) =>
  useGet<ResponseValidateTemplateInputsResponseDTO, Failure | Error, ValidateTemplateInputsQueryParams, void>(
    `/refresh-template/validate-template-inputs`,
    { base: getConfig('template/api'), ...props }
  )

/**
 * This validates whether yaml of template is valid or not
 */
export const validateTemplateInputsPromise = (
  props: GetUsingFetchProps<
    ResponseValidateTemplateInputsResponseDTO,
    Failure | Error,
    ValidateTemplateInputsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseValidateTemplateInputsResponseDTO, Failure | Error, ValidateTemplateInputsQueryParams, void>(
    getConfig('template/api'),
    `/refresh-template/validate-template-inputs`,
    props,
    signal
  )

export interface CreateTemplateQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  repoName?: string
  setDefaultTemplate?: boolean
  comments?: string
}

export type CreateTemplateProps = Omit<
  MutateProps<
    ResponseTemplateWrapperResponse,
    Failure | Error,
    CreateTemplateQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates a Template
 */
export const CreateTemplate = (props: CreateTemplateProps) => (
  <Mutate<
    ResponseTemplateWrapperResponse,
    Failure | Error,
    CreateTemplateQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    void
  >
    verb="POST"
    path={`/templates`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseCreateTemplateProps = Omit<
  UseMutateProps<
    ResponseTemplateWrapperResponse,
    Failure | Error,
    CreateTemplateQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates a Template
 */
export const useCreateTemplate = (props: UseCreateTemplateProps) =>
  useMutate<
    ResponseTemplateWrapperResponse,
    Failure | Error,
    CreateTemplateQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    void
  >('POST', `/templates`, { base: getConfig('template/api'), ...props })

/**
 * Creates a Template
 */
export const createTemplatePromise = (
  props: MutateUsingFetchProps<
    ResponseTemplateWrapperResponse,
    Failure | Error,
    CreateTemplateQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseTemplateWrapperResponse,
    Failure | Error,
    CreateTemplateQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    void
  >('POST', getConfig('template/api'), `/templates`, props, signal)

export interface GetYamlWithTemplateRefsResolvedQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  AppendInputSetValidator?: boolean
}

export type GetYamlWithTemplateRefsResolvedProps = Omit<
  MutateProps<
    ResponseTemplateMergeResponse,
    Failure | Error,
    GetYamlWithTemplateRefsResolvedQueryParams,
    TemplateApplyRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets complete yaml with templateRefs resolved
 */
export const GetYamlWithTemplateRefsResolved = (props: GetYamlWithTemplateRefsResolvedProps) => (
  <Mutate<
    ResponseTemplateMergeResponse,
    Failure | Error,
    GetYamlWithTemplateRefsResolvedQueryParams,
    TemplateApplyRequestRequestBody,
    void
  >
    verb="POST"
    path={`/templates/applyTemplates`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseGetYamlWithTemplateRefsResolvedProps = Omit<
  UseMutateProps<
    ResponseTemplateMergeResponse,
    Failure | Error,
    GetYamlWithTemplateRefsResolvedQueryParams,
    TemplateApplyRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets complete yaml with templateRefs resolved
 */
export const useGetYamlWithTemplateRefsResolved = (props: UseGetYamlWithTemplateRefsResolvedProps) =>
  useMutate<
    ResponseTemplateMergeResponse,
    Failure | Error,
    GetYamlWithTemplateRefsResolvedQueryParams,
    TemplateApplyRequestRequestBody,
    void
  >('POST', `/templates/applyTemplates`, { base: getConfig('template/api'), ...props })

/**
 * Gets complete yaml with templateRefs resolved
 */
export const getYamlWithTemplateRefsResolvedPromise = (
  props: MutateUsingFetchProps<
    ResponseTemplateMergeResponse,
    Failure | Error,
    GetYamlWithTemplateRefsResolvedQueryParams,
    TemplateApplyRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseTemplateMergeResponse,
    Failure | Error,
    GetYamlWithTemplateRefsResolvedQueryParams,
    TemplateApplyRequestRequestBody,
    void
  >('POST', getConfig('template/api'), `/templates/applyTemplates`, props, signal)

export type DummyApiForSwaggerSchemaCheckProps = Omit<
  GetProps<ResponseNGTemplateConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking template schema
 */
export const DummyApiForSwaggerSchemaCheck = (props: DummyApiForSwaggerSchemaCheckProps) => (
  <Get<ResponseNGTemplateConfig, Failure | Error, void, void>
    path={`/templates/dummyApiForSwaggerSchemaCheck`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseDummyApiForSwaggerSchemaCheckProps = Omit<
  UseGetProps<ResponseNGTemplateConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking template schema
 */
export const useDummyApiForSwaggerSchemaCheck = (props: UseDummyApiForSwaggerSchemaCheckProps) =>
  useGet<ResponseNGTemplateConfig, Failure | Error, void, void>(`/templates/dummyApiForSwaggerSchemaCheck`, {
    base: getConfig('template/api'),
    ...props
  })

/**
 * dummy api for checking template schema
 */
export const dummyApiForSwaggerSchemaCheckPromise = (
  props: GetUsingFetchProps<ResponseNGTemplateConfig, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNGTemplateConfig, Failure | Error, void, void>(
    getConfig('template/api'),
    `/templates/dummyApiForSwaggerSchemaCheck`,
    props,
    signal
  )

export interface ListTemplateUsageQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  versionLabel?: string
  isStableTemplate?: boolean
  searchTerm?: string
}

export interface ListTemplateUsagePathParams {
  templateIdentifier: string
}

export type ListTemplateUsageProps = Omit<
  GetProps<ResponsePageEntitySetupUsageDTO, Failure | Error, ListTemplateUsageQueryParams, ListTemplateUsagePathParams>,
  'path'
> &
  ListTemplateUsagePathParams

/**
 * Get Entities referring this template
 */
export const ListTemplateUsage = ({ templateIdentifier, ...props }: ListTemplateUsageProps) => (
  <Get<ResponsePageEntitySetupUsageDTO, Failure | Error, ListTemplateUsageQueryParams, ListTemplateUsagePathParams>
    path={`/templates/entitySetupUsage/${templateIdentifier}`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseListTemplateUsageProps = Omit<
  UseGetProps<
    ResponsePageEntitySetupUsageDTO,
    Failure | Error,
    ListTemplateUsageQueryParams,
    ListTemplateUsagePathParams
  >,
  'path'
> &
  ListTemplateUsagePathParams

/**
 * Get Entities referring this template
 */
export const useListTemplateUsage = ({ templateIdentifier, ...props }: UseListTemplateUsageProps) =>
  useGet<ResponsePageEntitySetupUsageDTO, Failure | Error, ListTemplateUsageQueryParams, ListTemplateUsagePathParams>(
    (paramsInPath: ListTemplateUsagePathParams) => `/templates/entitySetupUsage/${paramsInPath.templateIdentifier}`,
    { base: getConfig('template/api'), pathParams: { templateIdentifier }, ...props }
  )

/**
 * Get Entities referring this template
 */
export const listTemplateUsagePromise = (
  {
    templateIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponsePageEntitySetupUsageDTO,
    Failure | Error,
    ListTemplateUsageQueryParams,
    ListTemplateUsagePathParams
  > & { templateIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageEntitySetupUsageDTO,
    Failure | Error,
    ListTemplateUsageQueryParams,
    ListTemplateUsagePathParams
  >(getConfig('template/api'), `/templates/entitySetupUsage/${templateIdentifier}`, props, signal)

export interface ImportTemplateQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  connectorRef?: string
  repoName?: string
  branch?: string
  filePath?: string
  isForceImport?: boolean
}

export interface ImportTemplatePathParams {
  templateIdentifier: string
}

export type ImportTemplateProps = Omit<
  MutateProps<
    ResponseTemplateImportSaveResponse,
    Failure | Error,
    ImportTemplateQueryParams,
    TemplateImportRequest,
    ImportTemplatePathParams
  >,
  'path' | 'verb'
> &
  ImportTemplatePathParams

/**
 * import template from git
 */
export const ImportTemplate = ({ templateIdentifier, ...props }: ImportTemplateProps) => (
  <Mutate<
    ResponseTemplateImportSaveResponse,
    Failure | Error,
    ImportTemplateQueryParams,
    TemplateImportRequest,
    ImportTemplatePathParams
  >
    verb="POST"
    path={`/templates/import/${templateIdentifier}`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseImportTemplateProps = Omit<
  UseMutateProps<
    ResponseTemplateImportSaveResponse,
    Failure | Error,
    ImportTemplateQueryParams,
    TemplateImportRequest,
    ImportTemplatePathParams
  >,
  'path' | 'verb'
> &
  ImportTemplatePathParams

/**
 * import template from git
 */
export const useImportTemplate = ({ templateIdentifier, ...props }: UseImportTemplateProps) =>
  useMutate<
    ResponseTemplateImportSaveResponse,
    Failure | Error,
    ImportTemplateQueryParams,
    TemplateImportRequest,
    ImportTemplatePathParams
  >('POST', (paramsInPath: ImportTemplatePathParams) => `/templates/import/${paramsInPath.templateIdentifier}`, {
    base: getConfig('template/api'),
    pathParams: { templateIdentifier },
    ...props
  })

/**
 * import template from git
 */
export const importTemplatePromise = (
  {
    templateIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseTemplateImportSaveResponse,
    Failure | Error,
    ImportTemplateQueryParams,
    TemplateImportRequest,
    ImportTemplatePathParams
  > & { templateIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseTemplateImportSaveResponse,
    Failure | Error,
    ImportTemplateQueryParams,
    TemplateImportRequest,
    ImportTemplatePathParams
  >('POST', getConfig('template/api'), `/templates/import/${templateIdentifier}`, props, signal)

export interface GetTemplateListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  page?: number
  size?: number
  sort?: string[]
  searchTerm?: string
  filterIdentifier?: string
  templateListType: 'Stable' | 'LastUpdated' | 'All'
  includeAllTemplatesAvailableAtScope?: boolean
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  getDistinctFromBranches?: boolean
}

export type GetTemplateListProps = Omit<
  MutateProps<
    ResponsePageTemplateSummaryResponse,
    Failure | Error,
    GetTemplateListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets all template list
 */
export const GetTemplateList = (props: GetTemplateListProps) => (
  <Mutate<
    ResponsePageTemplateSummaryResponse,
    Failure | Error,
    GetTemplateListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >
    verb="POST"
    path={`/templates/list`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseGetTemplateListProps = Omit<
  UseMutateProps<
    ResponsePageTemplateSummaryResponse,
    Failure | Error,
    GetTemplateListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets all template list
 */
export const useGetTemplateList = (props: UseGetTemplateListProps) =>
  useMutate<
    ResponsePageTemplateSummaryResponse,
    Failure | Error,
    GetTemplateListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >('POST', `/templates/list`, { base: getConfig('template/api'), ...props })

/**
 * Gets all template list
 */
export const getTemplateListPromise = (
  props: MutateUsingFetchProps<
    ResponsePageTemplateSummaryResponse,
    Failure | Error,
    GetTemplateListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageTemplateSummaryResponse,
    Failure | Error,
    GetTemplateListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >('POST', getConfig('template/api'), `/templates/list`, props, signal)

export interface GetTemplateMetadataListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  page?: number
  size?: number
  sort?: string[]
  searchTerm?: string
  filterIdentifier?: string
  templateListType: 'Stable' | 'LastUpdated' | 'All'
  includeAllTemplatesAvailableAtScope?: boolean
  getDistinctFromBranches?: boolean
}

export type GetTemplateMetadataListProps = Omit<
  MutateProps<
    ResponsePageTemplateMetadataSummaryResponse,
    Failure | Error,
    GetTemplateMetadataListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets all template list
 */
export const GetTemplateMetadataList = (props: GetTemplateMetadataListProps) => (
  <Mutate<
    ResponsePageTemplateMetadataSummaryResponse,
    Failure | Error,
    GetTemplateMetadataListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >
    verb="POST"
    path={`/templates/list-metadata`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseGetTemplateMetadataListProps = Omit<
  UseMutateProps<
    ResponsePageTemplateMetadataSummaryResponse,
    Failure | Error,
    GetTemplateMetadataListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets all template list
 */
export const useGetTemplateMetadataList = (props: UseGetTemplateMetadataListProps) =>
  useMutate<
    ResponsePageTemplateMetadataSummaryResponse,
    Failure | Error,
    GetTemplateMetadataListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >('POST', `/templates/list-metadata`, { base: getConfig('template/api'), ...props })

/**
 * Gets all template list
 */
export const getTemplateMetadataListPromise = (
  props: MutateUsingFetchProps<
    ResponsePageTemplateMetadataSummaryResponse,
    Failure | Error,
    GetTemplateMetadataListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageTemplateMetadataSummaryResponse,
    Failure | Error,
    GetTemplateMetadataListQueryParams,
    TemplateFilterPropertiesRequestBody,
    void
  >('POST', getConfig('template/api'), `/templates/list-metadata`, props, signal)

export interface GetRepositoryListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  includeAllTemplatesAvailableAtScope?: boolean
}

export type GetRepositoryListProps = Omit<
  GetProps<ResponseTemplateListRepoResponse, Failure | Error, GetRepositoryListQueryParams, void>,
  'path'
>

/**
 * Gets all repo list
 */
export const GetRepositoryList = (props: GetRepositoryListProps) => (
  <Get<ResponseTemplateListRepoResponse, Failure | Error, GetRepositoryListQueryParams, void>
    path={`/templates/list-repo`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseGetRepositoryListProps = Omit<
  UseGetProps<ResponseTemplateListRepoResponse, Failure | Error, GetRepositoryListQueryParams, void>,
  'path'
>

/**
 * Gets all repo list
 */
export const useGetRepositoryList = (props: UseGetRepositoryListProps) =>
  useGet<ResponseTemplateListRepoResponse, Failure | Error, GetRepositoryListQueryParams, void>(
    `/templates/list-repo`,
    { base: getConfig('template/api'), ...props }
  )

/**
 * Gets all repo list
 */
export const getRepositoryListPromise = (
  props: GetUsingFetchProps<ResponseTemplateListRepoResponse, Failure | Error, GetRepositoryListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseTemplateListRepoResponse, Failure | Error, GetRepositoryListQueryParams, void>(
    getConfig('template/api'),
    `/templates/list-repo`,
    props,
    signal
  )

export interface GetsMergedTemplateInputYamlQueryParams {
  accountIdentifier: string
}

export type GetsMergedTemplateInputYamlProps = Omit<
  MutateProps<
    ResponseTemplateRetainVariablesResponse,
    Failure | Error,
    GetsMergedTemplateInputYamlQueryParams,
    TemplateRetainVariablesRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Get merged Template input YAML
 */
export const GetsMergedTemplateInputYaml = (props: GetsMergedTemplateInputYamlProps) => (
  <Mutate<
    ResponseTemplateRetainVariablesResponse,
    Failure | Error,
    GetsMergedTemplateInputYamlQueryParams,
    TemplateRetainVariablesRequestDTO,
    void
  >
    verb="POST"
    path={`/templates/mergeTemplateInputs`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseGetsMergedTemplateInputYamlProps = Omit<
  UseMutateProps<
    ResponseTemplateRetainVariablesResponse,
    Failure | Error,
    GetsMergedTemplateInputYamlQueryParams,
    TemplateRetainVariablesRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Get merged Template input YAML
 */
export const useGetsMergedTemplateInputYaml = (props: UseGetsMergedTemplateInputYamlProps) =>
  useMutate<
    ResponseTemplateRetainVariablesResponse,
    Failure | Error,
    GetsMergedTemplateInputYamlQueryParams,
    TemplateRetainVariablesRequestDTO,
    void
  >('POST', `/templates/mergeTemplateInputs`, { base: getConfig('template/api'), ...props })

/**
 * Get merged Template input YAML
 */
export const getsMergedTemplateInputYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseTemplateRetainVariablesResponse,
    Failure | Error,
    GetsMergedTemplateInputYamlQueryParams,
    TemplateRetainVariablesRequestDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseTemplateRetainVariablesResponse,
    Failure | Error,
    GetsMergedTemplateInputYamlQueryParams,
    TemplateRetainVariablesRequestDTO,
    void
  >('POST', getConfig('template/api'), `/templates/mergeTemplateInputs`, props, signal)

export interface MoveTemplateConfigsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  connectorRef?: string
  repoName?: string
  branch?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
  moveConfigType?: 'INLINE_TO_REMOTE'
  versionLabel: string
}

export interface MoveTemplateConfigsPathParams {
  templateIdentifier: string
}

export type MoveTemplateConfigsProps = Omit<
  MutateProps<
    ResponseTemplateMoveConfigResponse,
    Failure | Error,
    MoveTemplateConfigsQueryParams,
    void,
    MoveTemplateConfigsPathParams
  >,
  'path' | 'verb'
> &
  MoveTemplateConfigsPathParams

/**
 * Move Template YAML from inline to remote
 */
export const MoveTemplateConfigs = ({ templateIdentifier, ...props }: MoveTemplateConfigsProps) => (
  <Mutate<
    ResponseTemplateMoveConfigResponse,
    Failure | Error,
    MoveTemplateConfigsQueryParams,
    void,
    MoveTemplateConfigsPathParams
  >
    verb="POST"
    path={`/templates/move-config/${templateIdentifier}`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseMoveTemplateConfigsProps = Omit<
  UseMutateProps<
    ResponseTemplateMoveConfigResponse,
    Failure | Error,
    MoveTemplateConfigsQueryParams,
    void,
    MoveTemplateConfigsPathParams
  >,
  'path' | 'verb'
> &
  MoveTemplateConfigsPathParams

/**
 * Move Template YAML from inline to remote
 */
export const useMoveTemplateConfigs = ({ templateIdentifier, ...props }: UseMoveTemplateConfigsProps) =>
  useMutate<
    ResponseTemplateMoveConfigResponse,
    Failure | Error,
    MoveTemplateConfigsQueryParams,
    void,
    MoveTemplateConfigsPathParams
  >(
    'POST',
    (paramsInPath: MoveTemplateConfigsPathParams) => `/templates/move-config/${paramsInPath.templateIdentifier}`,
    { base: getConfig('template/api'), pathParams: { templateIdentifier }, ...props }
  )

/**
 * Move Template YAML from inline to remote
 */
export const moveTemplateConfigsPromise = (
  {
    templateIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseTemplateMoveConfigResponse,
    Failure | Error,
    MoveTemplateConfigsQueryParams,
    void,
    MoveTemplateConfigsPathParams
  > & { templateIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseTemplateMoveConfigResponse,
    Failure | Error,
    MoveTemplateConfigsQueryParams,
    void,
    MoveTemplateConfigsPathParams
  >('POST', getConfig('template/api'), `/templates/move-config/${templateIdentifier}`, props, signal)

export interface GetTemplateSchemaQueryParams {
  templateEntityType:
    | 'Step'
    | 'Stage'
    | 'Pipeline'
    | 'CustomDeployment'
    | 'MonitoredService'
    | 'SecretManager'
    | 'ArtifactSource'
    | 'StepGroup'
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
  accountIdentifier: string
  entityType?: string
}

export type GetTemplateSchemaProps = Omit<
  GetProps<ResponseJsonNode, Failure | Error, GetTemplateSchemaQueryParams, void>,
  'path'
>

/**
 * Get Template Schema
 */
export const GetTemplateSchema = (props: GetTemplateSchemaProps) => (
  <Get<ResponseJsonNode, Failure | Error, GetTemplateSchemaQueryParams, void>
    path={`/templates/schema/templateSchema`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseGetTemplateSchemaProps = Omit<
  UseGetProps<ResponseJsonNode, Failure | Error, GetTemplateSchemaQueryParams, void>,
  'path'
>

/**
 * Get Template Schema
 */
export const useGetTemplateSchema = (props: UseGetTemplateSchemaProps) =>
  useGet<ResponseJsonNode, Failure | Error, GetTemplateSchemaQueryParams, void>(`/templates/schema/templateSchema`, {
    base: getConfig('template/api'),
    ...props
  })

/**
 * Get Template Schema
 */
export const getTemplateSchemaPromise = (
  props: GetUsingFetchProps<ResponseJsonNode, Failure | Error, GetTemplateSchemaQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJsonNode, Failure | Error, GetTemplateSchemaQueryParams, void>(
    getConfig('template/api'),
    `/templates/schema/templateSchema`,
    props,
    signal
  )

export interface GetTemplateInputSetYamlQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  versionLabel: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export interface GetTemplateInputSetYamlPathParams {
  templateIdentifier: string
}

export type GetTemplateInputSetYamlProps = Omit<
  GetProps<ResponseString, Failure | Error, GetTemplateInputSetYamlQueryParams, GetTemplateInputSetYamlPathParams>,
  'path'
> &
  GetTemplateInputSetYamlPathParams

/**
 * Gets template input set yaml
 */
export const GetTemplateInputSetYaml = ({ templateIdentifier, ...props }: GetTemplateInputSetYamlProps) => (
  <Get<ResponseString, Failure | Error, GetTemplateInputSetYamlQueryParams, GetTemplateInputSetYamlPathParams>
    path={`/templates/templateInputs/${templateIdentifier}`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseGetTemplateInputSetYamlProps = Omit<
  UseGetProps<ResponseString, Failure | Error, GetTemplateInputSetYamlQueryParams, GetTemplateInputSetYamlPathParams>,
  'path'
> &
  GetTemplateInputSetYamlPathParams

/**
 * Gets template input set yaml
 */
export const useGetTemplateInputSetYaml = ({ templateIdentifier, ...props }: UseGetTemplateInputSetYamlProps) =>
  useGet<ResponseString, Failure | Error, GetTemplateInputSetYamlQueryParams, GetTemplateInputSetYamlPathParams>(
    (paramsInPath: GetTemplateInputSetYamlPathParams) => `/templates/templateInputs/${paramsInPath.templateIdentifier}`,
    { base: getConfig('template/api'), pathParams: { templateIdentifier }, ...props }
  )

/**
 * Gets template input set yaml
 */
export const getTemplateInputSetYamlPromise = (
  {
    templateIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseString,
    Failure | Error,
    GetTemplateInputSetYamlQueryParams,
    GetTemplateInputSetYamlPathParams
  > & { templateIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, Failure | Error, GetTemplateInputSetYamlQueryParams, GetTemplateInputSetYamlPathParams>(
    getConfig('template/api'),
    `/templates/templateInputs/${templateIdentifier}`,
    props,
    signal
  )

export interface GetTemplateReferencesQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetTemplateReferencesProps = Omit<
  MutateProps<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetTemplateReferencesQueryParams,
    TemplateReferenceRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * get all Template entity references
 */
export const GetTemplateReferences = (props: GetTemplateReferencesProps) => (
  <Mutate<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetTemplateReferencesQueryParams,
    TemplateReferenceRequest,
    void
  >
    verb="POST"
    path={`/templates/templateReferences`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseGetTemplateReferencesProps = Omit<
  UseMutateProps<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetTemplateReferencesQueryParams,
    TemplateReferenceRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * get all Template entity references
 */
export const useGetTemplateReferences = (props: UseGetTemplateReferencesProps) =>
  useMutate<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetTemplateReferencesQueryParams,
    TemplateReferenceRequest,
    void
  >('POST', `/templates/templateReferences`, { base: getConfig('template/api'), ...props })

/**
 * get all Template entity references
 */
export const getTemplateReferencesPromise = (
  props: MutateUsingFetchProps<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetTemplateReferencesQueryParams,
    TemplateReferenceRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListEntityDetailProtoDTO,
    Failure | Error,
    GetTemplateReferencesQueryParams,
    TemplateReferenceRequest,
    void
  >('POST', getConfig('template/api'), `/templates/templateReferences`, props, signal)

export interface GetTemplateAlongWithInputSetYamlQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  versionLabel: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export interface GetTemplateAlongWithInputSetYamlPathParams {
  templateIdentifier: string
}

export type GetTemplateAlongWithInputSetYamlProps = Omit<
  GetProps<
    ResponseTemplateWithInputsResponse,
    Failure | Error,
    GetTemplateAlongWithInputSetYamlQueryParams,
    GetTemplateAlongWithInputSetYamlPathParams
  >,
  'path'
> &
  GetTemplateAlongWithInputSetYamlPathParams

/**
 * Get Template along with Input Set YAML
 */
export const GetTemplateAlongWithInputSetYaml = ({
  templateIdentifier,
  ...props
}: GetTemplateAlongWithInputSetYamlProps) => (
  <Get<
    ResponseTemplateWithInputsResponse,
    Failure | Error,
    GetTemplateAlongWithInputSetYamlQueryParams,
    GetTemplateAlongWithInputSetYamlPathParams
  >
    path={`/templates/templateWithInputs/${templateIdentifier}`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseGetTemplateAlongWithInputSetYamlProps = Omit<
  UseGetProps<
    ResponseTemplateWithInputsResponse,
    Failure | Error,
    GetTemplateAlongWithInputSetYamlQueryParams,
    GetTemplateAlongWithInputSetYamlPathParams
  >,
  'path'
> &
  GetTemplateAlongWithInputSetYamlPathParams

/**
 * Get Template along with Input Set YAML
 */
export const useGetTemplateAlongWithInputSetYaml = ({
  templateIdentifier,
  ...props
}: UseGetTemplateAlongWithInputSetYamlProps) =>
  useGet<
    ResponseTemplateWithInputsResponse,
    Failure | Error,
    GetTemplateAlongWithInputSetYamlQueryParams,
    GetTemplateAlongWithInputSetYamlPathParams
  >(
    (paramsInPath: GetTemplateAlongWithInputSetYamlPathParams) =>
      `/templates/templateWithInputs/${paramsInPath.templateIdentifier}`,
    { base: getConfig('template/api'), pathParams: { templateIdentifier }, ...props }
  )

/**
 * Get Template along with Input Set YAML
 */
export const getTemplateAlongWithInputSetYamlPromise = (
  {
    templateIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseTemplateWithInputsResponse,
    Failure | Error,
    GetTemplateAlongWithInputSetYamlQueryParams,
    GetTemplateAlongWithInputSetYamlPathParams
  > & { templateIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseTemplateWithInputsResponse,
    Failure | Error,
    GetTemplateAlongWithInputSetYamlQueryParams,
    GetTemplateAlongWithInputSetYamlPathParams
  >(getConfig('template/api'), `/templates/templateWithInputs/${templateIdentifier}`, props, signal)

export interface UpdateGitDetailsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface UpdateGitDetailsPathParams {
  templateIdentifier: string
  versionLabel: string
}

export type UpdateGitDetailsProps = Omit<
  MutateProps<
    ResponseTemplateUpdateGitDetailsResponse,
    Failure | Error,
    UpdateGitDetailsQueryParams,
    TemplateUpdateGitDetailsRequest,
    UpdateGitDetailsPathParams
  >,
  'path' | 'verb'
> &
  UpdateGitDetailsPathParams

/**
 * Update git metadata details for a remote template
 */
export const UpdateGitDetails = ({ templateIdentifier, versionLabel, ...props }: UpdateGitDetailsProps) => (
  <Mutate<
    ResponseTemplateUpdateGitDetailsResponse,
    Failure | Error,
    UpdateGitDetailsQueryParams,
    TemplateUpdateGitDetailsRequest,
    UpdateGitDetailsPathParams
  >
    verb="POST"
    path={`/templates/update/git-metadata/${templateIdentifier}/${versionLabel}`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseUpdateGitDetailsProps = Omit<
  UseMutateProps<
    ResponseTemplateUpdateGitDetailsResponse,
    Failure | Error,
    UpdateGitDetailsQueryParams,
    TemplateUpdateGitDetailsRequest,
    UpdateGitDetailsPathParams
  >,
  'path' | 'verb'
> &
  UpdateGitDetailsPathParams

/**
 * Update git metadata details for a remote template
 */
export const useUpdateGitDetails = ({ templateIdentifier, versionLabel, ...props }: UseUpdateGitDetailsProps) =>
  useMutate<
    ResponseTemplateUpdateGitDetailsResponse,
    Failure | Error,
    UpdateGitDetailsQueryParams,
    TemplateUpdateGitDetailsRequest,
    UpdateGitDetailsPathParams
  >(
    'POST',
    (paramsInPath: UpdateGitDetailsPathParams) =>
      `/templates/update/git-metadata/${paramsInPath.templateIdentifier}/${paramsInPath.versionLabel}`,
    { base: getConfig('template/api'), pathParams: { templateIdentifier, versionLabel }, ...props }
  )

/**
 * Update git metadata details for a remote template
 */
export const updateGitDetailsPromise = (
  {
    templateIdentifier,
    versionLabel,
    ...props
  }: MutateUsingFetchProps<
    ResponseTemplateUpdateGitDetailsResponse,
    Failure | Error,
    UpdateGitDetailsQueryParams,
    TemplateUpdateGitDetailsRequest,
    UpdateGitDetailsPathParams
  > & { templateIdentifier: string; versionLabel: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseTemplateUpdateGitDetailsResponse,
    Failure | Error,
    UpdateGitDetailsQueryParams,
    TemplateUpdateGitDetailsRequest,
    UpdateGitDetailsPathParams
  >(
    'POST',
    getConfig('template/api'),
    `/templates/update/git-metadata/${templateIdentifier}/${versionLabel}`,
    props,
    signal
  )

export interface UpdateExistingTemplateVersionQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  lastCommitId?: string
  isNewBranch?: boolean
  setDefaultTemplate?: boolean
  comments?: string
}

export interface UpdateExistingTemplateVersionPathParams {
  templateIdentifier: string
  versionLabel: string
}

export type UpdateExistingTemplateVersionProps = Omit<
  MutateProps<
    ResponseTemplateWrapperResponse,
    Failure | Error,
    UpdateExistingTemplateVersionQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    UpdateExistingTemplateVersionPathParams
  >,
  'path' | 'verb'
> &
  UpdateExistingTemplateVersionPathParams

/**
 * Updating existing template version
 */
export const UpdateExistingTemplateVersion = ({
  templateIdentifier,
  versionLabel,
  ...props
}: UpdateExistingTemplateVersionProps) => (
  <Mutate<
    ResponseTemplateWrapperResponse,
    Failure | Error,
    UpdateExistingTemplateVersionQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    UpdateExistingTemplateVersionPathParams
  >
    verb="PUT"
    path={`/templates/update/${templateIdentifier}/${versionLabel}`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseUpdateExistingTemplateVersionProps = Omit<
  UseMutateProps<
    ResponseTemplateWrapperResponse,
    Failure | Error,
    UpdateExistingTemplateVersionQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    UpdateExistingTemplateVersionPathParams
  >,
  'path' | 'verb'
> &
  UpdateExistingTemplateVersionPathParams

/**
 * Updating existing template version
 */
export const useUpdateExistingTemplateVersion = ({
  templateIdentifier,
  versionLabel,
  ...props
}: UseUpdateExistingTemplateVersionProps) =>
  useMutate<
    ResponseTemplateWrapperResponse,
    Failure | Error,
    UpdateExistingTemplateVersionQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    UpdateExistingTemplateVersionPathParams
  >(
    'PUT',
    (paramsInPath: UpdateExistingTemplateVersionPathParams) =>
      `/templates/update/${paramsInPath.templateIdentifier}/${paramsInPath.versionLabel}`,
    { base: getConfig('template/api'), pathParams: { templateIdentifier, versionLabel }, ...props }
  )

/**
 * Updating existing template version
 */
export const updateExistingTemplateVersionPromise = (
  {
    templateIdentifier,
    versionLabel,
    ...props
  }: MutateUsingFetchProps<
    ResponseTemplateWrapperResponse,
    Failure | Error,
    UpdateExistingTemplateVersionQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    UpdateExistingTemplateVersionPathParams
  > & { templateIdentifier: string; versionLabel: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseTemplateWrapperResponse,
    Failure | Error,
    UpdateExistingTemplateVersionQueryParams,
    RefreshAndUpdateTemplateInputsBodyRequestBody,
    UpdateExistingTemplateVersionPathParams
  >('PUT', getConfig('template/api'), `/templates/update/${templateIdentifier}/${versionLabel}`, props, signal)

export interface UpdateStableTemplateQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  comments?: string
}

export interface UpdateStableTemplatePathParams {
  templateIdentifier: string
  versionLabel: string
}

export type UpdateStableTemplateProps = Omit<
  MutateProps<ResponseString, Failure | Error, UpdateStableTemplateQueryParams, void, UpdateStableTemplatePathParams>,
  'path' | 'verb'
> &
  UpdateStableTemplatePathParams

/**
 * Updating stable template version
 */
export const UpdateStableTemplate = ({ templateIdentifier, versionLabel, ...props }: UpdateStableTemplateProps) => (
  <Mutate<ResponseString, Failure | Error, UpdateStableTemplateQueryParams, void, UpdateStableTemplatePathParams>
    verb="PUT"
    path={`/templates/updateStableTemplate/${templateIdentifier}/${versionLabel}`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseUpdateStableTemplateProps = Omit<
  UseMutateProps<
    ResponseString,
    Failure | Error,
    UpdateStableTemplateQueryParams,
    void,
    UpdateStableTemplatePathParams
  >,
  'path' | 'verb'
> &
  UpdateStableTemplatePathParams

/**
 * Updating stable template version
 */
export const useUpdateStableTemplate = ({ templateIdentifier, versionLabel, ...props }: UseUpdateStableTemplateProps) =>
  useMutate<ResponseString, Failure | Error, UpdateStableTemplateQueryParams, void, UpdateStableTemplatePathParams>(
    'PUT',
    (paramsInPath: UpdateStableTemplatePathParams) =>
      `/templates/updateStableTemplate/${paramsInPath.templateIdentifier}/${paramsInPath.versionLabel}`,
    { base: getConfig('template/api'), pathParams: { templateIdentifier, versionLabel }, ...props }
  )

/**
 * Updating stable template version
 */
export const updateStableTemplatePromise = (
  {
    templateIdentifier,
    versionLabel,
    ...props
  }: MutateUsingFetchProps<
    ResponseString,
    Failure | Error,
    UpdateStableTemplateQueryParams,
    void,
    UpdateStableTemplatePathParams
  > & { templateIdentifier: string; versionLabel: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseString,
    Failure | Error,
    UpdateStableTemplateQueryParams,
    void,
    UpdateStableTemplatePathParams
  >(
    'PUT',
    getConfig('template/api'),
    `/templates/updateStableTemplate/${templateIdentifier}/${versionLabel}`,
    props,
    signal
  )

export interface UpdateTemplateSettingsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  updateStableTemplateVersion?: string
  currentScope?: 'account' | 'org' | 'project' | 'unknown'
  updateScope?: 'account' | 'org' | 'project' | 'unknown'
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  getDistinctFromBranches?: boolean
}

export interface UpdateTemplateSettingsPathParams {
  templateIdentifier: string
}

export type UpdateTemplateSettingsProps = Omit<
  MutateProps<
    ResponseBoolean,
    Failure | Error,
    UpdateTemplateSettingsQueryParams,
    void,
    UpdateTemplateSettingsPathParams
  >,
  'path' | 'verb'
> &
  UpdateTemplateSettingsPathParams

/**
 * Updating template settings, template scope and template stable version
 */
export const UpdateTemplateSettings = ({ templateIdentifier, ...props }: UpdateTemplateSettingsProps) => (
  <Mutate<ResponseBoolean, Failure | Error, UpdateTemplateSettingsQueryParams, void, UpdateTemplateSettingsPathParams>
    verb="PUT"
    path={`/templates/updateTemplateSettings/${templateIdentifier}`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseUpdateTemplateSettingsProps = Omit<
  UseMutateProps<
    ResponseBoolean,
    Failure | Error,
    UpdateTemplateSettingsQueryParams,
    void,
    UpdateTemplateSettingsPathParams
  >,
  'path' | 'verb'
> &
  UpdateTemplateSettingsPathParams

/**
 * Updating template settings, template scope and template stable version
 */
export const useUpdateTemplateSettings = ({ templateIdentifier, ...props }: UseUpdateTemplateSettingsProps) =>
  useMutate<
    ResponseBoolean,
    Failure | Error,
    UpdateTemplateSettingsQueryParams,
    void,
    UpdateTemplateSettingsPathParams
  >(
    'PUT',
    (paramsInPath: UpdateTemplateSettingsPathParams) =>
      `/templates/updateTemplateSettings/${paramsInPath.templateIdentifier}`,
    { base: getConfig('template/api'), pathParams: { templateIdentifier }, ...props }
  )

/**
 * Updating template settings, template scope and template stable version
 */
export const updateTemplateSettingsPromise = (
  {
    templateIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    UpdateTemplateSettingsQueryParams,
    void,
    UpdateTemplateSettingsPathParams
  > & { templateIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    Failure | Error,
    UpdateTemplateSettingsQueryParams,
    void,
    UpdateTemplateSettingsPathParams
  >('PUT', getConfig('template/api'), `/templates/updateTemplateSettings/${templateIdentifier}`, props, signal)

export interface GetYamlWithTemplateRefsResolvedV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  AppendInputSetValidator?: boolean
}

export type GetYamlWithTemplateRefsResolvedV2Props = Omit<
  MutateProps<
    ResponseTemplateMergeResponse,
    Failure | Error,
    GetYamlWithTemplateRefsResolvedV2QueryParams,
    TemplateApplyRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets complete yaml with templateRefs resolved
 */
export const GetYamlWithTemplateRefsResolvedV2 = (props: GetYamlWithTemplateRefsResolvedV2Props) => (
  <Mutate<
    ResponseTemplateMergeResponse,
    Failure | Error,
    GetYamlWithTemplateRefsResolvedV2QueryParams,
    TemplateApplyRequestRequestBody,
    void
  >
    verb="POST"
    path={`/templates/v2/applyTemplates`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseGetYamlWithTemplateRefsResolvedV2Props = Omit<
  UseMutateProps<
    ResponseTemplateMergeResponse,
    Failure | Error,
    GetYamlWithTemplateRefsResolvedV2QueryParams,
    TemplateApplyRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets complete yaml with templateRefs resolved
 */
export const useGetYamlWithTemplateRefsResolvedV2 = (props: UseGetYamlWithTemplateRefsResolvedV2Props) =>
  useMutate<
    ResponseTemplateMergeResponse,
    Failure | Error,
    GetYamlWithTemplateRefsResolvedV2QueryParams,
    TemplateApplyRequestRequestBody,
    void
  >('POST', `/templates/v2/applyTemplates`, { base: getConfig('template/api'), ...props })

/**
 * Gets complete yaml with templateRefs resolved
 */
export const getYamlWithTemplateRefsResolvedV2Promise = (
  props: MutateUsingFetchProps<
    ResponseTemplateMergeResponse,
    Failure | Error,
    GetYamlWithTemplateRefsResolvedV2QueryParams,
    TemplateApplyRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseTemplateMergeResponse,
    Failure | Error,
    GetYamlWithTemplateRefsResolvedV2QueryParams,
    TemplateApplyRequestRequestBody,
    void
  >('POST', getConfig('template/api'), `/templates/v2/applyTemplates`, props, signal)

export interface CreateVariablesV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateVariablesV2Props = Omit<
  MutateProps<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesV2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create variables for Template
 */
export const CreateVariablesV2 = (props: CreateVariablesV2Props) => (
  <Mutate<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesV2QueryParams, void, void>
    verb="POST"
    path={`/templates/v2/variables`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseCreateVariablesV2Props = Omit<
  UseMutateProps<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesV2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create variables for Template
 */
export const useCreateVariablesV2 = (props: UseCreateVariablesV2Props) =>
  useMutate<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesV2QueryParams, void, void>(
    'POST',
    `/templates/v2/variables`,
    { base: getConfig('template/api'), ...props }
  )

/**
 * Create variables for Template
 */
export const createVariablesV2Promise = (
  props: MutateUsingFetchProps<
    ResponseVariableMergeServiceResponse,
    Failure | Error,
    CreateVariablesV2QueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesV2QueryParams, void, void>(
    'POST',
    getConfig('template/api'),
    `/templates/v2/variables`,
    props,
    signal
  )

export interface ValidateTheIdentifierIsUniqueQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  versionLabel?: string
}

export type ValidateTheIdentifierIsUniqueProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>,
  'path'
>

/**
 * Validate Identifier is unique
 */
export const ValidateTheIdentifierIsUnique = (props: ValidateTheIdentifierIsUniqueProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>
    path={`/templates/validateUniqueIdentifier`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseValidateTheIdentifierIsUniqueProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>,
  'path'
>

/**
 * Validate Identifier is unique
 */
export const useValidateTheIdentifierIsUnique = (props: UseValidateTheIdentifierIsUniqueProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>(
    `/templates/validateUniqueIdentifier`,
    { base: getConfig('template/api'), ...props }
  )

/**
 * Validate Identifier is unique
 */
export const validateTheIdentifierIsUniquePromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>(
    getConfig('template/api'),
    `/templates/validateUniqueIdentifier`,
    props,
    signal
  )

export interface CreateVariablesQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateVariablesProps = Omit<
  MutateProps<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create variables for Template
 */
export const CreateVariables = (props: CreateVariablesProps) => (
  <Mutate<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>
    verb="POST"
    path={`/templates/variables`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseCreateVariablesProps = Omit<
  UseMutateProps<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create variables for Template
 */
export const useCreateVariables = (props: UseCreateVariablesProps) =>
  useMutate<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>(
    'POST',
    `/templates/variables`,
    { base: getConfig('template/api'), ...props }
  )

/**
 * Create variables for Template
 */
export const createVariablesPromise = (
  props: MutateUsingFetchProps<
    ResponseVariableMergeServiceResponse,
    Failure | Error,
    CreateVariablesQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>(
    'POST',
    getConfig('template/api'),
    `/templates/variables`,
    props,
    signal
  )

export interface DeleteTemplateVersionsOfIdentifierQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  comments?: string
  forceDelete?: boolean
}

export type DeleteTemplateVersionsOfIdentifierProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteTemplateVersionsOfIdentifierQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete Template Versions
 */
export const DeleteTemplateVersionsOfIdentifier = (props: DeleteTemplateVersionsOfIdentifierProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteTemplateVersionsOfIdentifierQueryParams, string, void>
    verb="DELETE"
    path={`/templates`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseDeleteTemplateVersionsOfIdentifierProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteTemplateVersionsOfIdentifierQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete Template Versions
 */
export const useDeleteTemplateVersionsOfIdentifier = (props: UseDeleteTemplateVersionsOfIdentifierProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteTemplateVersionsOfIdentifierQueryParams, string, void>(
    'DELETE',
    `/templates`,
    { base: getConfig('template/api'), ...props }
  )

/**
 * Delete Template Versions
 */
export const deleteTemplateVersionsOfIdentifierPromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    DeleteTemplateVersionsOfIdentifierQueryParams,
    string,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteTemplateVersionsOfIdentifierQueryParams, string, void>(
    'DELETE',
    getConfig('template/api'),
    `/templates`,
    props,
    signal
  )

export interface GetTemplateQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  versionLabel?: string
  deleted?: boolean
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  loadFromFallbackBranch?: boolean
}

export interface GetTemplatePathParams {
  templateIdentifier: string
}

export type GetTemplateProps = Omit<
  GetProps<ResponseTemplateResponse, Failure | Error, GetTemplateQueryParams, GetTemplatePathParams>,
  'path'
> &
  GetTemplatePathParams

/**
 * Gets Template
 */
export const GetTemplate = ({ templateIdentifier, ...props }: GetTemplateProps) => (
  <Get<ResponseTemplateResponse, Failure | Error, GetTemplateQueryParams, GetTemplatePathParams>
    path={`/templates/${templateIdentifier}`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseGetTemplateProps = Omit<
  UseGetProps<ResponseTemplateResponse, Failure | Error, GetTemplateQueryParams, GetTemplatePathParams>,
  'path'
> &
  GetTemplatePathParams

/**
 * Gets Template
 */
export const useGetTemplate = ({ templateIdentifier, ...props }: UseGetTemplateProps) =>
  useGet<ResponseTemplateResponse, Failure | Error, GetTemplateQueryParams, GetTemplatePathParams>(
    (paramsInPath: GetTemplatePathParams) => `/templates/${paramsInPath.templateIdentifier}`,
    { base: getConfig('template/api'), pathParams: { templateIdentifier }, ...props }
  )

/**
 * Gets Template
 */
export const getTemplatePromise = (
  {
    templateIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseTemplateResponse, Failure | Error, GetTemplateQueryParams, GetTemplatePathParams> & {
    templateIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseTemplateResponse, Failure | Error, GetTemplateQueryParams, GetTemplatePathParams>(
    getConfig('template/api'),
    `/templates/${templateIdentifier}`,
    props,
    signal
  )

export interface DeleteTemplateVersionQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  comments?: string
  forceDelete?: boolean
}

export interface DeleteTemplateVersionPathParams {
  templateIdentifier: string
}

export type DeleteTemplateVersionProps = Omit<
  MutateProps<
    ResponseBoolean,
    Failure | Error,
    DeleteTemplateVersionQueryParams,
    string,
    DeleteTemplateVersionPathParams
  >,
  'path' | 'verb'
> &
  DeleteTemplateVersionPathParams

/**
 * Deletes template version
 */
export const DeleteTemplateVersion = ({ templateIdentifier, ...props }: DeleteTemplateVersionProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteTemplateVersionQueryParams, string, DeleteTemplateVersionPathParams>
    verb="DELETE"
    path={`/templates/${templateIdentifier}`}
    base={getConfig('template/api')}
    {...props}
  />
)

export type UseDeleteTemplateVersionProps = Omit<
  UseMutateProps<
    ResponseBoolean,
    Failure | Error,
    DeleteTemplateVersionQueryParams,
    string,
    DeleteTemplateVersionPathParams
  >,
  'path' | 'verb'
> &
  DeleteTemplateVersionPathParams

/**
 * Deletes template version
 */
export const useDeleteTemplateVersion = ({ templateIdentifier, ...props }: UseDeleteTemplateVersionProps) =>
  useMutate<
    ResponseBoolean,
    Failure | Error,
    DeleteTemplateVersionQueryParams,
    string,
    DeleteTemplateVersionPathParams
  >('DELETE', (paramsInPath: DeleteTemplateVersionPathParams) => `/templates/${paramsInPath.templateIdentifier}`, {
    base: getConfig('template/api'),
    pathParams: { templateIdentifier },
    ...props
  })

/**
 * Deletes template version
 */
export const deleteTemplateVersionPromise = (
  {
    templateIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    DeleteTemplateVersionQueryParams,
    string,
    DeleteTemplateVersionPathParams
  > & { templateIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    Failure | Error,
    DeleteTemplateVersionQueryParams,
    string,
    DeleteTemplateVersionPathParams
  >('DELETE', getConfig('template/api'), `/templates/${templateIdentifier}`, props, signal)
