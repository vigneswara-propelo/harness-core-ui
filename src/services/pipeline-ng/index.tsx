/*
 * Copyright 2023 Harness Inc. All rights reserved.
 * Use of this source code is governed by the PolyForm Shield 1.0.0 license
 * that can be found in the licenses directory at the root of this repository, also available at
 * https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt.
 */

/* Generated by restful-react */

import React from 'react'
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'

import { getConfig, getUsingFetch, mutateUsingFetch, GetUsingFetchProps, MutateUsingFetchProps } from '../config'
export const SPEC_VERSION = '2.0'
export type ACRStepInfo = StepSpecType & {
  baseImageConnectorRefs?: string[]
  buildArgs?: {
    [key: string]: string
  }
  cacheFrom?: string[]
  cacheTo?: string
  caching?: boolean
  connectorRef: string
  context?: string
  dockerfile?: string
  labels?: {
    [key: string]: string
  }
  optimize?: boolean
  remoteCacheImage?: string
  repository: string
  resources?: ContainerResource
  runAsUser?: number
  subscriptionId?: string
  tags: string[]
  target?: string
  version?: string
}

export interface AMIFilter {
  name?: string
  value?: string
}

export type AMIRegistrySpec = ArtifactTypeSpec & {
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  filters?: AMIFilter[]
  jexlCondition?: string
  metaDataConditions?: TriggerEventDataCondition[]
  region?: string
  tags?: AMITag[]
  version?: string
  versionRegex?: string
}

export interface AMITag {
  name?: string
  value?: string
}

export type AbortFailureActionConfig = FailureStrategyActionConfig & {
  type: 'Abort'
}

export interface AbortedBy {
  createdAt?: number
  email?: string
  userName?: string
}

export interface AccessControlCheckError {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'ACCOUNT_MIGRATED_TO_NEXT_GEN'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'SCM_REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SPOTNIST_REST_EXCEPTION'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'MISSING_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
    | 'ABORT_ALL_ALREADY_NG'
  correlationId?: string
  detailedMessage?: string
  failedPermissionChecks?: PermissionCheck[]
  message?: string
  metadata?: ErrorMetadataDTO
  responseMessages?: ResponseMessage[]
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export type AcrSpec = ArtifactTypeSpec & {
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  metaDataConditions?: TriggerEventDataCondition[]
  registry?: string
  repository?: string
  subscriptionId?: string
  tag?: string
}

export type ActionStepInfo = StepSpecType & {
  env?: ParameterFieldMapStringString
  uses: string
  version?: string
  with?: ParameterFieldMapStringString
}

export type ActionStepInfoV1 = StepSpecType & {
  envs?: ParameterFieldMapStringString
  outputs?: string[]
  resources?: ContainerResource
  uses: string
  version?: string
  with?: ParameterFieldMapStringString
}

export type AddRuleYaml = PatchInstruction & {
  identifier: string
  spec: AddRuleYamlSpec
  type: 'AddRule'
}

export interface AddRuleYamlSpec {
  clauses?: Clause[]
  distribution?: DistributionYamlSpec
  priority?: number
  serve?: Serve
}

export type AddSegmentToVariationTargetMapYaml = PatchInstruction & {
  identifier: string
  spec: AddSegmentToVariationTargetMapYamlSpec
  type: 'AddSegmentToVariationTargetMap'
}

export interface AddSegmentToVariationTargetMapYamlSpec {
  segments: string[]
  variation: string
}

export type AddTargetsToVariationTargetMapYaml = PatchInstruction & {
  identifier: string
  spec: AddTargetsToVariationTargetMapYamlSpec
  type: 'AddTargetsToVariationTargetMap'
}

export interface AddTargetsToVariationTargetMapYamlSpec {
  targets: string[]
  variation: string
}

export interface AdviserIssuer {
  adviseType:
    | 'UNKNOWN'
    | 'NEXT_STEP'
    | 'RETRY'
    | 'INTERVENTION_WAIT'
    | 'END_PLAN'
    | 'MARK_SUCCESS'
    | 'IGNORE_FAILURE'
    | 'PROCEED_WITH_DEFAULT'
    | 'MARK_AS_FAILURE'
    | 'UNRECOGNIZED'
}

export type AmazonS3RegistrySpec = ArtifactTypeSpec & {
  bucketName?: string
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  filePathRegex?: string
  jexlCondition?: string
  metaDataConditions?: TriggerEventDataCondition[]
  region?: string
}

export interface Ambiance {
  [key: string]: any
}

export interface ApprovalInstanceDetailsDTO {
  [key: string]: any
}

export interface ApprovalInstanceResponse {
  createdAt?: number
  deadline?: number
  details: ApprovalInstanceDetailsDTO
  errorMessage?: string
  id?: string
  lastModifiedAt?: number
  status: 'WAITING' | 'APPROVED' | 'REJECTED' | 'FAILED' | 'ABORTED' | 'EXPIRED'
  type: 'HarnessApproval' | 'JiraApproval' | 'CustomApproval' | 'ServiceNowApproval'
}

export type ApprovalStageConfig = StageInfoConfig & {
  execution: ExecutionElementConfig
}

export interface ApprovalUserGroupDTO {
  accountIdentifier?: string
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface ApproverInput {
  name?: string
  value: string
}

export interface ApproverInputInfo {
  defaultValue?: string
  name?: string
}

export interface ApproverInputInfoDTO {
  defaultValue?: string
  name?: string
}

export interface Approvers {
  disallowPipelineExecutor: boolean
  minimumCount: number
  userGroups: string[]
}

export interface ApproversDTO {
  disallowPipelineExecutor?: boolean
  minimumCount?: number
  userGroups?: string[]
}

export type ArrayNGVariableV1 = NGVariableV1 & {
  __uuid?: string
  default?: { [key: string]: any }[]
  validator?: ArrayValidator
  value?: ParameterFieldListObject
}

export interface ArrayValidator {
  [key: string]: any
}

export type ArtifactTriggerConfig = NGTriggerSpecV2 & {
  artifactRef?: string
  spec?: ArtifactTypeSpec
  stageIdentifier?: string
  type?:
    | 'Gcr'
    | 'Ecr'
    | 'DockerRegistry'
    | 'Nexus3Registry'
    | 'Nexus2Registry'
    | 'ArtifactoryRegistry'
    | 'Acr'
    | 'AmazonS3'
    | 'Jenkins'
    | 'CustomArtifact'
    | 'GoogleArtifactRegistry'
    | 'GithubPackageRegistry'
    | 'AzureArtifacts'
    | 'AmazonMachineImage'
    | 'GoogleCloudStorage'
    | 'Bamboo'
}

export interface ArtifactTypeSpec {
  [key: string]: any
}

export interface ArtifactTypeSpecWrapper {
  spec?: ArtifactTypeSpec
}

export type ArtifactoryRegistrySpec = ArtifactTypeSpec & {
  artifactDirectory?: string
  artifactFilter?: string
  artifactPath?: string
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  metaDataConditions?: TriggerEventDataCondition[]
  repository?: string
  repositoryFormat?: string
  repositoryUrl?: string
}

export interface Attestation {
  spec?: AttestationSpec
  type?: 'cosign'
}

export interface AttestationSpec {
  [key: string]: any
}

export type AuditFilterProperties = FilterProperties & {
  actions?: (
    | 'CREATE'
    | 'UPDATE'
    | 'RESTORE'
    | 'DELETE'
    | 'FORCE_DELETE'
    | 'UPSERT'
    | 'INVITE'
    | 'RESEND_INVITE'
    | 'REVOKE_INVITE'
    | 'ADD_COLLABORATOR'
    | 'REMOVE_COLLABORATOR'
    | 'CREATE_TOKEN'
    | 'REVOKE_TOKEN'
    | 'LOGIN'
    | 'LOGIN2FA'
    | 'UNSUCCESSFUL_LOGIN'
    | 'ADD_MEMBERSHIP'
    | 'REMOVE_MEMBERSHIP'
    | 'ERROR_BUDGET_RESET'
    | 'START'
    | 'END'
    | 'STAGE_START'
    | 'STAGE_END'
    | 'PAUSE'
    | 'RESUME'
    | 'ABORT'
    | 'TIMEOUT'
    | 'SIGNED_EULA'
    | 'ROLE_ASSIGNMENT_CREATED'
    | 'ROLE_ASSIGNMENT_UPDATED'
    | 'ROLE_ASSIGNMENT_DELETED'
  )[]
  endTime?: number
  environments?: Environment[]
  modules?: (
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'IDP'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'SSCA'
    | 'GOVERNANCE'
    | 'SEI'
  )[]
  principals?: Principal[]
  resources?: ResourceDTO[]
  scopes?: ResourceScopeDTO[]
  startTime?: number
  staticFilter?: 'EXCLUDE_LOGIN_EVENTS' | 'EXCLUDE_SYSTEM_EVENTS'
}

export interface AutoApprovalDTO {
  action: 'APPROVE'
  comments?: string
  scheduledDeadline: ScheduledDeadlineDTO
}

export interface AutoApprovalParams {
  action: 'APPROVE'
  comments?: string
  scheduledDeadline: ScheduledDeadline
}

export interface AwsCodeCommitEventSpec {
  [key: string]: any
}

export type AwsCodeCommitPushSpec = AwsCodeCommitEventSpec & {
  connectorRef?: string
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type AwsCodeCommitSpec = WebhookTriggerSpecV2 & {
  spec?: AwsCodeCommitEventSpec
  type?: 'Push'
}

export type AzureArtifactsRegistrySpec = ArtifactTypeSpec & {
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  feed?: string
  jexlCondition?: string
  metaDataConditions?: TriggerEventDataCondition[]
  packageName?: string
  packageType?: string
  project?: string
  version?: string
  versionRegex?: string
}

export interface AzureRepoEventSpec {
  [key: string]: any
}

export type AzureRepoIssueCommentSpec = AzureRepoEventSpec & {
  actions?: ('Create' | 'Edit' | 'Delete')[]
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type AzureRepoPRSpec = AzureRepoEventSpec & {
  actions?: ('Create' | 'Update' | 'Merge')[]
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type AzureRepoPushSpec = AzureRepoEventSpec & {
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type AzureRepoSpec = WebhookTriggerSpecV2 & {
  spec?: AzureRepoEventSpec
  type?: 'PullRequest' | 'Push' | 'IssueComment'
}

export type BackgroundStepInfo = StepSpecType & {
  command?: string
  connectorRef?: string
  entrypoint?: string[]
  envVariables?: {
    [key: string]: string
  }
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  portBindings?: {
    [key: string]: string
  }
  privileged?: boolean
  reports?: UnitTestReport
  resources?: ContainerResource
  runAsUser?: number
  shell?: 'Sh' | 'Bash' | 'Powershell' | 'Pwsh' | 'Python'
  version?: string
}

export type BackgroundStepInfoV1 = StepSpecType & {
  args?: string[]
  entrypoint?: string
  entrypointList?: ParameterFieldListString
  envs?: {
    [key: string]: string
  }
  image?: string
  network?: string
  ports?: string[]
  privileged?: boolean
  pull?: 'always' | 'never' | 'if-not-exists'
  resources?: ContainerResource
  run: string
  shell?: 'sh' | 'bash' | 'powershell' | 'pwsh' | 'python'
  user?: number
  version?: string
}

export type BambooRegistrySpec = ArtifactTypeSpec & {
  artifactPaths?: string[]
  build?: string
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  metaDataConditions?: TriggerEventDataCondition[]
  planKey?: string
}

export interface BarrierExecutionInfo {
  identifier?: string
  name?: string
  stages?: StageDetail[]
  started?: boolean
  startedAt?: number
  timeoutIn?: number
}

export interface BarrierInfo {
  name?: string
  stages?: StageDetail[]
  timeoutIn?: number
}

export interface BarrierInfoConfig {
  identifier: string
  name: string
}

export interface BarrierSetupInfo {
  identifier?: string
  name?: string
  stages?: StageDetail[]
}

export type BarrierStepInfo = StepSpecType & {
  barrierRef: string
}

export interface BitbucketEventSpec {
  [key: string]: any
}

export type BitbucketPRCommentSpec = BitbucketEventSpec & {
  actions?: ('Create' | 'Edit' | 'Delete')[]
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type BitbucketPRSpec = BitbucketEventSpec & {
  actions?: ('Create' | 'Update' | 'Merge' | 'Decline')[]
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type BitbucketPushSpec = BitbucketEventSpec & {
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type BitbucketSpec = WebhookTriggerSpecV2 & {
  spec?: BitbucketEventSpec
  type?: 'PullRequest' | 'Push' | 'PRComment'
}

export type BitriseStepInfo = StepSpecType & {
  env?: ParameterFieldMapStringString
  uses: string
  version?: string
  with?: ParameterFieldMapStringString
}

export type BitriseStepInfoV1 = StepSpecType & {
  envs?: ParameterFieldMapStringString
  outputs?: string[]
  resources?: ContainerResource
  uses: string
  version?: string
  with?: ParameterFieldMapStringString
}

export type BranchBuildSpec = BuildSpec & {
  branch: string
}

export interface Build {
  spec: BuildSpec
  type: 'branch' | 'tag' | 'PR' | 'commitSha'
}

export interface BuildDetails {
  buildType?: string
}

export interface BuildSpec {
  [key: string]: any
}

export interface BuildStore {
  spec?: BuildStoreTypeSpec
  type?: 'Http' | 'S3' | 'Gcs'
}

export interface BuildStoreTypeSpec {
  [key: string]: any
}

export interface CIProperties {
  codebase?: CodeBase
}

export interface CIVolume {
  type?: 'EmptyDir' | 'PersistentVolumeClaim' | 'HostPath'
}

export interface CacheResponseMetadata {
  cacheState: 'VALID_CACHE' | 'STALE_CACHE' | 'UNKNOWN'
  isSyncEnabled: boolean
  lastUpdatedAt: number
  ttlLeft: number
}

export interface Capabilities {
  add?: string[]
  drop?: string[]
}

export interface CcmConnectorFilter {
  awsAccountId?: string
  awsAccountIds?: string[]
  azureSubscriptionId?: string
  azureTenantId?: string
  featuresDisabled?: (
    | 'BILLING'
    | 'OPTIMIZATION'
    | 'VISIBILITY'
    | 'GOVERNANCE'
    | 'COMMITMENT_ORCHESTRATOR'
    | 'CLUSTER_ORCHESTRATOR'
  )[]
  featuresEnabled?: (
    | 'BILLING'
    | 'OPTIMIZATION'
    | 'VISIBILITY'
    | 'GOVERNANCE'
    | 'COMMITMENT_ORCHESTRATOR'
    | 'CLUSTER_ORCHESTRATOR'
  )[]
  gcpProjectId?: string
  k8sConnectorRef?: string[]
}

export type CdSscaEnforcementStepInfo = StepSpecType & {
  infrastructure: ContainerStepInfra
  policy: EnforcementPolicy
  source: SbomSource
  verifyAttestation?: VerifyAttestation
}

export type CdSscaOrchestrationStepInfo = StepSpecType & {
  attestation?: Attestation
  infrastructure: ContainerStepInfra
  source: SbomSource
  tool: SbomOrchestrationTool
}

export type ChangeTaskUpdateMultipleSpec = UpdateMultipleSpec & {
  changeRequestNumber: string
  changeTaskType?: string
}

export interface ChildExecutionDetailDTO {
  executionGraph?: ExecutionGraph
  pipelineExecutionSummary?: PipelineExecutionSummary
}

export interface Clause {
  attribute: string
  id: string
  negate: boolean
  op: string
  values: string[]
}

export interface ClauseYamlSpec {
  attribute?: string
  op: string
  values: string[]
}

export interface CloneConfig {
  connectors?: boolean
  inputSets?: boolean
  templates?: boolean
  triggers?: boolean
}

export interface ClonePipelineProperties {
  cloneConfig?: CloneConfig
  destinationConfig?: DestinationPipelineConfig
  sourceConfig?: SourceIdentifierConfig
}

export interface CodeBase {
  build: Build
  connectorRef?: string
  depth?: number
  prCloneStrategy?: 'MergeCommit' | 'SourceBranch'
  repoName?: string
  resources?: ContainerResource
  sslVerify?: boolean
}

export type CommitShaBuildSpec = BuildSpec & {
  commitSha: string
}

export interface Condition {
  key: string
  operator: 'equals' | 'not equals' | 'in' | 'not in'
  value: string
}

export interface ConditionDTO {
  key: string
  operator: 'equals' | 'not equals' | 'in' | 'not in'
  value: string
}

export interface ConnectorCheckResponse {
  connectorIdentifier?: string
  errorInfo?: PreFlightEntityErrorInfo
  fqn?: string
  stageIdentifier?: string
  stageName?: string
  status?: 'SUCCESS' | 'FAILURE' | 'IN_PROGRESS' | 'UNKNOWN'
  stepIdentifier?: string
  stepName?: string
}

export type ConnectorFilterProperties = FilterProperties & {
  categories?: (
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  )[]
  ccmConnectorFilter?: CcmConnectorFilter
  connectivityStatuses?: ('SUCCESS' | 'FAILURE' | 'PARTIAL' | 'UNKNOWN')[]
  connectorConnectivityModes?: ('DELEGATE' | 'MANAGER')[]
  connectorIdentifiers?: string[]
  connectorIds?: string[]
  connectorNames?: string[]
  description?: string
  inheritingCredentialsFromDelegate?: boolean
  types?: (
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Azure'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
    | 'ErrorTracking'
    | 'Pdc'
    | 'AzureRepo'
    | 'Jenkins'
    | 'OciHelmRepo'
    | 'CustomSecretManager'
    | 'ElasticSearch'
    | 'GcpSecretManager'
    | 'AzureArtifacts'
    | 'Tas'
    | 'Spot'
    | 'Bamboo'
    | 'TerraformCloud'
    | 'SignalFX'
    | 'Harness'
    | 'Rancher'
  )[]
}

export type ConnectorInternalFilterProperties = FilterProperties & {
  accountIdentifiers?: string[]
  ccmConnectorFilter?: CcmConnectorFilter
  connectivityStatuses?: ('SUCCESS' | 'FAILURE' | 'PARTIAL' | 'UNKNOWN')[]
  types?: (
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Azure'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
    | 'ErrorTracking'
    | 'Pdc'
    | 'AzureRepo'
    | 'Jenkins'
    | 'OciHelmRepo'
    | 'CustomSecretManager'
    | 'ElasticSearch'
    | 'GcpSecretManager'
    | 'AzureArtifacts'
    | 'Tas'
    | 'Spot'
    | 'Bamboo'
    | 'TerraformCloud'
    | 'SignalFX'
    | 'Harness'
    | 'Rancher'
  )[]
}

export type ConnectorValidationErrorMetadataDTO = ErrorMetadataDTO & {
  taskId?: string
}

export interface ConnectorWrapperResponse {
  checkResponses?: ConnectorCheckResponse[]
  label?: string
  status?: 'SUCCESS' | 'FAILURE' | 'IN_PROGRESS' | 'UNKNOWN'
}

export interface ContainerInfraYamlSpec {
  annotations?: {
    [key: string]: string
  }
  automountServiceAccountToken?: boolean
  connectorRef: string
  containerSecurityContext?: SecurityContext
  harnessImageConnectorRef?: string
  hostNames?: string[]
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  initTimeout?: string
  labels?: {
    [key: string]: string
  }
  namespace: string
  nodeSelector?: {
    [key: string]: string
  }
  os?: 'Linux' | 'MacOS' | 'Windows'
  priorityClassName?: string
  resources?: ContainerResource
  runAsUser?: number
  serviceAccountName?: string
  tolerations?: Toleration[]
  volumes?: CIVolume[]
}

export type ContainerK8sInfra = ContainerStepInfra & {
  spec: ContainerInfraYamlSpec
  type: 'KubernetesDirect'
}

export interface ContainerResource {
  limits: Limits
}

export type ContainerStepInfo = StepSpecType & {
  command: string
  connectorRef?: string
  entrypoint?: string[]
  envVariables?: {
    [key: string]: string
  }
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  infrastructure: ContainerStepInfra
  metadata?: string
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  settings?: ParameterFieldMapStringJsonNode
  shell?: 'Sh' | 'Bash' | 'Powershell' | 'Pwsh' | 'Python'
  version?: string
}

export interface ContainerStepInfra {
  type?: 'KubernetesDirect'
}

export type CosignAttestation = AttestationSpec & {
  password?: string
  privateKey?: string
}

export type CosignVerifyAttestation = VerifyAttestationSpec & {
  publicKey?: string
}

export interface CriteriaSpec {
  [key: string]: any
}

export interface CriteriaSpecDTO {
  [key: string]: any
}

export interface CriteriaSpecWrapper {
  spec: CriteriaSpec
  type: 'Jexl' | 'KeyValues'
}

export interface CriteriaSpecWrapperDTO {
  spec: CriteriaSpecDTO
  type: 'Jexl' | 'KeyValues'
}

export type CronTriggerSpec = ScheduledTriggerSpec & {
  expression?: string
  type?: string
}

export type CustomApprovalStepInfo = StepSpecType & {
  approvalCriteria: CriteriaSpecWrapper
  delegateSelectors?: string[]
  environmentVariables?: NGVariable[]
  outputVariables?: NGVariable[]
  rejectionCriteria?: CriteriaSpecWrapper
  retryInterval: string
  scriptTimeout: string
  shell: 'Bash' | 'PowerShell'
  source: ShellScriptSourceWrapper
}

export type CustomArtifactSpec = ArtifactTypeSpec & {
  artifactsArrayPath?: string
  eventConditions?: TriggerEventDataCondition[]
  inputs?: NGVariable[]
  jexlCondition?: string
  metaDataConditions?: TriggerEventDataCondition[]
  metadata?: {
    [key: string]: string
  }
  script?: string
  version?: string
  versionPath?: string
}

export type CustomPolicyStepSpec = PolicySpec & {
  payload: string
}

export type CustomStageConfig = StageInfoConfig & {
  execution: ExecutionElementConfig
}

export type CustomTriggerSpec = WebhookTriggerSpecV2 & {
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
}

export interface DashboardPipelineExecutionInfo {
  pipelineExecutionInfoList?: PipelineExecutionInfo[]
}

export interface DashboardPipelineHealthInfo {
  executions?: PipelineHealthInfo
}

export interface DelegateInfo {
  id?: string
  name?: string
  taskId?: string
  taskName?: string
}

export interface DestinationPipelineConfig {
  description?: string
  orgIdentifier?: string
  pipelineIdentifier?: string
  pipelineName?: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
}

export interface Distribution {
  bucketBy: string
  variations: WeightedVariation[]
}

export interface DistributionYamlSpec {
  bucketBy: string
  clauses?: ClauseYamlSpec[]
  variations?: VariationYamlSpec[]
}

export type DockerRegistrySpec = ArtifactTypeSpec & {
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  imagePath?: string
  jexlCondition?: string
  metaDataConditions?: TriggerEventDataCondition[]
  tag?: string
}

export type DockerStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  buildArgs?: {
    [key: string]: string
  }
  cacheFrom?: string[]
  cacheTo?: string
  caching?: boolean
  connectorRef: string
  context?: string
  dockerfile?: string
  labels?: {
    [key: string]: string
  }
  optimize?: boolean
  remoteCacheRepo?: string
  repo: string
  resources?: ContainerResource
  runAsUser?: number
  tags: string[]
  target?: string
  version?: string
}

export type ECRStepInfo = StepSpecType & {
  account: string
  baseImageConnectorRefs?: string[]
  buildArgs?: {
    [key: string]: string
  }
  cacheFrom?: string[]
  cacheTo?: string
  caching?: boolean
  connectorRef: string
  context?: string
  dockerfile?: string
  imageName: string
  labels?: {
    [key: string]: string
  }
  optimize?: boolean
  region: string
  remoteCacheImage?: string
  resources?: ContainerResource
  runAsUser?: number
  tags: string[]
  target?: string
  version?: string
}

export type EcrSpec = ArtifactTypeSpec & {
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  imagePath?: string
  jexlCondition?: string
  metaDataConditions?: TriggerEventDataCondition[]
  region?: string
  registryId?: string
  tag?: string
}

export interface EdgeLayoutList {
  currentNodeChildren?: string[]
  nextIds?: string[]
}

export type EmailStepInfo = StepSpecType & {
  body?: string
  cc?: string
  delegateSelectors?: string[]
  subject: string
  to: string
}

export interface EmbeddedUser {
  email?: string
  externalUserId?: string
  name?: string
  uuid?: string
}

export type EmptyDirYaml = CIVolume & {
  mountPath: string
  spec: EmptyDirYamlSpec
  type: 'EmptyDir' | 'PersistentVolumeClaim' | 'HostPath'
}

export interface EmptyDirYamlSpec {
  medium?: string
  size?: string
}

export interface EnforcementPolicy {
  store?: PolicyStore
}

export interface EntityGitDetails {
  branch?: string
  commitId?: string
  filePath?: string
  fileUrl?: string
  objectId?: string
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  repoIdentifier?: string
  repoName?: string
  repoUrl?: string
  rootFolder?: string
}

export interface EntityValidityDetails {
  invalidYaml?: string
  valid?: boolean
}

export interface Environment {
  identifier: string
  type: 'PreProduction' | 'Production'
}

export interface Error {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'ACCOUNT_MIGRATED_TO_NEXT_GEN'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'SCM_REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SPOTNIST_REST_EXCEPTION'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'MISSING_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
    | 'ABORT_ALL_ALREADY_NG'
  correlationId?: string
  detailedMessage?: string
  message?: string
  metadata?: ErrorMetadataDTO
  responseMessages?: ResponseMessage[]
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ErrorMetadata {
  errorCode?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'ACCOUNT_MIGRATED_TO_NEXT_GEN'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'SCM_REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SPOTNIST_REST_EXCEPTION'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'MISSING_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
    | 'ABORT_ALL_ALREADY_NG'
  errorMessage?: string
}

export interface ErrorMetadataDTO {
  type?: string
}

export interface ErrorNodeSummary {
  childrenErrorNodes?: ErrorNodeSummary[]
  nodeInfo?: NodeInfo
  templateInfo?: TemplateInfo
  templateResponse?: TemplateResponse
}

export interface ExecutableResponse {
  [key: string]: any
}

export interface ExecutionDataResponse {
  executionId?: string
  executionYaml?: string
}

export interface ExecutionElementConfig {
  rollbackSteps?: ExecutionWrapperConfig[]
  steps: ExecutionWrapperConfig[]
}

export interface ExecutionErrorInfo {
  [key: string]: any
}

export interface ExecutionGraph {
  executionMetadata?: {
    [key: string]: string
  }
  nodeAdjacencyListMap?: {
    [key: string]: ExecutionNodeAdjacencyList
  }
  nodeMap?: {
    [key: string]: ExecutionNode
  }
  representationStrategy?: 'camelCase'
  rootNodeId?: string
}

export interface ExecutionInfo {
  endTs?: number
  runSequence?: number
  startTs?: number
  status?:
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'WaitStepRunning'
    | 'QueuedLicenseLimitReached'
    | 'QueuedExecutionConcurrencyReached'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'InputWaiting'
    | 'AbortedByFreeze'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
  uuid?: string
}

export interface ExecutionInputDTO {
  fieldYaml?: string
  inputInstanceId?: string
  inputTemplate?: string
  nodeExecutionId?: string
  userInput?: string
}

export interface ExecutionInputStatus {
  inputInstanceId?: string
  nodeExecutionId?: string
  status?: 'Failed' | 'Success'
}

export interface ExecutionInputVariablesResponse {
  pipelineYaml?: string
  variableMergeServiceResponse?: VariableMergeServiceResponse
}

export interface ExecutionMetaDataResponse {
  executionYaml?: string
  inputYaml?: string
  planExecutionId: string
  triggerPayload?: TriggerPayload
}

export interface ExecutionMetadata {
  [key: string]: any
}

export interface ExecutionNode {
  baseFqn?: string
  delegateInfoList?: DelegateInfo[]
  endTs?: number
  executableResponses?: ExecutableResponse[]
  executionInputConfigured?: boolean
  failureInfo?: FailureInfoDTO
  identifier?: string
  interruptHistories?: InterruptEffectDTO[]
  logBaseKey?: string
  name?: string
  nodeRunInfo?: NodeRunInfo
  outcomes?: {
    [key: string]: {
      [key: string]: { [key: string]: any }
    }
  }
  progressData?: {
    [key: string]: { [key: string]: any }
  }
  setupId?: string
  skipInfo?: SkipInfo
  startTs?: number
  status?:
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'WaitStepRunning'
    | 'QueuedLicenseLimitReached'
    | 'QueuedExecutionConcurrencyReached'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'InputWaiting'
    | 'AbortedByFreeze'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
  stepDetails?: {
    [key: string]: {
      [key: string]: { [key: string]: any }
    }
  }
  stepParameters?: {
    [key: string]: { [key: string]: any }
  }
  stepType?: string
  strategyMetadata?: StrategyMetadata
  unitProgresses?: UnitProgress[]
  uuid?: string
}

export interface ExecutionNodeAdjacencyList {
  children?: string[]
  nextIds?: string[]
}

export interface ExecutionTarget {
  connectorRef?: string
  host?: string
  workingDirectory?: string
}

export interface ExecutionTargetV1 {
  connector?: ParameterFieldString
  dir?: ParameterFieldString
  host?: ParameterFieldString
}

export interface ExecutionTriggerInfo {
  [key: string]: any
}

export interface ExecutionWrapperConfig {
  parallel?: ParallelStepElementConfig
  step?: StepElementConfig
  stepGroup?: StepGroupElementConfig
}

export interface ExecutionsCount {
  newCount?: number
  totalCount?: number
}

export interface ExecutorInfoDTO {
  email?: string
  triggerType?:
    | 'NOOP'
    | 'MANUAL'
    | 'WEBHOOK'
    | 'WEBHOOK_CUSTOM'
    | 'SCHEDULER_CRON'
    | 'ARTIFACT'
    | 'MANIFEST'
    | 'UNRECOGNIZED'
  username?: string
}

export interface ExpressionEvaluation {
  error?: string
  fqn?: string
  originalExpression?: string
  resolvedByYaml?: boolean
  resolvedValue?: string
}

export interface ExpressionEvaluationDetail {
  compiledYaml?: string
  mapExpression?: {
    [key: string]: ExpressionEvaluation
  }
}

export interface ExpressionMetadataDTO {
  expression?: string
  fqn?: string
}

export interface ExpressionUsagesDTO {
  accountIdentifier?: string
  category?: 'ANY' | 'WHEN_CONDITION' | 'VARIABLE_VALUE' | 'COMMON_FIELD_VALUE'
  expressions?: ExpressionMetadataDTO[]
}

export interface Failure {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'ACCOUNT_MIGRATED_TO_NEXT_GEN'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'SCM_REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SPOTNIST_REST_EXCEPTION'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'MISSING_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
    | 'ABORT_ALL_ALREADY_NG'
  correlationId?: string
  errors?: ValidationError[]
  message?: string
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface FailureInfoDTO {
  failureTypeList?: (
    | 'EXPIRED'
    | 'DELEGATE_PROVISIONING'
    | 'CONNECTIVITY'
    | 'AUTHENTICATION'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'TIMEOUT_ERROR'
    | 'POLICY_EVALUATION_FAILURE'
    | 'INPUT_TIMEOUT_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'DELEGATE_RESTART'
    | 'USER_MARKED_FAILURE'
  )[]
  message?: string
  responseMessages?: ResponseMessage[]
}

export interface FailureStrategyActionConfig {
  type:
    | 'Ignore'
    | 'Retry'
    | 'MarkAsSuccess'
    | 'Abort'
    | 'StageRollback'
    | 'StepGroupRollback'
    | 'PipelineRollback'
    | 'ManualIntervention'
    | 'ProceedWithDefaultValues'
    | 'MarkAsFailure'
    | 'RetryStepGroup'
}

export interface FailureStrategyConfig {
  onFailure: OnFailureConfig
}

export type FeatureFlagStageConfig = StageInfoConfig & {}

export type FilterCreatorErrorResponse = ErrorMetadataDTO & {
  errorMetadataList?: ErrorMetadata[]
}

export interface FilterDTO {
  filterProperties: FilterProperties
  filterVisibility?: 'EveryOne' | 'OnlyCreator'
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface FilterProperties {
  filterType?:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
    | 'Trigger'
    | 'EnvironmentGroup'
    | 'FileStore'
    | 'CCMRecommendation'
    | 'Anomaly'
    | 'Environment'
    | 'RuleExecution'
    | 'Override'
    | 'InputSet'
  labels?: {
    [key: string]: string
  }
  tags?: {
    [key: string]: string
  }
}

export type FlagConfigurationStepInfo = StepSpecType & {
  environment: string
  feature: string
  instructions: PatchInstruction[]
}

export interface FlowControlConfig {
  barriers?: BarrierInfoConfig[]
}

export type GARStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  buildArgs?: {
    [key: string]: string
  }
  cacheFrom?: string[]
  cacheTo?: string
  caching?: boolean
  connectorRef: string
  context?: string
  dockerfile?: string
  host: string
  imageName: string
  labels?: {
    [key: string]: string
  }
  optimize?: boolean
  projectID: string
  remoteCacheImage?: string
  resources?: ContainerResource
  runAsUser?: number
  tags: string[]
  target?: string
  version?: string
}

export type GCRStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  buildArgs?: {
    [key: string]: string
  }
  cacheFrom?: string[]
  cacheTo?: string
  caching?: boolean
  connectorRef: string
  context?: string
  dockerfile?: string
  host: string
  imageName: string
  labels?: {
    [key: string]: string
  }
  optimize?: boolean
  projectID: string
  remoteCacheImage?: string
  resources?: ContainerResource
  runAsUser?: number
  tags: string[]
  target?: string
  version?: string
}

export type GarSpec = ArtifactTypeSpec & {
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  metaDataConditions?: TriggerEventDataCondition[]
  pkg?: string
  project?: string
  region?: string
  repositoryName?: string
  version?: string
}

export type GcrSpec = ArtifactTypeSpec & {
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  imagePath?: string
  jexlCondition?: string
  metaDataConditions?: TriggerEventDataCondition[]
  registryHostname?: string
  tag?: string
}

export type GcsBuildStoreTypeSpec = BuildStoreTypeSpec & {
  bucketName?: string
  connectorRef?: string
  folderPath?: string
}

export type GitCloneStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  build: Build
  cloneDirectory?: string
  connectorRef: string
  depth?: number
  outputFilePathsContent?: string[]
  projectName?: string
  repoName?: string
  resources?: ContainerResource
  runAsUser?: number
  sslVerify?: boolean
  version?: string
}

export type GitErrorMetadataDTO = ErrorMetadataDTO & {
  branch?: string
  repo?: string
}

export interface GithubEventSpec {
  [key: string]: any
}

export type GithubIssueCommentSpec = GithubEventSpec & {
  actions?: ('Create' | 'Edit' | 'Delete')[]
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type GithubPRSpec = GithubEventSpec & {
  actions?: ('Close' | 'Edit' | 'Open' | 'Reopen' | 'Label' | 'Unlabel' | 'Synchronize' | 'ReadyForReview')[]
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type GithubPackagesSpec = ArtifactTypeSpec & {
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  metaDataConditions?: TriggerEventDataCondition[]
  org?: string
  packageName?: string
  packageType?: string
}

export type GithubPushSpec = GithubEventSpec & {
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type GithubReleaseSpec = GithubEventSpec & {
  actions?: ('Create' | 'Edit' | 'Delete' | 'Prerelease' | 'Publish' | 'Release' | 'Unpublish')[]
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type GithubSpec = WebhookTriggerSpecV2 & {
  spec?: GithubEventSpec
  type?: 'PullRequest' | 'Push' | 'IssueComment' | 'Release'
}

export interface GitlabEventSpec {
  [key: string]: any
}

export type GitlabMRCommentSpec = GitlabEventSpec & {
  actions?: 'Create'[]
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type GitlabPRSpec = GitlabEventSpec & {
  actions?: ('Open' | 'Close' | 'Reopen' | 'Merge' | 'Update' | 'Sync')[]
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type GitlabPushSpec = GitlabEventSpec & {
  autoAbortPreviousExecutions?: boolean
  connectorRef?: string
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type GitlabSpec = WebhookTriggerSpecV2 & {
  spec?: GitlabEventSpec
  type?: 'MergeRequest' | 'Push' | 'MRComment'
}

export type GoolgeCloudStorageRegistrySpec = ArtifactTypeSpec & {
  artifactPath?: string
  bucket?: string
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  metaDataConditions?: TriggerEventDataCondition[]
  project?: string
}

export interface GovernanceMetadata {
  [key: string]: any
}

export interface GraphLayoutNode {
  barrierFound?: boolean
  edgeLayoutList?: EdgeLayoutList
  endTs?: number
  executionInputConfigured?: boolean
  failureInfo?: ExecutionErrorInfo
  failureInfoDTO?: FailureInfoDTO
  hidden?: boolean
  isRollbackStageNode?: boolean
  module?: string
  moduleInfo?: {
    [key: string]: {
      [key: string]: { [key: string]: any }
    }
  }
  name?: string
  nodeExecutionId?: string
  nodeGroup?: string
  nodeIdentifier?: string
  nodeRunInfo?: NodeRunInfo
  nodeType?: string
  nodeUuid?: string
  skipInfo?: SkipInfo
  startTs?: number
  status?:
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'WaitStepRunning'
    | 'QueuedLicenseLimitReached'
    | 'QueuedExecutionConcurrencyReached'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'InputWaiting'
    | 'AbortedByFreeze'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
  stepDetails?: {
    [key: string]: {
      [key: string]: { [key: string]: any }
    }
  }
  strategyMetadata?: StrategyMetadata
}

export interface HarnessApprovalActivity {
  action: 'APPROVE' | 'REJECT'
  approvedAt?: number
  approverInputs?: ApproverInput[]
  comments?: string
  user: EmbeddedUser
}

export interface HarnessApprovalActivityRequest {
  action: 'APPROVE' | 'REJECT'
  approverInputs?: ApproverInput[]
  comments?: string
}

export interface HarnessApprovalInstanceAuthorization {
  authorized?: boolean
  reason?: string
}

export type HarnessApprovalInstanceDetails = ApprovalInstanceDetailsDTO & {
  approvalActivities?: HarnessApprovalActivity[]
  approvalMessage: string
  approverInputs?: ApproverInputInfoDTO[]
  approvers: ApproversDTO
  autoApprovalParams?: AutoApprovalDTO
  autoRejectEnabled?: boolean
  includePipelineExecutionHistory?: boolean
  validatedApprovalUserGroups?: ApprovalUserGroupDTO[]
}

export type HarnessApprovalStepInfo = StepSpecType & {
  approvalMessage?: string
  approverInputs?: ApproverInputInfo[]
  approvers: Approvers
  autoApproval?: AutoApprovalParams
  includePipelineExecutionHistory: boolean
  isAutoRejectEnabled?: boolean
}

export interface HarnessEventSpec {
  [key: string]: any
}

export type HarnessFileStoreSource = ShellScriptBaseSource & {
  file?: string
}

export type HarnessFileStoreSourceV1 = ShellScriptBaseSourceV1 & {
  file?: ParameterFieldString
}

export interface HarnessForConfig {
  end?: number
  items?: string[]
  maxConcurrency?: number
  partitionSize?: number
  start?: number
  times?: number
  unit?: 'Percentage' | 'Count'
}

export type HarnessIssueCommentSpec = HarnessEventSpec & {
  actions?: ('Create' | 'Edit' | 'Delete')[]
  autoAbortPreviousExecutions?: boolean
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type HarnessPRSpec = HarnessEventSpec & {
  actions?: ('Close' | 'Edit' | 'Open' | 'Reopen' | 'Label' | 'Unlabel' | 'Synchronize')[]
  autoAbortPreviousExecutions?: boolean
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type HarnessPushSpec = HarnessEventSpec & {
  autoAbortPreviousExecutions?: boolean
  headerConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  payloadConditions?: TriggerEventDataCondition[]
  repoName?: string
}

export type HarnessSpec = WebhookTriggerSpecV2 & {
  spec?: HarnessEventSpec
  type?: 'PullRequest' | 'Push' | 'IssueComment'
}

export type HarnessStore = StoreSpec & {
  file?: string
}

export type HelmManifestSpec = ManifestTypeSpec & {
  chartName?: string
  chartVersion?: string
  eventConditions?: TriggerEventDataCondition[]
  helmVersion?: 'V2' | 'V3' | 'V380'
  store?: BuildStore
}

export type HostPathYaml = CIVolume & {
  mountPath: string
  spec: HostPathYamlSpec
  type: 'EmptyDir' | 'PersistentVolumeClaim' | 'HostPath'
}

export interface HostPathYamlSpec {
  path: string
  type?: string
}

export type HttpBuildStoreTypeSpec = BuildStoreTypeSpec & {
  connectorRef?: string
}

export interface HttpHeaderConfig {
  key?: string
  value?: string
}

export type HttpStepInfo = StepSpecType & {
  assertion?: string
  certificate?: string
  certificateKey?: string
  delegateSelectors?: string[]
  headers?: HttpHeaderConfig[]
  inputVariables?: NGVariable[]
  method: string
  outputVariables?: NGVariable[]
  requestBody?: string
  url: string
}

export type HttpStepInfoV1 = StepSpecType & {
  assertion?: ParameterFieldString
  body?: ParameterFieldString
  cert?: ParameterFieldString
  cert_key?: ParameterFieldString
  delegate?: ParameterFieldListTaskSelectorYaml
  headers?: HttpHeaderConfig[]
  input_vars?: NGVariableV1Wrapper
  metadata?: string
  method?: ParameterFieldString
  output_vars?: NGVariableV1Wrapper
  url?: ParameterFieldString
}

export type IgnoreFailureActionConfig = FailureStrategyActionConfig & {
  type: 'Ignore'
}

export type ImageSbomSource = SbomSourceSpec & {
  connector?: string
  image?: string
}

export interface ImportDataSpec {
  [key: string]: any
}

export interface ImportDataSpecWrapper {
  spec: ImportDataSpec
  type: 'Json' | 'KeyValues'
}

export interface InputSetError {
  fieldName?: string
  identifierOfErrorSource?: string
  message?: string
}

export interface InputSetErrorResponse {
  errors?: InputSetError[]
}

export type InputSetErrorWrapper = ErrorMetadataDTO & {
  errorPipelineYaml?: string
  invalidInputSetReferences?: string[]
  uuidToErrorResponseMap?: {
    [key: string]: InputSetErrorResponse
  }
}

export type InputSetFilterProperties = FilterProperties & {
  inputSetIdsWithPipelineIds?: string[]
}

export interface InputSetGitUpdateResponse {
  identifier?: string
}

export interface InputSetImportRequestDTO {
  inputSetDescription?: string
  inputSetName?: string
}

export interface InputSetImportResponseDTO {
  identifier?: string
}

export interface InputSetListResponse {
  description?: string
  identifier?: string
  inputSetIdWithPipelineId?: string
  inputSetType?: 'INPUT_SET' | 'OVERLAY_INPUT_SET'
  name?: string
  pipelineIdentifier?: string
}

export interface InputSetMoveConfigResponseDTO {
  identifier?: string
}

export interface InputSetResponse {
  accountId?: string
  cacheResponse?: CacheResponseMetadata
  connectorRef?: string
  description?: string
  entityValidityDetails?: EntityValidityDetails
  errorResponse?: boolean
  gitDetails?: EntityGitDetails
  identifier?: string
  inputSetErrorWrapper?: InputSetErrorWrapper
  inputSetYaml?: string
  name?: string
  orgIdentifier?: string
  outdated?: boolean
  pipelineIdentifier?: string
  projectIdentifier?: string
  storeType?: 'INLINE' | 'REMOTE'
  tags?: {
    [key: string]: string
  }
}

export interface InputSetSanitiseResponse {
  inputSetUpdateResponse?: InputSetResponse
  shouldDeleteInputSet?: boolean
}

export interface InputSetSummaryResponse {
  connectorRef?: string
  createdAt?: number
  description?: string
  entityValidityDetails?: EntityValidityDetails
  gitDetails?: EntityGitDetails
  identifier?: string
  inputSetErrorDetails?: InputSetErrorWrapper
  inputSetType?: 'INPUT_SET' | 'OVERLAY_INPUT_SET'
  isOutdated?: boolean
  lastUpdatedAt?: number
  modules?: string[]
  name?: string
  overlaySetErrorDetails?: {
    [key: string]: string
  }
  pipelineIdentifier?: string
  storeType?: 'INLINE' | 'REMOTE'
  tags?: {
    [key: string]: string
  }
}

export interface InputSetTemplateRequest {
  stageIdentifiers?: string[]
}

export interface InputSetTemplateResponse {
  expressionValues?: {
    [key: string]: string
  }
  inputSetTemplateYaml?: string
  inputSetYaml?: string
}

export interface InputSetTemplateWithReplacedExpressionsResponse {
  hasInputSets?: boolean
  inputSetTemplateYaml?: string
  modules?: string[]
  replacedExpressions?: string[]
}

export interface InputSetValidator {
  parameters?: string
  validatorType?: 'ALLOWED_VALUES' | 'REGEX'
}

export interface InputSetYamlDiff {
  gitDetails?: EntityGitDetails
  inputSetEmpty?: boolean
  invalidReferences?: string[]
  newYAML?: string
  noUpdatePossible?: boolean
  oldYAML?: string
  yamlDiffPresent?: boolean
}

export interface InterruptConfig {
  issuedBy: IssuedBy
  retryInterruptConfig?: RetryInterruptConfig
}

export interface InterruptEffectDTO {
  interruptConfig: InterruptConfig
  interruptId: string
  interruptType:
    | 'UNKNOWN'
    | 'ABORT'
    | 'ABORT_ALL'
    | 'PAUSE'
    | 'PAUSE_ALL'
    | 'RESUME'
    | 'RESUME_ALL'
    | 'RETRY'
    | 'IGNORE'
    | 'WAITING_FOR_MANUAL_INTERVENTION'
    | 'MARK_FAILED'
    | 'MARK_SUCCESS'
    | 'NEXT_STEP'
    | 'END_EXECUTION'
    | 'MARK_EXPIRED'
    | 'CUSTOM_FAILURE'
    | 'EXPIRE_ALL'
    | 'PROCEED_WITH_DEFAULT'
    | 'USER_MARKED_FAIL_ALL'
    | 'UNRECOGNIZED'
  tookEffectAt: number
}

export type InvalidFieldsDTO = ErrorMetadataDTO & {}

export interface IssuedBy {
  adviserIssuer?: AdviserIssuer
  issueTime: number
  manualIssuer?: ManualIssuer
  timeoutIssuer?: TimeoutIssuer
  triggerIssuer?: TriggerIssuer
}

export type JUnitTestReport = UnitTestReportSpec & {
  paths?: string[]
}

export type JenkinsRegistrySpec = ArtifactTypeSpec & {
  artifactPath?: string
  build?: string
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  jobName?: string
  metaDataConditions?: TriggerEventDataCondition[]
}

export type JexlCriteriaSpec = CriteriaSpec & {
  expression: string
}

export type JiraApprovalInstanceDetails = ApprovalInstanceDetailsDTO & {
  approvalCriteria: CriteriaSpecWrapperDTO
  connectorRef?: string
  delegateTaskName?: string
  issue: JiraIssueKeyNG
  latestDelegateTaskId?: string
  rejectionCriteria: CriteriaSpecWrapperDTO
  retryInterval?: Timeout
}

export type JiraApprovalStepInfo = StepSpecType & {
  approvalCriteria: CriteriaSpecWrapper
  connectorRef: string
  delegateSelectors?: string[]
  issueKey: string
  issueType?: string
  projectKey?: string
  rejectionCriteria?: CriteriaSpecWrapper
  retryInterval?: string
}

export type JiraCreateStepInfo = StepSpecType & {
  connectorRef: string
  delegateSelectors?: string[]
  fields?: JiraField[]
  issueType: string
  projectKey: string
}

export interface JiraField {
  name?: string
  value: string
}

export interface JiraIssueKeyNG {
  key: string
  ticketFields?: {
    [key: string]: { [key: string]: any }
  }
  url: string
}

export type JiraUpdateStepInfo = StepSpecType & {
  connectorRef: string
  delegateSelectors?: string[]
  fields?: JiraField[]
  issueKey: string
  issueType?: string
  projectKey?: string
  transitionTo?: TransitionTo
}

export type JsonImportDataSpec = ImportDataSpec & {
  jsonBody: string
}

export interface JsonNode {
  [key: string]: any
}

export type K8sDirectInfra = StepGroupInfra & {
  spec: ContainerInfraYamlSpec
  type: 'KubernetesDirect' | 'Delegate' | 'Noop'
}

export type KeyValuesCriteriaSpec = CriteriaSpec & {
  conditions: Condition[]
  matchAnyCondition?: boolean
}

export type KeyValuesImportDataSpec = ImportDataSpec & {
  fields: ServiceNowField[]
}

export interface LandingDashboardRequestPMS {
  orgProjectIdentifiers: OrgProjectIdentifier[]
}

export interface LastTriggerExecutionDetails {
  lastExecutionStatus?: string
  lastExecutionSuccessful?: boolean
  lastExecutionTime?: number
  message?: string
  planExecutionId?: string
}

export interface Limits {
  cpu?: string
  memory?: string
}

export type ManifestTriggerConfig = NGTriggerSpecV2 & {
  manifestRef?: string
  spec?: ManifestTypeSpec
  stageIdentifier?: string
  type?: 'HelmChart'
}

export interface ManifestTypeSpec {
  [key: string]: any
}

export interface ManualFailureSpecConfig {
  onTimeout: OnTimeoutConfig
  timeout: string
}

export type ManualInterventionFailureActionConfig = FailureStrategyActionConfig & {
  spec: ManualFailureSpecConfig
  type: 'ManualIntervention'
}

export interface ManualIssuer {
  email_id: string
  identifier: string
  type: string
  user_id: string
}

export type MarkAsFailFailureActionConfig = FailureStrategyActionConfig & {
  type: 'MarkAsFailure'
}

export type MarkAsSuccessFailureActionConfig = FailureStrategyActionConfig & {
  type: 'MarkAsSuccess'
}

export interface MatrixConfigInterface {
  [key: string]: any
}

export interface MeanMedianInfo {
  duration?: number
  rate?: number
}

export interface MergeInputSetForRerunRequest {
  getResponseWithMergedPipelineYaml?: boolean
  planExecutionId?: string
  stageIdentifiers?: string[]
}

export interface MergeInputSetRequest {
  getOnlyFileContent?: boolean
  inputSetReferences?: string[]
  lastYamlToMerge?: string
  stageIdentifiers?: string[]
  withMergedPipelineYaml?: boolean
}

export interface MergeInputSetResponse {
  completePipelineYaml?: string
  errorResponse?: boolean
  inputSetErrorWrapper?: InputSetErrorWrapper
  pipelineYaml?: string
}

export interface MergeInputSetTemplateRequest {
  runtimeInputYaml?: string
}

export interface MoveConfigResponse {
  pipelineIdentifier?: string
}

export type MultiRegionArtifactTriggerConfig = NGTriggerSpecV2 & {
  artifactRef?: string
  eventConditions?: TriggerEventDataCondition[]
  jexlCondition?: string
  metaDataConditions?: TriggerEventDataCondition[]
  sources?: ArtifactTypeSpecWrapper[]
  stageIdentifier?: string
  type?:
    | 'Gcr'
    | 'Ecr'
    | 'DockerRegistry'
    | 'Nexus3Registry'
    | 'Nexus2Registry'
    | 'ArtifactoryRegistry'
    | 'Acr'
    | 'AmazonS3'
    | 'Jenkins'
    | 'CustomArtifact'
    | 'GoogleArtifactRegistry'
    | 'GithubPackageRegistry'
    | 'AzureArtifacts'
    | 'AmazonMachineImage'
    | 'GoogleCloudStorage'
    | 'Bamboo'
}

export interface NGLabel {
  key?: string
  value?: string
}

export interface NGProcessWebhookResponse {
  apiUrl?: string
  eventCorrelationId?: string
  uiSetupUrl?: string
  uiUrl?: string
}

export interface NGProperties {
  ci?: CIProperties
}

export interface NGTag {
  key: string
  value?: string
}

export interface NGTriggerConfigV2 {
  description?: string
  enabled?: boolean
  encryptedWebhookSecretIdentifier?: string
  identifier: string
  inputSetRefs?: string[]
  inputYaml?: string
  name?: string
  orgIdentifier?: string
  pipelineBranchName?: string
  pipelineIdentifier?: string
  projectIdentifier?: string
  source?: NGTriggerSourceV2
  stagesToExecute?: string[]
  tags?: {
    [key: string]: string
  }
}

export interface NGTriggerDetailsResponse {
  buildDetails?: BuildDetails
  description?: string
  enabled?: boolean
  executions?: number[]
  identifier?: string
  lastTriggerExecutionDetails?: LastTriggerExecutionDetails
  name?: string
  pipelineInputOutdated?: boolean
  registrationStatus?: 'SUCCESS' | 'FAILED' | 'ERROR' | 'TIMEOUT' | 'UNAVAILABLE'
  tags?: {
    [key: string]: string
  }
  triggerStatus?: TriggerStatus
  type?: 'Webhook' | 'Artifact' | 'Manifest' | 'Scheduled' | 'MultiRegionArtifact'
  webhookCurlCommand?: string
  webhookDetails?: WebhookDetails
  webhookUrl?: string
  yaml?: string
}

export interface NGTriggerEventHistoryResponse {
  accountId?: string
  createdAt?: number
  eventCorrelationId?: string
  eventCreatedAt?: number
  exceptionOccurred?: boolean
  finalStatus?:
    | 'SCM_SERVICE_CONNECTION_FAILED'
    | 'INVALID_PAYLOAD'
    | 'TRIGGER_DID_NOT_MATCH_EVENT_CONDITION'
    | 'TRIGGER_DID_NOT_MATCH_METADATA_CONDITION'
    | 'TRIGGER_DID_NOT_MATCH_ARTIFACT_JEXL_CONDITION'
    | 'NO_MATCHING_TRIGGER_FOR_REPO'
    | 'NO_MATCHING_TRIGGER_FOR_EVENT_ACTION'
    | 'NO_MATCHING_TRIGGER_FOR_METADATA_CONDITIONS'
    | 'NO_MATCHING_TRIGGER_FOR_PAYLOAD_CONDITIONS'
    | 'NO_MATCHING_TRIGGER_FOR_JEXL_CONDITIONS'
    | 'NO_MATCHING_TRIGGER_FOR_HEADER_CONDITIONS'
    | 'INVALID_RUNTIME_INPUT_YAML'
    | 'TARGET_DID_NOT_EXECUTE'
    | 'TARGET_EXECUTION_REQUESTED'
    | 'NO_ENABLED_CUSTOM_TRIGGER_FOUND'
    | 'NO_ENABLED_CUSTOM_TRIGGER_FOUND_FOR_ACCOUNT'
    | 'NO_ENABLED_TRIGGER_FOR_PROJECT'
    | 'NO_ENABLED_TRIGGER_FOR_ACCOUNT'
    | 'NO_ENABLED_TRIGGER_FOR_SOURCEREPO_TYPE'
    | 'NO_ENABLED_TRIGGER_FOR_ACCOUNT_SOURCE_REPO'
    | 'NO_MATCHING_TRIGGER_FOR_FILEPATH_CONDITIONS'
    | 'FAILED_TO_FETCH_PR_DETAILS'
    | 'EXCEPTION_WHILE_PROCESSING'
    | 'TRIGGER_CONFIRMATION_SUCCESSFUL'
    | 'TRIGGER_CONFIRMATION_FAILED'
    | 'TRIGGER_AUTHENTICATION_FAILED'
    | 'VALIDATION_FAILED_FOR_TRIGGER'
    | 'ALL_MAPPED_TRIGGER_FAILED_VALIDATION_FOR_POLLING_EVENT'
    | 'NO_MATCHING_TRIGGER_FOR_FOR_EVENT_SIGNATURES'
    | 'NO_MATCHING_TRIGGER_FOR_FOR_EVENT_CONDITION'
    | 'POLLING_EVENT_WITH_NO_VERSIONS'
    | 'NEW_ARTIFACT_EVENT_PROCESSED'
    | 'NEW_MANIFEST_EVENT_PROCESSED'
  message?: string
  ngTriggerEventInfo?: NGTriggerEventInfo
  orgIdentifier?: string
  payload?: string
  projectIdentifier?: string
  targetExecutionSummary?: TargetExecutionSummary
  targetIdentifier?: string
  triggerEventStatus?: TriggerEventStatus
  triggerIdentifier?: string
  type?: 'Webhook' | 'Artifact' | 'Manifest' | 'Scheduled' | 'MultiRegionArtifact'
}

export interface NGTriggerEventInfo {
  [key: string]: any
}

export interface NGTriggerResponse {
  accountIdentifier?: string
  description?: string
  enabled?: boolean
  errorResponse?: boolean
  errors?: {
    [key: string]: {
      [key: string]: string
    }
  }
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  stagesToExecute?: string[]
  targetIdentifier?: string
  type?: 'Webhook' | 'Artifact' | 'Manifest' | 'Scheduled' | 'MultiRegionArtifact'
  yaml?: string
}

export interface NGTriggerSourceV2 {
  pollInterval?: string
  spec?: NGTriggerSpecV2
  type?: 'Webhook' | 'Artifact' | 'Manifest' | 'Scheduled' | 'MultiRegionArtifact'
  webhookId?: string
}

export interface NGTriggerSpecV2 {
  [key: string]: any
}

export interface NGVariable {
  description?: string
  metadata?: string
  name?: string
  required?: boolean
  type?: 'String' | 'Number' | 'Secret'
}

export interface NGVariableV1 {
  desc?: string
  execution_input?: boolean
  metadata?: string
  required?: boolean
  type?: 'string' | 'number' | 'secret' | 'array' | 'object' | 'boolean'
}

export interface NGVariableV1Wrapper {
  map?: {
    [key: string]: NGVariableV1
  }
}

export type Nexus2RegistrySpec = ArtifactTypeSpec & {
  artifactId?: string
  classifier?: string
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  extension?: string
  groupId?: string
  jexlCondition?: string
  metaDataConditions?: TriggerEventDataCondition[]
  packageName?: string
  repositoryFormat?: string
  repositoryName?: string
  repositoryUrl?: string
  tag?: string
}

export type NexusRegistrySpec = ArtifactTypeSpec & {
  artifactId?: string
  classifier?: string
  connectorRef?: string
  eventConditions?: TriggerEventDataCondition[]
  extension?: string
  group?: string
  groupId?: string
  imagePath?: string
  jexlCondition?: string
  metaDataConditions?: TriggerEventDataCondition[]
  packageName?: string
  repository?: string
  repositoryFormat?: string
  repositoryUrl?: string
  tag?: string
}

export interface NodeErrorInfo {
  fqn?: string
  identifier?: string
  name?: string
  type?: string
}

export interface NodeExecutionDetails {
  executionGraph?: ExecutionGraph
}

export interface NodeInfo {
  identifier?: string
  localFqn?: string
  name?: string
}

export interface NodeRunInfo {
  [key: string]: any
}

export interface NotificationChannelWrapper {
  spec?: PmsNotificationChannel
  type?: string
}

export interface NotificationRules {
  enabled?: boolean
  name?: string
  notificationMethod?: NotificationChannelWrapper
  pipelineEvents?: PipelineEvent[]
}

export type NumberNGVariable = NGVariable & {
  default?: number
  name?: string
  type?: 'Number'
  value: number
}

export type NumberNGVariableV1 = NGVariableV1 & {
  __uuid?: string
  default?: number
  validator?: NumberValidator
  value?: ParameterFieldDouble
}

export interface NumberValidator {
  [key: string]: any
}

export type ObjectNGVariableV1 = NGVariableV1 & {
  __uuid?: string
  default?: { [key: string]: any }
  validator?: ObjectValidator
  value?: ParameterFieldObject
}

export interface ObjectValidator {
  [key: string]: any
}

export interface OnFailureConfig {
  action: FailureStrategyActionConfig
  errors: (
    | 'Unknown'
    | 'AllErrors'
    | 'Authentication'
    | 'Connectivity'
    | 'Timeout'
    | 'Authorization'
    | 'Verification'
    | 'DelegateProvisioning'
    | 'PolicyEvaluationFailure'
    | 'InputTimeoutError'
    | 'ApprovalRejection'
    | 'DelegateRestart'
    | 'UserMarkedFailure'
  )[]
}

export interface OnRetryFailureConfig {
  action?: FailureStrategyActionConfig
}

export interface OnTimeoutConfig {
  action?: FailureStrategyActionConfig
}

export interface OrgProjectIdentifier {
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface OutputAlias {
  key: string
  scope: 'Pipeline' | 'Stage' | 'StepGroup'
}

export interface OutputAliasV1 {
  key?: ParameterFieldString
  scope?: 'pipeline' | 'stage' | 'group'
}

export interface OutputNGVariable {
  description?: string
  name?: string
}

export type OverlayInputSetErrorWrapper = ErrorMetadataDTO & {
  invalidReferences?: {
    [key: string]: string
  }
}

export interface OverlayInputSetResponse {
  accountId?: string
  cacheResponse?: CacheResponseMetadata
  connectorRef?: string
  description?: string
  entityValidityDetails?: EntityValidityDetails
  errorResponse?: boolean
  gitDetails?: EntityGitDetails
  identifier?: string
  inputSetReferences?: string[]
  invalidInputSetReferences?: {
    [key: string]: string
  }
  name?: string
  orgIdentifier?: string
  outdated?: boolean
  overlayInputSetYaml?: string
  pipelineIdentifier?: string
  projectIdentifier?: string
  storeType?: 'INLINE' | 'REMOTE'
  tags?: {
    [key: string]: string
  }
}

export interface PMSGitUpdateResponse {
  identifier?: string
}

export interface PMSInputSetListRepoResponse {
  repositories?: string[]
}

export interface PMSPipelineListBranchesResponse {
  branches?: string[]
}

export interface PMSPipelineListRepoResponse {
  repositories?: string[]
}

export interface PMSPipelineResponseDTO {
  cacheResponse?: CacheResponseMetadata
  entityValidityDetails?: EntityValidityDetails
  gitDetails?: EntityGitDetails
  governanceMetadata?: GovernanceMetadata
  modules?: string[]
  publicAccessResponse?: PublicAccessResponse
  resolvedTemplatesPipelineYaml?: string
  storeType?: 'INLINE' | 'REMOTE'
  validateTemplateInputsResponse?: ValidateTemplateInputsResponseDTO
  validationUuid?: string
  yamlPipeline?: string
  yamlSchemaErrorWrapper?: YamlSchemaErrorWrapperDTO
}

export interface PMSPipelineSummaryResponse {
  connectorRef?: string
  createdAt?: number
  description?: string
  entityValidityDetails?: EntityValidityDetails
  executionSummaryInfo?: ExecutionSummaryInfo
  filters?: {
    [key: string]: {
      [key: string]: { [key: string]: any }
    }
  }
  gitDetails?: EntityGitDetails
  identifier?: string
  isDraft?: boolean
  lastUpdatedAt?: number
  modules?: string[]
  name?: string
  numOfStages?: number
  recentExecutionsInfo?: RecentExecutionInfoDTO[]
  stageNames?: string[]
  storeType?: 'INLINE' | 'REMOTE'
  tags?: {
    [key: string]: string
  }
  version?: number
  yamlVersion?: string
}

export type PRBuildSpec = BuildSpec & {
  number: string
}

export interface Page {
  content?: { [key: string]: any }[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface PageFilterDTO {
  content?: FilterDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageInputSetListResponse {
  content?: InputSetListResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageInputSetSummaryResponse {
  content?: InputSetSummaryResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageNGTriggerDetailsResponse {
  content?: NGTriggerDetailsResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageNGTriggerEventHistoryResponse {
  content?: NGTriggerEventHistoryResponse[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface PagePMSPipelineSummaryResponse {
  content?: PMSPipelineSummaryResponse[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface PagePipelineExecutionIdentifierSummary {
  content?: PipelineExecutionIdentifierSummary[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface PagePipelineExecutionSummary {
  content?: PipelineExecutionSummary[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface Pageable {
  offset?: number
  pageNumber?: number
  pageSize?: number
  paged?: boolean
  sort?: Sort
  unpaged?: boolean
}

export type ParallelStageElementConfig = StageElementWrapperConfig[]

export type ParallelStepElementConfig = ExecutionWrapperConfig[]

export interface ParameterField {
  defaultValue?: { [key: string]: any }
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: { [key: string]: any }
}

export interface ParameterFieldBoolean {
  defaultValue?: boolean
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: boolean
}

export interface ParameterFieldDouble {
  defaultValue?: number
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: number
}

export interface ParameterFieldListObject {
  defaultValue?: { [key: string]: any }[]
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: { [key: string]: any }[]
}

export interface ParameterFieldListString {
  defaultValue?: string[]
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: string[]
}

export interface ParameterFieldListTaskSelectorYaml {
  defaultValue?: TaskSelectorYaml[]
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: TaskSelectorYaml[]
}

export interface ParameterFieldMapStringJsonNode {
  defaultValue?: {
    [key: string]: JsonNode
  }
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: {
    [key: string]: JsonNode
  }
}

export interface ParameterFieldMapStringString {
  defaultValue?: {
    [key: string]: string
  }
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: {
    [key: string]: string
  }
}

export interface ParameterFieldMatrixConfigInterface {
  defaultValue?: MatrixConfigInterface
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: MatrixConfigInterface
}

export interface ParameterFieldObject {
  defaultValue?: { [key: string]: any }
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: { [key: string]: any }
}

export interface ParameterFieldSecretRefData {
  defaultValue?: SecretRefData
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: SecretRefData
}

export interface ParameterFieldString {
  defaultValue?: string
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: string
}

export interface ParameterFieldTILanguage {
  defaultValue?: 'Java' | 'Kotlin' | 'Scala' | 'Csharp' | 'Python' | 'Ruby'
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: 'Java' | 'Kotlin' | 'Scala' | 'Csharp' | 'Python' | 'Ruby'
}

export interface PatchInstruction {
  type?:
    | 'SetFeatureFlagState'
    | 'SetOnVariation'
    | 'SetOffVariation'
    | 'SetDefaultVariations'
    | 'AddRule'
    | 'UpdateRule'
    | 'AddTargetsToVariationTargetMap'
    | 'RemoveTargetsToVariationTargetMap'
    | 'AddSegmentToVariationTargetMap'
    | 'RemoveSegmentsToVariationTargetMap'
}

export interface PermissionCheck {
  permission?: string
  resourceAttributes?: {
    [key: string]: string
  }
  resourceIdentifier?: string
  resourceScope?: ResourceScope
  resourceType?: string
}

export type PersistentVolumeClaimYaml = CIVolume & {
  mountPath: string
  spec: PersistentVolumeClaimYamlSpec
  type: 'EmptyDir' | 'PersistentVolumeClaim' | 'HostPath'
}

export interface PersistentVolumeClaimYamlSpec {
  claimName: string
  readOnly?: boolean
}

export interface PipelineConfig {
  pipeline?: PipelineInfoConfig
}

export interface PipelineCountInfo {
  aborted?: number
  expired?: number
  failure?: number
  success?: number
  total?: number
}

export interface PipelineEvent {
  forStages?: string[]
  type?:
    | 'AllEvents'
    | 'PipelineStart'
    | 'PipelineSuccess'
    | 'PipelineFailed'
    | 'PipelineEnd'
    | 'PipelinePaused'
    | 'StageSuccess'
    | 'StageFailed'
    | 'StageStart'
    | 'StepFailed'
}

export interface PipelineExecutionDetail {
  childGraph?: ChildExecutionDetailDTO
  executionGraph?: ExecutionGraph
  pipelineExecutionSummary?: PipelineExecutionSummary
  rollbackGraph?: ChildExecutionDetailDTO
}

export type PipelineExecutionFilterProperties = FilterProperties & {
  executionModeFilter?: 'ROLLBACK' | 'ALL' | 'DEFAULT'
  moduleProperties?: {
    [key: string]: { [key: string]: any }
  }
  pipelineLabels?: NGLabel[]
  pipelineName?: string
  pipelineTags?: NGTag[]
  status?: (
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'WaitStepRunning'
    | 'QueuedLicenseLimitReached'
    | 'QueuedExecutionConcurrencyReached'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'InputWaiting'
    | 'AbortedByFreeze'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
  )[]
  timeRange?: TimeRange
  triggerIdentifiers?: string[]
  triggerTypes?: (
    | 'NOOP'
    | 'MANUAL'
    | 'WEBHOOK'
    | 'WEBHOOK_CUSTOM'
    | 'SCHEDULER_CRON'
    | 'ARTIFACT'
    | 'MANIFEST'
    | 'UNRECOGNIZED'
  )[]
}

export interface PipelineExecutionIdentifierSummary {
  orgIdentifier?: string
  pipelineIdentifier?: string
  planExecutionId?: string
  projectIdentifier?: string
  runSequence?: number
  status?:
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'WaitStepRunning'
    | 'QueuedLicenseLimitReached'
    | 'QueuedExecutionConcurrencyReached'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'InputWaiting'
    | 'AbortedByFreeze'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
}

export interface PipelineExecutionInfo {
  count?: PipelineCountInfo
  date?: number
}

export interface PipelineExecutionNotes {
  notes?: string
}

export interface PipelineExecutionSummary {
  abortedBy?: AbortedBy
  allowStageExecutions?: boolean
  canRetry?: boolean
  connectorRef?: string
  createdAt?: number
  endTs?: number
  executionErrorInfo?: ExecutionErrorInfo
  executionInputConfigured?: boolean
  executionMode?: 'UNDEFINED_MODE' | 'NORMAL' | 'POST_EXECUTION_ROLLBACK' | 'PIPELINE_ROLLBACK' | 'UNRECOGNIZED'
  executionTriggerInfo?: ExecutionTriggerInfo
  failedStagesCount?: number
  failureInfo?: FailureInfoDTO
  gitDetails?: EntityGitDetails
  governanceMetadata?: GovernanceMetadata
  layoutNodeMap?: {
    [key: string]: GraphLayoutNode
  }
  moduleInfo?: {
    [key: string]: {
      [key: string]: { [key: string]: any }
    }
  }
  modules?: string[]
  name?: string
  notesExistForPlanExecutionId?: boolean
  orgIdentifier?: string
  parentStageInfo?: PipelineStageInfo
  pipelineIdentifier?: string
  planExecutionId?: string
  projectIdentifier?: string
  runSequence?: number
  runningStagesCount?: number
  shouldUseSimplifiedKey?: boolean
  showRetryHistory?: boolean
  stagesExecuted?: string[]
  stagesExecutedNames?: {
    [key: string]: string
  }
  stagesExecution?: boolean
  startTs?: number
  startingNodeId?: string
  status?:
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'WaitStepRunning'
    | 'QueuedLicenseLimitReached'
    | 'QueuedExecutionConcurrencyReached'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'InputWaiting'
    | 'AbortedByFreeze'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
  storeType?: 'INLINE' | 'REMOTE'
  successfulStagesCount?: number
  tags?: NGTag[]
  totalStagesCount?: number
  yamlVersion?: string
}

export interface PipelineExpandedJson {
  expandedJson?: string
}

export type PipelineFilterProperties = FilterProperties & {
  description?: string
  moduleProperties?: {
    [key: string]: { [key: string]: any }
  }
  name?: string
  pipelineIdentifiers?: string[]
  pipelineTags?: NGTag[]
  repoName?: string
}

export interface PipelineHealthInfo {
  meanInfo?: MeanMedianInfo
  medianInfo?: MeanMedianInfo
  success?: SuccessHealthInfo
  total?: TotalHealthInfo
}

export interface PipelineImportRequest {
  pipelineDescription?: string
  pipelineName?: string
}

export interface PipelineInfoConfig {
  allowStageExecutions?: boolean
  delegateSelectors?: string[]
  description?: string
  flowControl?: FlowControlConfig
  identifier: string
  name: string
  notificationRules?: NotificationRules[]
  orgIdentifier?: string
  projectIdentifier?: string
  properties?: NGProperties
  stages?: StageElementWrapperConfig[]
  tags?: {
    [key: string]: string
  }
  template?: TemplateLinkConfig
  timeout?: string
  variables?: NGVariable[]
}

export interface PipelineInputResponse {
  errorInfo?: PreFlightEntityErrorInfo
  fqn?: string
  stageName?: string
  stepName?: string
  success?: boolean
}

export interface PipelineOpaEvaluationContext {
  action?: string
  date?: string
  pipeline?: { [key: string]: any }
  user?: UserOpaEvaluationContext
}

export type PipelineRollbackFailureActionConfig = FailureStrategyActionConfig & {
  type: 'PipelineRollback'
}

export type PipelineRollbackStageConfig = StageInfoConfig & {}

export interface PipelineSaveResponse {
  governanceMetadata?: GovernanceMetadata
  identifier?: string
  publicAccessResponse?: PublicAccessResponse
}

export type PipelineStageConfig = StageInfoConfig & {
  inputSetReferences?: string[]
  inputs?: JsonNode
  org: string
  outputs?: PipelineStageOutputs[]
  pipeline: string
  pipelineInputs?: JsonNode
  project: string
}

export interface PipelineStageInfo {
  [key: string]: any
}

export interface PipelineStageOutputs {
  name: string
  value: string
}

export interface PipelineValidationResponseDTO {
  endTs?: number
  policyEval?: GovernanceMetadata
  startTs?: number
  status?: string
  templateValidationResponse?: TemplateValidationResponseDTO
  validateTemplateReconcileResponseDTO?: ValidateTemplateReconcileResponseDTO
}

export interface PipelineValidationUUIDResponseBody {
  uuid?: string
}

export interface PipelineWrapperResponse {
  label?: string
  pipelineInputResponse?: PipelineInputResponse[]
  status?: 'SUCCESS' | 'FAILURE' | 'IN_PROGRESS' | 'UNKNOWN'
}

export interface PipelinesCount {
  newCount?: number
  totalCount?: number
}

export interface PlanExecution {
  ambiance?: Ambiance
  createdAt?: number
  endTs?: number
  governanceMetadata?: GovernanceMetadata
  lastUpdatedAt?: number
  metadata?: ExecutionMetadata
  nextIteration?: number
  nodeId?: string
  nodeType?: 'PLAN' | 'PLAN_NODE' | 'IDENTITY_PLAN_NODE'
  planId?: string
  setupAbstractions?: {
    [key: string]: string
  }
  startTs?: number
  status?:
    | 'NO_OP'
    | 'RUNNING'
    | 'INTERVENTION_WAITING'
    | 'TIMED_WAITING'
    | 'ASYNC_WAITING'
    | 'TASK_WAITING'
    | 'DISCONTINUING'
    | 'PAUSING'
    | 'QUEUED'
    | 'SKIPPED'
    | 'PAUSED'
    | 'ABORTED'
    | 'ERRORED'
    | 'FAILED'
    | 'EXPIRED'
    | 'SUSPENDED'
    | 'SUCCEEDED'
    | 'IGNORE_FAILED'
    | 'APPROVAL_WAITING'
    | 'RESOURCE_WAITING'
    | 'APPROVAL_REJECTED'
    | 'INPUT_WAITING'
    | 'WAIT_STEP_RUNNING'
    | 'FREEZE_FAILED'
    | 'QUEUED_LICENSE_LIMIT_REACHED'
    | 'QUEUED_EXECUTION_CONCURRENCY_REACHED'
    | 'UNRECOGNIZED'
  uuid?: string
  validUntil?: string
  version?: number
}

export interface PlanExecutionResponseDto {
  gitDetails?: EntityGitDetails
  planExecution?: PlanExecution
}

export type PluginStepInfo = StepSpecType & {
  connectorRef?: string
  entrypoint?: string[]
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  privileged?: boolean
  reports?: UnitTestReport
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  uses?: string
  version?: string
}

export type PluginStepInfoV1 = StepSpecType & {
  envs?: {
    [key: string]: string
  }
  image?: string
  privileged?: boolean
  pull?: 'always' | 'never' | 'if-not-exists'
  resources?: ContainerResource
  user?: number
  uses?: string
  version?: string
  with?: ParameterFieldMapStringJsonNode
}

export interface PmsAbstractStepNode {
  description?: string
  enforce?: PolicyConfig
  failureStrategies?: FailureStrategyConfig[]
  identifier: string
  name: string
  strategy?: StrategyConfig
  timeout?: string
  when?: StepWhenCondition
}

export type PmsEmailChannel = PmsNotificationChannel & {
  recipients?: string[]
  userGroups?: string[]
}

export type PmsMSTeamChannel = PmsNotificationChannel & {
  msTeamKeys?: string[]
  userGroups?: string[]
}

export interface PmsNotificationChannel {
  [key: string]: any
}

export type PmsPagerDutyChannel = PmsNotificationChannel & {
  integrationKey?: string
  userGroups?: string[]
}

export type PmsSlackChannel = PmsNotificationChannel & {
  userGroups?: string[]
  webhookUrl?: string
}

export type PmsWebhookChannel = PmsNotificationChannel & {
  webhookUrl?: string
}

export interface PolicyConfig {
  policySets: string[]
}

export interface PolicySpec {
  type?: string
}

export type PolicyStepInfo = StepSpecType & {
  metadata?: string
  policySets: string[]
  policySpec?: PolicySpec
  type?: string
}

export interface PolicyStore {
  spec?: StoreSpec
  type: 'Harness'
}

export interface PolledResponse {
  allPolledKeys?: string[]
}

export interface PollingInfoForTriggers {
  perpetualTaskId?: string
  polledResponse?: PolledResponse
  pollingDocId?: string
}

export interface PollingSubscriptionStatus {
  detailedMessage?: string
  errorStatusValidUntil?: number
  lastPolled?: string[]
  lastPollingUpdate?: number
  statusResult?: 'SUCCESS' | 'FAILED' | 'UNKNOWN' | 'PENDING'
}

export interface PollingTriggerStatusUpdateDTO {
  errorMessage?: string
  errorStatusValidUntil?: number
  lastCollectedTime?: number
  lastCollectedVersions?: string[]
  signatures?: string[]
  success?: boolean
}

export interface PreFlightCause {
  cause?: string
}

export interface PreFlightDTO {
  connectorWrapperResponse?: ConnectorWrapperResponse
  errorInfo?: PreFlightErrorInfo
  pipelineInputWrapperResponse?: PipelineWrapperResponse
  status?: 'SUCCESS' | 'FAILURE' | 'IN_PROGRESS' | 'UNKNOWN'
}

export interface PreFlightEntityErrorInfo {
  causes?: PreFlightCause[]
  description?: string
  resolution?: PreFlightResolution[]
  summary?: string
}

export interface PreFlightErrorInfo {
  count?: number
  message?: string
}

export interface PreFlightResolution {
  resolution?: string
}

export interface Principal {
  identifier: string
  type: 'USER' | 'SYSTEM' | 'API_KEY' | 'SERVICE_ACCOUNT'
}

export type ProceedWithDefaultValuesFailureActionConfig = FailureStrategyActionConfig & {
  type: 'ProceedWithDefaultValues'
}

export interface PublicAccessResponse {
  errorMessage?: string
  public?: boolean
}

export type QueueStepInfo = StepSpecType & {
  key: string
  scope: 'Pipeline' | 'Stage'
}

export interface RecentExecutionInfoDTO {
  endTs?: number
  executorInfo?: ExecutorInfoDTO
  parentStageInfo?: PipelineStageInfo
  planExecutionId?: string
  runSequence?: number
  startTs?: number
  status?:
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'WaitStepRunning'
    | 'QueuedLicenseLimitReached'
    | 'QueuedExecutionConcurrencyReached'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'InputWaiting'
    | 'AbortedByFreeze'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
}

export type RemoveSegmentToVariationTargetMapYaml = PatchInstruction & {
  identifier: string
  spec: RemoveSegmentToVariationTargetMapYamlSpec
  type: 'RemoveSegmentsToVariationTargetMap'
}

export interface RemoveSegmentToVariationTargetMapYamlSpec {
  segments: string[]
  variation: string
}

export type RemoveTargetsToVariationTargetMapYaml = PatchInstruction & {
  identifier: string
  spec: RemoveTargetsToVariationTargetMapYamlSpec
  type: 'RemoveTargetsToVariationTargetMap'
}

export interface RemoveTargetsToVariationTargetMapYamlSpec {
  targets: string[]
  variation: string
}

export interface ResourceConstraintDetail {
  accountId?: string
  orgIdentifier?: string
  pipelineIdentifier?: string
  pipelineName?: string
  planExecutionId?: string
  projectIdentifier?: string
  startTs?: number
  state?: 'BLOCKED' | 'ACTIVE' | 'FINISHED' | 'REJECTED'
}

export interface ResourceConstraintExecutionInfo {
  capacity?: number
  name?: string
  resourceConstraints?: ResourceConstraintDetail[]
}

export type ResourceConstraintStepInfo = StepSpecType & {
  acquireMode: 'ENSURE' | 'ACCUMULATE'
  holdingScope: 'PLAN' | 'PIPELINE' | 'STAGE' | 'STEP_GROUP'
  name: string
  permits: number
  resourceUnit: ParameterFieldString
}

export interface ResourceDTO {
  identifier: string
  labels?: {
    [key: string]: string
  }
  type:
    | 'ORGANIZATION'
    | 'PROJECT'
    | 'USER_GROUP'
    | 'SECRET'
    | 'RESOURCE_GROUP'
    | 'USER'
    | 'ROLE'
    | 'PIPELINE'
    | 'TRIGGER'
    | 'TEMPLATE'
    | 'INPUT_SET'
    | 'DELEGATE_CONFIGURATION'
    | 'DELEGATE_GROUPS'
    | 'SERVICE'
    | 'ENVIRONMENT'
    | 'ENVIRONMENT_GROUP'
    | 'DELEGATE'
    | 'SERVICE_ACCOUNT'
    | 'CONNECTOR'
    | 'API_KEY'
    | 'TOKEN'
    | 'DELEGATE_TOKEN'
    | 'GOVERNANCE_POLICY'
    | 'GOVERNANCE_POLICY_SET'
    | 'VARIABLE'
    | 'CHAOS_HUB'
    | 'MONITORED_SERVICE'
    | 'CHAOS_INFRASTRUCTURE'
    | 'CHAOS_EXPERIMENT'
    | 'CHAOS_GAMEDAY'
    | 'STO_TARGET'
    | 'STO_EXEMPTION'
    | 'SERVICE_LEVEL_OBJECTIVE'
    | 'PERSPECTIVE'
    | 'PERSPECTIVE_BUDGET'
    | 'PERSPECTIVE_REPORT'
    | 'COST_CATEGORY'
    | 'SMTP'
    | 'PERSPECTIVE_FOLDER'
    | 'AUTOSTOPPING_RULE'
    | 'AUTOSTOPPING_LB'
    | 'AUTOSTOPPING_STARTSTOP'
    | 'SETTING'
    | 'NG_LOGIN_SETTINGS'
    | 'DEPLOYMENT_FREEZE'
    | 'CLOUD_ASSET_GOVERNANCE_RULE'
    | 'CLOUD_ASSET_GOVERNANCE_RULE_SET'
    | 'CLOUD_ASSET_GOVERNANCE_RULE_ENFORCEMENT'
    | 'TARGET_GROUP'
    | 'FEATURE_FLAG'
    | 'NG_ACCOUNT_DETAILS'
    | 'BUDGET_GROUP'
    | 'IP_ALLOWLIST_CONFIG'
    | 'NETWORK_MAP'
    | 'CET_AGENT_TOKEN'
    | 'CET_CRITICAL_EVENT'
    | 'CHAOS_SECURITY_GOVERNANCE'
    | 'END_USER_LICENSE_AGREEMENT'
    | 'WORKSPACE'
    | 'SEI_CONFIGURATION_SETTINGS'
    | 'SEI_COLLECTIONS'
    | 'SEI_INSIGHTS'
    | 'CET_SAVED_FILTER'
    | 'GITOPS_AGENT'
    | 'GITOPS_REPOSITORY'
    | 'GITOPS_CLUSTER'
    | 'GITOPS_CREDENTIAL_TEMPLATE'
    | 'GITOPS_REPOSITORY_CERTIFICATE'
    | 'GITOPS_GNUPG_KEY'
    | 'GITOPS_PROJECT_MAPPING'
    | 'GITOPS_APPLICATION'
    | 'CODE_REPOSITORY'
  uniqueId?: string
}

export interface ResourceScope {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface ResourceScopeDTO {
  accountIdentifier?: string
  labels?: {
    [key: string]: string
  }
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface Response {
  correlationId?: string
  data?: { [key: string]: any }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseApprovalInstanceResponse {
  correlationId?: string
  data?: ApprovalInstanceResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseBarrierInfo {
  correlationId?: string
  data?: BarrierInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseBoolean {
  correlationId?: string
  data?: boolean
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDashboardPipelineExecutionInfo {
  correlationId?: string
  data?: DashboardPipelineExecutionInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDashboardPipelineHealthInfo {
  correlationId?: string
  data?: DashboardPipelineHealthInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseExecutionDataResponse {
  correlationId?: string
  data?: ExecutionDataResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseExecutionInputDTO {
  correlationId?: string
  data?: ExecutionInputDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseExecutionInputStatus {
  correlationId?: string
  data?: ExecutionInputStatus
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseExecutionInputVariablesResponse {
  correlationId?: string
  data?: ExecutionInputVariablesResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseExecutionMetaDataResponse {
  correlationId?: string
  data?: ExecutionMetaDataResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseExecutionNode {
  correlationId?: string
  data?: ExecutionNode
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseExecutionsCount {
  correlationId?: string
  data?: ExecutionsCount
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseExpressionEvaluationDetail {
  correlationId?: string
  data?: ExpressionEvaluationDetail
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseExpressionUsagesDTO {
  correlationId?: string
  data?: ExpressionUsagesDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFilterDTO {
  correlationId?: string
  data?: FilterDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseHarnessApprovalInstanceAuthorization {
  correlationId?: string
  data?: HarnessApprovalInstanceAuthorization
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInputSetGitUpdateResponse {
  correlationId?: string
  data?: InputSetGitUpdateResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInputSetImportResponseDTO {
  correlationId?: string
  data?: InputSetImportResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInputSetMoveConfigResponseDTO {
  correlationId?: string
  data?: InputSetMoveConfigResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInputSetResponse {
  correlationId?: string
  data?: InputSetResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInputSetSanitiseResponse {
  correlationId?: string
  data?: InputSetSanitiseResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInputSetTemplateResponse {
  correlationId?: string
  data?: InputSetTemplateResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInputSetTemplateWithReplacedExpressionsResponse {
  correlationId?: string
  data?: InputSetTemplateWithReplacedExpressionsResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInputSetYamlDiff {
  correlationId?: string
  data?: InputSetYamlDiff
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseJsonNode {
  correlationId?: string
  data?: JsonNode
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListBarrierExecutionInfo {
  correlationId?: string
  data?: BarrierExecutionInfo[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListBarrierSetupInfo {
  correlationId?: string
  data?: BarrierSetupInfo[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListBitbucketPRAction {
  correlationId?: string
  data?: ('Create' | 'Update' | 'Merge' | 'Decline')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListBitbucketTriggerEvent {
  correlationId?: string
  data?: ('PullRequest' | 'Push' | 'PRComment')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListGithubIssueCommentAction {
  correlationId?: string
  data?: ('Create' | 'Edit' | 'Delete')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListGithubPRAction {
  correlationId?: string
  data?: ('Close' | 'Edit' | 'Open' | 'Reopen' | 'Label' | 'Unlabel' | 'Synchronize' | 'ReadyForReview')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListGithubTriggerEvent {
  correlationId?: string
  data?: ('PullRequest' | 'Push' | 'IssueComment' | 'Release')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListGitlabPRAction {
  correlationId?: string
  data?: ('Open' | 'Close' | 'Reopen' | 'Merge' | 'Update' | 'Sync')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListGitlabTriggerEvent {
  correlationId?: string
  data?: ('MergeRequest' | 'Push' | 'MRComment')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListStageExecutionResponse {
  correlationId?: string
  data?: StageExecutionResponse[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListWebhookAction {
  correlationId?: string
  data?: (
    | 'created'
    | 'closed'
    | 'edited'
    | 'updated'
    | 'opened'
    | 'reopened'
    | 'labeled'
    | 'unlabeled'
    | 'deleted'
    | 'synchronized'
    | 'synced'
    | 'merged'
    | 'sync'
    | 'open'
    | 'close'
    | 'reopen'
    | 'merge'
    | 'update'
    | 'mr comment create'
    | 'pull request created'
    | 'pull request updated'
    | 'pull request merged'
    | 'pull request declined'
    | 'pr comment created'
    | 'pr comment edited'
    | 'pr comment deleted'
  )[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListWebhookTriggerType {
  correlationId?: string
  data?: ('AzureRepo' | 'Github' | 'Gitlab' | 'Bitbucket' | 'Custom' | 'AwsCodeCommit' | 'Harness')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMapStringMapStringListString {
  correlationId?: string
  data?: {
    [key: string]: {
      [key: string]: string[]
    }
  }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMapWebhookSourceRepoListWebhookEvent {
  correlationId?: string
  data?: {
    [key: string]: (
      | 'Pull Request'
      | 'Push'
      | 'Issue Comment'
      | 'MR Comment'
      | 'PR Comment'
      | 'Delete'
      | 'Merge Request'
      | 'Repository'
      | 'Branch'
      | 'Tag'
      | 'Release'
    )[]
  }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMergeInputSetResponse {
  correlationId?: string
  data?: MergeInputSetResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMessage {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'ACCOUNT_MIGRATED_TO_NEXT_GEN'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'SCM_REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SPOTNIST_REST_EXCEPTION'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'MISSING_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
    | 'ABORT_ALL_ALREADY_NG'
  exception?: Throwable
  failureTypes?: (
    | 'EXPIRED'
    | 'DELEGATE_PROVISIONING'
    | 'CONNECTIVITY'
    | 'AUTHENTICATION'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'TIMEOUT_ERROR'
    | 'POLICY_EVALUATION_FAILURE'
    | 'INPUT_TIMEOUT_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'DELEGATE_RESTART'
    | 'USER_MARKED_FAILURE'
  )[]
  level?: 'INFO' | 'ERROR'
  message?: string
}

export interface ResponseMoveConfigResponse {
  correlationId?: string
  data?: MoveConfigResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseNGProcessWebhookResponse {
  correlationId?: string
  data?: NGProcessWebhookResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseNGTriggerConfigV2 {
  correlationId?: string
  data?: NGTriggerConfigV2
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseNGTriggerDetailsResponse {
  correlationId?: string
  data?: NGTriggerDetailsResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseNGTriggerResponse {
  correlationId?: string
  data?: NGTriggerResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseNodeExecutionDetails {
  correlationId?: string
  data?: NodeExecutionDetails
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseNotificationRules {
  correlationId?: string
  data?: NotificationRules
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseOverlayInputSetResponse {
  correlationId?: string
  data?: OverlayInputSetResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePMSGitUpdateResponse {
  correlationId?: string
  data?: PMSGitUpdateResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePMSInputSetListRepoResponse {
  correlationId?: string
  data?: PMSInputSetListRepoResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePMSPipelineListBranchesResponse {
  correlationId?: string
  data?: PMSPipelineListBranchesResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePMSPipelineListRepoResponse {
  correlationId?: string
  data?: PMSPipelineListRepoResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePMSPipelineResponseDTO {
  correlationId?: string
  data?: PMSPipelineResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePMSPipelineSummaryResponse {
  correlationId?: string
  data?: PMSPipelineSummaryResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageFilterDTO {
  correlationId?: string
  data?: PageFilterDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageInputSetListResponse {
  correlationId?: string
  data?: PageInputSetListResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageInputSetSummaryResponse {
  correlationId?: string
  data?: PageInputSetSummaryResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageNGTriggerDetailsResponse {
  correlationId?: string
  data?: PageNGTriggerDetailsResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageNGTriggerEventHistoryResponse {
  correlationId?: string
  data?: PageNGTriggerEventHistoryResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePagePMSPipelineSummaryResponse {
  correlationId?: string
  data?: PagePMSPipelineSummaryResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePagePipelineExecutionIdentifierSummary {
  correlationId?: string
  data?: PagePipelineExecutionIdentifierSummary
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePagePipelineExecutionSummary {
  correlationId?: string
  data?: PagePipelineExecutionSummary
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelineConfig {
  correlationId?: string
  data?: PipelineConfig
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelineExecutionDetail {
  correlationId?: string
  data?: PipelineExecutionDetail
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelineExecutionInterrupt {
  correlationId?: string
  data?: PipelineExecutionInterrupt
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelineExecutionNotes {
  correlationId?: string
  data?: PipelineExecutionNotes
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelineExpandedJson {
  correlationId?: string
  data?: PipelineExpandedJson
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelineOpaEvaluationContext {
  correlationId?: string
  data?: PipelineOpaEvaluationContext
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelineSaveResponse {
  correlationId?: string
  data?: PipelineSaveResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelineValidationResponseDTO {
  correlationId?: string
  data?: PipelineValidationResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelineValidationUUIDResponseBody {
  correlationId?: string
  data?: PipelineValidationUUIDResponseBody
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelinesCount {
  correlationId?: string
  data?: PipelinesCount
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePlanExecutionResponseDto {
  correlationId?: string
  data?: PlanExecutionResponseDto
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePmsAbstractStepNode {
  correlationId?: string
  data?: PmsAbstractStepNode
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePollingInfoForTriggers {
  correlationId?: string
  data?: PollingInfoForTriggers
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePreFlightDTO {
  correlationId?: string
  data?: PreFlightDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseResourceConstraintExecutionInfo {
  correlationId?: string
  data?: ResourceConstraintExecutionInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseRetryHistoryResponseDto {
  correlationId?: string
  data?: RetryHistoryResponseDto
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseRetryInfo {
  correlationId?: string
  data?: RetryInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseRetryLatestExecutionResponseDto {
  correlationId?: string
  data?: RetryLatestExecutionResponseDto
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseStepCategory {
  correlationId?: string
  data?: StepCategory
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseString {
  correlationId?: string
  data?: string
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTemplateStageNode {
  correlationId?: string
  data?: TemplateStageNode
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTemplateStepNode {
  correlationId?: string
  data?: TemplateStepNode
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTemplatesResolvedPipelineResponseDTO {
  correlationId?: string
  data?: TemplatesResolvedPipelineResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTriggerCatalogResponse {
  correlationId?: string
  data?: TriggerCatalogResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTriggerUpdateCount {
  correlationId?: string
  data?: TriggerUpdateCount
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseValidateTemplateInputsResponseDTO {
  correlationId?: string
  data?: ValidateTemplateInputsResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseVariableMergeServiceResponse {
  correlationId?: string
  data?: VariableMergeServiceResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseWaitStepExecutionDetailsDto {
  correlationId?: string
  data?: WaitStepExecutionDetailsDto
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseWaitStepResponseDto {
  correlationId?: string
  data?: WaitStepResponseDto
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseWebhookEventProcessingDetails {
  correlationId?: string
  data?: WebhookEventProcessingDetails
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseWebhookExecutionDetails {
  correlationId?: string
  data?: WebhookExecutionDetails
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseYamlDiffResponseDTO {
  correlationId?: string
  data?: YamlDiffResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface RestResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: { [key: string]: any }
  responseMessages?: ResponseMessage[]
}

export interface RestResponseString {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: string
  responseMessages?: ResponseMessage[]
}

export type RestoreCacheGCSStepInfo = StepSpecType & {
  archiveFormat?: 'Tar' | 'Gzip'
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  failIfKeyNotFound?: boolean
  key: string
  resources?: ContainerResource
  runAsUser?: number
  version?: string
}

export type RestoreCacheS3StepInfo = StepSpecType & {
  archiveFormat?: 'Tar' | 'Gzip'
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  endpoint?: string
  failIfKeyNotFound?: boolean
  key: string
  pathStyle?: boolean
  region?: string
  resources?: ContainerResource
  runAsUser?: number
  version?: string
}

export type RetryFailureActionConfig = FailureStrategyActionConfig & {
  spec: RetryFailureSpecConfig
  type: 'Retry'
}

export interface RetryFailureSpecConfig {
  onRetryFailure: OnRetryFailureConfig
  retryCount: number
  retryIntervals: string[]
}

export interface RetryGroup {
  info?: RetryStageInfo[]
}

export interface RetryHistoryResponseDto {
  errorMessage?: string
  executionInfos?: ExecutionInfo[]
  latestExecutionId?: string
  retryStagesMetadata?: RetryStagesMetadataDTO
}

export interface RetryInfo {
  errorMessage?: string
  groups?: RetryGroup[]
  resumable?: boolean
}

export interface RetryInterruptConfig {
  retryId: string
}

export interface RetryLatestExecutionResponseDto {
  errorMessage?: string
  latestExecutionId?: string
}

export type RetrySGFailureActionConfig = FailureStrategyActionConfig & {
  spec: RetryStepGroupFailureSpecConfig
  type: 'RetryStepGroup'
}

export interface RetryStageInfo {
  createdAt?: number
  identifier?: string
  name?: string
  nextId?: string
  parentId?: string
  status?:
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'WaitStepRunning'
    | 'QueuedLicenseLimitReached'
    | 'QueuedExecutionConcurrencyReached'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'InputWaiting'
    | 'AbortedByFreeze'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
}

export interface RetryStagesMetadataDTO {
  retryStagesIdentifier?: string[]
  skipStagesIdentifier?: string[]
}

export interface RetryStepGroupFailureSpecConfig {
  retryCount: number
  retryIntervals: string[]
}

export interface RunStageRequestDTO {
  expressionValues?: {
    [key: string]: string
  }
  runtimeInputYaml?: string
  stageIdentifiers?: string[]
}

export type RunStepInfo = StepSpecType & {
  command: string
  connectorRef?: string
  envVariables?: {
    [key: string]: string
  }
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  reports?: UnitTestReport
  resources?: ContainerResource
  runAsUser?: number
  shell?: 'Sh' | 'Bash' | 'Powershell' | 'Pwsh' | 'Python'
  version?: string
}

export type RunTestsStepInfo = StepSpecType & {
  args?: string
  buildEnvironment?: 'Core' | 'Framework'
  buildTool: 'Maven' | 'Bazel' | 'Gradle' | 'Dotnet' | 'Nunitconsole' | 'SBT' | 'Pytest' | 'Unittest' | 'Rspec'
  connectorRef?: string
  enableTestSplitting?: boolean
  envVariables?: {
    [key: string]: string
  }
  frameworkVersion?: '5.0' | '6.0'
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  language: 'Java' | 'Kotlin' | 'Scala' | 'Csharp' | 'Python' | 'Ruby'
  namespaces?: string
  outputVariables?: OutputNGVariable[]
  packages?: string
  postCommand?: string
  preCommand?: string
  privileged?: boolean
  pythonVersion?: '3' | '2'
  reports?: UnitTestReport
  resources?: ContainerResource
  runAsUser?: number
  runOnlySelectedTests?: boolean
  shell?: 'Sh' | 'Bash' | 'Powershell' | 'Pwsh' | 'Python'
  testAnnotations?: string
  testGlobs?: string
  testRoot?: string
  testSplitStrategy?: 'ClassTiming' | 'TestCount'
  version?: string
}

export type S3BuildStoreTypeSpec = BuildStoreTypeSpec & {
  bucketName?: string
  connectorRef?: string
  folderPath?: string
  region?: string
}

export type SampleErrorMetadataDTO = ErrorMetadataDTO & {
  sampleMap?: {
    [key: string]: string
  }
}

export type SaveCacheGCSStepInfo = StepSpecType & {
  archiveFormat?: 'Tar' | 'Gzip'
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  key: string
  override?: boolean
  resources?: ContainerResource
  runAsUser?: number
  sourcePaths: string[]
  version?: string
}

export type SaveCacheS3StepInfo = StepSpecType & {
  archiveFormat?: 'Tar' | 'Gzip'
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  endpoint?: string
  key: string
  override?: boolean
  pathStyle?: boolean
  region?: string
  resources?: ContainerResource
  runAsUser?: number
  sourcePaths: string[]
  version?: string
}

export interface SbomOrchestrationSpec {
  [key: string]: any
}

export interface SbomOrchestrationTool {
  spec?: SbomOrchestrationSpec
  type: 'Syft'
}

export interface SbomSource {
  spec?: SbomSourceSpec
  type: 'image'
}

export interface SbomSourceSpec {
  [key: string]: any
}

export interface ScheduledDeadline {
  time: ParameterFieldString
  timeZone: ParameterFieldString
}

export interface ScheduledDeadlineDTO {
  time: string
  timeZone: string
}

export type ScheduledTriggerConfig = NGTriggerSpecV2 & {
  spec?: ScheduledTriggerSpec
  type?: string
}

export interface ScheduledTriggerSpec {
  [key: string]: any
}

export type ScmErrorMetadataDTO = ErrorMetadataDTO & {
  conflictCommitId?: string
}

export type ScriptStepInfo = StepSpecType & {
  envs?: {
    [key: string]: string
  }
  image?: string
  outputs?: string[]
  privileged?: boolean
  pull?: 'always' | 'never' | 'if-not-exists'
  resources?: ContainerResource
  run: string
  shell?: 'sh' | 'bash' | 'powershell' | 'pwsh' | 'python'
  user?: number
  version?: string
}

export type SecretNGVariable = NGVariable & {
  default?: string
  name?: string
  type?: 'Secret'
  value: string
}

export type SecretNGVariableV1 = NGVariableV1 & {
  __uuid?: string
  default?: SecretRefData
  value?: ParameterFieldSecretRefData
}

export interface SecretRefData {
  decryptedValue?: string[]
  identifier?: string
  null?: boolean
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export interface SecurityContext {
  allowPrivilegeEscalation?: boolean
  capabilities?: Capabilities
  privileged?: boolean
  procMount?: string
  readOnlyRootFilesystem?: boolean
  runAsGroup?: number
  runAsNonRoot?: boolean
  runAsUser?: number
}

export type SecurityStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  version?: string
}

export interface Serve {
  distribution?: Distribution
  variation?: string
}

export interface ServiceExpressionProperties {
  expression?: string
  serviceName?: string
}

export type ServiceNowApprovalInstanceDetails = ApprovalInstanceDetailsDTO & {
  approvalCriteria: CriteriaSpecWrapperDTO
  changeWindowSpec?: ServiceNowChangeWindowSpec
  connectorRef?: string
  delegateTaskName?: string
  latestDelegateTaskId?: string
  rejectionCriteria?: CriteriaSpecWrapperDTO
  retryInterval?: Timeout
  ticket: ServiceNowTicketKeyNG
}

export type ServiceNowApprovalStepInfo = StepSpecType & {
  approvalCriteria: CriteriaSpecWrapper
  changeWindow?: ServiceNowChangeWindowSpec
  connectorRef: string
  delegateSelectors?: string[]
  rejectionCriteria?: CriteriaSpecWrapper
  retryInterval?: string
  ticketNumber: string
  ticketType: string
}

export interface ServiceNowChangeWindowSpec {
  endField: string
  startField: string
}

export type ServiceNowCreateStepInfo = StepSpecType & {
  connectorRef: string
  createType?: string
  delegateSelectors?: string[]
  fields?: ServiceNowField[]
  templateName?: string
  ticketType: string
  useServiceNowTemplate?: boolean
}

export interface ServiceNowField {
  name: string
  value: string
}

export type ServiceNowImportSetStepInfo = StepSpecType & {
  connectorRef: string
  delegateSelectors?: string[]
  importData: ImportDataSpecWrapper
  stagingTableName: string
}

export interface ServiceNowTicketKeyNG {
  key: string
  ticketFields?: {
    [key: string]: string
  }
  ticketType: string
  url: string
}

export type ServiceNowUpdateStepInfo = StepSpecType & {
  connectorRef: string
  delegateSelectors?: string[]
  fields?: ServiceNowField[]
  templateName?: string
  ticketNumber?: string
  ticketType: string
  updateMultiple?: UpdateMultipleTaskNode
  useServiceNowTemplate: boolean
}

export type SetDefaultVariationsYaml = PatchInstruction & {
  identifier: string
  spec: SetDefaultVariationsYamlSpec
  type: 'SetDefaultVariations'
}

export interface SetDefaultVariationsYamlSpec {
  off: string
  on: string
}

export type SetFeatureFlagStateYaml = PatchInstruction & {
  identifier: string
  spec: SetFeatureFlagStateYamlSpec
  type: 'SetFeatureFlagState'
}

export interface SetFeatureFlagStateYamlSpec {
  state: string
}

export type SetOffVariationYaml = PatchInstruction & {
  identifier: string
  spec: SetOffVariationYamlSpec
  type: 'SetOffVariation'
}

export interface SetOffVariationYamlSpec {
  variation: string
}

export type SetOnVariationYaml = PatchInstruction & {
  identifier: string
  spec: SetOnVariationYamlSpec
  type: 'SetOnVariation'
}

export interface SetOnVariationYamlSpec {
  variation: string
}

export interface ShellScriptBaseSource {
  type?: string
}

export interface ShellScriptBaseSourceV1 {
  type?: string
}

export type ShellScriptInlineSource = ShellScriptBaseSource & {
  script?: string
}

export type ShellScriptInlineSourceV1 = ShellScriptBaseSourceV1 & {
  script?: ParameterFieldString
}

export interface ShellScriptSourceWrapper {
  spec: ShellScriptBaseSource
  type: string
}

export interface ShellScriptSourceWrapperV1 {
  spec?: ShellScriptBaseSourceV1
  type?: string
}

export type ShellScriptStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  environmentVariables?: NGVariable[]
  executionTarget?: ExecutionTarget
  includeInfraSelectors?: boolean
  metadata?: string
  onDelegate: boolean
  outputAlias?: OutputAlias
  outputVariables?: NGVariable[]
  shell: 'Bash' | 'PowerShell'
  source: ShellScriptSourceWrapper
}

export type ShellScriptStepInfoV1 = StepSpecType & {
  delegate?: ParameterFieldListTaskSelectorYaml
  env_vars?: NGVariableV1Wrapper
  execution_target?: ExecutionTargetV1
  include_infra_selectors?: ParameterFieldBoolean
  metadata?: string
  on_delegate?: ParameterFieldBoolean
  output_alias?: OutputAliasV1
  output_vars?: NGVariableV1Wrapper
  shell?: 'bash' | 'power-shell'
  source?: ShellScriptSourceWrapperV1
}

export interface SkipInfo {
  [key: string]: any
}

export interface Sort {
  empty?: boolean
  sorted?: boolean
  unsorted?: boolean
}

export interface SourceIdentifierConfig {
  orgIdentifier?: string
  pipelineIdentifier?: string
  projectIdentifier?: string
}

export interface Splitting {
  concurrency?: number
  enabled?: boolean
  strategy?: 'class_timing' | 'test_count'
}

export interface StackTraceElement {
  classLoaderName?: string
  className?: string
  fileName?: string
  lineNumber?: number
  methodName?: string
  moduleName?: string
  moduleVersion?: string
  nativeMethod?: boolean
}

export interface StageDetail {
  name?: string
}

export interface StageElementConfig {
  delegateSelectors?: string[]
  description?: string
  failureStrategies?: FailureStrategyConfig[]
  identifier: string
  name: string
  skipInstances?: boolean
  spec?: StageInfoConfig
  strategy?: StrategyConfig
  tags?: {
    [key: string]: string
  }
  template?: TemplateLinkConfig
  timeout?: string
  type?: string
  variables?: NGVariable[]
  when?: StageWhenCondition
}

export interface StageElementWrapperConfig {
  parallel?: ParallelStageElementConfig
  stage?: StageElementConfig
}

export interface StageExecutionResponse {
  message?: string
  stageIdentifier?: string
  stageName?: string
  stagesRequired?: string[]
  toBeBlocked?: boolean
}

export interface StageInfoConfig {
  execution?: ExecutionElementConfig
}

export type StageRollbackFailureActionConfig = FailureStrategyActionConfig & {
  type: 'StageRollback'
}

export interface StageWhenCondition {
  condition?: string
  pipelineStatus: 'Success' | 'Failure' | 'All'
}

export interface StepCategory {
  name?: string
  stepCategories?: StepCategory[]
  stepsData?: StepData[]
}

export interface StepData {
  disabled?: boolean
  featureRestrictionName?:
    | 'TEST1'
    | 'TEST2'
    | 'TEST3'
    | 'TEST4'
    | 'TEST5'
    | 'TEST6'
    | 'TEST7'
    | 'PERSPECTIVES'
    | 'CCM_K8S_CLUSTERS'
    | 'CCM_AUTOSTOPPING_RULES'
    | 'MULTIPLE_ORGANIZATIONS'
    | 'MULTIPLE_PROJECTS'
    | 'MULTIPLE_SECRETS'
    | 'MULTIPLE_USER_GROUPS'
    | 'MULTIPLE_USERS'
    | 'MULTIPLE_SERVICE_ACCOUNTS'
    | 'MULTIPLE_VARIABLES'
    | 'MULTIPLE_CONNECTORS'
    | 'MULTIPLE_API_KEYS'
    | 'MULTIPLE_API_TOKENS'
    | 'INTEGRATED_APPROVALS_WITH_HARNESS_UI'
    | 'INTEGRATED_APPROVALS_WITH_CUSTOM_SCRIPT'
    | 'INTEGRATED_APPROVALS_WITH_JIRA'
    | 'SECRET_MANAGERS'
    | 'DEPLOYMENTS'
    | 'INITIAL_DEPLOYMENTS'
    | 'DEPLOYMENTS_PER_MONTH'
    | 'SERVICES'
    | 'BUILDS'
    | 'SAML_SUPPORT'
    | 'OAUTH_SUPPORT'
    | 'LDAP_SUPPORT'
    | 'TWO_FACTOR_AUTH_SUPPORT'
    | 'CUSTOM_ROLES'
    | 'CUSTOM_RESOURCE_GROUPS'
    | 'MAX_TOTAL_BUILDS'
    | 'MAX_BUILDS_PER_MONTH'
    | 'MAX_BUILDS_PER_DAY'
    | 'ACTIVE_COMMITTERS'
    | 'TEST_INTELLIGENCE'
    | 'TEMPLATE_SERVICE'
    | 'CACHE_SIZE_ALLOWANCE'
    | 'SRM_SERVICES'
    | 'ANALYZE_DEPLOYMENT_STEP'
    | 'TERRAFORM_APPLY'
    | 'TERRAFORM_PLAN'
    | 'TERRAFORM_DESTROY'
    | 'TERRAFORM_ROLLBACK'
    | 'INTEGRATED_APPROVALS_WITH_SERVICE_NOW'
    | 'CREATE_STACK'
    | 'DELETE_STACK'
    | 'ROLLBACK_STACK'
    | 'COMMAND'
    | 'AZURE_SLOT_DEPLOYMENT'
    | 'AZURE_TRAFFIC_SHIFT'
    | 'AZURE_SWAP_SLOT'
    | 'AZURE_WEBAPP_ROLLBACK'
    | 'JENKINS_BUILD'
    | 'AZURE_CREATE_ARM_RESOURCE'
    | 'AZURE_CREATE_BP_RESOURCE'
    | 'AZURE_ROLLBACK_ARM_RESOURCE'
    | 'SHELL_SCRIPT_PROVISION'
    | 'TERRAFORM_CLOUD_RUN'
    | 'TERRAFORM_CLOUD_ROLLBACK'
    | 'SECURITY'
    | 'DEVELOPERS'
    | 'MONTHLY_ACTIVE_USERS'
    | 'STRATEGY_MAX_CONCURRENT'
    | 'MAX_PARALLEL_STEP_IN_A_PIPELINE'
    | 'PIPELINE_EXECUTION_DATA_RETENTION_DAYS'
    | 'MAX_PIPELINE_TIMEOUT_SECONDS'
    | 'MAX_STAGE_TIMEOUT_SECONDS'
    | 'MAX_STEP_TIMEOUT_SECONDS'
    | 'MAX_CONCURRENT_ACTIVE_PIPELINE_EXECUTIONS'
    | 'MAX_CHAOS_EXPERIMENT_RUNS_PER_MONTH'
    | 'MAX_CHAOS_INFRASTRUCTURES'
    | 'TERRAGRUNT_PLAN'
    | 'TERRAGRUNT_APPLY'
    | 'TERRAGRUNT_DESTROY'
    | 'TERRAGRUNT_ROLLBACK'
    | 'SEI_MAX_NUMBER_OF_CONTRIBUTORS'
  name?: string
  type?: string
}

export interface StepElementConfig {
  description?: string
  enforce?: PolicyConfig
  failureStrategies?: FailureStrategyConfig[]
  identifier: string
  name: string
  spec?: StepSpecType
  strategy?: StrategyConfig
  timeout?: string
  type: string
  when?: StepWhenCondition
}

export interface StepGroupElementConfig {
  delegateSelectors?: string[]
  failureStrategies?: FailureStrategyConfig[]
  identifier: string
  name: string
  sharedPaths?: string[]
  stepGroupInfra?: StepGroupInfra
  steps?: ExecutionWrapperConfig[]
  strategy?: StrategyConfig
  template?: TemplateLinkConfig
  variables?: NGVariable[]
  when?: StepWhenCondition
}

export type StepGroupFailureActionConfig = FailureStrategyActionConfig & {
  type: 'StepGroupRollback'
}

export interface StepGroupInfra {
  type?: 'KubernetesDirect' | 'Delegate' | 'Noop'
}

export interface StepPalleteFilterWrapper {
  stepPalleteModuleInfos?: StepPalleteModuleInfo[]
}

export interface StepPalleteModuleInfo {
  category?: string
  commonStepCategory?: string
  module?: string
  shouldShowCommonSteps?: boolean
}

export interface StepSpecType {
  [key: string]: any
}

export interface StepWhenCondition {
  condition?: string
  stageStatus: 'Success' | 'Failure' | 'All'
}

export interface StoreSpec {
  [key: string]: any
}

export interface StrategyConfig {
  matrix?: ParameterFieldMatrixConfigInterface
  parallelism?: number
  repeat?: HarnessForConfig
}

export interface StrategyMetadata {
  [key: string]: any
}

export type StringNGVariable = NGVariable & {
  default?: string
  name?: string
  type?: 'String'
  value: string
}

export type StringNGVariableV1 = NGVariableV1 & {
  __uuid?: string
  default?: string
  validator?: StringValidator
  value?: ParameterFieldString
}

export interface StringValidator {
  [key: string]: any
}

export interface SuccessHealthInfo {
  percent?: number
  rate?: number
}

export type SyftSbomOrchestration = SbomOrchestrationSpec & {
  format?: 'spdx-json' | 'cyclonedx-json'
}

export type TagBuildSpec = BuildSpec & {
  tag: string
}

export interface TargetExecutionSummary {
  executionStatus?: string
  planExecutionId?: string
  runSequence?: number
  runtimeInput?: string
  startTs?: number
  targetId?: string
  triggerId?: string
}

export interface TaskSelectorYaml {
  delegateSelectors?: string
  origin?: string
}

export type TemplateFilterProperties = FilterProperties & {
  childTypes?: string[]
  description?: string
  listingScope?: TemplateScope
  repoName?: string
  templateEntityTypes?: (
    | 'Step'
    | 'Stage'
    | 'Pipeline'
    | 'CustomDeployment'
    | 'MonitoredService'
    | 'SecretManager'
    | 'ArtifactSource'
    | 'StepGroup'
  )[]
  templateIdentifiers?: string[]
  templateNames?: string[]
}

export interface TemplateInfo {
  templateEntityType?:
    | 'Step'
    | 'Stage'
    | 'Pipeline'
    | 'CustomDeployment'
    | 'MonitoredService'
    | 'SecretManager'
    | 'ArtifactSource'
    | 'StepGroup'
  templateIdentifier?: string
  versionLabel?: string
}

export interface TemplateInputsErrorDTO {
  fieldName?: string
  identifierOfErrorSource?: string
  message?: string
}

export type TemplateInputsErrorMetadataDTO = ErrorMetadataDTO & {
  errorMap?: {
    [key: string]: TemplateInputsErrorDTO
  }
  errorYaml?: string
}

export interface TemplateLinkConfig {
  gitBranch?: string
  templateInputs?: JsonNode
  templateRef: string
  templateVariables?: JsonNode
  versionLabel?: string
}

export interface TemplateResponse {
  accountId: string
  cacheResponseMetadata?: CacheResponseMetadata
  childType?: string
  connectorRef?: string
  description?: string
  entityValidityDetails?: EntityValidityDetails
  gitDetails?: EntityGitDetails
  icon?: string
  identifier: string
  lastUpdatedAt?: number
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  stableTemplate?: boolean
  storeType?: 'INLINE' | 'REMOTE'
  tags?: {
    [key: string]: string
  }
  templateEntityType?:
    | 'Step'
    | 'Stage'
    | 'Pipeline'
    | 'CustomDeployment'
    | 'MonitoredService'
    | 'SecretManager'
    | 'ArtifactSource'
    | 'StepGroup'
  templateScope?: 'account' | 'org' | 'project' | 'unknown'
  version?: number
  versionLabel?: string
  yaml?: string
  yamlVersion?: string
}

export interface TemplateScope {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface TemplateStageNode {
  description?: string
  identifier: string
  name: string
  template: TemplateLinkConfig
}

export interface TemplateStepNode {
  description?: string
  identifier: string
  name: string
  template: TemplateLinkConfig
}

export interface TemplateValidationResponseDTO {
  exceptionMessage?: string
  validYaml?: boolean
}

export interface TemplatesResolvedPipelineResponseDTO {
  resolvedTemplatesPipelineYaml?: string
  yamlPipeline?: string
}

export type TestStepInfo = StepSpecType & {
  envs?: {
    [key: string]: string
  }
  image?: string
  language?: ParameterFieldTILanguage
  outputs?: string[]
  privileged?: boolean
  pull?: 'always' | 'never' | 'if-not-exists'
  resources?: ContainerResource
  shell?: 'sh' | 'bash' | 'powershell' | 'pwsh' | 'python'
  splitting?: Splitting
  user?: number
  uses?: 'maven' | 'bazel' | 'gradle' | 'dotnet' | 'nunit_console' | 'sbt' | 'pytest' | 'unittest' | 'rspec'
  version?: string
  with?: {
    [key: string]: JsonNode
  }
}

export interface Throwable {
  cause?: Throwable
  localizedMessage?: string
  message?: string
  stackTrace?: StackTraceElement[]
  suppressed?: Throwable[]
}

export interface TimeRange {
  endTime?: number
  startTime?: number
}

export interface Timeout {
  timeoutInMillis?: number
  timeoutString?: string
}

export interface TimeoutIssuer {
  timeoutInstanceId: string
}

export interface Toleration {
  effect?: string
  key?: string
  operator?: string
  tolerationSeconds?: number
  value?: string
}

export interface TotalHealthInfo {
  count?: number
  rate?: number
}

export interface TransitionTo {
  status: string
  transitionName?: string
}

export interface TriggerCatalogItem {
  category: 'Webhook' | 'Artifact' | 'Manifest' | 'Scheduled' | 'MultiRegionArtifact'
  triggerCatalogType: (
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'AwsCodeCommit'
    | 'Custom'
    | 'Gcr'
    | 'Ecr'
    | 'DockerRegistry'
    | 'ArtifactoryRegistry'
    | 'Acr'
    | 'AmazonS3'
    | 'GoogleArtifactRegistry'
    | 'CustomArtifact'
    | 'GithubPackageRegistry'
    | 'Nexus2Registry'
    | 'Nexus3Registry'
    | 'Jenkins'
    | 'AzureArtifacts'
    | 'AmazonMachineImage'
    | 'GoogleCloudStorage'
    | 'Bamboo'
    | 'HelmChart'
    | 'Cron'
  )[]
}

export interface TriggerCatalogResponse {
  catalog: TriggerCatalogItem[]
}

export interface TriggerEventDataCondition {
  key?: string
  operator?:
    | 'In'
    | 'Equals'
    | 'NotEquals'
    | 'NotIn'
    | 'Regex'
    | 'EndsWith'
    | 'StartsWith'
    | 'Contains'
    | 'DoesNotContain'
  value?: string
}

export interface TriggerEventStatus {
  message?: string
  status?: 'SUCCESS' | 'FAILED' | 'SKIPPED'
}

export type TriggerFilterProperties = FilterProperties & {
  triggerIdentifiers?: string[]
  triggerNames?: string[]
  triggerTypes?: ('Webhook' | 'Artifact' | 'Manifest' | 'Scheduled' | 'MultiRegionArtifact')[]
}

export interface TriggerIssuer {
  abortPrevConcurrentExecution: boolean
  triggerRef: string
}

export interface TriggerPayload {
  [key: string]: any
}

export interface TriggerStatus {
  detailMessages?: string[]
  lastPolled?: string[]
  lastPollingUpdate?: number
  pollingSubscriptionStatus?: PollingSubscriptionStatus
  status?: 'SUCCESS' | 'FAILED' | 'UNKNOWN' | 'PENDING'
  validationStatus?: ValidationStatus
  webhookAutoRegistrationStatus?: WebhookAutoRegistrationStatus
  webhookInfo?: WebhookInfo
}

export interface TriggerUpdateCount {
  failureCount?: number
  successCount?: number
}

export interface UnitProgress {
  [key: string]: any
}

export interface UnitTestReport {
  spec?: UnitTestReportSpec
  type?: 'JUnit'
}

export interface UnitTestReportSpec {
  [key: string]: any
}

export interface UpdateMultipleSpec {
  [key: string]: any
}

export interface UpdateMultipleTaskNode {
  spec: UpdateMultipleSpec
  type: 'CHANGE_TASK'
}

export type UpdateRuleYaml = PatchInstruction & {
  identifier: string
  spec: UpdateRuleYamlSpec
  type: 'UpdateRule'
}

export interface UpdateRuleYamlSpec {
  bucketBy: string
  ruleID: string
  serve?: Serve
  variations?: VariationYamlSpec[]
}

export type UploadToArtifactoryStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  connectorRef: string
  resources?: ContainerResource
  runAsUser?: number
  sourcePath: string
  target: string
  version?: string
}

export type UploadToGCSStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  resources?: ContainerResource
  runAsUser?: number
  sourcePath: string
  target?: string
  version?: string
}

export type UploadToS3StepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  endpoint?: string
  region: string
  resources?: ContainerResource
  runAsUser?: number
  sourcePath: string
  stripPrefix?: string
  target?: string
  version?: string
}

export interface UserOpaEvaluationContext {
  email?: string
  name?: string
}

export type ValidatePipelineInputsResponseDTO = ErrorMetadataDTO & {
  errorMap?: {
    [key: string]: {
      [key: string]: string
    }
  }
  validYaml?: boolean
}

export type ValidateTemplateInputsResponseDTO = ErrorMetadataDTO & {
  errorNodeSummary?: ErrorNodeSummary
  validYaml?: boolean
}

export interface ValidateTemplateReconcileResponseDTO {
  reconcileNeeded?: boolean
}

export interface ValidationError {
  error?: string
  fieldId?: string
}

export interface ValidationStatus {
  detailedMessage?: string
  statusResult?: 'SUCCESS' | 'FAILED' | 'UNKNOWN' | 'PENDING'
}

export interface VariableMergeServiceResponse {
  errorResponses?: string[]
  metadataMap?: {
    [key: string]: VariableResponseMapValue
  }
  serviceExpressionPropertiesList?: ServiceExpressionProperties[]
  yaml?: string
}

export interface VariableResponseMapValue {
  yamlExtraProperties?: YamlExtraProperties
  yamlOutputProperties?: YamlOutputProperties
  yamlProperties?: YamlProperties
}

export interface VariationYamlSpec {
  variation: string
  weight: number
}

export interface VerifyAttestation {
  spec?: VerifyAttestationSpec
  type?: 'cosign'
}

export interface VerifyAttestationSpec {
  [key: string]: any
}

export interface WaitStepExecutionDetailsDto {
  createdAt?: number
  duration?: number
  nodeExecutionId?: string
}

export type WaitStepInfo = StepSpecType & {
  duration: string
  metadata?: string
}

export interface WaitStepRequestDto {
  action?: 'MARK_AS_SUCCESS' | 'MARK_AS_FAIL'
}

export interface WaitStepResponseDto {
  status?: boolean
}

export interface WebhookAutoRegistrationStatus {
  detailedMessage?: string
  registrationResult?: 'SUCCESS' | 'FAILED' | 'ERROR' | 'TIMEOUT' | 'UNAVAILABLE'
}

export interface WebhookDetails {
  webhookSecret?: string
  webhookSourceRepo?: string
}

export interface WebhookEventProcessingDetails {
  accountIdentifier?: string
  eventCreatedAt?: number
  eventFound?: boolean
  eventId?: string
  exceptionOccured?: boolean
  message?: string
  orgIdentifier?: string
  payload?: string
  pipelineExecutionId?: string
  pipelineIdentifier?: string
  projectIdentifier?: string
  runtimeInput?: string
  status?: string
  triggerIdentifier?: string
  warningMsg?: string
}

export interface WebhookExecutionDetails {
  executionDetails?: { [key: string]: any }
  webhookProcessingDetails?: WebhookEventProcessingDetails
}

export interface WebhookInfo {
  webhookId?: string
}

export type WebhookTriggerConfigV2 = NGTriggerSpecV2 & {
  spec?: WebhookTriggerSpecV2
  type?: 'AzureRepo' | 'Github' | 'Gitlab' | 'Bitbucket' | 'Custom' | 'AwsCodeCommit' | 'Harness'
}

export interface WebhookTriggerSpecV2 {
  [key: string]: any
}

export interface WeightedVariation {
  variation: string
  weight: number
}

export interface YamlDiffResponseDTO {
  originalYaml?: string
  refreshedYaml?: string
}

export interface YamlExtraProperties {
  [key: string]: any
}

export interface YamlOutputProperties {
  [key: string]: any
}

export interface YamlProperties {
  [key: string]: any
}

export interface YamlSchemaErrorDTO {
  fqn?: string
  hintMessage?: string
  message?: string
  messageWithFQN?: string
  stageInfo?: NodeErrorInfo
  stepInfo?: NodeErrorInfo
}

export type YamlSchemaErrorWrapperDTO = ErrorMetadataDTO & {
  schemaErrors?: YamlSchemaErrorDTO[]
}

export interface ExecutionSummaryInfo {
  deployments?: number[]
  lastExecutionId?: string
  lastExecutionStatus?:
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'WaitStepRunning'
    | 'QueuedLicenseLimitReached'
    | 'QueuedExecutionConcurrencyReached'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'InputWaiting'
    | 'AbortedByFreeze'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
  lastExecutionTs?: number
  numOfErrors?: number[]
}

export type KeyValueCriteriaSpec = CriteriaSpecDTO & {
  conditions: ConditionDTO[]
  matchAnyCondition?: boolean
}

export interface PipelineExecutionInterrupt {
  id?: string
  planExecutionId?: string
  type?:
    | 'AbortAll'
    | 'Abort'
    | 'Pause'
    | 'Resume'
    | 'Ignore'
    | 'StageRollback'
    | 'StepGroupRollback'
    | 'MarkAsSuccess'
    | 'ExpireAll'
    | 'Retry'
    | 'MarkAsFailure'
    | 'UserMarkedFailure'
}

export type FilterDTORequestBody = FilterDTO

export type FilterPropertiesRequestBody = FilterProperties

export type LandingDashboardRequestPMSRequestBody = LandingDashboardRequestPMS

export type MergeInputSetRequestRequestBody = MergeInputSetRequest

export type RunStageRequestDTORequestBody = RunStageRequestDTO

export type GetExpressionEvaluatedBodyRequestBody = string

export type UpdateTriggerBodyRequestBody = string

export interface GetInitialStageYamlSnippetQueryParams {
  approvalType: 'HarnessApproval' | 'JiraApproval' | 'CustomApproval' | 'ServiceNowApproval'
  routingId?: string
}

export type GetInitialStageYamlSnippetProps = Omit<
  GetProps<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>,
  'path'
>

/**
 * Gets the initial yaml snippet for Approval stage
 */
export const GetInitialStageYamlSnippet = (props: GetInitialStageYamlSnippetProps) => (
  <Get<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>
    path={`/approvals/stage-yaml-snippet`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetInitialStageYamlSnippetProps = Omit<
  UseGetProps<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>,
  'path'
>

/**
 * Gets the initial yaml snippet for Approval stage
 */
export const useGetInitialStageYamlSnippet = (props: UseGetInitialStageYamlSnippetProps) =>
  useGet<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>(
    `/approvals/stage-yaml-snippet`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Gets the initial yaml snippet for Approval stage
 */
export const getInitialStageYamlSnippetPromise = (
  props: GetUsingFetchProps<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, Failure | Error, GetInitialStageYamlSnippetQueryParams, void>(
    getConfig('pipeline/api'),
    `/approvals/stage-yaml-snippet`,
    props,
    signal
  )

export interface GetApprovalInstanceQueryParams {
  accountIdentifier?: string
}

export interface GetApprovalInstancePathParams {
  approvalInstanceId: string
}

export type GetApprovalInstanceProps = Omit<
  GetProps<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    GetApprovalInstanceQueryParams,
    GetApprovalInstancePathParams
  >,
  'path'
> &
  GetApprovalInstancePathParams

/**
 * Gets an Approval Instance by identifier
 */
export const GetApprovalInstance = ({ approvalInstanceId, ...props }: GetApprovalInstanceProps) => (
  <Get<ResponseApprovalInstanceResponse, Failure | Error, GetApprovalInstanceQueryParams, GetApprovalInstancePathParams>
    path={`/approvals/${approvalInstanceId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetApprovalInstanceProps = Omit<
  UseGetProps<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    GetApprovalInstanceQueryParams,
    GetApprovalInstancePathParams
  >,
  'path'
> &
  GetApprovalInstancePathParams

/**
 * Gets an Approval Instance by identifier
 */
export const useGetApprovalInstance = ({ approvalInstanceId, ...props }: UseGetApprovalInstanceProps) =>
  useGet<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    GetApprovalInstanceQueryParams,
    GetApprovalInstancePathParams
  >((paramsInPath: GetApprovalInstancePathParams) => `/approvals/${paramsInPath.approvalInstanceId}`, {
    base: getConfig('pipeline/api'),
    pathParams: { approvalInstanceId },
    ...props
  })

/**
 * Gets an Approval Instance by identifier
 */
export const getApprovalInstancePromise = (
  {
    approvalInstanceId,
    ...props
  }: GetUsingFetchProps<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    GetApprovalInstanceQueryParams,
    GetApprovalInstancePathParams
  > & { approvalInstanceId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    GetApprovalInstanceQueryParams,
    GetApprovalInstancePathParams
  >(getConfig('pipeline/api'), `/approvals/${approvalInstanceId}`, props, signal)

export interface AddHarnessApprovalActivityQueryParams {
  accountIdentifier?: string
}

export interface AddHarnessApprovalActivityPathParams {
  approvalInstanceId: string
}

export type AddHarnessApprovalActivityProps = Omit<
  MutateProps<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    AddHarnessApprovalActivityQueryParams,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  >,
  'path' | 'verb'
> &
  AddHarnessApprovalActivityPathParams

/**
 * Approve or Reject a Pipeline Execution
 */
export const AddHarnessApprovalActivity = ({ approvalInstanceId, ...props }: AddHarnessApprovalActivityProps) => (
  <Mutate<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    AddHarnessApprovalActivityQueryParams,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  >
    verb="POST"
    path={`/approvals/${approvalInstanceId}/harness/activity`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseAddHarnessApprovalActivityProps = Omit<
  UseMutateProps<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    AddHarnessApprovalActivityQueryParams,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  >,
  'path' | 'verb'
> &
  AddHarnessApprovalActivityPathParams

/**
 * Approve or Reject a Pipeline Execution
 */
export const useAddHarnessApprovalActivity = ({ approvalInstanceId, ...props }: UseAddHarnessApprovalActivityProps) =>
  useMutate<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    AddHarnessApprovalActivityQueryParams,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  >(
    'POST',
    (paramsInPath: AddHarnessApprovalActivityPathParams) =>
      `/approvals/${paramsInPath.approvalInstanceId}/harness/activity`,
    { base: getConfig('pipeline/api'), pathParams: { approvalInstanceId }, ...props }
  )

/**
 * Approve or Reject a Pipeline Execution
 */
export const addHarnessApprovalActivityPromise = (
  {
    approvalInstanceId,
    ...props
  }: MutateUsingFetchProps<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    AddHarnessApprovalActivityQueryParams,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  > & { approvalInstanceId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseApprovalInstanceResponse,
    Failure | Error,
    AddHarnessApprovalActivityQueryParams,
    HarnessApprovalActivityRequest,
    AddHarnessApprovalActivityPathParams
  >('POST', getConfig('pipeline/api'), `/approvals/${approvalInstanceId}/harness/activity`, props, signal)

export interface GetHarnessApprovalInstanceAuthorizationPathParams {
  approvalInstanceId: string
}

export type GetHarnessApprovalInstanceAuthorizationProps = Omit<
  GetProps<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  >,
  'path'
> &
  GetHarnessApprovalInstanceAuthorizationPathParams

/**
 * Gets a Harness Approval Instance authorization for the current user
 */
export const GetHarnessApprovalInstanceAuthorization = ({
  approvalInstanceId,
  ...props
}: GetHarnessApprovalInstanceAuthorizationProps) => (
  <Get<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  >
    path={`/approvals/${approvalInstanceId}/harness/authorization`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetHarnessApprovalInstanceAuthorizationProps = Omit<
  UseGetProps<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  >,
  'path'
> &
  GetHarnessApprovalInstanceAuthorizationPathParams

/**
 * Gets a Harness Approval Instance authorization for the current user
 */
export const useGetHarnessApprovalInstanceAuthorization = ({
  approvalInstanceId,
  ...props
}: UseGetHarnessApprovalInstanceAuthorizationProps) =>
  useGet<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  >(
    (paramsInPath: GetHarnessApprovalInstanceAuthorizationPathParams) =>
      `/approvals/${paramsInPath.approvalInstanceId}/harness/authorization`,
    { base: getConfig('pipeline/api'), pathParams: { approvalInstanceId }, ...props }
  )

/**
 * Gets a Harness Approval Instance authorization for the current user
 */
export const getHarnessApprovalInstanceAuthorizationPromise = (
  {
    approvalInstanceId,
    ...props
  }: GetUsingFetchProps<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  > & { approvalInstanceId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseHarnessApprovalInstanceAuthorization,
    Failure | Error,
    void,
    GetHarnessApprovalInstanceAuthorizationPathParams
  >(getConfig('pipeline/api'), `/approvals/${approvalInstanceId}/harness/authorization`, props, signal)

export interface GetBarriersExecutionInfoQueryParams {
  stageSetupId: string
  planExecutionId: string
}

export type GetBarriersExecutionInfoProps = Omit<
  GetProps<ResponseListBarrierExecutionInfo, Failure | Error, GetBarriersExecutionInfoQueryParams, void>,
  'path'
>

/**
 * Gets barriers execution info list
 */
export const GetBarriersExecutionInfo = (props: GetBarriersExecutionInfoProps) => (
  <Get<ResponseListBarrierExecutionInfo, Failure | Error, GetBarriersExecutionInfoQueryParams, void>
    path={`/barriers/executionInfo`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetBarriersExecutionInfoProps = Omit<
  UseGetProps<ResponseListBarrierExecutionInfo, Failure | Error, GetBarriersExecutionInfoQueryParams, void>,
  'path'
>

/**
 * Gets barriers execution info list
 */
export const useGetBarriersExecutionInfo = (props: UseGetBarriersExecutionInfoProps) =>
  useGet<ResponseListBarrierExecutionInfo, Failure | Error, GetBarriersExecutionInfoQueryParams, void>(
    `/barriers/executionInfo`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Gets barriers execution info list
 */
export const getBarriersExecutionInfoPromise = (
  props: GetUsingFetchProps<
    ResponseListBarrierExecutionInfo,
    Failure | Error,
    GetBarriersExecutionInfoQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListBarrierExecutionInfo, Failure | Error, GetBarriersExecutionInfoQueryParams, void>(
    getConfig('pipeline/api'),
    `/barriers/executionInfo`,
    props,
    signal
  )

export interface GetBarrierInfoQueryParams {
  barrierSetupId: string
  planExecutionId: string
}

export type GetBarrierInfoProps = Omit<
  GetProps<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>,
  'path'
>

/**
 * Gets barriers info
 */
export const GetBarrierInfo = (props: GetBarrierInfoProps) => (
  <Get<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>
    path={`/barriers/info`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetBarrierInfoProps = Omit<
  UseGetProps<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>,
  'path'
>

/**
 * Gets barriers info
 */
export const useGetBarrierInfo = (props: UseGetBarrierInfoProps) =>
  useGet<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>(`/barriers/info`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Gets barriers info
 */
export const getBarrierInfoPromise = (
  props: GetUsingFetchProps<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBarrierInfo, Failure | Error, GetBarrierInfoQueryParams, void>(
    getConfig('pipeline/api'),
    `/barriers/info`,
    props,
    signal
  )

export type GetBarriersSetupInfoListProps = Omit<
  MutateProps<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>,
  'path' | 'verb'
>

/**
 * Gets barriers setup info list
 */
export const GetBarriersSetupInfoList = (props: GetBarriersSetupInfoListProps) => (
  <Mutate<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>
    verb="PUT"
    path={`/barriers/setupInfo`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetBarriersSetupInfoListProps = Omit<
  UseMutateProps<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>,
  'path' | 'verb'
>

/**
 * Gets barriers setup info list
 */
export const useGetBarriersSetupInfoList = (props: UseGetBarriersSetupInfoListProps) =>
  useMutate<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>('PUT', `/barriers/setupInfo`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Gets barriers setup info list
 */
export const getBarriersSetupInfoListPromise = (
  props: MutateUsingFetchProps<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseListBarrierSetupInfo, Failure | Error, void, void, void>(
    'PUT',
    getConfig('pipeline/api'),
    `/barriers/setupInfo`,
    props,
    signal
  )

export interface GetPipelineDashboardExecutionQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  moduleInfo?: string
  startTime: number
  endTime: number
}

export type GetPipelineDashboardExecutionProps = Omit<
  GetProps<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineDashboardExecutionQueryParams, void>,
  'path'
>

/**
 * Get pipeline dashboard Execution
 */
export const GetPipelineDashboardExecution = (props: GetPipelineDashboardExecutionProps) => (
  <Get<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineDashboardExecutionQueryParams, void>
    path={`/dashboard/pipelineExecution`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineDashboardExecutionProps = Omit<
  UseGetProps<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineDashboardExecutionQueryParams, void>,
  'path'
>

/**
 * Get pipeline dashboard Execution
 */
export const useGetPipelineDashboardExecution = (props: UseGetPipelineDashboardExecutionProps) =>
  useGet<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineDashboardExecutionQueryParams, void>(
    `/dashboard/pipelineExecution`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Get pipeline dashboard Execution
 */
export const getPipelineDashboardExecutionPromise = (
  props: GetUsingFetchProps<
    ResponseDashboardPipelineExecutionInfo,
    Failure | Error,
    GetPipelineDashboardExecutionQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseDashboardPipelineExecutionInfo,
    Failure | Error,
    GetPipelineDashboardExecutionQueryParams,
    void
  >(getConfig('pipeline/api'), `/dashboard/pipelineExecution`, props, signal)

export interface FetchPipelineHealthQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  moduleInfo?: string
  startTime: number
  endTime: number
}

export type FetchPipelineHealthProps = Omit<
  GetProps<ResponseDashboardPipelineHealthInfo, Failure | Error, FetchPipelineHealthQueryParams, void>,
  'path'
>

/**
 * Get pipeline health
 */
export const FetchPipelineHealth = (props: FetchPipelineHealthProps) => (
  <Get<ResponseDashboardPipelineHealthInfo, Failure | Error, FetchPipelineHealthQueryParams, void>
    path={`/dashboard/pipelineHealth`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseFetchPipelineHealthProps = Omit<
  UseGetProps<ResponseDashboardPipelineHealthInfo, Failure | Error, FetchPipelineHealthQueryParams, void>,
  'path'
>

/**
 * Get pipeline health
 */
export const useFetchPipelineHealth = (props: UseFetchPipelineHealthProps) =>
  useGet<ResponseDashboardPipelineHealthInfo, Failure | Error, FetchPipelineHealthQueryParams, void>(
    `/dashboard/pipelineHealth`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Get pipeline health
 */
export const fetchPipelineHealthPromise = (
  props: GetUsingFetchProps<ResponseDashboardPipelineHealthInfo, Failure | Error, FetchPipelineHealthQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDashboardPipelineHealthInfo, Failure | Error, FetchPipelineHealthQueryParams, void>(
    getConfig('pipeline/api'),
    `/dashboard/pipelineHealth`,
    props,
    signal
  )

export interface FetchExpressionUsagesQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  category?: 'ANY' | 'WHEN_CONDITION' | 'VARIABLE_VALUE' | 'COMMON_FIELD_VALUE'
}

export type FetchExpressionUsagesProps = Omit<
  GetProps<ResponseExpressionUsagesDTO, Failure | Error, FetchExpressionUsagesQueryParams, void>,
  'path'
>

/**
 * Fetch the expression usages for an account
 */
export const FetchExpressionUsages = (props: FetchExpressionUsagesProps) => (
  <Get<ResponseExpressionUsagesDTO, Failure | Error, FetchExpressionUsagesQueryParams, void>
    path={`/expression-usages`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseFetchExpressionUsagesProps = Omit<
  UseGetProps<ResponseExpressionUsagesDTO, Failure | Error, FetchExpressionUsagesQueryParams, void>,
  'path'
>

/**
 * Fetch the expression usages for an account
 */
export const useFetchExpressionUsages = (props: UseFetchExpressionUsagesProps) =>
  useGet<ResponseExpressionUsagesDTO, Failure | Error, FetchExpressionUsagesQueryParams, void>(`/expression-usages`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Fetch the expression usages for an account
 */
export const fetchExpressionUsagesPromise = (
  props: GetUsingFetchProps<ResponseExpressionUsagesDTO, Failure | Error, FetchExpressionUsagesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseExpressionUsagesDTO, Failure | Error, FetchExpressionUsagesQueryParams, void>(
    getConfig('pipeline/api'),
    `/expression-usages`,
    props,
    signal
  )

export interface GetFilterListQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
    | 'Trigger'
    | 'EnvironmentGroup'
    | 'FileStore'
    | 'CCMRecommendation'
    | 'Anomaly'
    | 'Environment'
    | 'RuleExecution'
    | 'Override'
    | 'InputSet'
}

export type GetFilterListProps = Omit<
  GetProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  'path'
>

/**
 * Get Filter
 */
export const GetFilterList = (props: GetFilterListProps) => (
  <Get<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>
    path={`/filters`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetFilterListProps = Omit<
  UseGetProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  'path'
>

/**
 * Get Filter
 */
export const useGetFilterList = (props: UseGetFilterListProps) =>
  useGet<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>(`/filters`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Filter
 */
export const getFilterListPromise = (
  props: GetUsingFetchProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>(
    getConfig('pipeline/api'),
    `/filters`,
    props,
    signal
  )

export interface PostFilterQueryParams {
  accountIdentifier: string
}

export type PostFilterProps = Omit<
  MutateProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Filter
 */
export const PostFilter = (props: PostFilterProps) => (
  <Mutate<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>
    verb="POST"
    path={`/filters`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePostFilterProps = Omit<
  UseMutateProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Filter
 */
export const usePostFilter = (props: UsePostFilterProps) =>
  useMutate<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>('POST', `/filters`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Create a Filter
 */
export const postFilterPromise = (
  props: MutateUsingFetchProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>(
    'POST',
    getConfig('pipeline/api'),
    `/filters`,
    props,
    signal
  )

export interface UpdateFilterQueryParams {
  accountIdentifier: string
}

export type UpdateFilterProps = Omit<
  MutateProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Filter
 */
export const UpdateFilter = (props: UpdateFilterProps) => (
  <Mutate<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>
    verb="PUT"
    path={`/filters`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateFilterProps = Omit<
  UseMutateProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Filter
 */
export const useUpdateFilter = (props: UseUpdateFilterProps) =>
  useMutate<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>(
    'PUT',
    `/filters`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Update a Filter
 */
export const updateFilterPromise = (
  props: MutateUsingFetchProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>(
    'PUT',
    getConfig('pipeline/api'),
    `/filters`,
    props,
    signal
  )

export interface DeleteFilterQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
    | 'Trigger'
    | 'EnvironmentGroup'
    | 'FileStore'
    | 'CCMRecommendation'
    | 'Anomaly'
    | 'Environment'
    | 'RuleExecution'
    | 'Override'
    | 'InputSet'
}

export type DeleteFilterProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a filter
 */
export const DeleteFilter = (props: DeleteFilterProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>
    verb="DELETE"
    path={`/filters`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDeleteFilterProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a filter
 */
export const useDeleteFilter = (props: UseDeleteFilterProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>('DELETE', `/filters`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Delete a filter
 */
export const deleteFilterPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>(
    'DELETE',
    getConfig('pipeline/api'),
    `/filters`,
    props,
    signal
  )

export interface GetFilterQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
    | 'Trigger'
    | 'EnvironmentGroup'
    | 'FileStore'
    | 'CCMRecommendation'
    | 'Anomaly'
    | 'Environment'
    | 'RuleExecution'
    | 'Override'
    | 'InputSet'
}

export interface GetFilterPathParams {
  identifier: string
}

export type GetFilterProps = Omit<
  GetProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>,
  'path'
> &
  GetFilterPathParams

/**
 * Get Filter
 */
export const GetFilter = ({ identifier, ...props }: GetFilterProps) => (
  <Get<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>
    path={`/filters/${identifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetFilterProps = Omit<
  UseGetProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>,
  'path'
> &
  GetFilterPathParams

/**
 * Get Filter
 */
export const useGetFilter = ({ identifier, ...props }: UseGetFilterProps) =>
  useGet<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>(
    (paramsInPath: GetFilterPathParams) => `/filters/${paramsInPath.identifier}`,
    { base: getConfig('pipeline/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Filter
 */
export const getFilterPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>(
    getConfig('pipeline/api'),
    `/filters/${identifier}`,
    props,
    signal
  )

export type Get1Props = Omit<GetProps<RestResponseString, unknown, void, void>, 'path'>

export const Get1 = (props: Get1Props) => (
  <Get<RestResponseString, unknown, void, void> path={`/health`} base={getConfig('pipeline/api')} {...props} />
)

export type UseGet1Props = Omit<UseGetProps<RestResponseString, unknown, void, void>, 'path'>

export const useGet1 = (props: UseGet1Props) =>
  useGet<RestResponseString, unknown, void, void>(`/health`, { base: getConfig('pipeline/api'), ...props })

export const get1Promise = (
  props: GetUsingFetchProps<RestResponseString, unknown, void, void>,
  signal?: RequestInit['signal']
) => getUsingFetch<RestResponseString, unknown, void, void>(getConfig('pipeline/api'), `/health`, props, signal)

export type DoLivenessCheck1Props = Omit<GetProps<RestResponseString, unknown, void, void>, 'path'>

export const DoLivenessCheck1 = (props: DoLivenessCheck1Props) => (
  <Get<RestResponseString, unknown, void, void> path={`/health/liveness`} base={getConfig('pipeline/api')} {...props} />
)

export type UseDoLivenessCheck1Props = Omit<UseGetProps<RestResponseString, unknown, void, void>, 'path'>

export const useDoLivenessCheck1 = (props: UseDoLivenessCheck1Props) =>
  useGet<RestResponseString, unknown, void, void>(`/health/liveness`, { base: getConfig('pipeline/api'), ...props })

export const doLivenessCheck1Promise = (
  props: GetUsingFetchProps<RestResponseString, unknown, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseString, unknown, void, void>(getConfig('pipeline/api'), `/health/liveness`, props, signal)

export interface GetInputSetsListForPipelineQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  inputSetType?: 'ALL' | 'INPUT_SET' | 'OVERLAY_INPUT_SET'
  searchTerm?: string
  sortOrders?: string[]
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetInputSetsListForPipelineProps = Omit<
  GetProps<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>,
  'path'
>

/**
 * Gets InputSets list for a pipeline
 */
export const GetInputSetsListForPipeline = (props: GetInputSetsListForPipelineProps) => (
  <Get<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>
    path={`/inputSets`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetInputSetsListForPipelineProps = Omit<
  UseGetProps<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>,
  'path'
>

/**
 * Gets InputSets list for a pipeline
 */
export const useGetInputSetsListForPipeline = (props: UseGetInputSetsListForPipelineProps) =>
  useGet<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>(
    `/inputSets`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Gets InputSets list for a pipeline
 */
export const getInputSetsListForPipelinePromise = (
  props: GetUsingFetchProps<
    ResponsePageInputSetSummaryResponse,
    Failure | Error,
    GetInputSetsListForPipelineQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageInputSetSummaryResponse, Failure | Error, GetInputSetsListForPipelineQueryParams, void>(
    getConfig('pipeline/api'),
    `/inputSets`,
    props,
    signal
  )

export interface CreateInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  pipelineBranch?: string
  pipelineRepoID?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  repoName?: string
}

export type CreateInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an InputSet For Pipeline
 */
export const CreateInputSetForPipeline = (props: CreateInputSetForPipelineProps) => (
  <Mutate<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >
    verb="POST"
    path={`/inputSets`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreateInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an InputSet For Pipeline
 */
export const useCreateInputSetForPipeline = (props: UseCreateInputSetForPipelineProps) =>
  useMutate<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >('POST', `/inputSets`, { base: getConfig('pipeline/api'), ...props })

/**
 * Create an InputSet For Pipeline
 */
export const createInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInputSetResponse,
    Failure | Error,
    CreateInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/inputSets`, props, signal)

export interface ImportInputSetQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  connectorRef?: string
  repoName?: string
  branch?: string
  filePath?: string
  isForceImport?: boolean
}

export interface ImportInputSetPathParams {
  inputSetIdentifier: string
}

export type ImportInputSetProps = Omit<
  MutateProps<
    ResponseInputSetImportResponseDTO,
    Failure | Error,
    ImportInputSetQueryParams,
    InputSetImportRequestDTO,
    ImportInputSetPathParams
  >,
  'path' | 'verb'
> &
  ImportInputSetPathParams

/**
 * Get Input Set YAML from Git Repository
 */
export const ImportInputSet = ({ inputSetIdentifier, ...props }: ImportInputSetProps) => (
  <Mutate<
    ResponseInputSetImportResponseDTO,
    Failure | Error,
    ImportInputSetQueryParams,
    InputSetImportRequestDTO,
    ImportInputSetPathParams
  >
    verb="POST"
    path={`/inputSets/import/${inputSetIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseImportInputSetProps = Omit<
  UseMutateProps<
    ResponseInputSetImportResponseDTO,
    Failure | Error,
    ImportInputSetQueryParams,
    InputSetImportRequestDTO,
    ImportInputSetPathParams
  >,
  'path' | 'verb'
> &
  ImportInputSetPathParams

/**
 * Get Input Set YAML from Git Repository
 */
export const useImportInputSet = ({ inputSetIdentifier, ...props }: UseImportInputSetProps) =>
  useMutate<
    ResponseInputSetImportResponseDTO,
    Failure | Error,
    ImportInputSetQueryParams,
    InputSetImportRequestDTO,
    ImportInputSetPathParams
  >('POST', (paramsInPath: ImportInputSetPathParams) => `/inputSets/import/${paramsInPath.inputSetIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { inputSetIdentifier },
    ...props
  })

/**
 * Get Input Set YAML from Git Repository
 */
export const importInputSetPromise = (
  {
    inputSetIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseInputSetImportResponseDTO,
    Failure | Error,
    ImportInputSetQueryParams,
    InputSetImportRequestDTO,
    ImportInputSetPathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInputSetImportResponseDTO,
    Failure | Error,
    ImportInputSetQueryParams,
    InputSetImportRequestDTO,
    ImportInputSetPathParams
  >('POST', getConfig('pipeline/api'), `/inputSets/import/${inputSetIdentifier}`, props, signal)

export interface GetInputSetsListForProjectQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  inputSetType?: 'ALL' | 'INPUT_SET' | 'OVERLAY_INPUT_SET'
  searchTerm?: string
  sortOrders?: string[]
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetInputSetsListForProjectProps = Omit<
  MutateProps<
    ResponsePageInputSetListResponse,
    Failure | Error,
    GetInputSetsListForProjectQueryParams,
    InputSetFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets InputSets list for a project
 */
export const GetInputSetsListForProject = (props: GetInputSetsListForProjectProps) => (
  <Mutate<
    ResponsePageInputSetListResponse,
    Failure | Error,
    GetInputSetsListForProjectQueryParams,
    InputSetFilterProperties,
    void
  >
    verb="POST"
    path={`/inputSets/list`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetInputSetsListForProjectProps = Omit<
  UseMutateProps<
    ResponsePageInputSetListResponse,
    Failure | Error,
    GetInputSetsListForProjectQueryParams,
    InputSetFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets InputSets list for a project
 */
export const useGetInputSetsListForProject = (props: UseGetInputSetsListForProjectProps) =>
  useMutate<
    ResponsePageInputSetListResponse,
    Failure | Error,
    GetInputSetsListForProjectQueryParams,
    InputSetFilterProperties,
    void
  >('POST', `/inputSets/list`, { base: getConfig('pipeline/api'), ...props })

/**
 * Gets InputSets list for a project
 */
export const getInputSetsListForProjectPromise = (
  props: MutateUsingFetchProps<
    ResponsePageInputSetListResponse,
    Failure | Error,
    GetInputSetsListForProjectQueryParams,
    InputSetFilterProperties,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageInputSetListResponse,
    Failure | Error,
    GetInputSetsListForProjectQueryParams,
    InputSetFilterProperties,
    void
  >('POST', getConfig('pipeline/api'), `/inputSets/list`, props, signal)

export interface GetInputSetRepositoryListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export type GetInputSetRepositoryListProps = Omit<
  GetProps<ResponsePMSInputSetListRepoResponse, Failure | Error, GetInputSetRepositoryListQueryParams, void>,
  'path'
>

/**
 * Gets InputSet Repository list
 */
export const GetInputSetRepositoryList = (props: GetInputSetRepositoryListProps) => (
  <Get<ResponsePMSInputSetListRepoResponse, Failure | Error, GetInputSetRepositoryListQueryParams, void>
    path={`/inputSets/list-repos`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetInputSetRepositoryListProps = Omit<
  UseGetProps<ResponsePMSInputSetListRepoResponse, Failure | Error, GetInputSetRepositoryListQueryParams, void>,
  'path'
>

/**
 * Gets InputSet Repository list
 */
export const useGetInputSetRepositoryList = (props: UseGetInputSetRepositoryListProps) =>
  useGet<ResponsePMSInputSetListRepoResponse, Failure | Error, GetInputSetRepositoryListQueryParams, void>(
    `/inputSets/list-repos`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Gets InputSet Repository list
 */
export const getInputSetRepositoryListPromise = (
  props: GetUsingFetchProps<
    ResponsePMSInputSetListRepoResponse,
    Failure | Error,
    GetInputSetRepositoryListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePMSInputSetListRepoResponse, Failure | Error, GetInputSetRepositoryListQueryParams, void>(
    getConfig('pipeline/api'),
    `/inputSets/list-repos`,
    props,
    signal
  )

export interface GetMergeInputSetFromPipelineTemplateWithListInputQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  pipelineBranch?: string
  pipelineRepoID?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetMergeInputSetFromPipelineTemplateWithListInputProps = Omit<
  MutateProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Merges given Input Sets list on pipeline and return Input Set template format of applied pipeline
 */
export const GetMergeInputSetFromPipelineTemplateWithListInput = (
  props: GetMergeInputSetFromPipelineTemplateWithListInputProps
) => (
  <Mutate<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >
    verb="POST"
    path={`/inputSets/merge`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetMergeInputSetFromPipelineTemplateWithListInputProps = Omit<
  UseMutateProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Merges given Input Sets list on pipeline and return Input Set template format of applied pipeline
 */
export const useGetMergeInputSetFromPipelineTemplateWithListInput = (
  props: UseGetMergeInputSetFromPipelineTemplateWithListInputProps
) =>
  useMutate<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >('POST', `/inputSets/merge`, { base: getConfig('pipeline/api'), ...props })

/**
 * Merges given Input Sets list on pipeline and return Input Set template format of applied pipeline
 */
export const getMergeInputSetFromPipelineTemplateWithListInputPromise = (
  props: MutateUsingFetchProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateWithListInputQueryParams,
    MergeInputSetRequestRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/inputSets/merge`, props, signal)

export interface GetMergeInputSetForRunQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  pipelineBranch?: string
  pipelineRepoID?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetMergeInputSetForRunProps = Omit<
  MutateProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetForRunQueryParams,
    MergeInputSetForRerunRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Merges runtime input YAML from the given planExecutionId and return Input Set template format of applied pipeline
 */
export const GetMergeInputSetForRun = (props: GetMergeInputSetForRunProps) => (
  <Mutate<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetForRunQueryParams,
    MergeInputSetForRerunRequest,
    void
  >
    verb="POST"
    path={`/inputSets/merge-for-rerun`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetMergeInputSetForRunProps = Omit<
  UseMutateProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetForRunQueryParams,
    MergeInputSetForRerunRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Merges runtime input YAML from the given planExecutionId and return Input Set template format of applied pipeline
 */
export const useGetMergeInputSetForRun = (props: UseGetMergeInputSetForRunProps) =>
  useMutate<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetForRunQueryParams,
    MergeInputSetForRerunRequest,
    void
  >('POST', `/inputSets/merge-for-rerun`, { base: getConfig('pipeline/api'), ...props })

/**
 * Merges runtime input YAML from the given planExecutionId and return Input Set template format of applied pipeline
 */
export const getMergeInputSetForRunPromise = (
  props: MutateUsingFetchProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetForRunQueryParams,
    MergeInputSetForRerunRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetForRunQueryParams,
    MergeInputSetForRerunRequest,
    void
  >('POST', getConfig('pipeline/api'), `/inputSets/merge-for-rerun`, props, signal)

export interface GetMergeInputForExecutionQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  resolveExpressions?: boolean
  resolveExpressionsType?: 'RESOLVE_ALL_EXPRESSIONS' | 'RESOLVE_TRIGGER_EXPRESSIONS' | 'UNKNOWN'
  planExecutionId: string
}

export type GetMergeInputForExecutionProps = Omit<
  MutateProps<ResponseMergeInputSetResponse, Failure | Error, GetMergeInputForExecutionQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Merges pipeline template and input set yaml of pipeline execution for given planExecutionId
 */
export const GetMergeInputForExecution = (props: GetMergeInputForExecutionProps) => (
  <Mutate<ResponseMergeInputSetResponse, Failure | Error, GetMergeInputForExecutionQueryParams, void, void>
    verb="POST"
    path={`/inputSets/merge-input-for-execution`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetMergeInputForExecutionProps = Omit<
  UseMutateProps<ResponseMergeInputSetResponse, Failure | Error, GetMergeInputForExecutionQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Merges pipeline template and input set yaml of pipeline execution for given planExecutionId
 */
export const useGetMergeInputForExecution = (props: UseGetMergeInputForExecutionProps) =>
  useMutate<ResponseMergeInputSetResponse, Failure | Error, GetMergeInputForExecutionQueryParams, void, void>(
    'POST',
    `/inputSets/merge-input-for-execution`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Merges pipeline template and input set yaml of pipeline execution for given planExecutionId
 */
export const getMergeInputForExecutionPromise = (
  props: MutateUsingFetchProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputForExecutionQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseMergeInputSetResponse, Failure | Error, GetMergeInputForExecutionQueryParams, void, void>(
    'POST',
    getConfig('pipeline/api'),
    `/inputSets/merge-input-for-execution`,
    props,
    signal
  )

export interface GetMergeInputSetFromPipelineTemplateQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  pipelineBranch?: string
  pipelineRepoID?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetMergeInputSetFromPipelineTemplateProps = Omit<
  MutateProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateQueryParams,
    MergeInputSetTemplateRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Merges given runtime input YAML on pipeline and return Input Set template format of applied pipeline
 */
export const GetMergeInputSetFromPipelineTemplate = (props: GetMergeInputSetFromPipelineTemplateProps) => (
  <Mutate<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateQueryParams,
    MergeInputSetTemplateRequest,
    void
  >
    verb="POST"
    path={`/inputSets/mergeWithTemplateYaml`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetMergeInputSetFromPipelineTemplateProps = Omit<
  UseMutateProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateQueryParams,
    MergeInputSetTemplateRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Merges given runtime input YAML on pipeline and return Input Set template format of applied pipeline
 */
export const useGetMergeInputSetFromPipelineTemplate = (props: UseGetMergeInputSetFromPipelineTemplateProps) =>
  useMutate<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateQueryParams,
    MergeInputSetTemplateRequest,
    void
  >('POST', `/inputSets/mergeWithTemplateYaml`, { base: getConfig('pipeline/api'), ...props })

/**
 * Merges given runtime input YAML on pipeline and return Input Set template format of applied pipeline
 */
export const getMergeInputSetFromPipelineTemplatePromise = (
  props: MutateUsingFetchProps<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateQueryParams,
    MergeInputSetTemplateRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseMergeInputSetResponse,
    Failure | Error,
    GetMergeInputSetFromPipelineTemplateQueryParams,
    MergeInputSetTemplateRequest,
    void
  >('POST', getConfig('pipeline/api'), `/inputSets/mergeWithTemplateYaml`, props, signal)

export interface InputSetMoveConfigQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  connectorRef?: string
  repoName?: string
  branch?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
  moveConfigType?: 'INLINE_TO_REMOTE' | 'REMOTE_TO_INLINE'
  pipelineIdentifier?: string
  inputSetIdentifier?: string
}

export interface InputSetMoveConfigPathParams {
  inputSetIdentifier: string
}

export type InputSetMoveConfigProps = Omit<
  MutateProps<
    ResponseInputSetMoveConfigResponseDTO,
    Failure | Error,
    InputSetMoveConfigQueryParams,
    void,
    InputSetMoveConfigPathParams
  >,
  'path' | 'verb'
> &
  InputSetMoveConfigPathParams

/**
 * Move Input Set YAML from inline to remote or remote to inline
 */
export const InputSetMoveConfig = ({ inputSetIdentifier, ...props }: InputSetMoveConfigProps) => (
  <Mutate<
    ResponseInputSetMoveConfigResponseDTO,
    Failure | Error,
    InputSetMoveConfigQueryParams,
    void,
    InputSetMoveConfigPathParams
  >
    verb="POST"
    path={`/inputSets/move-config/${inputSetIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseInputSetMoveConfigProps = Omit<
  UseMutateProps<
    ResponseInputSetMoveConfigResponseDTO,
    Failure | Error,
    InputSetMoveConfigQueryParams,
    void,
    InputSetMoveConfigPathParams
  >,
  'path' | 'verb'
> &
  InputSetMoveConfigPathParams

/**
 * Move Input Set YAML from inline to remote or remote to inline
 */
export const useInputSetMoveConfig = ({ inputSetIdentifier, ...props }: UseInputSetMoveConfigProps) =>
  useMutate<
    ResponseInputSetMoveConfigResponseDTO,
    Failure | Error,
    InputSetMoveConfigQueryParams,
    void,
    InputSetMoveConfigPathParams
  >(
    'POST',
    (paramsInPath: InputSetMoveConfigPathParams) => `/inputSets/move-config/${paramsInPath.inputSetIdentifier}`,
    { base: getConfig('pipeline/api'), pathParams: { inputSetIdentifier }, ...props }
  )

/**
 * Move Input Set YAML from inline to remote or remote to inline
 */
export const inputSetMoveConfigPromise = (
  {
    inputSetIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseInputSetMoveConfigResponseDTO,
    Failure | Error,
    InputSetMoveConfigQueryParams,
    void,
    InputSetMoveConfigPathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInputSetMoveConfigResponseDTO,
    Failure | Error,
    InputSetMoveConfigQueryParams,
    void,
    InputSetMoveConfigPathParams
  >('POST', getConfig('pipeline/api'), `/inputSets/move-config/${inputSetIdentifier}`, props, signal)

export interface CreateOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  repoName?: string
}

export type CreateOverlayInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Overlay InputSet For Pipeline
 */
export const CreateOverlayInputSetForPipeline = (props: CreateOverlayInputSetForPipelineProps) => (
  <Mutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >
    verb="POST"
    path={`/inputSets/overlay`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreateOverlayInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Overlay InputSet For Pipeline
 */
export const useCreateOverlayInputSetForPipeline = (props: UseCreateOverlayInputSetForPipelineProps) =>
  useMutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >('POST', `/inputSets/overlay`, { base: getConfig('pipeline/api'), ...props })

/**
 * Create an Overlay InputSet For Pipeline
 */
export const createOverlayInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    CreateOverlayInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/inputSets/overlay`, props, signal)

export interface GetOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  pipelineBranch?: string
  pipelineRepoID?: string
  loadFromFallbackBranch?: boolean
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export interface GetOverlayInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type GetOverlayInputSetForPipelineProps = Omit<
  GetProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >,
  'path'
> &
  GetOverlayInputSetForPipelinePathParams

/**
 * Gets an Overlay InputSet by identifier
 */
export const GetOverlayInputSetForPipeline = ({ inputSetIdentifier, ...props }: GetOverlayInputSetForPipelineProps) => (
  <Get<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >
    path={`/inputSets/overlay/${inputSetIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetOverlayInputSetForPipelineProps = Omit<
  UseGetProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >,
  'path'
> &
  GetOverlayInputSetForPipelinePathParams

/**
 * Gets an Overlay InputSet by identifier
 */
export const useGetOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UseGetOverlayInputSetForPipelineProps) =>
  useGet<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >(
    (paramsInPath: GetOverlayInputSetForPipelinePathParams) => `/inputSets/overlay/${paramsInPath.inputSetIdentifier}`,
    { base: getConfig('pipeline/api'), pathParams: { inputSetIdentifier }, ...props }
  )

/**
 * Gets an Overlay InputSet by identifier
 */
export const getOverlayInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    GetOverlayInputSetForPipelineQueryParams,
    GetOverlayInputSetForPipelinePathParams
  >(getConfig('pipeline/api'), `/inputSets/overlay/${inputSetIdentifier}`, props, signal)

export interface UpdateOverlayInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  lastCommitId?: string
  isNewBranch?: boolean
}

export interface UpdateOverlayInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type UpdateOverlayInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateOverlayInputSetForPipelinePathParams

/**
 * Update an Overlay InputSet by identifier
 */
export const UpdateOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UpdateOverlayInputSetForPipelineProps) => (
  <Mutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  >
    verb="PUT"
    path={`/inputSets/overlay/${inputSetIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateOverlayInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateOverlayInputSetForPipelinePathParams

/**
 * Update an Overlay InputSet by identifier
 */
export const useUpdateOverlayInputSetForPipeline = ({
  inputSetIdentifier,
  ...props
}: UseUpdateOverlayInputSetForPipelineProps) =>
  useMutate<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  >(
    'PUT',
    (paramsInPath: UpdateOverlayInputSetForPipelinePathParams) =>
      `/inputSets/overlay/${paramsInPath.inputSetIdentifier}`,
    { base: getConfig('pipeline/api'), pathParams: { inputSetIdentifier }, ...props }
  )

/**
 * Update an Overlay InputSet by identifier
 */
export const updateOverlayInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOverlayInputSetResponse,
    Failure | Error,
    UpdateOverlayInputSetForPipelineQueryParams,
    void,
    UpdateOverlayInputSetForPipelinePathParams
  >('PUT', getConfig('pipeline/api'), `/inputSets/overlay/${inputSetIdentifier}`, props, signal)

export interface GetTemplateFromPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetTemplateFromPipelineProps = Omit<
  MutateProps<
    ResponseInputSetTemplateWithReplacedExpressionsResponse,
    Failure | Error,
    GetTemplateFromPipelineQueryParams,
    InputSetTemplateRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Get template from a pipeline YAML
 */
export const GetTemplateFromPipeline = (props: GetTemplateFromPipelineProps) => (
  <Mutate<
    ResponseInputSetTemplateWithReplacedExpressionsResponse,
    Failure | Error,
    GetTemplateFromPipelineQueryParams,
    InputSetTemplateRequest,
    void
  >
    verb="POST"
    path={`/inputSets/template`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetTemplateFromPipelineProps = Omit<
  UseMutateProps<
    ResponseInputSetTemplateWithReplacedExpressionsResponse,
    Failure | Error,
    GetTemplateFromPipelineQueryParams,
    InputSetTemplateRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Get template from a pipeline YAML
 */
export const useGetTemplateFromPipeline = (props: UseGetTemplateFromPipelineProps) =>
  useMutate<
    ResponseInputSetTemplateWithReplacedExpressionsResponse,
    Failure | Error,
    GetTemplateFromPipelineQueryParams,
    InputSetTemplateRequest,
    void
  >('POST', `/inputSets/template`, { base: getConfig('pipeline/api'), ...props })

/**
 * Get template from a pipeline YAML
 */
export const getTemplateFromPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseInputSetTemplateWithReplacedExpressionsResponse,
    Failure | Error,
    GetTemplateFromPipelineQueryParams,
    InputSetTemplateRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInputSetTemplateWithReplacedExpressionsResponse,
    Failure | Error,
    GetTemplateFromPipelineQueryParams,
    InputSetTemplateRequest,
    void
  >('POST', getConfig('pipeline/api'), `/inputSets/template`, props, signal)

export interface DeleteInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
}

export type DeleteInputSetForPipelineProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an InputSet by identifier
 */
export const DeleteInputSetForPipeline = (props: DeleteInputSetForPipelineProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>
    verb="DELETE"
    path={`/inputSets`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDeleteInputSetForPipelineProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an InputSet by identifier
 */
export const useDeleteInputSetForPipeline = (props: UseDeleteInputSetForPipelineProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>(
    'DELETE',
    `/inputSets`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Delete an InputSet by identifier
 */
export const deleteInputSetForPipelinePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteInputSetForPipelineQueryParams, string, void>(
    'DELETE',
    getConfig('pipeline/api'),
    `/inputSets`,
    props,
    signal
  )

export interface GetInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  pipelineBranch?: string
  pipelineRepoID?: string
  loadFromFallbackBranch?: boolean
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export interface GetInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type GetInputSetForPipelineProps = Omit<
  GetProps<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >,
  'path'
> &
  GetInputSetForPipelinePathParams

/**
 * Gets an InputSet by identifier
 */
export const GetInputSetForPipeline = ({ inputSetIdentifier, ...props }: GetInputSetForPipelineProps) => (
  <Get<ResponseInputSetResponse, Failure | Error, GetInputSetForPipelineQueryParams, GetInputSetForPipelinePathParams>
    path={`/inputSets/${inputSetIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetInputSetForPipelineProps = Omit<
  UseGetProps<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >,
  'path'
> &
  GetInputSetForPipelinePathParams

/**
 * Gets an InputSet by identifier
 */
export const useGetInputSetForPipeline = ({ inputSetIdentifier, ...props }: UseGetInputSetForPipelineProps) =>
  useGet<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >((paramsInPath: GetInputSetForPipelinePathParams) => `/inputSets/${paramsInPath.inputSetIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { inputSetIdentifier },
    ...props
  })

/**
 * Gets an InputSet by identifier
 */
export const getInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInputSetResponse,
    Failure | Error,
    GetInputSetForPipelineQueryParams,
    GetInputSetForPipelinePathParams
  >(getConfig('pipeline/api'), `/inputSets/${inputSetIdentifier}`, props, signal)

export interface UpdateInputSetForPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  pipelineBranch?: string
  pipelineRepoID?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  lastCommitId?: string
  isNewBranch?: boolean
}

export interface UpdateInputSetForPipelinePathParams {
  inputSetIdentifier: string
}

export type UpdateInputSetForPipelineProps = Omit<
  MutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    UpdateInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateInputSetForPipelinePathParams

/**
 * Update an InputSet by identifier
 */
export const UpdateInputSetForPipeline = ({ inputSetIdentifier, ...props }: UpdateInputSetForPipelineProps) => (
  <Mutate<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    UpdateInputSetForPipelinePathParams
  >
    verb="PUT"
    path={`/inputSets/${inputSetIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateInputSetForPipelineProps = Omit<
  UseMutateProps<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    UpdateInputSetForPipelinePathParams
  >,
  'path' | 'verb'
> &
  UpdateInputSetForPipelinePathParams

/**
 * Update an InputSet by identifier
 */
export const useUpdateInputSetForPipeline = ({ inputSetIdentifier, ...props }: UseUpdateInputSetForPipelineProps) =>
  useMutate<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    UpdateInputSetForPipelinePathParams
  >('PUT', (paramsInPath: UpdateInputSetForPipelinePathParams) => `/inputSets/${paramsInPath.inputSetIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { inputSetIdentifier },
    ...props
  })

/**
 * Update an InputSet by identifier
 */
export const updateInputSetForPipelinePromise = (
  {
    inputSetIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    UpdateInputSetForPipelinePathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInputSetResponse,
    Failure | Error,
    UpdateInputSetForPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    UpdateInputSetForPipelinePathParams
  >('PUT', getConfig('pipeline/api'), `/inputSets/${inputSetIdentifier}`, props, signal)

export interface SanitiseInputSetQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  pipelineBranch?: string
  pipelineRepoID?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  lastCommitId?: string
  isNewBranch?: boolean
}

export interface SanitiseInputSetPathParams {
  inputSetIdentifier: string
}

export type SanitiseInputSetProps = Omit<
  MutateProps<
    ResponseInputSetSanitiseResponse,
    Failure | Error,
    SanitiseInputSetQueryParams,
    UpdateTriggerBodyRequestBody,
    SanitiseInputSetPathParams
  >,
  'path' | 'verb'
> &
  SanitiseInputSetPathParams

/**
 * Sanitise an InputSet
 */
export const SanitiseInputSet = ({ inputSetIdentifier, ...props }: SanitiseInputSetProps) => (
  <Mutate<
    ResponseInputSetSanitiseResponse,
    Failure | Error,
    SanitiseInputSetQueryParams,
    UpdateTriggerBodyRequestBody,
    SanitiseInputSetPathParams
  >
    verb="POST"
    path={`/inputSets/${inputSetIdentifier}/sanitise`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseSanitiseInputSetProps = Omit<
  UseMutateProps<
    ResponseInputSetSanitiseResponse,
    Failure | Error,
    SanitiseInputSetQueryParams,
    UpdateTriggerBodyRequestBody,
    SanitiseInputSetPathParams
  >,
  'path' | 'verb'
> &
  SanitiseInputSetPathParams

/**
 * Sanitise an InputSet
 */
export const useSanitiseInputSet = ({ inputSetIdentifier, ...props }: UseSanitiseInputSetProps) =>
  useMutate<
    ResponseInputSetSanitiseResponse,
    Failure | Error,
    SanitiseInputSetQueryParams,
    UpdateTriggerBodyRequestBody,
    SanitiseInputSetPathParams
  >('POST', (paramsInPath: SanitiseInputSetPathParams) => `/inputSets/${paramsInPath.inputSetIdentifier}/sanitise`, {
    base: getConfig('pipeline/api'),
    pathParams: { inputSetIdentifier },
    ...props
  })

/**
 * Sanitise an InputSet
 */
export const sanitiseInputSetPromise = (
  {
    inputSetIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseInputSetSanitiseResponse,
    Failure | Error,
    SanitiseInputSetQueryParams,
    UpdateTriggerBodyRequestBody,
    SanitiseInputSetPathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInputSetSanitiseResponse,
    Failure | Error,
    SanitiseInputSetQueryParams,
    UpdateTriggerBodyRequestBody,
    SanitiseInputSetPathParams
  >('POST', getConfig('pipeline/api'), `/inputSets/${inputSetIdentifier}/sanitise`, props, signal)

export interface UpdateInputSetGitDetailsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  connectorRef?: string
  repoName?: string
  filePath?: string
}

export interface UpdateInputSetGitDetailsPathParams {
  inputSetIdentifier: string
}

export type UpdateInputSetGitDetailsProps = Omit<
  MutateProps<
    ResponseInputSetGitUpdateResponse,
    Failure | Error,
    UpdateInputSetGitDetailsQueryParams,
    void,
    UpdateInputSetGitDetailsPathParams
  >,
  'path' | 'verb'
> &
  UpdateInputSetGitDetailsPathParams

/**
 * Update git-metadata in remote inputSet
 */
export const UpdateInputSetGitDetails = ({ inputSetIdentifier, ...props }: UpdateInputSetGitDetailsProps) => (
  <Mutate<
    ResponseInputSetGitUpdateResponse,
    Failure | Error,
    UpdateInputSetGitDetailsQueryParams,
    void,
    UpdateInputSetGitDetailsPathParams
  >
    verb="PUT"
    path={`/inputSets/${inputSetIdentifier}/update-git-metadata`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateInputSetGitDetailsProps = Omit<
  UseMutateProps<
    ResponseInputSetGitUpdateResponse,
    Failure | Error,
    UpdateInputSetGitDetailsQueryParams,
    void,
    UpdateInputSetGitDetailsPathParams
  >,
  'path' | 'verb'
> &
  UpdateInputSetGitDetailsPathParams

/**
 * Update git-metadata in remote inputSet
 */
export const useUpdateInputSetGitDetails = ({ inputSetIdentifier, ...props }: UseUpdateInputSetGitDetailsProps) =>
  useMutate<
    ResponseInputSetGitUpdateResponse,
    Failure | Error,
    UpdateInputSetGitDetailsQueryParams,
    void,
    UpdateInputSetGitDetailsPathParams
  >(
    'PUT',
    (paramsInPath: UpdateInputSetGitDetailsPathParams) =>
      `/inputSets/${paramsInPath.inputSetIdentifier}/update-git-metadata`,
    { base: getConfig('pipeline/api'), pathParams: { inputSetIdentifier }, ...props }
  )

/**
 * Update git-metadata in remote inputSet
 */
export const updateInputSetGitDetailsPromise = (
  {
    inputSetIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseInputSetGitUpdateResponse,
    Failure | Error,
    UpdateInputSetGitDetailsQueryParams,
    void,
    UpdateInputSetGitDetailsPathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseInputSetGitUpdateResponse,
    Failure | Error,
    UpdateInputSetGitDetailsQueryParams,
    void,
    UpdateInputSetGitDetailsPathParams
  >('PUT', getConfig('pipeline/api'), `/inputSets/${inputSetIdentifier}/update-git-metadata`, props, signal)

export interface YamlDiffForInputSetQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  pipelineBranch?: string
  pipelineRepoID?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  lastCommitId?: string
  isNewBranch?: boolean
}

export interface YamlDiffForInputSetPathParams {
  inputSetIdentifier: string
}

export type YamlDiffForInputSetProps = Omit<
  GetProps<ResponseInputSetYamlDiff, Failure | Error, YamlDiffForInputSetQueryParams, YamlDiffForInputSetPathParams>,
  'path'
> &
  YamlDiffForInputSetPathParams

/**
 * Get sanitised YAML for an InputSet
 */
export const YamlDiffForInputSet = ({ inputSetIdentifier, ...props }: YamlDiffForInputSetProps) => (
  <Get<ResponseInputSetYamlDiff, Failure | Error, YamlDiffForInputSetQueryParams, YamlDiffForInputSetPathParams>
    path={`/inputSets/${inputSetIdentifier}/yaml-diff`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseYamlDiffForInputSetProps = Omit<
  UseGetProps<ResponseInputSetYamlDiff, Failure | Error, YamlDiffForInputSetQueryParams, YamlDiffForInputSetPathParams>,
  'path'
> &
  YamlDiffForInputSetPathParams

/**
 * Get sanitised YAML for an InputSet
 */
export const useYamlDiffForInputSet = ({ inputSetIdentifier, ...props }: UseYamlDiffForInputSetProps) =>
  useGet<ResponseInputSetYamlDiff, Failure | Error, YamlDiffForInputSetQueryParams, YamlDiffForInputSetPathParams>(
    (paramsInPath: YamlDiffForInputSetPathParams) => `/inputSets/${paramsInPath.inputSetIdentifier}/yaml-diff`,
    { base: getConfig('pipeline/api'), pathParams: { inputSetIdentifier }, ...props }
  )

/**
 * Get sanitised YAML for an InputSet
 */
export const yamlDiffForInputSetPromise = (
  {
    inputSetIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseInputSetYamlDiff,
    Failure | Error,
    YamlDiffForInputSetQueryParams,
    YamlDiffForInputSetPathParams
  > & { inputSetIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInputSetYamlDiff,
    Failure | Error,
    YamlDiffForInputSetQueryParams,
    YamlDiffForInputSetPathParams
  >(getConfig('pipeline/api'), `/inputSets/${inputSetIdentifier}/yaml-diff`, props, signal)

export interface GetExecutionsCountQueryParams {
  accountIdentifier: string
  startTime: number
  endTime: number
}

export type GetExecutionsCountProps = Omit<
  MutateProps<
    ResponseExecutionsCount,
    Failure | Error,
    GetExecutionsCountQueryParams,
    LandingDashboardRequestPMSRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get pipeline executions count
 */
export const GetExecutionsCount = (props: GetExecutionsCountProps) => (
  <Mutate<
    ResponseExecutionsCount,
    Failure | Error,
    GetExecutionsCountQueryParams,
    LandingDashboardRequestPMSRequestBody,
    void
  >
    verb="POST"
    path={`/landingDashboards/executionsCount`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExecutionsCountProps = Omit<
  UseMutateProps<
    ResponseExecutionsCount,
    Failure | Error,
    GetExecutionsCountQueryParams,
    LandingDashboardRequestPMSRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get pipeline executions count
 */
export const useGetExecutionsCount = (props: UseGetExecutionsCountProps) =>
  useMutate<
    ResponseExecutionsCount,
    Failure | Error,
    GetExecutionsCountQueryParams,
    LandingDashboardRequestPMSRequestBody,
    void
  >('POST', `/landingDashboards/executionsCount`, { base: getConfig('pipeline/api'), ...props })

/**
 * Get pipeline executions count
 */
export const getExecutionsCountPromise = (
  props: MutateUsingFetchProps<
    ResponseExecutionsCount,
    Failure | Error,
    GetExecutionsCountQueryParams,
    LandingDashboardRequestPMSRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseExecutionsCount,
    Failure | Error,
    GetExecutionsCountQueryParams,
    LandingDashboardRequestPMSRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/landingDashboards/executionsCount`, props, signal)

export interface GetPipelinesCountQueryParams {
  accountIdentifier: string
  startTime: number
  endTime: number
}

export type GetPipelinesCountProps = Omit<
  MutateProps<
    ResponsePipelinesCount,
    Failure | Error,
    GetPipelinesCountQueryParams,
    LandingDashboardRequestPMSRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get pipelines count
 */
export const GetPipelinesCount = (props: GetPipelinesCountProps) => (
  <Mutate<
    ResponsePipelinesCount,
    Failure | Error,
    GetPipelinesCountQueryParams,
    LandingDashboardRequestPMSRequestBody,
    void
  >
    verb="POST"
    path={`/landingDashboards/pipelinesCount`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelinesCountProps = Omit<
  UseMutateProps<
    ResponsePipelinesCount,
    Failure | Error,
    GetPipelinesCountQueryParams,
    LandingDashboardRequestPMSRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get pipelines count
 */
export const useGetPipelinesCount = (props: UseGetPipelinesCountProps) =>
  useMutate<
    ResponsePipelinesCount,
    Failure | Error,
    GetPipelinesCountQueryParams,
    LandingDashboardRequestPMSRequestBody,
    void
  >('POST', `/landingDashboards/pipelinesCount`, { base: getConfig('pipeline/api'), ...props })

/**
 * Get pipelines count
 */
export const getPipelinesCountPromise = (
  props: MutateUsingFetchProps<
    ResponsePipelinesCount,
    Failure | Error,
    GetPipelinesCountQueryParams,
    LandingDashboardRequestPMSRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelinesCount,
    Failure | Error,
    GetPipelinesCountQueryParams,
    LandingDashboardRequestPMSRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/landingDashboards/pipelinesCount`, props, signal)

export interface GetPipelineOpaContextQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  opaAction: string
}

export type GetPipelineOpaContextProps = Omit<
  MutateProps<ResponsePipelineOpaEvaluationContext, unknown, GetPipelineOpaContextQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * get pipeline opa context
 */
export const GetPipelineOpaContext = (props: GetPipelineOpaContextProps) => (
  <Mutate<ResponsePipelineOpaEvaluationContext, unknown, GetPipelineOpaContextQueryParams, void, void>
    verb="POST"
    path={`/opa/getPipelineOpaContext`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineOpaContextProps = Omit<
  UseMutateProps<ResponsePipelineOpaEvaluationContext, unknown, GetPipelineOpaContextQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * get pipeline opa context
 */
export const useGetPipelineOpaContext = (props: UseGetPipelineOpaContextProps) =>
  useMutate<ResponsePipelineOpaEvaluationContext, unknown, GetPipelineOpaContextQueryParams, void, void>(
    'POST',
    `/opa/getPipelineOpaContext`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * get pipeline opa context
 */
export const getPipelineOpaContextPromise = (
  props: MutateUsingFetchProps<
    ResponsePipelineOpaEvaluationContext,
    unknown,
    GetPipelineOpaContextQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponsePipelineOpaEvaluationContext, unknown, GetPipelineOpaContextQueryParams, void, void>(
    'POST',
    getConfig('pipeline/api'),
    `/opa/getPipelineOpaContext`,
    props,
    signal
  )

export interface GetPipelineOpaContextFromEvaluationQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  opaAction: string
}

export interface GetPipelineOpaContextFromEvaluationPathParams {
  planExecutionId: string
}

export type GetPipelineOpaContextFromEvaluationProps = Omit<
  GetProps<
    ResponsePipelineOpaEvaluationContext,
    unknown,
    GetPipelineOpaContextFromEvaluationQueryParams,
    GetPipelineOpaContextFromEvaluationPathParams
  >,
  'path'
> &
  GetPipelineOpaContextFromEvaluationPathParams

/**
 * get pipeline opa context from evaluation
 */
export const GetPipelineOpaContextFromEvaluation = ({
  planExecutionId,
  ...props
}: GetPipelineOpaContextFromEvaluationProps) => (
  <Get<
    ResponsePipelineOpaEvaluationContext,
    unknown,
    GetPipelineOpaContextFromEvaluationQueryParams,
    GetPipelineOpaContextFromEvaluationPathParams
  >
    path={`/opa/getPipelineOpaContextFromEvaluation/${planExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineOpaContextFromEvaluationProps = Omit<
  UseGetProps<
    ResponsePipelineOpaEvaluationContext,
    unknown,
    GetPipelineOpaContextFromEvaluationQueryParams,
    GetPipelineOpaContextFromEvaluationPathParams
  >,
  'path'
> &
  GetPipelineOpaContextFromEvaluationPathParams

/**
 * get pipeline opa context from evaluation
 */
export const useGetPipelineOpaContextFromEvaluation = ({
  planExecutionId,
  ...props
}: UseGetPipelineOpaContextFromEvaluationProps) =>
  useGet<
    ResponsePipelineOpaEvaluationContext,
    unknown,
    GetPipelineOpaContextFromEvaluationQueryParams,
    GetPipelineOpaContextFromEvaluationPathParams
  >(
    (paramsInPath: GetPipelineOpaContextFromEvaluationPathParams) =>
      `/opa/getPipelineOpaContextFromEvaluation/${paramsInPath.planExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * get pipeline opa context from evaluation
 */
export const getPipelineOpaContextFromEvaluationPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponsePipelineOpaEvaluationContext,
    unknown,
    GetPipelineOpaContextFromEvaluationQueryParams,
    GetPipelineOpaContextFromEvaluationPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePipelineOpaEvaluationContext,
    unknown,
    GetPipelineOpaContextFromEvaluationQueryParams,
    GetPipelineOpaContextFromEvaluationPathParams
  >(getConfig('pipeline/api'), `/opa/getPipelineOpaContextFromEvaluation/${planExecutionId}`, props, signal)

export interface DebugPipelineExecuteWithInputSetYamlV2QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  useFQNIfError?: boolean
}

export interface DebugPipelineExecuteWithInputSetYamlV2PathParams {
  originalExecutionId: string
  identifier: string
}

export type DebugPipelineExecuteWithInputSetYamlV2Props = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    DebugPipelineExecuteWithInputSetYamlV2PathParams
  >,
  'path' | 'verb'
> &
  DebugPipelineExecuteWithInputSetYamlV2PathParams

/**
 * Re Execute a pipeline with inputSet pipeline yaml Version 2
 */
export const DebugPipelineExecuteWithInputSetYamlV2 = ({
  originalExecutionId,
  identifier,
  ...props
}: DebugPipelineExecuteWithInputSetYamlV2Props) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    DebugPipelineExecuteWithInputSetYamlV2PathParams
  >
    verb="POST"
    path={`/pipeline/execute/debug/v2/${originalExecutionId}/${identifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDebugPipelineExecuteWithInputSetYamlV2Props = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    DebugPipelineExecuteWithInputSetYamlV2PathParams
  >,
  'path' | 'verb'
> &
  DebugPipelineExecuteWithInputSetYamlV2PathParams

/**
 * Re Execute a pipeline with inputSet pipeline yaml Version 2
 */
export const useDebugPipelineExecuteWithInputSetYamlV2 = ({
  originalExecutionId,
  identifier,
  ...props
}: UseDebugPipelineExecuteWithInputSetYamlV2Props) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    DebugPipelineExecuteWithInputSetYamlV2PathParams
  >(
    'POST',
    (paramsInPath: DebugPipelineExecuteWithInputSetYamlV2PathParams) =>
      `/pipeline/execute/debug/v2/${paramsInPath.originalExecutionId}/${paramsInPath.identifier}`,
    { base: getConfig('pipeline/api'), pathParams: { originalExecutionId, identifier }, ...props }
  )

/**
 * Re Execute a pipeline with inputSet pipeline yaml Version 2
 */
export const debugPipelineExecuteWithInputSetYamlV2Promise = (
  {
    originalExecutionId,
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    DebugPipelineExecuteWithInputSetYamlV2PathParams
  > & { originalExecutionId: string; identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    DebugPipelineExecuteWithInputSetYamlV2PathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/debug/v2/${originalExecutionId}/${identifier}`, props, signal)

export interface DebugPipelineExecuteWithInputSetYamlQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  useFQNIfError?: boolean
}

export interface DebugPipelineExecuteWithInputSetYamlPathParams {
  originalExecutionId: string
  identifier: string
}

export type DebugPipelineExecuteWithInputSetYamlProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugPipelineExecuteWithInputSetYamlQueryParams,
    void,
    DebugPipelineExecuteWithInputSetYamlPathParams
  >,
  'path' | 'verb'
> &
  DebugPipelineExecuteWithInputSetYamlPathParams

/**
 * debug a pipeline with inputSet pipeline yaml
 */
export const DebugPipelineExecuteWithInputSetYaml = ({
  originalExecutionId,
  identifier,
  ...props
}: DebugPipelineExecuteWithInputSetYamlProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugPipelineExecuteWithInputSetYamlQueryParams,
    void,
    DebugPipelineExecuteWithInputSetYamlPathParams
  >
    verb="POST"
    path={`/pipeline/execute/debug/${originalExecutionId}/${identifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDebugPipelineExecuteWithInputSetYamlProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugPipelineExecuteWithInputSetYamlQueryParams,
    void,
    DebugPipelineExecuteWithInputSetYamlPathParams
  >,
  'path' | 'verb'
> &
  DebugPipelineExecuteWithInputSetYamlPathParams

/**
 * debug a pipeline with inputSet pipeline yaml
 */
export const useDebugPipelineExecuteWithInputSetYaml = ({
  originalExecutionId,
  identifier,
  ...props
}: UseDebugPipelineExecuteWithInputSetYamlProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugPipelineExecuteWithInputSetYamlQueryParams,
    void,
    DebugPipelineExecuteWithInputSetYamlPathParams
  >(
    'POST',
    (paramsInPath: DebugPipelineExecuteWithInputSetYamlPathParams) =>
      `/pipeline/execute/debug/${paramsInPath.originalExecutionId}/${paramsInPath.identifier}`,
    { base: getConfig('pipeline/api'), pathParams: { originalExecutionId, identifier }, ...props }
  )

/**
 * debug a pipeline with inputSet pipeline yaml
 */
export const debugPipelineExecuteWithInputSetYamlPromise = (
  {
    originalExecutionId,
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugPipelineExecuteWithInputSetYamlQueryParams,
    void,
    DebugPipelineExecuteWithInputSetYamlPathParams
  > & { originalExecutionId: string; identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugPipelineExecuteWithInputSetYamlQueryParams,
    void,
    DebugPipelineExecuteWithInputSetYamlPathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/debug/${originalExecutionId}/${identifier}`, props, signal)

export interface DebugStagesWithRuntimeInputYamlQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  useFQNIfError?: boolean
}

export interface DebugStagesWithRuntimeInputYamlPathParams {
  originalExecutionId: string
  identifier: string
}

export type DebugStagesWithRuntimeInputYamlProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    DebugStagesWithRuntimeInputYamlPathParams
  >,
  'path' | 'verb'
> &
  DebugStagesWithRuntimeInputYamlPathParams

/**
 * debug a pipeline with inputSet pipeline yaml
 */
export const DebugStagesWithRuntimeInputYaml = ({
  originalExecutionId,
  identifier,
  ...props
}: DebugStagesWithRuntimeInputYamlProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    DebugStagesWithRuntimeInputYamlPathParams
  >
    verb="POST"
    path={`/pipeline/execute/debug/${originalExecutionId}/${identifier}/stages`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDebugStagesWithRuntimeInputYamlProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    DebugStagesWithRuntimeInputYamlPathParams
  >,
  'path' | 'verb'
> &
  DebugStagesWithRuntimeInputYamlPathParams

/**
 * debug a pipeline with inputSet pipeline yaml
 */
export const useDebugStagesWithRuntimeInputYaml = ({
  originalExecutionId,
  identifier,
  ...props
}: UseDebugStagesWithRuntimeInputYamlProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    DebugStagesWithRuntimeInputYamlPathParams
  >(
    'POST',
    (paramsInPath: DebugStagesWithRuntimeInputYamlPathParams) =>
      `/pipeline/execute/debug/${paramsInPath.originalExecutionId}/${paramsInPath.identifier}/stages`,
    { base: getConfig('pipeline/api'), pathParams: { originalExecutionId, identifier }, ...props }
  )

/**
 * debug a pipeline with inputSet pipeline yaml
 */
export const debugStagesWithRuntimeInputYamlPromise = (
  {
    originalExecutionId,
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    DebugStagesWithRuntimeInputYamlPathParams
  > & { originalExecutionId: string; identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    DebugStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    DebugStagesWithRuntimeInputYamlPathParams
  >(
    'POST',
    getConfig('pipeline/api'),
    `/pipeline/execute/debug/${originalExecutionId}/${identifier}/stages`,
    props,
    signal
  )

export interface GetPreflightCheckResponseQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  preflightCheckId: string
}

export type GetPreflightCheckResponseProps = Omit<
  GetProps<ResponsePreFlightDTO, Failure | AccessControlCheckError | Error, GetPreflightCheckResponseQueryParams, void>,
  'path'
>

/**
 * get preflight check response
 */
export const GetPreflightCheckResponse = (props: GetPreflightCheckResponseProps) => (
  <Get<ResponsePreFlightDTO, Failure | AccessControlCheckError | Error, GetPreflightCheckResponseQueryParams, void>
    path={`/pipeline/execute/getPreflightCheckResponse`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPreflightCheckResponseProps = Omit<
  UseGetProps<
    ResponsePreFlightDTO,
    Failure | AccessControlCheckError | Error,
    GetPreflightCheckResponseQueryParams,
    void
  >,
  'path'
>

/**
 * get preflight check response
 */
export const useGetPreflightCheckResponse = (props: UseGetPreflightCheckResponseProps) =>
  useGet<ResponsePreFlightDTO, Failure | AccessControlCheckError | Error, GetPreflightCheckResponseQueryParams, void>(
    `/pipeline/execute/getPreflightCheckResponse`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * get preflight check response
 */
export const getPreflightCheckResponsePromise = (
  props: GetUsingFetchProps<
    ResponsePreFlightDTO,
    Failure | AccessControlCheckError | Error,
    GetPreflightCheckResponseQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePreFlightDTO,
    Failure | AccessControlCheckError | Error,
    GetPreflightCheckResponseQueryParams,
    void
  >(getConfig('pipeline/api'), `/pipeline/execute/getPreflightCheckResponse`, props, signal)

export interface HandleInterruptQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  interruptType: 'AbortAll'
}

export interface HandleInterruptPathParams {
  planExecutionId: string
}

export type HandleInterruptProps = Omit<
  MutateProps<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleInterruptPathParams

/**
 * stop the pipeline executions
 */
export const HandleInterrupt = ({ planExecutionId, ...props }: HandleInterruptProps) => (
  <Mutate<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >
    verb="PUT"
    path={`/pipeline/execute/interrupt/${planExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseHandleInterruptProps = Omit<
  UseMutateProps<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleInterruptPathParams

/**
 * stop the pipeline executions
 */
export const useHandleInterrupt = ({ planExecutionId, ...props }: UseHandleInterruptProps) =>
  useMutate<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >('PUT', (paramsInPath: HandleInterruptPathParams) => `/pipeline/execute/interrupt/${paramsInPath.planExecutionId}`, {
    base: getConfig('pipeline/api'),
    pathParams: { planExecutionId },
    ...props
  })

/**
 * stop the pipeline executions
 */
export const handleInterruptPromise = (
  {
    planExecutionId,
    ...props
  }: MutateUsingFetchProps<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleInterruptQueryParams,
    void,
    HandleInterruptPathParams
  >('PUT', getConfig('pipeline/api'), `/pipeline/execute/interrupt/${planExecutionId}`, props, signal)

export interface HandleStageInterruptQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  interruptType: 'AbortAll' | 'UserMarkedFailure'
}

export interface HandleStageInterruptPathParams {
  planExecutionId: string
  nodeExecutionId: string
}

export type HandleStageInterruptProps = Omit<
  MutateProps<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleStageInterruptPathParams

/**
 * mark as failure or stop the stage executions
 */
export const HandleStageInterrupt = ({ planExecutionId, nodeExecutionId, ...props }: HandleStageInterruptProps) => (
  <Mutate<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  >
    verb="PUT"
    path={`/pipeline/execute/interrupt/${planExecutionId}/${nodeExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseHandleStageInterruptProps = Omit<
  UseMutateProps<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleStageInterruptPathParams

/**
 * mark as failure or stop the stage executions
 */
export const useHandleStageInterrupt = ({ planExecutionId, nodeExecutionId, ...props }: UseHandleStageInterruptProps) =>
  useMutate<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  >(
    'PUT',
    (paramsInPath: HandleStageInterruptPathParams) =>
      `/pipeline/execute/interrupt/${paramsInPath.planExecutionId}/${paramsInPath.nodeExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId, nodeExecutionId }, ...props }
  )

/**
 * mark as failure or stop the stage executions
 */
export const handleStageInterruptPromise = (
  {
    planExecutionId,
    nodeExecutionId,
    ...props
  }: MutateUsingFetchProps<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  > & { planExecutionId: string; nodeExecutionId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleStageInterruptQueryParams,
    void,
    HandleStageInterruptPathParams
  >(
    'PUT',
    getConfig('pipeline/api'),
    `/pipeline/execute/interrupt/${planExecutionId}/${nodeExecutionId}`,
    props,
    signal
  )

export interface LatestExecutionIdQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export interface LatestExecutionIdPathParams {
  planExecutionId: string
}

export type LatestExecutionIdProps = Omit<
  GetProps<
    ResponseRetryLatestExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    LatestExecutionIdQueryParams,
    LatestExecutionIdPathParams
  >,
  'path'
> &
  LatestExecutionIdPathParams

/**
 * Latest ExecutionId from Retry Executions
 */
export const LatestExecutionId = ({ planExecutionId, ...props }: LatestExecutionIdProps) => (
  <Get<
    ResponseRetryLatestExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    LatestExecutionIdQueryParams,
    LatestExecutionIdPathParams
  >
    path={`/pipeline/execute/latestExecutionId/${planExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseLatestExecutionIdProps = Omit<
  UseGetProps<
    ResponseRetryLatestExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    LatestExecutionIdQueryParams,
    LatestExecutionIdPathParams
  >,
  'path'
> &
  LatestExecutionIdPathParams

/**
 * Latest ExecutionId from Retry Executions
 */
export const useLatestExecutionId = ({ planExecutionId, ...props }: UseLatestExecutionIdProps) =>
  useGet<
    ResponseRetryLatestExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    LatestExecutionIdQueryParams,
    LatestExecutionIdPathParams
  >(
    (paramsInPath: LatestExecutionIdPathParams) =>
      `/pipeline/execute/latestExecutionId/${paramsInPath.planExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * Latest ExecutionId from Retry Executions
 */
export const latestExecutionIdPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponseRetryLatestExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    LatestExecutionIdQueryParams,
    LatestExecutionIdPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseRetryLatestExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    LatestExecutionIdQueryParams,
    LatestExecutionIdPathParams
  >(getConfig('pipeline/api'), `/pipeline/execute/latestExecutionId/${planExecutionId}`, props, signal)

export interface HandleManualInterventionInterruptQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  interruptType:
    | 'AbortAll'
    | 'Abort'
    | 'Pause'
    | 'Resume'
    | 'Ignore'
    | 'StageRollback'
    | 'StepGroupRollback'
    | 'MarkAsSuccess'
    | 'ExpireAll'
    | 'Retry'
    | 'MarkAsFailure'
    | 'UserMarkedFailure'
}

export interface HandleManualInterventionInterruptPathParams {
  planExecutionId: string
  nodeExecutionId: string
}

export type HandleManualInterventionInterruptProps = Omit<
  MutateProps<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleManualInterventionInterruptPathParams

/**
 * Ignore,Abort,MarkAsSuccess,Retry on post manual intervention
 */
export const HandleManualInterventionInterrupt = ({
  planExecutionId,
  nodeExecutionId,
  ...props
}: HandleManualInterventionInterruptProps) => (
  <Mutate<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  >
    verb="PUT"
    path={`/pipeline/execute/manualIntervention/interrupt/${planExecutionId}/${nodeExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseHandleManualInterventionInterruptProps = Omit<
  UseMutateProps<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  >,
  'path' | 'verb'
> &
  HandleManualInterventionInterruptPathParams

/**
 * Ignore,Abort,MarkAsSuccess,Retry on post manual intervention
 */
export const useHandleManualInterventionInterrupt = ({
  planExecutionId,
  nodeExecutionId,
  ...props
}: UseHandleManualInterventionInterruptProps) =>
  useMutate<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  >(
    'PUT',
    (paramsInPath: HandleManualInterventionInterruptPathParams) =>
      `/pipeline/execute/manualIntervention/interrupt/${paramsInPath.planExecutionId}/${paramsInPath.nodeExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId, nodeExecutionId }, ...props }
  )

/**
 * Ignore,Abort,MarkAsSuccess,Retry on post manual intervention
 */
export const handleManualInterventionInterruptPromise = (
  {
    planExecutionId,
    nodeExecutionId,
    ...props
  }: MutateUsingFetchProps<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  > & { planExecutionId: string; nodeExecutionId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineExecutionInterrupt,
    Failure | AccessControlCheckError | Error,
    HandleManualInterventionInterruptQueryParams,
    void,
    HandleManualInterventionInterruptPathParams
  >(
    'PUT',
    getConfig('pipeline/api'),
    `/pipeline/execute/manualIntervention/interrupt/${planExecutionId}/${nodeExecutionId}`,
    props,
    signal
  )

export interface PostExecutionRollbackQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  stageNodeExecutionIds: string
  notesForPipelineExecution?: string
}

export interface PostExecutionRollbackPathParams {
  planExecutionId: string
}

export type PostExecutionRollbackProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostExecutionRollbackQueryParams,
    void,
    PostExecutionRollbackPathParams
  >,
  'path' | 'verb'
> &
  PostExecutionRollbackPathParams

/**
 * Rollback a previous Execution
 */
export const PostExecutionRollback = ({ planExecutionId, ...props }: PostExecutionRollbackProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostExecutionRollbackQueryParams,
    void,
    PostExecutionRollbackPathParams
  >
    verb="POST"
    path={`/pipeline/execute/postExecutionRollback/${planExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePostExecutionRollbackProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostExecutionRollbackQueryParams,
    void,
    PostExecutionRollbackPathParams
  >,
  'path' | 'verb'
> &
  PostExecutionRollbackPathParams

/**
 * Rollback a previous Execution
 */
export const usePostExecutionRollback = ({ planExecutionId, ...props }: UsePostExecutionRollbackProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostExecutionRollbackQueryParams,
    void,
    PostExecutionRollbackPathParams
  >(
    'POST',
    (paramsInPath: PostExecutionRollbackPathParams) =>
      `/pipeline/execute/postExecutionRollback/${paramsInPath.planExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * Rollback a previous Execution
 */
export const postExecutionRollbackPromise = (
  {
    planExecutionId,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostExecutionRollbackQueryParams,
    void,
    PostExecutionRollbackPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostExecutionRollbackQueryParams,
    void,
    PostExecutionRollbackPathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/postExecutionRollback/${planExecutionId}`, props, signal)

export interface StartPreflightCheckQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type StartPreflightCheckProps = Omit<
  MutateProps<ResponseString, Failure | AccessControlCheckError | Error, StartPreflightCheckQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * initiate pre flight check
 */
export const StartPreflightCheck = (props: StartPreflightCheckProps) => (
  <Mutate<ResponseString, Failure | AccessControlCheckError | Error, StartPreflightCheckQueryParams, void, void>
    verb="POST"
    path={`/pipeline/execute/preflightCheck`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseStartPreflightCheckProps = Omit<
  UseMutateProps<ResponseString, Failure | AccessControlCheckError | Error, StartPreflightCheckQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * initiate pre flight check
 */
export const useStartPreflightCheck = (props: UseStartPreflightCheckProps) =>
  useMutate<ResponseString, Failure | AccessControlCheckError | Error, StartPreflightCheckQueryParams, void, void>(
    'POST',
    `/pipeline/execute/preflightCheck`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * initiate pre flight check
 */
export const startPreflightCheckPromise = (
  props: MutateUsingFetchProps<
    ResponseString,
    Failure | AccessControlCheckError | Error,
    StartPreflightCheckQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseString,
    Failure | AccessControlCheckError | Error,
    StartPreflightCheckQueryParams,
    void,
    void
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/preflightCheck`, props, signal)

export interface RePostPipelineExecuteWithInputSetYamlV2QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  useFQNIfError?: boolean
  notesForPipelineExecution?: string
}

export interface RePostPipelineExecuteWithInputSetYamlV2PathParams {
  originalExecutionId: string
  identifier: string
}

export type RePostPipelineExecuteWithInputSetYamlV2Props = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlV2PathParams
  >,
  'path' | 'verb'
> &
  RePostPipelineExecuteWithInputSetYamlV2PathParams

/**
 * Re Execute a pipeline with inputSet pipeline yaml Version 2
 */
export const RePostPipelineExecuteWithInputSetYamlV2 = ({
  originalExecutionId,
  identifier,
  ...props
}: RePostPipelineExecuteWithInputSetYamlV2Props) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlV2PathParams
  >
    verb="POST"
    path={`/pipeline/execute/rerun/v2/${originalExecutionId}/${identifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRePostPipelineExecuteWithInputSetYamlV2Props = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlV2PathParams
  >,
  'path' | 'verb'
> &
  RePostPipelineExecuteWithInputSetYamlV2PathParams

/**
 * Re Execute a pipeline with inputSet pipeline yaml Version 2
 */
export const useRePostPipelineExecuteWithInputSetYamlV2 = ({
  originalExecutionId,
  identifier,
  ...props
}: UseRePostPipelineExecuteWithInputSetYamlV2Props) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlV2PathParams
  >(
    'POST',
    (paramsInPath: RePostPipelineExecuteWithInputSetYamlV2PathParams) =>
      `/pipeline/execute/rerun/v2/${paramsInPath.originalExecutionId}/${paramsInPath.identifier}`,
    { base: getConfig('pipeline/api'), pathParams: { originalExecutionId, identifier }, ...props }
  )

/**
 * Re Execute a pipeline with inputSet pipeline yaml Version 2
 */
export const rePostPipelineExecuteWithInputSetYamlV2Promise = (
  {
    originalExecutionId,
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlV2PathParams
  > & { originalExecutionId: string; identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetYamlV2QueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlV2PathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/rerun/v2/${originalExecutionId}/${identifier}`, props, signal)

export interface RePostPipelineExecuteWithInputSetYamlQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  useFQNIfError?: boolean
  notesForPipelineExecution?: string
}

export interface RePostPipelineExecuteWithInputSetYamlPathParams {
  originalExecutionId: string
  identifier: string
}

export type RePostPipelineExecuteWithInputSetYamlProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlPathParams
  >,
  'path' | 'verb'
> &
  RePostPipelineExecuteWithInputSetYamlPathParams

/**
 * Re Execute a pipeline with inputSet pipeline yaml
 */
export const RePostPipelineExecuteWithInputSetYaml = ({
  originalExecutionId,
  identifier,
  ...props
}: RePostPipelineExecuteWithInputSetYamlProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlPathParams
  >
    verb="POST"
    path={`/pipeline/execute/rerun/${originalExecutionId}/${identifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRePostPipelineExecuteWithInputSetYamlProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlPathParams
  >,
  'path' | 'verb'
> &
  RePostPipelineExecuteWithInputSetYamlPathParams

/**
 * Re Execute a pipeline with inputSet pipeline yaml
 */
export const useRePostPipelineExecuteWithInputSetYaml = ({
  originalExecutionId,
  identifier,
  ...props
}: UseRePostPipelineExecuteWithInputSetYamlProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlPathParams
  >(
    'POST',
    (paramsInPath: RePostPipelineExecuteWithInputSetYamlPathParams) =>
      `/pipeline/execute/rerun/${paramsInPath.originalExecutionId}/${paramsInPath.identifier}`,
    { base: getConfig('pipeline/api'), pathParams: { originalExecutionId, identifier }, ...props }
  )

/**
 * Re Execute a pipeline with inputSet pipeline yaml
 */
export const rePostPipelineExecuteWithInputSetYamlPromise = (
  {
    originalExecutionId,
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlPathParams
  > & { originalExecutionId: string; identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    RePostPipelineExecuteWithInputSetYamlPathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/rerun/${originalExecutionId}/${identifier}`, props, signal)

export interface RePostPipelineExecuteWithInputSetListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  useFQNIfError?: boolean
  notesForPipelineExecution?: string
}

export interface RePostPipelineExecuteWithInputSetListPathParams {
  originalExecutionId: string
  identifier: string
}

export type RePostPipelineExecuteWithInputSetListProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    RePostPipelineExecuteWithInputSetListPathParams
  >,
  'path' | 'verb'
> &
  RePostPipelineExecuteWithInputSetListPathParams

/**
 * Execute a pipeline with input set references list
 */
export const RePostPipelineExecuteWithInputSetList = ({
  originalExecutionId,
  identifier,
  ...props
}: RePostPipelineExecuteWithInputSetListProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    RePostPipelineExecuteWithInputSetListPathParams
  >
    verb="POST"
    path={`/pipeline/execute/rerun/${originalExecutionId}/${identifier}/inputSetList`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRePostPipelineExecuteWithInputSetListProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    RePostPipelineExecuteWithInputSetListPathParams
  >,
  'path' | 'verb'
> &
  RePostPipelineExecuteWithInputSetListPathParams

/**
 * Execute a pipeline with input set references list
 */
export const useRePostPipelineExecuteWithInputSetList = ({
  originalExecutionId,
  identifier,
  ...props
}: UseRePostPipelineExecuteWithInputSetListProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    RePostPipelineExecuteWithInputSetListPathParams
  >(
    'POST',
    (paramsInPath: RePostPipelineExecuteWithInputSetListPathParams) =>
      `/pipeline/execute/rerun/${paramsInPath.originalExecutionId}/${paramsInPath.identifier}/inputSetList`,
    { base: getConfig('pipeline/api'), pathParams: { originalExecutionId, identifier }, ...props }
  )

/**
 * Execute a pipeline with input set references list
 */
export const rePostPipelineExecuteWithInputSetListPromise = (
  {
    originalExecutionId,
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    RePostPipelineExecuteWithInputSetListPathParams
  > & { originalExecutionId: string; identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RePostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    RePostPipelineExecuteWithInputSetListPathParams
  >(
    'POST',
    getConfig('pipeline/api'),
    `/pipeline/execute/rerun/${originalExecutionId}/${identifier}/inputSetList`,
    props,
    signal
  )

export interface RerunStagesWithRuntimeInputYamlQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  useFQNIfError?: boolean
  notesForPipelineExecution?: string
}

export interface RerunStagesWithRuntimeInputYamlPathParams {
  originalExecutionId: string
  identifier: string
}

export type RerunStagesWithRuntimeInputYamlProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RerunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RerunStagesWithRuntimeInputYamlPathParams
  >,
  'path' | 'verb'
> &
  RerunStagesWithRuntimeInputYamlPathParams

/**
 * Rerun a pipeline with inputSet pipeline yaml
 */
export const RerunStagesWithRuntimeInputYaml = ({
  originalExecutionId,
  identifier,
  ...props
}: RerunStagesWithRuntimeInputYamlProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RerunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RerunStagesWithRuntimeInputYamlPathParams
  >
    verb="POST"
    path={`/pipeline/execute/rerun/${originalExecutionId}/${identifier}/stages`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRerunStagesWithRuntimeInputYamlProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RerunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RerunStagesWithRuntimeInputYamlPathParams
  >,
  'path' | 'verb'
> &
  RerunStagesWithRuntimeInputYamlPathParams

/**
 * Rerun a pipeline with inputSet pipeline yaml
 */
export const useRerunStagesWithRuntimeInputYaml = ({
  originalExecutionId,
  identifier,
  ...props
}: UseRerunStagesWithRuntimeInputYamlProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RerunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RerunStagesWithRuntimeInputYamlPathParams
  >(
    'POST',
    (paramsInPath: RerunStagesWithRuntimeInputYamlPathParams) =>
      `/pipeline/execute/rerun/${paramsInPath.originalExecutionId}/${paramsInPath.identifier}/stages`,
    { base: getConfig('pipeline/api'), pathParams: { originalExecutionId, identifier }, ...props }
  )

/**
 * Rerun a pipeline with inputSet pipeline yaml
 */
export const rerunStagesWithRuntimeInputYamlPromise = (
  {
    originalExecutionId,
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RerunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RerunStagesWithRuntimeInputYamlPathParams
  > & { originalExecutionId: string; identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RerunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RerunStagesWithRuntimeInputYamlPathParams
  >(
    'POST',
    getConfig('pipeline/api'),
    `/pipeline/execute/rerun/${originalExecutionId}/${identifier}/stages`,
    props,
    signal
  )

export interface RetryPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType?: string
  planExecutionId: string
  retryStages: string[]
  runAllStages?: boolean
  notesForPipelineExecution?: string
}

export interface RetryPipelinePathParams {
  identifier: string
}

export type RetryPipelineProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RetryPipelineQueryParams,
    void,
    RetryPipelinePathParams
  >,
  'path' | 'verb'
> &
  RetryPipelinePathParams

/**
 * Retry a executed pipeline with inputSet pipeline yaml
 */
export const RetryPipeline = ({ identifier, ...props }: RetryPipelineProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RetryPipelineQueryParams,
    void,
    RetryPipelinePathParams
  >
    verb="POST"
    path={`/pipeline/execute/retry/${identifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRetryPipelineProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RetryPipelineQueryParams,
    void,
    RetryPipelinePathParams
  >,
  'path' | 'verb'
> &
  RetryPipelinePathParams

/**
 * Retry a executed pipeline with inputSet pipeline yaml
 */
export const useRetryPipeline = ({ identifier, ...props }: UseRetryPipelineProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RetryPipelineQueryParams,
    void,
    RetryPipelinePathParams
  >('POST', (paramsInPath: RetryPipelinePathParams) => `/pipeline/execute/retry/${paramsInPath.identifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Retry a executed pipeline with inputSet pipeline yaml
 */
export const retryPipelinePromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RetryPipelineQueryParams,
    void,
    RetryPipelinePathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RetryPipelineQueryParams,
    void,
    RetryPipelinePathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/retry/${identifier}`, props, signal)

export interface RetryHistoryQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export interface RetryHistoryPathParams {
  planExecutionId: string
}

export type RetryHistoryProps = Omit<
  GetProps<
    ResponseRetryHistoryResponseDto,
    Failure | AccessControlCheckError | Error,
    RetryHistoryQueryParams,
    RetryHistoryPathParams
  >,
  'path'
> &
  RetryHistoryPathParams

/**
 * Retry History for a given execution
 */
export const RetryHistory = ({ planExecutionId, ...props }: RetryHistoryProps) => (
  <Get<
    ResponseRetryHistoryResponseDto,
    Failure | AccessControlCheckError | Error,
    RetryHistoryQueryParams,
    RetryHistoryPathParams
  >
    path={`/pipeline/execute/retryHistory/${planExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRetryHistoryProps = Omit<
  UseGetProps<
    ResponseRetryHistoryResponseDto,
    Failure | AccessControlCheckError | Error,
    RetryHistoryQueryParams,
    RetryHistoryPathParams
  >,
  'path'
> &
  RetryHistoryPathParams

/**
 * Retry History for a given execution
 */
export const useRetryHistory = ({ planExecutionId, ...props }: UseRetryHistoryProps) =>
  useGet<
    ResponseRetryHistoryResponseDto,
    Failure | AccessControlCheckError | Error,
    RetryHistoryQueryParams,
    RetryHistoryPathParams
  >((paramsInPath: RetryHistoryPathParams) => `/pipeline/execute/retryHistory/${paramsInPath.planExecutionId}`, {
    base: getConfig('pipeline/api'),
    pathParams: { planExecutionId },
    ...props
  })

/**
 * Retry History for a given execution
 */
export const retryHistoryPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponseRetryHistoryResponseDto,
    Failure | AccessControlCheckError | Error,
    RetryHistoryQueryParams,
    RetryHistoryPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseRetryHistoryResponseDto,
    Failure | AccessControlCheckError | Error,
    RetryHistoryQueryParams,
    RetryHistoryPathParams
  >(getConfig('pipeline/api'), `/pipeline/execute/retryHistory/${planExecutionId}`, props, signal)

export interface GetStagesExecutionListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetStagesExecutionListProps = Omit<
  GetProps<
    ResponseListStageExecutionResponse,
    Failure | AccessControlCheckError | Error,
    GetStagesExecutionListQueryParams,
    void
  >,
  'path'
>

/**
 * get list of stages for stage execution
 */
export const GetStagesExecutionList = (props: GetStagesExecutionListProps) => (
  <Get<
    ResponseListStageExecutionResponse,
    Failure | AccessControlCheckError | Error,
    GetStagesExecutionListQueryParams,
    void
  >
    path={`/pipeline/execute/stagesExecutionList`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetStagesExecutionListProps = Omit<
  UseGetProps<
    ResponseListStageExecutionResponse,
    Failure | AccessControlCheckError | Error,
    GetStagesExecutionListQueryParams,
    void
  >,
  'path'
>

/**
 * get list of stages for stage execution
 */
export const useGetStagesExecutionList = (props: UseGetStagesExecutionListProps) =>
  useGet<
    ResponseListStageExecutionResponse,
    Failure | AccessControlCheckError | Error,
    GetStagesExecutionListQueryParams,
    void
  >(`/pipeline/execute/stagesExecutionList`, { base: getConfig('pipeline/api'), ...props })

/**
 * get list of stages for stage execution
 */
export const getStagesExecutionListPromise = (
  props: GetUsingFetchProps<
    ResponseListStageExecutionResponse,
    Failure | AccessControlCheckError | Error,
    GetStagesExecutionListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseListStageExecutionResponse,
    Failure | AccessControlCheckError | Error,
    GetStagesExecutionListQueryParams,
    void
  >(getConfig('pipeline/api'), `/pipeline/execute/stagesExecutionList`, props, signal)

export interface PostPipelineExecuteWithInputSetYamlQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  useFQNIfError?: boolean
  notifyOnlyUser?: boolean
  notesForPipelineExecution?: string
}

export interface PostPipelineExecuteWithInputSetYamlPathParams {
  identifier: string
}

export type PostPipelineExecuteWithInputSetYamlProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetYamlPathParams

/**
 * Execute a pipeline with inputSet pipeline YAML
 */
export const PostPipelineExecuteWithInputSetYaml = ({
  identifier,
  ...props
}: PostPipelineExecuteWithInputSetYamlProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  >
    verb="POST"
    path={`/pipeline/execute/${identifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePostPipelineExecuteWithInputSetYamlProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetYamlPathParams

/**
 * Execute a pipeline with inputSet pipeline YAML
 */
export const usePostPipelineExecuteWithInputSetYaml = ({
  identifier,
  ...props
}: UsePostPipelineExecuteWithInputSetYamlProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  >(
    'POST',
    (paramsInPath: PostPipelineExecuteWithInputSetYamlPathParams) => `/pipeline/execute/${paramsInPath.identifier}`,
    { base: getConfig('pipeline/api'), pathParams: { identifier }, ...props }
  )

/**
 * Execute a pipeline with inputSet pipeline YAML
 */
export const postPipelineExecuteWithInputSetYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetYamlQueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlPathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/${identifier}`, props, signal)

export interface PostPipelineExecuteWithInputSetListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  useFQNIfError?: boolean
  notesForPipelineExecution?: string
}

export interface PostPipelineExecuteWithInputSetListPathParams {
  identifier: string
}

export type PostPipelineExecuteWithInputSetListProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetListPathParams

/**
 * Execute a pipeline with input set references list
 */
export const PostPipelineExecuteWithInputSetList = ({
  identifier,
  ...props
}: PostPipelineExecuteWithInputSetListProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >
    verb="POST"
    path={`/pipeline/execute/${identifier}/inputSetList`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePostPipelineExecuteWithInputSetListProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetListPathParams

/**
 * Execute a pipeline with input set references list
 */
export const usePostPipelineExecuteWithInputSetList = ({
  identifier,
  ...props
}: UsePostPipelineExecuteWithInputSetListProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >(
    'POST',
    (paramsInPath: PostPipelineExecuteWithInputSetListPathParams) =>
      `/pipeline/execute/${paramsInPath.identifier}/inputSetList`,
    { base: getConfig('pipeline/api'), pathParams: { identifier }, ...props }
  )

/**
 * Execute a pipeline with input set references list
 */
export const postPipelineExecuteWithInputSetListPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetListQueryParams,
    MergeInputSetRequestRequestBody,
    PostPipelineExecuteWithInputSetListPathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/${identifier}/inputSetList`, props, signal)

export interface RunStagesWithRuntimeInputYamlQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  useFQNIfError?: boolean
  notesForPipelineExecution?: string
}

export interface RunStagesWithRuntimeInputYamlPathParams {
  identifier: string
}

export type RunStagesWithRuntimeInputYamlProps = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RunStagesWithRuntimeInputYamlPathParams
  >,
  'path' | 'verb'
> &
  RunStagesWithRuntimeInputYamlPathParams

/**
 * Execute a pipeline with inputSet pipeline yaml
 */
export const RunStagesWithRuntimeInputYaml = ({ identifier, ...props }: RunStagesWithRuntimeInputYamlProps) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RunStagesWithRuntimeInputYamlPathParams
  >
    verb="POST"
    path={`/pipeline/execute/${identifier}/stages`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRunStagesWithRuntimeInputYamlProps = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RunStagesWithRuntimeInputYamlPathParams
  >,
  'path' | 'verb'
> &
  RunStagesWithRuntimeInputYamlPathParams

/**
 * Execute a pipeline with inputSet pipeline yaml
 */
export const useRunStagesWithRuntimeInputYaml = ({ identifier, ...props }: UseRunStagesWithRuntimeInputYamlProps) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RunStagesWithRuntimeInputYamlPathParams
  >(
    'POST',
    (paramsInPath: RunStagesWithRuntimeInputYamlPathParams) => `/pipeline/execute/${paramsInPath.identifier}/stages`,
    { base: getConfig('pipeline/api'), pathParams: { identifier }, ...props }
  )

/**
 * Execute a pipeline with inputSet pipeline yaml
 */
export const runStagesWithRuntimeInputYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RunStagesWithRuntimeInputYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    RunStagesWithRuntimeInputYamlQueryParams,
    RunStageRequestDTORequestBody,
    RunStagesWithRuntimeInputYamlPathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/${identifier}/stages`, props, signal)

export interface PostPipelineExecuteWithInputSetYamlv2QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  moduleType?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  useFQNIfError?: boolean
  notesForPipelineExecution?: string
}

export interface PostPipelineExecuteWithInputSetYamlv2PathParams {
  identifier: string
}

export type PostPipelineExecuteWithInputSetYamlv2Props = Omit<
  MutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetYamlv2QueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlv2PathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetYamlv2PathParams

/**
 * Execute a pipeline with inputSet pipeline YAML V2
 */
export const PostPipelineExecuteWithInputSetYamlv2 = ({
  identifier,
  ...props
}: PostPipelineExecuteWithInputSetYamlv2Props) => (
  <Mutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetYamlv2QueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlv2PathParams
  >
    verb="POST"
    path={`/pipeline/execute/${identifier}/v2`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePostPipelineExecuteWithInputSetYamlv2Props = Omit<
  UseMutateProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetYamlv2QueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlv2PathParams
  >,
  'path' | 'verb'
> &
  PostPipelineExecuteWithInputSetYamlv2PathParams

/**
 * Execute a pipeline with inputSet pipeline YAML V2
 */
export const usePostPipelineExecuteWithInputSetYamlv2 = ({
  identifier,
  ...props
}: UsePostPipelineExecuteWithInputSetYamlv2Props) =>
  useMutate<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetYamlv2QueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlv2PathParams
  >(
    'POST',
    (paramsInPath: PostPipelineExecuteWithInputSetYamlv2PathParams) =>
      `/pipeline/execute/${paramsInPath.identifier}/v2`,
    { base: getConfig('pipeline/api'), pathParams: { identifier }, ...props }
  )

/**
 * Execute a pipeline with inputSet pipeline YAML V2
 */
export const postPipelineExecuteWithInputSetYamlv2Promise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetYamlv2QueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlv2PathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePlanExecutionResponseDto,
    Failure | AccessControlCheckError | Error,
    PostPipelineExecuteWithInputSetYamlv2QueryParams,
    void,
    PostPipelineExecuteWithInputSetYamlv2PathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execute/${identifier}/v2`, props, signal)

export interface GetRetryStagesQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export interface GetRetryStagesPathParams {
  planExecutionId: string
}

export type GetRetryStagesProps = Omit<
  GetProps<
    ResponseRetryInfo,
    Failure | AccessControlCheckError | Error,
    GetRetryStagesQueryParams,
    GetRetryStagesPathParams
  >,
  'path'
> &
  GetRetryStagesPathParams

/**
 * Get retry stages for failed pipeline
 */
export const GetRetryStages = ({ planExecutionId, ...props }: GetRetryStagesProps) => (
  <Get<
    ResponseRetryInfo,
    Failure | AccessControlCheckError | Error,
    GetRetryStagesQueryParams,
    GetRetryStagesPathParams
  >
    path={`/pipeline/execute/${planExecutionId}/retryStages`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetRetryStagesProps = Omit<
  UseGetProps<
    ResponseRetryInfo,
    Failure | AccessControlCheckError | Error,
    GetRetryStagesQueryParams,
    GetRetryStagesPathParams
  >,
  'path'
> &
  GetRetryStagesPathParams

/**
 * Get retry stages for failed pipeline
 */
export const useGetRetryStages = ({ planExecutionId, ...props }: UseGetRetryStagesProps) =>
  useGet<
    ResponseRetryInfo,
    Failure | AccessControlCheckError | Error,
    GetRetryStagesQueryParams,
    GetRetryStagesPathParams
  >((paramsInPath: GetRetryStagesPathParams) => `/pipeline/execute/${paramsInPath.planExecutionId}/retryStages`, {
    base: getConfig('pipeline/api'),
    pathParams: { planExecutionId },
    ...props
  })

/**
 * Get retry stages for failed pipeline
 */
export const getRetryStagesPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponseRetryInfo,
    Failure | AccessControlCheckError | Error,
    GetRetryStagesQueryParams,
    GetRetryStagesPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseRetryInfo,
    Failure | AccessControlCheckError | Error,
    GetRetryStagesQueryParams,
    GetRetryStagesPathParams
  >(getConfig('pipeline/api'), `/pipeline/execute/${planExecutionId}/retryStages`, props, signal)

export interface CreateVariablesForPipelineExecutionQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  planExecutionId: string
}

export type CreateVariablesForPipelineExecutionProps = Omit<
  MutateProps<
    ResponseExecutionInputVariablesResponse,
    Failure | Error,
    CreateVariablesForPipelineExecutionQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Create variables for Pipeline at execution time
 */
export const CreateVariablesForPipelineExecution = (props: CreateVariablesForPipelineExecutionProps) => (
  <Mutate<
    ResponseExecutionInputVariablesResponse,
    Failure | Error,
    CreateVariablesForPipelineExecutionQueryParams,
    void,
    void
  >
    verb="POST"
    path={`/pipeline/execution-input/variables`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreateVariablesForPipelineExecutionProps = Omit<
  UseMutateProps<
    ResponseExecutionInputVariablesResponse,
    Failure | Error,
    CreateVariablesForPipelineExecutionQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Create variables for Pipeline at execution time
 */
export const useCreateVariablesForPipelineExecution = (props: UseCreateVariablesForPipelineExecutionProps) =>
  useMutate<
    ResponseExecutionInputVariablesResponse,
    Failure | Error,
    CreateVariablesForPipelineExecutionQueryParams,
    void,
    void
  >('POST', `/pipeline/execution-input/variables`, { base: getConfig('pipeline/api'), ...props })

/**
 * Create variables for Pipeline at execution time
 */
export const createVariablesForPipelineExecutionPromise = (
  props: MutateUsingFetchProps<
    ResponseExecutionInputVariablesResponse,
    Failure | Error,
    CreateVariablesForPipelineExecutionQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseExecutionInputVariablesResponse,
    Failure | Error,
    CreateVariablesForPipelineExecutionQueryParams,
    void,
    void
  >('POST', getConfig('pipeline/api'), `/pipeline/execution-input/variables`, props, signal)

export interface GetExecutionInputTemplateQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface GetExecutionInputTemplatePathParams {
  nodeExecutionId: string
}

export type GetExecutionInputTemplateProps = Omit<
  GetProps<
    ResponseExecutionInputDTO,
    Failure | Error,
    GetExecutionInputTemplateQueryParams,
    GetExecutionInputTemplatePathParams
  >,
  'path'
> &
  GetExecutionInputTemplatePathParams

/**
 * Get the template for Execution time inputs for any step
 */
export const GetExecutionInputTemplate = ({ nodeExecutionId, ...props }: GetExecutionInputTemplateProps) => (
  <Get<
    ResponseExecutionInputDTO,
    Failure | Error,
    GetExecutionInputTemplateQueryParams,
    GetExecutionInputTemplatePathParams
  >
    path={`/pipeline/execution-input/${nodeExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExecutionInputTemplateProps = Omit<
  UseGetProps<
    ResponseExecutionInputDTO,
    Failure | Error,
    GetExecutionInputTemplateQueryParams,
    GetExecutionInputTemplatePathParams
  >,
  'path'
> &
  GetExecutionInputTemplatePathParams

/**
 * Get the template for Execution time inputs for any step
 */
export const useGetExecutionInputTemplate = ({ nodeExecutionId, ...props }: UseGetExecutionInputTemplateProps) =>
  useGet<
    ResponseExecutionInputDTO,
    Failure | Error,
    GetExecutionInputTemplateQueryParams,
    GetExecutionInputTemplatePathParams
  >(
    (paramsInPath: GetExecutionInputTemplatePathParams) => `/pipeline/execution-input/${paramsInPath.nodeExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { nodeExecutionId }, ...props }
  )

/**
 * Get the template for Execution time inputs for any step
 */
export const getExecutionInputTemplatePromise = (
  {
    nodeExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponseExecutionInputDTO,
    Failure | Error,
    GetExecutionInputTemplateQueryParams,
    GetExecutionInputTemplatePathParams
  > & { nodeExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseExecutionInputDTO,
    Failure | Error,
    GetExecutionInputTemplateQueryParams,
    GetExecutionInputTemplatePathParams
  >(getConfig('pipeline/api'), `/pipeline/execution-input/${nodeExecutionId}`, props, signal)

export interface SubmitExecutionInputQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface SubmitExecutionInputPathParams {
  nodeExecutionId: string
}

export type SubmitExecutionInputProps = Omit<
  MutateProps<
    ResponseExecutionInputStatus,
    Failure | Error,
    SubmitExecutionInputQueryParams,
    GetExpressionEvaluatedBodyRequestBody,
    SubmitExecutionInputPathParams
  >,
  'path' | 'verb'
> &
  SubmitExecutionInputPathParams

/**
 * Submit the Execution Input for a Stage/Step and continue Pipeline execution
 */
export const SubmitExecutionInput = ({ nodeExecutionId, ...props }: SubmitExecutionInputProps) => (
  <Mutate<
    ResponseExecutionInputStatus,
    Failure | Error,
    SubmitExecutionInputQueryParams,
    GetExpressionEvaluatedBodyRequestBody,
    SubmitExecutionInputPathParams
  >
    verb="POST"
    path={`/pipeline/execution-input/${nodeExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseSubmitExecutionInputProps = Omit<
  UseMutateProps<
    ResponseExecutionInputStatus,
    Failure | Error,
    SubmitExecutionInputQueryParams,
    GetExpressionEvaluatedBodyRequestBody,
    SubmitExecutionInputPathParams
  >,
  'path' | 'verb'
> &
  SubmitExecutionInputPathParams

/**
 * Submit the Execution Input for a Stage/Step and continue Pipeline execution
 */
export const useSubmitExecutionInput = ({ nodeExecutionId, ...props }: UseSubmitExecutionInputProps) =>
  useMutate<
    ResponseExecutionInputStatus,
    Failure | Error,
    SubmitExecutionInputQueryParams,
    GetExpressionEvaluatedBodyRequestBody,
    SubmitExecutionInputPathParams
  >(
    'POST',
    (paramsInPath: SubmitExecutionInputPathParams) => `/pipeline/execution-input/${paramsInPath.nodeExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { nodeExecutionId }, ...props }
  )

/**
 * Submit the Execution Input for a Stage/Step and continue Pipeline execution
 */
export const submitExecutionInputPromise = (
  {
    nodeExecutionId,
    ...props
  }: MutateUsingFetchProps<
    ResponseExecutionInputStatus,
    Failure | Error,
    SubmitExecutionInputQueryParams,
    GetExpressionEvaluatedBodyRequestBody,
    SubmitExecutionInputPathParams
  > & { nodeExecutionId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseExecutionInputStatus,
    Failure | Error,
    SubmitExecutionInputQueryParams,
    GetExpressionEvaluatedBodyRequestBody,
    SubmitExecutionInputPathParams
  >('POST', getConfig('pipeline/api'), `/pipeline/execution-input/${nodeExecutionId}`, props, signal)

export interface CreatePipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  identifier?: string
  name?: string
  description?: string
  skipValidation?: boolean
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  repoName?: string
}

export type CreatePipelineProps = Omit<
  MutateProps<ResponseString, Failure | Error, CreatePipelineQueryParams, UpdateTriggerBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const CreatePipeline = (props: CreatePipelineProps) => (
  <Mutate<ResponseString, Failure | Error, CreatePipelineQueryParams, UpdateTriggerBodyRequestBody, void>
    verb="POST"
    path={`/pipelines`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreatePipelineProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, CreatePipelineQueryParams, UpdateTriggerBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const useCreatePipeline = (props: UseCreatePipelineProps) =>
  useMutate<ResponseString, Failure | Error, CreatePipelineQueryParams, UpdateTriggerBodyRequestBody, void>(
    'POST',
    `/pipelines`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Create a Pipeline
 */
export const createPipelinePromise = (
  props: MutateUsingFetchProps<
    ResponseString,
    Failure | Error,
    CreatePipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, CreatePipelineQueryParams, UpdateTriggerBodyRequestBody, void>(
    'POST',
    getConfig('pipeline/api'),
    `/pipelines`,
    props,
    signal
  )

export interface ClonePipelineQueryParams {
  accountIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  repoName?: string
}

export type ClonePipelineProps = Omit<
  MutateProps<ResponsePipelineSaveResponse, Failure | Error, ClonePipelineQueryParams, ClonePipelineProperties, void>,
  'path' | 'verb'
>

/**
 * Clone a Pipeline
 */
export const ClonePipeline = (props: ClonePipelineProps) => (
  <Mutate<ResponsePipelineSaveResponse, Failure | Error, ClonePipelineQueryParams, ClonePipelineProperties, void>
    verb="POST"
    path={`/pipelines/clone`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseClonePipelineProps = Omit<
  UseMutateProps<
    ResponsePipelineSaveResponse,
    Failure | Error,
    ClonePipelineQueryParams,
    ClonePipelineProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * Clone a Pipeline
 */
export const useClonePipeline = (props: UseClonePipelineProps) =>
  useMutate<ResponsePipelineSaveResponse, Failure | Error, ClonePipelineQueryParams, ClonePipelineProperties, void>(
    'POST',
    `/pipelines/clone`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Clone a Pipeline
 */
export const clonePipelinePromise = (
  props: MutateUsingFetchProps<
    ResponsePipelineSaveResponse,
    Failure | Error,
    ClonePipelineQueryParams,
    ClonePipelineProperties,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineSaveResponse,
    Failure | Error,
    ClonePipelineQueryParams,
    ClonePipelineProperties,
    void
  >('POST', getConfig('pipeline/api'), `/pipelines/clone`, props, signal)

export type DummyPmsStepsApiProps = Omit<GetProps<ResponsePmsAbstractStepNode, Failure | Error, void, void>, 'path'>

/**
 * This is dummy api to expose pmsSteps
 */
export const DummyPmsStepsApi = (props: DummyPmsStepsApiProps) => (
  <Get<ResponsePmsAbstractStepNode, Failure | Error, void, void>
    path={`/pipelines/dummy-pmsSteps-api`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDummyPmsStepsApiProps = Omit<
  UseGetProps<ResponsePmsAbstractStepNode, Failure | Error, void, void>,
  'path'
>

/**
 * This is dummy api to expose pmsSteps
 */
export const useDummyPmsStepsApi = (props: UseDummyPmsStepsApiProps) =>
  useGet<ResponsePmsAbstractStepNode, Failure | Error, void, void>(`/pipelines/dummy-pmsSteps-api`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * This is dummy api to expose pmsSteps
 */
export const dummyPmsStepsApiPromise = (
  props: GetUsingFetchProps<ResponsePmsAbstractStepNode, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePmsAbstractStepNode, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/pipelines/dummy-pmsSteps-api`,
    props,
    signal
  )

export type DummyTemplateStageApiProps = Omit<GetProps<ResponseTemplateStageNode, Failure | Error, void, void>, 'path'>

/**
 * This is dummy api to expose templateStageNode
 */
export const DummyTemplateStageApi = (props: DummyTemplateStageApiProps) => (
  <Get<ResponseTemplateStageNode, Failure | Error, void, void>
    path={`/pipelines/dummy-templateStage-api`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDummyTemplateStageApiProps = Omit<
  UseGetProps<ResponseTemplateStageNode, Failure | Error, void, void>,
  'path'
>

/**
 * This is dummy api to expose templateStageNode
 */
export const useDummyTemplateStageApi = (props: UseDummyTemplateStageApiProps) =>
  useGet<ResponseTemplateStageNode, Failure | Error, void, void>(`/pipelines/dummy-templateStage-api`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * This is dummy api to expose templateStageNode
 */
export const dummyTemplateStageApiPromise = (
  props: GetUsingFetchProps<ResponseTemplateStageNode, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseTemplateStageNode, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/pipelines/dummy-templateStage-api`,
    props,
    signal
  )

export type DummyTemplateStepApiProps = Omit<GetProps<ResponseTemplateStepNode, Failure | Error, void, void>, 'path'>

/**
 * This is dummy api to expose templateStepNode
 */
export const DummyTemplateStepApi = (props: DummyTemplateStepApiProps) => (
  <Get<ResponseTemplateStepNode, Failure | Error, void, void>
    path={`/pipelines/dummy-templateStep-api`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDummyTemplateStepApiProps = Omit<
  UseGetProps<ResponseTemplateStepNode, Failure | Error, void, void>,
  'path'
>

/**
 * This is dummy api to expose templateStepNode
 */
export const useDummyTemplateStepApi = (props: UseDummyTemplateStepApiProps) =>
  useGet<ResponseTemplateStepNode, Failure | Error, void, void>(`/pipelines/dummy-templateStep-api`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * This is dummy api to expose templateStepNode
 */
export const dummyTemplateStepApiPromise = (
  props: GetUsingFetchProps<ResponseTemplateStepNode, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseTemplateStepNode, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/pipelines/dummy-templateStep-api`,
    props,
    signal
  )

export interface GetListOfExecutionIdentifierQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier?: string
  page?: number
  size?: number
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetListOfExecutionIdentifierProps = Omit<
  MutateProps<
    ResponsePagePipelineExecutionIdentifierSummary,
    Failure | Error,
    GetListOfExecutionIdentifierQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Executions Id list
 */
export const GetListOfExecutionIdentifier = (props: GetListOfExecutionIdentifierProps) => (
  <Mutate<
    ResponsePagePipelineExecutionIdentifierSummary,
    Failure | Error,
    GetListOfExecutionIdentifierQueryParams,
    void,
    void
  >
    verb="POST"
    path={`/pipelines/execution/executionSummary`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetListOfExecutionIdentifierProps = Omit<
  UseMutateProps<
    ResponsePagePipelineExecutionIdentifierSummary,
    Failure | Error,
    GetListOfExecutionIdentifierQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Executions Id list
 */
export const useGetListOfExecutionIdentifier = (props: UseGetListOfExecutionIdentifierProps) =>
  useMutate<
    ResponsePagePipelineExecutionIdentifierSummary,
    Failure | Error,
    GetListOfExecutionIdentifierQueryParams,
    void,
    void
  >('POST', `/pipelines/execution/executionSummary`, { base: getConfig('pipeline/api'), ...props })

/**
 * Gets Executions Id list
 */
export const getListOfExecutionIdentifierPromise = (
  props: MutateUsingFetchProps<
    ResponsePagePipelineExecutionIdentifierSummary,
    Failure | Error,
    GetListOfExecutionIdentifierQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePagePipelineExecutionIdentifierSummary,
    Failure | Error,
    GetListOfExecutionIdentifierQueryParams,
    void,
    void
  >('POST', getConfig('pipeline/api'), `/pipelines/execution/executionSummary`, props, signal)

export interface GetExecutionBranchesListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier?: string
  repoName?: string
}

export type GetExecutionBranchesListProps = Omit<
  GetProps<ResponsePMSPipelineListBranchesResponse, Failure | Error, GetExecutionBranchesListQueryParams, void>,
  'path'
>

/**
 * Gets execution branches list
 */
export const GetExecutionBranchesList = (props: GetExecutionBranchesListProps) => (
  <Get<ResponsePMSPipelineListBranchesResponse, Failure | Error, GetExecutionBranchesListQueryParams, void>
    path={`/pipelines/execution/list-branches`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExecutionBranchesListProps = Omit<
  UseGetProps<ResponsePMSPipelineListBranchesResponse, Failure | Error, GetExecutionBranchesListQueryParams, void>,
  'path'
>

/**
 * Gets execution branches list
 */
export const useGetExecutionBranchesList = (props: UseGetExecutionBranchesListProps) =>
  useGet<ResponsePMSPipelineListBranchesResponse, Failure | Error, GetExecutionBranchesListQueryParams, void>(
    `/pipelines/execution/list-branches`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Gets execution branches list
 */
export const getExecutionBranchesListPromise = (
  props: GetUsingFetchProps<
    ResponsePMSPipelineListBranchesResponse,
    Failure | Error,
    GetExecutionBranchesListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePMSPipelineListBranchesResponse, Failure | Error, GetExecutionBranchesListQueryParams, void>(
    getConfig('pipeline/api'),
    `/pipelines/execution/list-branches`,
    props,
    signal
  )

export interface GetExecutionRepositoriesListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier?: string
}

export type GetExecutionRepositoriesListProps = Omit<
  GetProps<ResponsePMSPipelineListRepoResponse, Failure | Error, GetExecutionRepositoriesListQueryParams, void>,
  'path'
>

/**
 * Gets execution repositories list
 */
export const GetExecutionRepositoriesList = (props: GetExecutionRepositoriesListProps) => (
  <Get<ResponsePMSPipelineListRepoResponse, Failure | Error, GetExecutionRepositoriesListQueryParams, void>
    path={`/pipelines/execution/list-repositories`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExecutionRepositoriesListProps = Omit<
  UseGetProps<ResponsePMSPipelineListRepoResponse, Failure | Error, GetExecutionRepositoriesListQueryParams, void>,
  'path'
>

/**
 * Gets execution repositories list
 */
export const useGetExecutionRepositoriesList = (props: UseGetExecutionRepositoriesListProps) =>
  useGet<ResponsePMSPipelineListRepoResponse, Failure | Error, GetExecutionRepositoriesListQueryParams, void>(
    `/pipelines/execution/list-repositories`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Gets execution repositories list
 */
export const getExecutionRepositoriesListPromise = (
  props: GetUsingFetchProps<
    ResponsePMSPipelineListRepoResponse,
    Failure | Error,
    GetExecutionRepositoriesListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePMSPipelineListRepoResponse, Failure | Error, GetExecutionRepositoriesListQueryParams, void>(
    getConfig('pipeline/api'),
    `/pipelines/execution/list-repositories`,
    props,
    signal
  )

export interface GetExecutionSubGraphForNodeExecutionQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface GetExecutionSubGraphForNodeExecutionPathParams {
  planExecutionId: string
  nodeExecutionId: string
}

export type GetExecutionSubGraphForNodeExecutionProps = Omit<
  GetProps<
    ResponseNodeExecutionDetails,
    Failure | Error,
    GetExecutionSubGraphForNodeExecutionQueryParams,
    GetExecutionSubGraphForNodeExecutionPathParams
  >,
  'path'
> &
  GetExecutionSubGraphForNodeExecutionPathParams

/**
 * Gets Execution SubGraph for nodeExecutionId
 */
export const GetExecutionSubGraphForNodeExecution = ({
  planExecutionId,
  nodeExecutionId,
  ...props
}: GetExecutionSubGraphForNodeExecutionProps) => (
  <Get<
    ResponseNodeExecutionDetails,
    Failure | Error,
    GetExecutionSubGraphForNodeExecutionQueryParams,
    GetExecutionSubGraphForNodeExecutionPathParams
  >
    path={`/pipelines/execution/subGraph/${planExecutionId}/${nodeExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExecutionSubGraphForNodeExecutionProps = Omit<
  UseGetProps<
    ResponseNodeExecutionDetails,
    Failure | Error,
    GetExecutionSubGraphForNodeExecutionQueryParams,
    GetExecutionSubGraphForNodeExecutionPathParams
  >,
  'path'
> &
  GetExecutionSubGraphForNodeExecutionPathParams

/**
 * Gets Execution SubGraph for nodeExecutionId
 */
export const useGetExecutionSubGraphForNodeExecution = ({
  planExecutionId,
  nodeExecutionId,
  ...props
}: UseGetExecutionSubGraphForNodeExecutionProps) =>
  useGet<
    ResponseNodeExecutionDetails,
    Failure | Error,
    GetExecutionSubGraphForNodeExecutionQueryParams,
    GetExecutionSubGraphForNodeExecutionPathParams
  >(
    (paramsInPath: GetExecutionSubGraphForNodeExecutionPathParams) =>
      `/pipelines/execution/subGraph/${paramsInPath.planExecutionId}/${paramsInPath.nodeExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId, nodeExecutionId }, ...props }
  )

/**
 * Gets Execution SubGraph for nodeExecutionId
 */
export const getExecutionSubGraphForNodeExecutionPromise = (
  {
    planExecutionId,
    nodeExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponseNodeExecutionDetails,
    Failure | Error,
    GetExecutionSubGraphForNodeExecutionQueryParams,
    GetExecutionSubGraphForNodeExecutionPathParams
  > & { planExecutionId: string; nodeExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseNodeExecutionDetails,
    Failure | Error,
    GetExecutionSubGraphForNodeExecutionQueryParams,
    GetExecutionSubGraphForNodeExecutionPathParams
  >(getConfig('pipeline/api'), `/pipelines/execution/subGraph/${planExecutionId}/${nodeExecutionId}`, props, signal)

export interface GetListOfExecutionsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  searchTerm?: string
  pipelineIdentifier?: string
  page?: number
  size?: number
  sort?: string[]
  filterIdentifier?: string
  showAllExecutions?: boolean
  module?: string
  status?: (
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'WaitStepRunning'
    | 'QueuedLicenseLimitReached'
    | 'QueuedExecutionConcurrencyReached'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'InputWaiting'
    | 'AbortedByFreeze'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
  )[]
  myDeployments?: boolean
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetListOfExecutionsProps = Omit<
  MutateProps<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Executions list
 */
export const GetListOfExecutions = (props: GetListOfExecutionsProps) => (
  <Mutate<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >
    verb="POST"
    path={`/pipelines/execution/summary`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetListOfExecutionsProps = Omit<
  UseMutateProps<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Executions list
 */
export const useGetListOfExecutions = (props: UseGetListOfExecutionsProps) =>
  useMutate<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >('POST', `/pipelines/execution/summary`, { base: getConfig('pipeline/api'), ...props })

/**
 * Gets Executions list
 */
export const getListOfExecutionsPromise = (
  props: MutateUsingFetchProps<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsQueryParams,
    FilterPropertiesRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/pipelines/execution/summary`, props, signal)

export interface GetListOfExecutionsForMultiplePipelinesIdentifiersWithOrOperatorsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier?: string[]
  page?: number
  size?: number
  filterIdentifier?: string
}

export type GetListOfExecutionsForMultiplePipelinesIdentifiersWithOrOperatorsProps = Omit<
  MutateProps<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsForMultiplePipelinesIdentifiersWithOrOperatorsQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Executions list for multiple pipeline filters with OR operator
 */
export const GetListOfExecutionsForMultiplePipelinesIdentifiersWithOrOperators = (
  props: GetListOfExecutionsForMultiplePipelinesIdentifiersWithOrOperatorsProps
) => (
  <Mutate<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsForMultiplePipelinesIdentifiersWithOrOperatorsQueryParams,
    FilterPropertiesRequestBody,
    void
  >
    verb="POST"
    path={`/pipelines/execution/v2/summary`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetListOfExecutionsForMultiplePipelinesIdentifiersWithOrOperatorsProps = Omit<
  UseMutateProps<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsForMultiplePipelinesIdentifiersWithOrOperatorsQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Executions list for multiple pipeline filters with OR operator
 */
export const useGetListOfExecutionsForMultiplePipelinesIdentifiersWithOrOperators = (
  props: UseGetListOfExecutionsForMultiplePipelinesIdentifiersWithOrOperatorsProps
) =>
  useMutate<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsForMultiplePipelinesIdentifiersWithOrOperatorsQueryParams,
    FilterPropertiesRequestBody,
    void
  >('POST', `/pipelines/execution/v2/summary`, { base: getConfig('pipeline/api'), ...props })

/**
 * Gets Executions list for multiple pipeline filters with OR operator
 */
export const getListOfExecutionsForMultiplePipelinesIdentifiersWithOrOperatorsPromise = (
  props: MutateUsingFetchProps<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsForMultiplePipelinesIdentifiersWithOrOperatorsQueryParams,
    FilterPropertiesRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePagePipelineExecutionSummary,
    Failure | Error,
    GetListOfExecutionsForMultiplePipelinesIdentifiersWithOrOperatorsQueryParams,
    FilterPropertiesRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/pipelines/execution/v2/summary`, props, signal)

export interface GetExecutionDetailV2QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  stageNodeId?: string
  stageNodeExecutionId?: string
  childStageNodeId?: string
  renderFullBottomGraph?: boolean
}

export interface GetExecutionDetailV2PathParams {
  planExecutionId: string
}

export type GetExecutionDetailV2Props = Omit<
  GetProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailV2QueryParams,
    GetExecutionDetailV2PathParams
  >,
  'path'
> &
  GetExecutionDetailV2PathParams

/**
 * Gets Execution Detail V2
 */
export const GetExecutionDetailV2 = ({ planExecutionId, ...props }: GetExecutionDetailV2Props) => (
  <Get<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailV2QueryParams,
    GetExecutionDetailV2PathParams
  >
    path={`/pipelines/execution/v2/${planExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExecutionDetailV2Props = Omit<
  UseGetProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailV2QueryParams,
    GetExecutionDetailV2PathParams
  >,
  'path'
> &
  GetExecutionDetailV2PathParams

/**
 * Gets Execution Detail V2
 */
export const useGetExecutionDetailV2 = ({ planExecutionId, ...props }: UseGetExecutionDetailV2Props) =>
  useGet<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailV2QueryParams,
    GetExecutionDetailV2PathParams
  >((paramsInPath: GetExecutionDetailV2PathParams) => `/pipelines/execution/v2/${paramsInPath.planExecutionId}`, {
    base: getConfig('pipeline/api'),
    pathParams: { planExecutionId },
    ...props
  })

/**
 * Gets Execution Detail V2
 */
export const getExecutionDetailV2Promise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailV2QueryParams,
    GetExecutionDetailV2PathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailV2QueryParams,
    GetExecutionDetailV2PathParams
  >(getConfig('pipeline/api'), `/pipelines/execution/v2/${planExecutionId}`, props, signal)

export interface GetExecutionDetailQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  stageNodeId?: string
  stageNodeExecutionId?: string
}

export interface GetExecutionDetailPathParams {
  planExecutionId: string
}

export type GetExecutionDetailProps = Omit<
  GetProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailQueryParams,
    GetExecutionDetailPathParams
  >,
  'path'
> &
  GetExecutionDetailPathParams

/**
 * Gets Execution Detail
 */
export const GetExecutionDetail = ({ planExecutionId, ...props }: GetExecutionDetailProps) => (
  <Get<ResponsePipelineExecutionDetail, Failure | Error, GetExecutionDetailQueryParams, GetExecutionDetailPathParams>
    path={`/pipelines/execution/${planExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExecutionDetailProps = Omit<
  UseGetProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailQueryParams,
    GetExecutionDetailPathParams
  >,
  'path'
> &
  GetExecutionDetailPathParams

/**
 * Gets Execution Detail
 */
export const useGetExecutionDetail = ({ planExecutionId, ...props }: UseGetExecutionDetailProps) =>
  useGet<ResponsePipelineExecutionDetail, Failure | Error, GetExecutionDetailQueryParams, GetExecutionDetailPathParams>(
    (paramsInPath: GetExecutionDetailPathParams) => `/pipelines/execution/${paramsInPath.planExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * Gets Execution Detail
 */
export const getExecutionDetailPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailQueryParams,
    GetExecutionDetailPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePipelineExecutionDetail,
    Failure | Error,
    GetExecutionDetailQueryParams,
    GetExecutionDetailPathParams
  >(getConfig('pipeline/api'), `/pipelines/execution/${planExecutionId}`, props, signal)

export interface GetExpressionEvaluatedQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
}

export interface GetExpressionEvaluatedPathParams {
  planExecutionId: string
}

export type GetExpressionEvaluatedProps = Omit<
  MutateProps<
    ResponseExpressionEvaluationDetail,
    Failure | Error,
    GetExpressionEvaluatedQueryParams,
    GetExpressionEvaluatedBodyRequestBody,
    GetExpressionEvaluatedPathParams
  >,
  'path' | 'verb'
> &
  GetExpressionEvaluatedPathParams

/**
 * Gets Execution Expression evaluated
 */
export const GetExpressionEvaluated = ({ planExecutionId, ...props }: GetExpressionEvaluatedProps) => (
  <Mutate<
    ResponseExpressionEvaluationDetail,
    Failure | Error,
    GetExpressionEvaluatedQueryParams,
    GetExpressionEvaluatedBodyRequestBody,
    GetExpressionEvaluatedPathParams
  >
    verb="POST"
    path={`/pipelines/execution/${planExecutionId}/evaluateExpression`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExpressionEvaluatedProps = Omit<
  UseMutateProps<
    ResponseExpressionEvaluationDetail,
    Failure | Error,
    GetExpressionEvaluatedQueryParams,
    GetExpressionEvaluatedBodyRequestBody,
    GetExpressionEvaluatedPathParams
  >,
  'path' | 'verb'
> &
  GetExpressionEvaluatedPathParams

/**
 * Gets Execution Expression evaluated
 */
export const useGetExpressionEvaluated = ({ planExecutionId, ...props }: UseGetExpressionEvaluatedProps) =>
  useMutate<
    ResponseExpressionEvaluationDetail,
    Failure | Error,
    GetExpressionEvaluatedQueryParams,
    GetExpressionEvaluatedBodyRequestBody,
    GetExpressionEvaluatedPathParams
  >(
    'POST',
    (paramsInPath: GetExpressionEvaluatedPathParams) =>
      `/pipelines/execution/${paramsInPath.planExecutionId}/evaluateExpression`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * Gets Execution Expression evaluated
 */
export const getExpressionEvaluatedPromise = (
  {
    planExecutionId,
    ...props
  }: MutateUsingFetchProps<
    ResponseExpressionEvaluationDetail,
    Failure | Error,
    GetExpressionEvaluatedQueryParams,
    GetExpressionEvaluatedBodyRequestBody,
    GetExpressionEvaluatedPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseExpressionEvaluationDetail,
    Failure | Error,
    GetExpressionEvaluatedQueryParams,
    GetExpressionEvaluatedBodyRequestBody,
    GetExpressionEvaluatedPathParams
  >('POST', getConfig('pipeline/api'), `/pipelines/execution/${planExecutionId}/evaluateExpression`, props, signal)

export interface GetInputsetYamlQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  resolveExpressions?: boolean
  resolveExpressionsType?: 'RESOLVE_ALL_EXPRESSIONS' | 'RESOLVE_TRIGGER_EXPRESSIONS' | 'UNKNOWN'
}

export interface GetInputsetYamlPathParams {
  planExecutionId: string
}

export type GetInputsetYamlProps = Omit<
  GetProps<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams>,
  'path'
> &
  GetInputsetYamlPathParams

/**
 * Gets  inputsetYaml
 */
export const GetInputsetYaml = ({ planExecutionId, ...props }: GetInputsetYamlProps) => (
  <Get<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams>
    path={`/pipelines/execution/${planExecutionId}/inputset`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetInputsetYamlProps = Omit<
  UseGetProps<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams>,
  'path'
> &
  GetInputsetYamlPathParams

/**
 * Gets  inputsetYaml
 */
export const useGetInputsetYaml = ({ planExecutionId, ...props }: UseGetInputsetYamlProps) =>
  useGet<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams>(
    (paramsInPath: GetInputsetYamlPathParams) => `/pipelines/execution/${paramsInPath.planExecutionId}/inputset`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * Gets  inputsetYaml
 */
export const getInputsetYamlPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams> & {
    planExecutionId: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, void, GetInputsetYamlQueryParams, GetInputsetYamlPathParams>(
    getConfig('pipeline/api'),
    `/pipelines/execution/${planExecutionId}/inputset`,
    props,
    signal
  )

export interface GetInputsetYamlV2QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  resolveExpressions?: boolean
  resolveExpressionsType?: 'RESOLVE_ALL_EXPRESSIONS' | 'RESOLVE_TRIGGER_EXPRESSIONS' | 'UNKNOWN'
}

export interface GetInputsetYamlV2PathParams {
  planExecutionId: string
}

export type GetInputsetYamlV2Props = Omit<
  GetProps<
    ResponseInputSetTemplateResponse,
    Failure | Error,
    GetInputsetYamlV2QueryParams,
    GetInputsetYamlV2PathParams
  >,
  'path'
> &
  GetInputsetYamlV2PathParams

/**
 * Gets  inputsetYaml
 */
export const GetInputsetYamlV2 = ({ planExecutionId, ...props }: GetInputsetYamlV2Props) => (
  <Get<ResponseInputSetTemplateResponse, Failure | Error, GetInputsetYamlV2QueryParams, GetInputsetYamlV2PathParams>
    path={`/pipelines/execution/${planExecutionId}/inputsetV2`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetInputsetYamlV2Props = Omit<
  UseGetProps<
    ResponseInputSetTemplateResponse,
    Failure | Error,
    GetInputsetYamlV2QueryParams,
    GetInputsetYamlV2PathParams
  >,
  'path'
> &
  GetInputsetYamlV2PathParams

/**
 * Gets  inputsetYaml
 */
export const useGetInputsetYamlV2 = ({ planExecutionId, ...props }: UseGetInputsetYamlV2Props) =>
  useGet<ResponseInputSetTemplateResponse, Failure | Error, GetInputsetYamlV2QueryParams, GetInputsetYamlV2PathParams>(
    (paramsInPath: GetInputsetYamlV2PathParams) => `/pipelines/execution/${paramsInPath.planExecutionId}/inputsetV2`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * Gets  inputsetYaml
 */
export const getInputsetYamlV2Promise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponseInputSetTemplateResponse,
    Failure | Error,
    GetInputsetYamlV2QueryParams,
    GetInputsetYamlV2PathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInputSetTemplateResponse,
    Failure | Error,
    GetInputsetYamlV2QueryParams,
    GetInputsetYamlV2PathParams
  >(getConfig('pipeline/api'), `/pipelines/execution/${planExecutionId}/inputsetV2`, props, signal)

export interface GetExecutionDataQueryParams {
  accountIdentifier: string
}

export interface GetExecutionDataPathParams {
  planExecutionId: string
}

export type GetExecutionDataProps = Omit<
  GetProps<ResponseExecutionDataResponse, Failure | Error, GetExecutionDataQueryParams, GetExecutionDataPathParams>,
  'path'
> &
  GetExecutionDataPathParams

/**
 * Get metadata of an execution
 */
export const GetExecutionData = ({ planExecutionId, ...props }: GetExecutionDataProps) => (
  <Get<ResponseExecutionDataResponse, Failure | Error, GetExecutionDataQueryParams, GetExecutionDataPathParams>
    path={`/pipelines/execution/${planExecutionId}/metadata`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExecutionDataProps = Omit<
  UseGetProps<ResponseExecutionDataResponse, Failure | Error, GetExecutionDataQueryParams, GetExecutionDataPathParams>,
  'path'
> &
  GetExecutionDataPathParams

/**
 * Get metadata of an execution
 */
export const useGetExecutionData = ({ planExecutionId, ...props }: UseGetExecutionDataProps) =>
  useGet<ResponseExecutionDataResponse, Failure | Error, GetExecutionDataQueryParams, GetExecutionDataPathParams>(
    (paramsInPath: GetExecutionDataPathParams) => `/pipelines/execution/${paramsInPath.planExecutionId}/metadata`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * Get metadata of an execution
 */
export const getExecutionDataPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponseExecutionDataResponse,
    Failure | Error,
    GetExecutionDataQueryParams,
    GetExecutionDataPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseExecutionDataResponse,
    Failure | Error,
    GetExecutionDataQueryParams,
    GetExecutionDataPathParams
  >(getConfig('pipeline/api'), `/pipelines/execution/${planExecutionId}/metadata`, props, signal)

export interface GetExecutionDataDetailsQueryParams {
  accountIdentifier: string
}

export interface GetExecutionDataDetailsPathParams {
  planExecutionId: string
}

export type GetExecutionDataDetailsProps = Omit<
  GetProps<
    ResponseExecutionMetaDataResponse,
    Failure | Error,
    GetExecutionDataDetailsQueryParams,
    GetExecutionDataDetailsPathParams
  >,
  'path'
> &
  GetExecutionDataDetailsPathParams

/**
 * Get plan metadata details of an execution
 */
export const GetExecutionDataDetails = ({ planExecutionId, ...props }: GetExecutionDataDetailsProps) => (
  <Get<
    ResponseExecutionMetaDataResponse,
    Failure | Error,
    GetExecutionDataDetailsQueryParams,
    GetExecutionDataDetailsPathParams
  >
    path={`/pipelines/execution/${planExecutionId}/metadata/details`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExecutionDataDetailsProps = Omit<
  UseGetProps<
    ResponseExecutionMetaDataResponse,
    Failure | Error,
    GetExecutionDataDetailsQueryParams,
    GetExecutionDataDetailsPathParams
  >,
  'path'
> &
  GetExecutionDataDetailsPathParams

/**
 * Get plan metadata details of an execution
 */
export const useGetExecutionDataDetails = ({ planExecutionId, ...props }: UseGetExecutionDataDetailsProps) =>
  useGet<
    ResponseExecutionMetaDataResponse,
    Failure | Error,
    GetExecutionDataDetailsQueryParams,
    GetExecutionDataDetailsPathParams
  >(
    (paramsInPath: GetExecutionDataDetailsPathParams) =>
      `/pipelines/execution/${paramsInPath.planExecutionId}/metadata/details`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * Get plan metadata details of an execution
 */
export const getExecutionDataDetailsPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponseExecutionMetaDataResponse,
    Failure | Error,
    GetExecutionDataDetailsQueryParams,
    GetExecutionDataDetailsPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseExecutionMetaDataResponse,
    Failure | Error,
    GetExecutionDataDetailsQueryParams,
    GetExecutionDataDetailsPathParams
  >(getConfig('pipeline/api'), `/pipelines/execution/${planExecutionId}/metadata/details`, props, signal)

export interface GetNotesForExecutionQueryParams {
  accountIdentifier: string
}

export interface GetNotesForExecutionPathParams {
  planExecutionId: string
}

export type GetNotesForExecutionProps = Omit<
  GetProps<
    ResponsePipelineExecutionNotes,
    Failure | Error,
    GetNotesForExecutionQueryParams,
    GetNotesForExecutionPathParams
  >,
  'path'
> &
  GetNotesForExecutionPathParams

/**
 * Get Notes of an execution from planExecutionMetadata
 */
export const GetNotesForExecution = ({ planExecutionId, ...props }: GetNotesForExecutionProps) => (
  <Get<ResponsePipelineExecutionNotes, Failure | Error, GetNotesForExecutionQueryParams, GetNotesForExecutionPathParams>
    path={`/pipelines/execution/${planExecutionId}/notes`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetNotesForExecutionProps = Omit<
  UseGetProps<
    ResponsePipelineExecutionNotes,
    Failure | Error,
    GetNotesForExecutionQueryParams,
    GetNotesForExecutionPathParams
  >,
  'path'
> &
  GetNotesForExecutionPathParams

/**
 * Get Notes of an execution from planExecutionMetadata
 */
export const useGetNotesForExecution = ({ planExecutionId, ...props }: UseGetNotesForExecutionProps) =>
  useGet<
    ResponsePipelineExecutionNotes,
    Failure | Error,
    GetNotesForExecutionQueryParams,
    GetNotesForExecutionPathParams
  >((paramsInPath: GetNotesForExecutionPathParams) => `/pipelines/execution/${paramsInPath.planExecutionId}/notes`, {
    base: getConfig('pipeline/api'),
    pathParams: { planExecutionId },
    ...props
  })

/**
 * Get Notes of an execution from planExecutionMetadata
 */
export const getNotesForExecutionPromise = (
  {
    planExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponsePipelineExecutionNotes,
    Failure | Error,
    GetNotesForExecutionQueryParams,
    GetNotesForExecutionPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePipelineExecutionNotes,
    Failure | Error,
    GetNotesForExecutionQueryParams,
    GetNotesForExecutionPathParams
  >(getConfig('pipeline/api'), `/pipelines/execution/${planExecutionId}/notes`, props, signal)

export interface UpdateNotesForExecutionQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  notesForPipelineExecution: string
}

export interface UpdateNotesForExecutionPathParams {
  planExecutionId: string
}

export type UpdateNotesForExecutionProps = Omit<
  MutateProps<
    ResponsePipelineExecutionNotes,
    Failure | Error,
    UpdateNotesForExecutionQueryParams,
    void,
    UpdateNotesForExecutionPathParams
  >,
  'path' | 'verb'
> &
  UpdateNotesForExecutionPathParams

/**
 * Updates Notes of a pipelineExecution
 */
export const UpdateNotesForExecution = ({ planExecutionId, ...props }: UpdateNotesForExecutionProps) => (
  <Mutate<
    ResponsePipelineExecutionNotes,
    Failure | Error,
    UpdateNotesForExecutionQueryParams,
    void,
    UpdateNotesForExecutionPathParams
  >
    verb="PUT"
    path={`/pipelines/execution/${planExecutionId}/notes`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateNotesForExecutionProps = Omit<
  UseMutateProps<
    ResponsePipelineExecutionNotes,
    Failure | Error,
    UpdateNotesForExecutionQueryParams,
    void,
    UpdateNotesForExecutionPathParams
  >,
  'path' | 'verb'
> &
  UpdateNotesForExecutionPathParams

/**
 * Updates Notes of a pipelineExecution
 */
export const useUpdateNotesForExecution = ({ planExecutionId, ...props }: UseUpdateNotesForExecutionProps) =>
  useMutate<
    ResponsePipelineExecutionNotes,
    Failure | Error,
    UpdateNotesForExecutionQueryParams,
    void,
    UpdateNotesForExecutionPathParams
  >(
    'PUT',
    (paramsInPath: UpdateNotesForExecutionPathParams) => `/pipelines/execution/${paramsInPath.planExecutionId}/notes`,
    { base: getConfig('pipeline/api'), pathParams: { planExecutionId }, ...props }
  )

/**
 * Updates Notes of a pipelineExecution
 */
export const updateNotesForExecutionPromise = (
  {
    planExecutionId,
    ...props
  }: MutateUsingFetchProps<
    ResponsePipelineExecutionNotes,
    Failure | Error,
    UpdateNotesForExecutionQueryParams,
    void,
    UpdateNotesForExecutionPathParams
  > & { planExecutionId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineExecutionNotes,
    Failure | Error,
    UpdateNotesForExecutionQueryParams,
    void,
    UpdateNotesForExecutionPathParams
  >('PUT', getConfig('pipeline/api'), `/pipelines/execution/${planExecutionId}/notes`, props, signal)

export interface GetExpandedPipelineJSONQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export interface GetExpandedPipelineJSONPathParams {
  pipelineIdentifier: string
}

export type GetExpandedPipelineJSONProps = Omit<
  GetProps<
    ResponsePipelineExpandedJson,
    Failure | Error,
    GetExpandedPipelineJSONQueryParams,
    GetExpandedPipelineJSONPathParams
  >,
  'path'
> &
  GetExpandedPipelineJSONPathParams

/**
 * Gets Pipeline JSON with extra info for some fields
 */
export const GetExpandedPipelineJSON = ({ pipelineIdentifier, ...props }: GetExpandedPipelineJSONProps) => (
  <Get<
    ResponsePipelineExpandedJson,
    Failure | Error,
    GetExpandedPipelineJSONQueryParams,
    GetExpandedPipelineJSONPathParams
  >
    path={`/pipelines/expandedJSON/${pipelineIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExpandedPipelineJSONProps = Omit<
  UseGetProps<
    ResponsePipelineExpandedJson,
    Failure | Error,
    GetExpandedPipelineJSONQueryParams,
    GetExpandedPipelineJSONPathParams
  >,
  'path'
> &
  GetExpandedPipelineJSONPathParams

/**
 * Gets Pipeline JSON with extra info for some fields
 */
export const useGetExpandedPipelineJSON = ({ pipelineIdentifier, ...props }: UseGetExpandedPipelineJSONProps) =>
  useGet<
    ResponsePipelineExpandedJson,
    Failure | Error,
    GetExpandedPipelineJSONQueryParams,
    GetExpandedPipelineJSONPathParams
  >((paramsInPath: GetExpandedPipelineJSONPathParams) => `/pipelines/expandedJSON/${paramsInPath.pipelineIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { pipelineIdentifier },
    ...props
  })

/**
 * Gets Pipeline JSON with extra info for some fields
 */
export const getExpandedPipelineJSONPromise = (
  {
    pipelineIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponsePipelineExpandedJson,
    Failure | Error,
    GetExpandedPipelineJSONQueryParams,
    GetExpandedPipelineJSONPathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePipelineExpandedJson,
    Failure | Error,
    GetExpandedPipelineJSONQueryParams,
    GetExpandedPipelineJSONPathParams
  >(getConfig('pipeline/api'), `/pipelines/expandedJSON/${pipelineIdentifier}`, props, signal)

export interface GetExecutionNodeQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  nodeExecutionId: string
}

export type GetExecutionNodeProps = Omit<
  GetProps<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>,
  'path'
>

/**
 * get execution node
 */
export const GetExecutionNode = (props: GetExecutionNodeProps) => (
  <Get<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>
    path={`/pipelines/getExecutionNode`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetExecutionNodeProps = Omit<
  UseGetProps<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>,
  'path'
>

/**
 * get execution node
 */
export const useGetExecutionNode = (props: UseGetExecutionNodeProps) =>
  useGet<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>(`/pipelines/getExecutionNode`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * get execution node
 */
export const getExecutionNodePromise = (
  props: GetUsingFetchProps<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseExecutionNode, Failure | Error, GetExecutionNodeQueryParams, void>(
    getConfig('pipeline/api'),
    `/pipelines/getExecutionNode`,
    props,
    signal
  )

export interface ImportPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  connectorRef?: string
  repoName?: string
  branch?: string
  filePath?: string
  isForceImport?: boolean
}

export interface ImportPipelinePathParams {
  pipelineIdentifier: string
}

export type ImportPipelineProps = Omit<
  MutateProps<
    ResponsePipelineSaveResponse,
    Failure | Error,
    ImportPipelineQueryParams,
    PipelineImportRequest,
    ImportPipelinePathParams
  >,
  'path' | 'verb'
> &
  ImportPipelinePathParams

/**
 * Get Pipeline YAML from Git Repository
 */
export const ImportPipeline = ({ pipelineIdentifier, ...props }: ImportPipelineProps) => (
  <Mutate<
    ResponsePipelineSaveResponse,
    Failure | Error,
    ImportPipelineQueryParams,
    PipelineImportRequest,
    ImportPipelinePathParams
  >
    verb="POST"
    path={`/pipelines/import/${pipelineIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseImportPipelineProps = Omit<
  UseMutateProps<
    ResponsePipelineSaveResponse,
    Failure | Error,
    ImportPipelineQueryParams,
    PipelineImportRequest,
    ImportPipelinePathParams
  >,
  'path' | 'verb'
> &
  ImportPipelinePathParams

/**
 * Get Pipeline YAML from Git Repository
 */
export const useImportPipeline = ({ pipelineIdentifier, ...props }: UseImportPipelineProps) =>
  useMutate<
    ResponsePipelineSaveResponse,
    Failure | Error,
    ImportPipelineQueryParams,
    PipelineImportRequest,
    ImportPipelinePathParams
  >('POST', (paramsInPath: ImportPipelinePathParams) => `/pipelines/import/${paramsInPath.pipelineIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { pipelineIdentifier },
    ...props
  })

/**
 * Get Pipeline YAML from Git Repository
 */
export const importPipelinePromise = (
  {
    pipelineIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePipelineSaveResponse,
    Failure | Error,
    ImportPipelineQueryParams,
    PipelineImportRequest,
    ImportPipelinePathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineSaveResponse,
    Failure | Error,
    ImportPipelineQueryParams,
    PipelineImportRequest,
    ImportPipelinePathParams
  >('POST', getConfig('pipeline/api'), `/pipelines/import/${pipelineIdentifier}`, props, signal)

export interface GetPipelineListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  page?: number
  size?: number
  sort?: string[]
  searchTerm?: string
  module?: string
  filterIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  getDistinctFromBranches?: boolean
}

export type GetPipelineListProps = Omit<
  MutateProps<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    PipelineFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Pipeline list
 */
export const GetPipelineList = (props: GetPipelineListProps) => (
  <Mutate<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    PipelineFilterProperties,
    void
  >
    verb="POST"
    path={`/pipelines/list`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineListProps = Omit<
  UseMutateProps<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    PipelineFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Pipeline list
 */
export const useGetPipelineList = (props: UseGetPipelineListProps) =>
  useMutate<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    PipelineFilterProperties,
    void
  >('POST', `/pipelines/list`, { base: getConfig('pipeline/api'), ...props })

/**
 * Gets Pipeline list
 */
export const getPipelineListPromise = (
  props: MutateUsingFetchProps<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    PipelineFilterProperties,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePagePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineListQueryParams,
    PipelineFilterProperties,
    void
  >('POST', getConfig('pipeline/api'), `/pipelines/list`, props, signal)

export interface GetRepositoryListQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetRepositoryListProps = Omit<
  GetProps<ResponsePMSPipelineListRepoResponse, Failure | Error, GetRepositoryListQueryParams, void>,
  'path'
>

/**
 * Gets Repository list
 */
export const GetRepositoryList = (props: GetRepositoryListProps) => (
  <Get<ResponsePMSPipelineListRepoResponse, Failure | Error, GetRepositoryListQueryParams, void>
    path={`/pipelines/list-repos`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetRepositoryListProps = Omit<
  UseGetProps<ResponsePMSPipelineListRepoResponse, Failure | Error, GetRepositoryListQueryParams, void>,
  'path'
>

/**
 * Gets Repository list
 */
export const useGetRepositoryList = (props: UseGetRepositoryListProps) =>
  useGet<ResponsePMSPipelineListRepoResponse, Failure | Error, GetRepositoryListQueryParams, void>(
    `/pipelines/list-repos`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Gets Repository list
 */
export const getRepositoryListPromise = (
  props: GetUsingFetchProps<ResponsePMSPipelineListRepoResponse, Failure | Error, GetRepositoryListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePMSPipelineListRepoResponse, Failure | Error, GetRepositoryListQueryParams, void>(
    getConfig('pipeline/api'),
    `/pipelines/list-repos`,
    props,
    signal
  )

export interface MoveConfigsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  connectorRef?: string
  repoName?: string
  branch?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
  moveConfigType?: 'INLINE_TO_REMOTE' | 'REMOTE_TO_INLINE'
  pipelineIdentifier?: string
}

export interface MoveConfigsPathParams {
  pipelineIdentifier: string
}

export type MoveConfigsProps = Omit<
  MutateProps<ResponseMoveConfigResponse, Failure | Error, MoveConfigsQueryParams, void, MoveConfigsPathParams>,
  'path' | 'verb'
> &
  MoveConfigsPathParams

/**
 * Move Pipeline YAML from inline to remote or remote to inline
 */
export const MoveConfigs = ({ pipelineIdentifier, ...props }: MoveConfigsProps) => (
  <Mutate<ResponseMoveConfigResponse, Failure | Error, MoveConfigsQueryParams, void, MoveConfigsPathParams>
    verb="POST"
    path={`/pipelines/move-config/${pipelineIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseMoveConfigsProps = Omit<
  UseMutateProps<ResponseMoveConfigResponse, Failure | Error, MoveConfigsQueryParams, void, MoveConfigsPathParams>,
  'path' | 'verb'
> &
  MoveConfigsPathParams

/**
 * Move Pipeline YAML from inline to remote or remote to inline
 */
export const useMoveConfigs = ({ pipelineIdentifier, ...props }: UseMoveConfigsProps) =>
  useMutate<ResponseMoveConfigResponse, Failure | Error, MoveConfigsQueryParams, void, MoveConfigsPathParams>(
    'POST',
    (paramsInPath: MoveConfigsPathParams) => `/pipelines/move-config/${paramsInPath.pipelineIdentifier}`,
    { base: getConfig('pipeline/api'), pathParams: { pipelineIdentifier }, ...props }
  )

/**
 * Move Pipeline YAML from inline to remote or remote to inline
 */
export const moveConfigsPromise = (
  {
    pipelineIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseMoveConfigResponse,
    Failure | Error,
    MoveConfigsQueryParams,
    void,
    MoveConfigsPathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseMoveConfigResponse, Failure | Error, MoveConfigsQueryParams, void, MoveConfigsPathParams>(
    'POST',
    getConfig('pipeline/api'),
    `/pipelines/move-config/${pipelineIdentifier}`,
    props,
    signal
  )

export type GetNotificationSchemaProps = Omit<GetProps<ResponseNotificationRules, Failure | Error, void, void>, 'path'>

/**
 * Get Notification Schema
 */
export const GetNotificationSchema = (props: GetNotificationSchemaProps) => (
  <Get<ResponseNotificationRules, Failure | Error, void, void>
    path={`/pipelines/notification`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetNotificationSchemaProps = Omit<
  UseGetProps<ResponseNotificationRules, Failure | Error, void, void>,
  'path'
>

/**
 * Get Notification Schema
 */
export const useGetNotificationSchema = (props: UseGetNotificationSchemaProps) =>
  useGet<ResponseNotificationRules, Failure | Error, void, void>(`/pipelines/notification`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Notification Schema
 */
export const getNotificationSchemaPromise = (
  props: GetUsingFetchProps<ResponseNotificationRules, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNotificationRules, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/pipelines/notification`,
    props,
    signal
  )

export interface GetPipelineExecutionQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  moduleInfo: string
  startTime: number
  endTime: number
}

export type GetPipelineExecutionProps = Omit<
  GetProps<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineExecutionQueryParams, void>,
  'path'
>

/**
 * Get pipeline execution
 */
export const GetPipelineExecution = (props: GetPipelineExecutionProps) => (
  <Get<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineExecutionQueryParams, void>
    path={`/pipelines/pipelineExecution`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineExecutionProps = Omit<
  UseGetProps<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineExecutionQueryParams, void>,
  'path'
>

/**
 * Get pipeline execution
 */
export const useGetPipelineExecution = (props: UseGetPipelineExecutionProps) =>
  useGet<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineExecutionQueryParams, void>(
    `/pipelines/pipelineExecution`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Get pipeline execution
 */
export const getPipelineExecutionPromise = (
  props: GetUsingFetchProps<
    ResponseDashboardPipelineExecutionInfo,
    Failure | Error,
    GetPipelineExecutionQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDashboardPipelineExecutionInfo, Failure | Error, GetPipelineExecutionQueryParams, void>(
    getConfig('pipeline/api'),
    `/pipelines/pipelineExecution`,
    props,
    signal
  )

export interface GetPipelinedHealthQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  moduleInfo: string
  startTime: number
  endTime: number
}

export type GetPipelinedHealthProps = Omit<
  GetProps<ResponseDashboardPipelineHealthInfo, Failure | Error, GetPipelinedHealthQueryParams, void>,
  'path'
>

/**
 * Get pipeline health
 */
export const GetPipelinedHealth = (props: GetPipelinedHealthProps) => (
  <Get<ResponseDashboardPipelineHealthInfo, Failure | Error, GetPipelinedHealthQueryParams, void>
    path={`/pipelines/pipelineHealth`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelinedHealthProps = Omit<
  UseGetProps<ResponseDashboardPipelineHealthInfo, Failure | Error, GetPipelinedHealthQueryParams, void>,
  'path'
>

/**
 * Get pipeline health
 */
export const useGetPipelinedHealth = (props: UseGetPipelinedHealthProps) =>
  useGet<ResponseDashboardPipelineHealthInfo, Failure | Error, GetPipelinedHealthQueryParams, void>(
    `/pipelines/pipelineHealth`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Get pipeline health
 */
export const getPipelinedHealthPromise = (
  props: GetUsingFetchProps<ResponseDashboardPipelineHealthInfo, Failure | Error, GetPipelinedHealthQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDashboardPipelineHealthInfo, Failure | Error, GetPipelinedHealthQueryParams, void>(
    getConfig('pipeline/api'),
    `/pipelines/pipelineHealth`,
    props,
    signal
  )

export interface GetTemplateResolvedPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export interface GetTemplateResolvedPipelinePathParams {
  pipelineIdentifier: string
}

export type GetTemplateResolvedPipelineProps = Omit<
  GetProps<
    ResponseTemplatesResolvedPipelineResponseDTO,
    Failure | Error,
    GetTemplateResolvedPipelineQueryParams,
    GetTemplateResolvedPipelinePathParams
  >,
  'path'
> &
  GetTemplateResolvedPipelinePathParams

/**
 * Gets template resolved pipeline yaml
 */
export const GetTemplateResolvedPipeline = ({ pipelineIdentifier, ...props }: GetTemplateResolvedPipelineProps) => (
  <Get<
    ResponseTemplatesResolvedPipelineResponseDTO,
    Failure | Error,
    GetTemplateResolvedPipelineQueryParams,
    GetTemplateResolvedPipelinePathParams
  >
    path={`/pipelines/resolved-templates-pipeline-yaml/${pipelineIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetTemplateResolvedPipelineProps = Omit<
  UseGetProps<
    ResponseTemplatesResolvedPipelineResponseDTO,
    Failure | Error,
    GetTemplateResolvedPipelineQueryParams,
    GetTemplateResolvedPipelinePathParams
  >,
  'path'
> &
  GetTemplateResolvedPipelinePathParams

/**
 * Gets template resolved pipeline yaml
 */
export const useGetTemplateResolvedPipeline = ({ pipelineIdentifier, ...props }: UseGetTemplateResolvedPipelineProps) =>
  useGet<
    ResponseTemplatesResolvedPipelineResponseDTO,
    Failure | Error,
    GetTemplateResolvedPipelineQueryParams,
    GetTemplateResolvedPipelinePathParams
  >(
    (paramsInPath: GetTemplateResolvedPipelinePathParams) =>
      `/pipelines/resolved-templates-pipeline-yaml/${paramsInPath.pipelineIdentifier}`,
    { base: getConfig('pipeline/api'), pathParams: { pipelineIdentifier }, ...props }
  )

/**
 * Gets template resolved pipeline yaml
 */
export const getTemplateResolvedPipelinePromise = (
  {
    pipelineIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseTemplatesResolvedPipelineResponseDTO,
    Failure | Error,
    GetTemplateResolvedPipelineQueryParams,
    GetTemplateResolvedPipelinePathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseTemplatesResolvedPipelineResponseDTO,
    Failure | Error,
    GetTemplateResolvedPipelineQueryParams,
    GetTemplateResolvedPipelinePathParams
  >(getConfig('pipeline/api'), `/pipelines/resolved-templates-pipeline-yaml/${pipelineIdentifier}`, props, signal)

export interface GetPipelineSummaryQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  getMetadataOnly?: boolean
  loadFromFallbackBranch?: boolean
}

export interface GetPipelineSummaryPathParams {
  pipelineIdentifier: string
}

export type GetPipelineSummaryProps = Omit<
  GetProps<
    ResponsePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >,
  'path'
> &
  GetPipelineSummaryPathParams

/**
 * Gets Pipeline Summary of a pipeline
 */
export const GetPipelineSummary = ({ pipelineIdentifier, ...props }: GetPipelineSummaryProps) => (
  <Get<ResponsePMSPipelineSummaryResponse, Failure | Error, GetPipelineSummaryQueryParams, GetPipelineSummaryPathParams>
    path={`/pipelines/summary/${pipelineIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineSummaryProps = Omit<
  UseGetProps<
    ResponsePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >,
  'path'
> &
  GetPipelineSummaryPathParams

/**
 * Gets Pipeline Summary of a pipeline
 */
export const useGetPipelineSummary = ({ pipelineIdentifier, ...props }: UseGetPipelineSummaryProps) =>
  useGet<
    ResponsePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >((paramsInPath: GetPipelineSummaryPathParams) => `/pipelines/summary/${paramsInPath.pipelineIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { pipelineIdentifier },
    ...props
  })

/**
 * Gets Pipeline Summary of a pipeline
 */
export const getPipelineSummaryPromise = (
  {
    pipelineIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponsePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePMSPipelineSummaryResponse,
    Failure | Error,
    GetPipelineSummaryQueryParams,
    GetPipelineSummaryPathParams
  >(getConfig('pipeline/api'), `/pipelines/summary/${pipelineIdentifier}`, props, signal)

export interface CreatePipelineV2QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  identifier?: string
  name?: string
  description?: string
  skipValidation?: boolean
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  repoName?: string
  public?: boolean
}

export type CreatePipelineV2Props = Omit<
  MutateProps<
    ResponsePipelineSaveResponse,
    Failure | Error,
    CreatePipelineV2QueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const CreatePipelineV2 = (props: CreatePipelineV2Props) => (
  <Mutate<
    ResponsePipelineSaveResponse,
    Failure | Error,
    CreatePipelineV2QueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >
    verb="POST"
    path={`/pipelines/v2`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreatePipelineV2Props = Omit<
  UseMutateProps<
    ResponsePipelineSaveResponse,
    Failure | Error,
    CreatePipelineV2QueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Pipeline
 */
export const useCreatePipelineV2 = (props: UseCreatePipelineV2Props) =>
  useMutate<
    ResponsePipelineSaveResponse,
    Failure | Error,
    CreatePipelineV2QueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >('POST', `/pipelines/v2`, { base: getConfig('pipeline/api'), ...props })

/**
 * Create a Pipeline
 */
export const createPipelineV2Promise = (
  props: MutateUsingFetchProps<
    ResponsePipelineSaveResponse,
    Failure | Error,
    CreatePipelineV2QueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineSaveResponse,
    Failure | Error,
    CreatePipelineV2QueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/pipelines/v2`, props, signal)

export interface GetStepsV2QueryParams {
  accountId: string
}

export type GetStepsV2Props = Omit<
  MutateProps<ResponseStepCategory, Failure | Error, GetStepsV2QueryParams, StepPalleteFilterWrapper, void>,
  'path' | 'verb'
>

/**
 * Get Steps for given modules Version 2
 */
export const GetStepsV2 = (props: GetStepsV2Props) => (
  <Mutate<ResponseStepCategory, Failure | Error, GetStepsV2QueryParams, StepPalleteFilterWrapper, void>
    verb="POST"
    path={`/pipelines/v2/steps`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetStepsV2Props = Omit<
  UseMutateProps<ResponseStepCategory, Failure | Error, GetStepsV2QueryParams, StepPalleteFilterWrapper, void>,
  'path' | 'verb'
>

/**
 * Get Steps for given modules Version 2
 */
export const useGetStepsV2 = (props: UseGetStepsV2Props) =>
  useMutate<ResponseStepCategory, Failure | Error, GetStepsV2QueryParams, StepPalleteFilterWrapper, void>(
    'POST',
    `/pipelines/v2/steps`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Get Steps for given modules Version 2
 */
export const getStepsV2Promise = (
  props: MutateUsingFetchProps<
    ResponseStepCategory,
    Failure | Error,
    GetStepsV2QueryParams,
    StepPalleteFilterWrapper,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseStepCategory, Failure | Error, GetStepsV2QueryParams, StepPalleteFilterWrapper, void>(
    'POST',
    getConfig('pipeline/api'),
    `/pipelines/v2/steps`,
    props,
    signal
  )

export interface CreateVariablesV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type CreateVariablesV2Props = Omit<
  MutateProps<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesV2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create variables for Pipeline
 */
export const CreateVariablesV2 = (props: CreateVariablesV2Props) => (
  <Mutate<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesV2QueryParams, void, void>
    verb="POST"
    path={`/pipelines/v2/variables`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreateVariablesV2Props = Omit<
  UseMutateProps<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesV2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create variables for Pipeline
 */
export const useCreateVariablesV2 = (props: UseCreateVariablesV2Props) =>
  useMutate<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesV2QueryParams, void, void>(
    'POST',
    `/pipelines/v2/variables`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Create variables for Pipeline
 */
export const createVariablesV2Promise = (
  props: MutateUsingFetchProps<
    ResponseVariableMergeServiceResponse,
    Failure | Error,
    CreateVariablesV2QueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesV2QueryParams, void, void>(
    'POST',
    getConfig('pipeline/api'),
    `/pipelines/v2/variables`,
    props,
    signal
  )

export interface PutPipelineV2QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  name?: string
  description?: string
  skipValidation?: boolean
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  lastCommitId?: string
  isNewBranch?: boolean
  public?: boolean
}

export interface PutPipelineV2PathParams {
  pipelineIdentifier: string
}

export type PutPipelineV2Props = Omit<
  MutateProps<
    ResponsePipelineSaveResponse,
    Failure | Error,
    PutPipelineV2QueryParams,
    UpdateTriggerBodyRequestBody,
    PutPipelineV2PathParams
  >,
  'path' | 'verb'
> &
  PutPipelineV2PathParams

/**
 * Update a Pipeline
 */
export const PutPipelineV2 = ({ pipelineIdentifier, ...props }: PutPipelineV2Props) => (
  <Mutate<
    ResponsePipelineSaveResponse,
    Failure | Error,
    PutPipelineV2QueryParams,
    UpdateTriggerBodyRequestBody,
    PutPipelineV2PathParams
  >
    verb="PUT"
    path={`/pipelines/v2/${pipelineIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePutPipelineV2Props = Omit<
  UseMutateProps<
    ResponsePipelineSaveResponse,
    Failure | Error,
    PutPipelineV2QueryParams,
    UpdateTriggerBodyRequestBody,
    PutPipelineV2PathParams
  >,
  'path' | 'verb'
> &
  PutPipelineV2PathParams

/**
 * Update a Pipeline
 */
export const usePutPipelineV2 = ({ pipelineIdentifier, ...props }: UsePutPipelineV2Props) =>
  useMutate<
    ResponsePipelineSaveResponse,
    Failure | Error,
    PutPipelineV2QueryParams,
    UpdateTriggerBodyRequestBody,
    PutPipelineV2PathParams
  >('PUT', (paramsInPath: PutPipelineV2PathParams) => `/pipelines/v2/${paramsInPath.pipelineIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { pipelineIdentifier },
    ...props
  })

/**
 * Update a Pipeline
 */
export const putPipelineV2Promise = (
  {
    pipelineIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePipelineSaveResponse,
    Failure | Error,
    PutPipelineV2QueryParams,
    UpdateTriggerBodyRequestBody,
    PutPipelineV2PathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineSaveResponse,
    Failure | Error,
    PutPipelineV2QueryParams,
    UpdateTriggerBodyRequestBody,
    PutPipelineV2PathParams
  >('PUT', getConfig('pipeline/api'), `/pipelines/v2/${pipelineIdentifier}`, props, signal)

export interface ValidatePipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier?: string
}

export type ValidatePipelineProps = Omit<
  MutateProps<ResponseString, Failure | Error, ValidatePipelineQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Validate a Pipeline
 */
export const ValidatePipeline = (props: ValidatePipelineProps) => (
  <Mutate<ResponseString, Failure | Error, ValidatePipelineQueryParams, void, void>
    verb="POST"
    path={`/pipelines/validate-pipeline-with-schema`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseValidatePipelineProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, ValidatePipelineQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Validate a Pipeline
 */
export const useValidatePipeline = (props: UseValidatePipelineProps) =>
  useMutate<ResponseString, Failure | Error, ValidatePipelineQueryParams, void, void>(
    'POST',
    `/pipelines/validate-pipeline-with-schema`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Validate a Pipeline
 */
export const validatePipelinePromise = (
  props: MutateUsingFetchProps<ResponseString, Failure | Error, ValidatePipelineQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, ValidatePipelineQueryParams, void, void>(
    'POST',
    getConfig('pipeline/api'),
    `/pipelines/validate-pipeline-with-schema`,
    props,
    signal
  )

export interface ValidatePipelineByYAMLQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidatePipelineByYAMLProps = Omit<
  MutateProps<ResponseString, Failure | Error, ValidatePipelineByYAMLQueryParams, UpdateTriggerBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * Validate a Pipeline YAML
 */
export const ValidatePipelineByYAML = (props: ValidatePipelineByYAMLProps) => (
  <Mutate<ResponseString, Failure | Error, ValidatePipelineByYAMLQueryParams, UpdateTriggerBodyRequestBody, void>
    verb="POST"
    path={`/pipelines/validate-yaml-with-schema`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseValidatePipelineByYAMLProps = Omit<
  UseMutateProps<
    ResponseString,
    Failure | Error,
    ValidatePipelineByYAMLQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate a Pipeline YAML
 */
export const useValidatePipelineByYAML = (props: UseValidatePipelineByYAMLProps) =>
  useMutate<ResponseString, Failure | Error, ValidatePipelineByYAMLQueryParams, UpdateTriggerBodyRequestBody, void>(
    'POST',
    `/pipelines/validate-yaml-with-schema`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Validate a Pipeline YAML
 */
export const validatePipelineByYAMLPromise = (
  props: MutateUsingFetchProps<
    ResponseString,
    Failure | Error,
    ValidatePipelineByYAMLQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseString,
    Failure | Error,
    ValidatePipelineByYAMLQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/pipelines/validate-yaml-with-schema`, props, signal)

export interface GetPipelineValidateResultQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface GetPipelineValidateResultPathParams {
  uuid: string
}

export type GetPipelineValidateResultProps = Omit<
  GetProps<
    ResponsePipelineValidationResponseDTO,
    Failure | Error,
    GetPipelineValidateResultQueryParams,
    GetPipelineValidateResultPathParams
  >,
  'path'
> &
  GetPipelineValidateResultPathParams

/**
 * Get Pipeline validation event data
 */
export const GetPipelineValidateResult = ({ uuid, ...props }: GetPipelineValidateResultProps) => (
  <Get<
    ResponsePipelineValidationResponseDTO,
    Failure | Error,
    GetPipelineValidateResultQueryParams,
    GetPipelineValidateResultPathParams
  >
    path={`/pipelines/validate/${uuid}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineValidateResultProps = Omit<
  UseGetProps<
    ResponsePipelineValidationResponseDTO,
    Failure | Error,
    GetPipelineValidateResultQueryParams,
    GetPipelineValidateResultPathParams
  >,
  'path'
> &
  GetPipelineValidateResultPathParams

/**
 * Get Pipeline validation event data
 */
export const useGetPipelineValidateResult = ({ uuid, ...props }: UseGetPipelineValidateResultProps) =>
  useGet<
    ResponsePipelineValidationResponseDTO,
    Failure | Error,
    GetPipelineValidateResultQueryParams,
    GetPipelineValidateResultPathParams
  >((paramsInPath: GetPipelineValidateResultPathParams) => `/pipelines/validate/${paramsInPath.uuid}`, {
    base: getConfig('pipeline/api'),
    pathParams: { uuid },
    ...props
  })

/**
 * Get Pipeline validation event data
 */
export const getPipelineValidateResultPromise = (
  {
    uuid,
    ...props
  }: GetUsingFetchProps<
    ResponsePipelineValidationResponseDTO,
    Failure | Error,
    GetPipelineValidateResultQueryParams,
    GetPipelineValidateResultPathParams
  > & { uuid: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePipelineValidationResponseDTO,
    Failure | Error,
    GetPipelineValidateResultQueryParams,
    GetPipelineValidateResultPathParams
  >(getConfig('pipeline/api'), `/pipelines/validate/${uuid}`, props, signal)

export interface CreateVariablesQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type CreateVariablesProps = Omit<
  MutateProps<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create variables for Pipeline
 */
export const CreateVariables = (props: CreateVariablesProps) => (
  <Mutate<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>
    verb="POST"
    path={`/pipelines/variables`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreateVariablesProps = Omit<
  UseMutateProps<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create variables for Pipeline
 */
export const useCreateVariables = (props: UseCreateVariablesProps) =>
  useMutate<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>(
    'POST',
    `/pipelines/variables`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Create variables for Pipeline
 */
export const createVariablesPromise = (
  props: MutateUsingFetchProps<
    ResponseVariableMergeServiceResponse,
    Failure | Error,
    CreateVariablesQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseVariableMergeServiceResponse, Failure | Error, CreateVariablesQueryParams, void, void>(
    'POST',
    getConfig('pipeline/api'),
    `/pipelines/variables`,
    props,
    signal
  )

export interface SoftDeletePipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
}

export type SoftDeletePipelineProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a pipeline
 */
export const SoftDeletePipeline = (props: SoftDeletePipelineProps) => (
  <Mutate<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>
    verb="DELETE"
    path={`/pipelines`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseSoftDeletePipelineProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a pipeline
 */
export const useSoftDeletePipeline = (props: UseSoftDeletePipelineProps) =>
  useMutate<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>('DELETE', `/pipelines`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Delete a pipeline
 */
export const softDeletePipelinePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, SoftDeletePipelineQueryParams, string, void>(
    'DELETE',
    getConfig('pipeline/api'),
    `/pipelines`,
    props,
    signal
  )

export interface GetPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
  getTemplatesResolvedPipeline?: boolean
  loadFromFallbackBranch?: boolean
  validateAsync?: boolean
}

export interface GetPipelinePathParams {
  pipelineIdentifier: string
}

export type GetPipelineProps = Omit<
  GetProps<ResponsePMSPipelineResponseDTO, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>,
  'path'
> &
  GetPipelinePathParams

/**
 * Gets a pipeline by identifier
 */
export const GetPipeline = ({ pipelineIdentifier, ...props }: GetPipelineProps) => (
  <Get<ResponsePMSPipelineResponseDTO, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>
    path={`/pipelines/${pipelineIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetPipelineProps = Omit<
  UseGetProps<ResponsePMSPipelineResponseDTO, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>,
  'path'
> &
  GetPipelinePathParams

/**
 * Gets a pipeline by identifier
 */
export const useGetPipeline = ({ pipelineIdentifier, ...props }: UseGetPipelineProps) =>
  useGet<ResponsePMSPipelineResponseDTO, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>(
    (paramsInPath: GetPipelinePathParams) => `/pipelines/${paramsInPath.pipelineIdentifier}`,
    { base: getConfig('pipeline/api'), pathParams: { pipelineIdentifier }, ...props }
  )

/**
 * Gets a pipeline by identifier
 */
export const getPipelinePromise = (
  {
    pipelineIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponsePMSPipelineResponseDTO,
    Failure | Error,
    GetPipelineQueryParams,
    GetPipelinePathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePMSPipelineResponseDTO, Failure | Error, GetPipelineQueryParams, GetPipelinePathParams>(
    getConfig('pipeline/api'),
    `/pipelines/${pipelineIdentifier}`,
    props,
    signal
  )

export interface PutPipelineQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  name?: string
  description?: string
  skipValidation?: boolean
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  lastCommitId?: string
  isNewBranch?: boolean
}

export interface PutPipelinePathParams {
  pipelineIdentifier: string
}

export type PutPipelineProps = Omit<
  MutateProps<
    ResponseString,
    Failure | Error,
    PutPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    PutPipelinePathParams
  >,
  'path' | 'verb'
> &
  PutPipelinePathParams

/**
 * Update a Pipeline
 */
export const PutPipeline = ({ pipelineIdentifier, ...props }: PutPipelineProps) => (
  <Mutate<ResponseString, Failure | Error, PutPipelineQueryParams, UpdateTriggerBodyRequestBody, PutPipelinePathParams>
    verb="PUT"
    path={`/pipelines/${pipelineIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePutPipelineProps = Omit<
  UseMutateProps<
    ResponseString,
    Failure | Error,
    PutPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    PutPipelinePathParams
  >,
  'path' | 'verb'
> &
  PutPipelinePathParams

/**
 * Update a Pipeline
 */
export const usePutPipeline = ({ pipelineIdentifier, ...props }: UsePutPipelineProps) =>
  useMutate<
    ResponseString,
    Failure | Error,
    PutPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    PutPipelinePathParams
  >('PUT', (paramsInPath: PutPipelinePathParams) => `/pipelines/${paramsInPath.pipelineIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { pipelineIdentifier },
    ...props
  })

/**
 * Update a Pipeline
 */
export const putPipelinePromise = (
  {
    pipelineIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseString,
    Failure | Error,
    PutPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    PutPipelinePathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseString,
    Failure | Error,
    PutPipelineQueryParams,
    UpdateTriggerBodyRequestBody,
    PutPipelinePathParams
  >('PUT', getConfig('pipeline/api'), `/pipelines/${pipelineIdentifier}`, props, signal)

export interface UpdatePipelineGitDetailsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  connectorRef?: string
  repoName?: string
  filePath?: string
}

export interface UpdatePipelineGitDetailsPathParams {
  pipelineIdentifier: string
}

export type UpdatePipelineGitDetailsProps = Omit<
  MutateProps<
    ResponsePMSGitUpdateResponse,
    Failure | Error,
    UpdatePipelineGitDetailsQueryParams,
    void,
    UpdatePipelineGitDetailsPathParams
  >,
  'path' | 'verb'
> &
  UpdatePipelineGitDetailsPathParams

/**
 * Update git-metadata in remote pipeline Entity
 */
export const UpdatePipelineGitDetails = ({ pipelineIdentifier, ...props }: UpdatePipelineGitDetailsProps) => (
  <Mutate<
    ResponsePMSGitUpdateResponse,
    Failure | Error,
    UpdatePipelineGitDetailsQueryParams,
    void,
    UpdatePipelineGitDetailsPathParams
  >
    verb="PUT"
    path={`/pipelines/${pipelineIdentifier}/update-git-metadata`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdatePipelineGitDetailsProps = Omit<
  UseMutateProps<
    ResponsePMSGitUpdateResponse,
    Failure | Error,
    UpdatePipelineGitDetailsQueryParams,
    void,
    UpdatePipelineGitDetailsPathParams
  >,
  'path' | 'verb'
> &
  UpdatePipelineGitDetailsPathParams

/**
 * Update git-metadata in remote pipeline Entity
 */
export const useUpdatePipelineGitDetails = ({ pipelineIdentifier, ...props }: UseUpdatePipelineGitDetailsProps) =>
  useMutate<
    ResponsePMSGitUpdateResponse,
    Failure | Error,
    UpdatePipelineGitDetailsQueryParams,
    void,
    UpdatePipelineGitDetailsPathParams
  >(
    'PUT',
    (paramsInPath: UpdatePipelineGitDetailsPathParams) =>
      `/pipelines/${paramsInPath.pipelineIdentifier}/update-git-metadata`,
    { base: getConfig('pipeline/api'), pathParams: { pipelineIdentifier }, ...props }
  )

/**
 * Update git-metadata in remote pipeline Entity
 */
export const updatePipelineGitDetailsPromise = (
  {
    pipelineIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePMSGitUpdateResponse,
    Failure | Error,
    UpdatePipelineGitDetailsQueryParams,
    void,
    UpdatePipelineGitDetailsPathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePMSGitUpdateResponse,
    Failure | Error,
    UpdatePipelineGitDetailsQueryParams,
    void,
    UpdatePipelineGitDetailsPathParams
  >('PUT', getConfig('pipeline/api'), `/pipelines/${pipelineIdentifier}/update-git-metadata`, props, signal)

export interface ValidatePipelineAsyncQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export interface ValidatePipelineAsyncPathParams {
  pipelineIdentifier: string
}

export type ValidatePipelineAsyncProps = Omit<
  MutateProps<
    ResponsePipelineValidationUUIDResponseBody,
    Failure | Error,
    ValidatePipelineAsyncQueryParams,
    void,
    ValidatePipelineAsyncPathParams
  >,
  'path' | 'verb'
> &
  ValidatePipelineAsyncPathParams

/**
 * Start a validation event for a Pipeline
 */
export const ValidatePipelineAsync = ({ pipelineIdentifier, ...props }: ValidatePipelineAsyncProps) => (
  <Mutate<
    ResponsePipelineValidationUUIDResponseBody,
    Failure | Error,
    ValidatePipelineAsyncQueryParams,
    void,
    ValidatePipelineAsyncPathParams
  >
    verb="POST"
    path={`/pipelines/${pipelineIdentifier}/validate`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseValidatePipelineAsyncProps = Omit<
  UseMutateProps<
    ResponsePipelineValidationUUIDResponseBody,
    Failure | Error,
    ValidatePipelineAsyncQueryParams,
    void,
    ValidatePipelineAsyncPathParams
  >,
  'path' | 'verb'
> &
  ValidatePipelineAsyncPathParams

/**
 * Start a validation event for a Pipeline
 */
export const useValidatePipelineAsync = ({ pipelineIdentifier, ...props }: UseValidatePipelineAsyncProps) =>
  useMutate<
    ResponsePipelineValidationUUIDResponseBody,
    Failure | Error,
    ValidatePipelineAsyncQueryParams,
    void,
    ValidatePipelineAsyncPathParams
  >(
    'POST',
    (paramsInPath: ValidatePipelineAsyncPathParams) => `/pipelines/${paramsInPath.pipelineIdentifier}/validate`,
    { base: getConfig('pipeline/api'), pathParams: { pipelineIdentifier }, ...props }
  )

/**
 * Start a validation event for a Pipeline
 */
export const validatePipelineAsyncPromise = (
  {
    pipelineIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePipelineValidationUUIDResponseBody,
    Failure | Error,
    ValidatePipelineAsyncQueryParams,
    void,
    ValidatePipelineAsyncPathParams
  > & { pipelineIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelineValidationUUIDResponseBody,
    Failure | Error,
    ValidatePipelineAsyncQueryParams,
    void,
    ValidatePipelineAsyncPathParams
  >('POST', getConfig('pipeline/api'), `/pipelines/${pipelineIdentifier}/validate`, props, signal)

export interface RefreshAndUpdateTemplateInputsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  lastCommitId?: string
  isNewBranch?: boolean
}

export type RefreshAndUpdateTemplateInputsProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, RefreshAndUpdateTemplateInputsQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * This refreshes and update template inputs in pipeline
 */
export const RefreshAndUpdateTemplateInputs = (props: RefreshAndUpdateTemplateInputsProps) => (
  <Mutate<ResponseBoolean, Failure | Error, RefreshAndUpdateTemplateInputsQueryParams, void, void>
    verb="POST"
    path={`/refresh-template`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRefreshAndUpdateTemplateInputsProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, RefreshAndUpdateTemplateInputsQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * This refreshes and update template inputs in pipeline
 */
export const useRefreshAndUpdateTemplateInputs = (props: UseRefreshAndUpdateTemplateInputsProps) =>
  useMutate<ResponseBoolean, Failure | Error, RefreshAndUpdateTemplateInputsQueryParams, void, void>(
    'POST',
    `/refresh-template`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * This refreshes and update template inputs in pipeline
 */
export const refreshAndUpdateTemplateInputsPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, RefreshAndUpdateTemplateInputsQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, RefreshAndUpdateTemplateInputsQueryParams, void, void>(
    'POST',
    getConfig('pipeline/api'),
    `/refresh-template`,
    props,
    signal
  )

export interface RefreshAllQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  resolvedConflictCommitId?: string
  baseBranch?: string
  connectorRef?: string
  storeType?: 'INLINE' | 'REMOTE'
  lastCommitId?: string
  isNewBranch?: boolean
}

export type RefreshAllProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, RefreshAllQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * This recursively refresh and update template inputs in pipeline
 */
export const RefreshAll = (props: RefreshAllProps) => (
  <Mutate<ResponseBoolean, Failure | Error, RefreshAllQueryParams, void, void>
    verb="POST"
    path={`/refresh-template/refresh-all`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseRefreshAllProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, RefreshAllQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * This recursively refresh and update template inputs in pipeline
 */
export const useRefreshAll = (props: UseRefreshAllProps) =>
  useMutate<ResponseBoolean, Failure | Error, RefreshAllQueryParams, void, void>(
    'POST',
    `/refresh-template/refresh-all`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * This recursively refresh and update template inputs in pipeline
 */
export const refreshAllPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, RefreshAllQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, RefreshAllQueryParams, void, void>(
    'POST',
    getConfig('pipeline/api'),
    `/refresh-template/refresh-all`,
    props,
    signal
  )

export interface GetYamlDiffQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type GetYamlDiffProps = Omit<
  GetProps<ResponseYamlDiffResponseDTO, Failure | Error, GetYamlDiffQueryParams, void>,
  'path'
>

/**
 * This returns original yaml and refresh yaml of pipeline
 */
export const GetYamlDiff = (props: GetYamlDiffProps) => (
  <Get<ResponseYamlDiffResponseDTO, Failure | Error, GetYamlDiffQueryParams, void>
    path={`/refresh-template/show-diff`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetYamlDiffProps = Omit<
  UseGetProps<ResponseYamlDiffResponseDTO, Failure | Error, GetYamlDiffQueryParams, void>,
  'path'
>

/**
 * This returns original yaml and refresh yaml of pipeline
 */
export const useGetYamlDiff = (props: UseGetYamlDiffProps) =>
  useGet<ResponseYamlDiffResponseDTO, Failure | Error, GetYamlDiffQueryParams, void>(`/refresh-template/show-diff`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * This returns original yaml and refresh yaml of pipeline
 */
export const getYamlDiffPromise = (
  props: GetUsingFetchProps<ResponseYamlDiffResponseDTO, Failure | Error, GetYamlDiffQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseYamlDiffResponseDTO, Failure | Error, GetYamlDiffQueryParams, void>(
    getConfig('pipeline/api'),
    `/refresh-template/show-diff`,
    props,
    signal
  )

export interface ValidateTemplateInputsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  parentEntityAccountIdentifier?: string
  parentEntityOrgIdentifier?: string
  parentEntityProjectIdentifier?: string
  repoName?: string
}

export type ValidateTemplateInputsProps = Omit<
  GetProps<ResponseValidateTemplateInputsResponseDTO, Failure | Error, ValidateTemplateInputsQueryParams, void>,
  'path'
>

/**
 * Validates the YAML specification of a pipeline
 */
export const ValidateTemplateInputs = (props: ValidateTemplateInputsProps) => (
  <Get<ResponseValidateTemplateInputsResponseDTO, Failure | Error, ValidateTemplateInputsQueryParams, void>
    path={`/refresh-template/validate-template-inputs`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseValidateTemplateInputsProps = Omit<
  UseGetProps<ResponseValidateTemplateInputsResponseDTO, Failure | Error, ValidateTemplateInputsQueryParams, void>,
  'path'
>

/**
 * Validates the YAML specification of a pipeline
 */
export const useValidateTemplateInputs = (props: UseValidateTemplateInputsProps) =>
  useGet<ResponseValidateTemplateInputsResponseDTO, Failure | Error, ValidateTemplateInputsQueryParams, void>(
    `/refresh-template/validate-template-inputs`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Validates the YAML specification of a pipeline
 */
export const validateTemplateInputsPromise = (
  props: GetUsingFetchProps<
    ResponseValidateTemplateInputsResponseDTO,
    Failure | Error,
    ValidateTemplateInputsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseValidateTemplateInputsResponseDTO, Failure | Error, ValidateTemplateInputsQueryParams, void>(
    getConfig('pipeline/api'),
    `/refresh-template/validate-template-inputs`,
    props,
    signal
  )

export interface GetResourceConstraintsExecutionInfoQueryParams {
  accountId: string
  resourceUnit: string
}

export type GetResourceConstraintsExecutionInfoProps = Omit<
  GetProps<
    ResponseResourceConstraintExecutionInfo,
    Failure | Error,
    GetResourceConstraintsExecutionInfoQueryParams,
    void
  >,
  'path'
>

/**
 * Gets resource constraints execution info
 */
export const GetResourceConstraintsExecutionInfo = (props: GetResourceConstraintsExecutionInfoProps) => (
  <Get<ResponseResourceConstraintExecutionInfo, Failure | Error, GetResourceConstraintsExecutionInfoQueryParams, void>
    path={`/resource-constraints/executionInfo`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetResourceConstraintsExecutionInfoProps = Omit<
  UseGetProps<
    ResponseResourceConstraintExecutionInfo,
    Failure | Error,
    GetResourceConstraintsExecutionInfoQueryParams,
    void
  >,
  'path'
>

/**
 * Gets resource constraints execution info
 */
export const useGetResourceConstraintsExecutionInfo = (props: UseGetResourceConstraintsExecutionInfoProps) =>
  useGet<
    ResponseResourceConstraintExecutionInfo,
    Failure | Error,
    GetResourceConstraintsExecutionInfoQueryParams,
    void
  >(`/resource-constraints/executionInfo`, { base: getConfig('pipeline/api'), ...props })

/**
 * Gets resource constraints execution info
 */
export const getResourceConstraintsExecutionInfoPromise = (
  props: GetUsingFetchProps<
    ResponseResourceConstraintExecutionInfo,
    Failure | Error,
    GetResourceConstraintsExecutionInfoQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseResourceConstraintExecutionInfo,
    Failure | Error,
    GetResourceConstraintsExecutionInfoQueryParams,
    void
  >(getConfig('pipeline/api'), `/resource-constraints/executionInfo`, props, signal)

export interface GetTriggerListForTargetQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
  filter?: string
  page?: number
  size?: number
  sort?: string[]
  searchTerm?: string
}

export type GetTriggerListForTargetProps = Omit<
  GetProps<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>,
  'path'
>

/**
 * Gets paginated Triggers list for target
 */
export const GetTriggerListForTarget = (props: GetTriggerListForTargetProps) => (
  <Get<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>
    path={`/triggers`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetTriggerListForTargetProps = Omit<
  UseGetProps<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>,
  'path'
>

/**
 * Gets paginated Triggers list for target
 */
export const useGetTriggerListForTarget = (props: UseGetTriggerListForTargetProps) =>
  useGet<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>(`/triggers`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Gets paginated Triggers list for target
 */
export const getTriggerListForTargetPromise = (
  props: GetUsingFetchProps<
    ResponsePageNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerListForTargetQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageNGTriggerDetailsResponse, Failure | Error, GetTriggerListForTargetQueryParams, void>(
    getConfig('pipeline/api'),
    `/triggers`,
    props,
    signal
  )

export interface CreateTriggerQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
  ignoreError?: boolean
  withServiceV2?: boolean
}

export type CreateTriggerProps = Omit<
  MutateProps<ResponseNGTriggerResponse, Failure | Error, CreateTriggerQueryParams, UpdateTriggerBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create Trigger
 */
export const CreateTrigger = (props: CreateTriggerProps) => (
  <Mutate<ResponseNGTriggerResponse, Failure | Error, CreateTriggerQueryParams, UpdateTriggerBodyRequestBody, void>
    verb="POST"
    path={`/triggers`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCreateTriggerProps = Omit<
  UseMutateProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    CreateTriggerQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Trigger
 */
export const useCreateTrigger = (props: UseCreateTriggerProps) =>
  useMutate<ResponseNGTriggerResponse, Failure | Error, CreateTriggerQueryParams, UpdateTriggerBodyRequestBody, void>(
    'POST',
    `/triggers`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * Create Trigger
 */
export const createTriggerPromise = (
  props: MutateUsingFetchProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    CreateTriggerQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseNGTriggerResponse,
    Failure | Error,
    CreateTriggerQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/triggers`, props, signal)

export interface GetTriggerCatalogQueryParams {
  accountIdentifier: string
}

export type GetTriggerCatalogProps = Omit<
  GetProps<ResponseTriggerCatalogResponse, Failure | Error, GetTriggerCatalogQueryParams, void>,
  'path'
>

/**
 * Get Trigger catalog
 */
export const GetTriggerCatalog = (props: GetTriggerCatalogProps) => (
  <Get<ResponseTriggerCatalogResponse, Failure | Error, GetTriggerCatalogQueryParams, void>
    path={`/triggers/catalog`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetTriggerCatalogProps = Omit<
  UseGetProps<ResponseTriggerCatalogResponse, Failure | Error, GetTriggerCatalogQueryParams, void>,
  'path'
>

/**
 * Get Trigger catalog
 */
export const useGetTriggerCatalog = (props: UseGetTriggerCatalogProps) =>
  useGet<ResponseTriggerCatalogResponse, Failure | Error, GetTriggerCatalogQueryParams, void>(`/triggers/catalog`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Trigger catalog
 */
export const getTriggerCatalogPromise = (
  props: GetUsingFetchProps<ResponseTriggerCatalogResponse, Failure | Error, GetTriggerCatalogQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseTriggerCatalogResponse, Failure | Error, GetTriggerCatalogQueryParams, void>(
    getConfig('pipeline/api'),
    `/triggers/catalog`,
    props,
    signal
  )

export type NGTriggerConfigV2Props = Omit<GetProps<ResponseNGTriggerConfigV2, Failure | Error, void, void>, 'path'>

/**
 * This is dummy api to expose NGTriggerConfigV2
 */
export const NGTriggerConfigV2 = (props: NGTriggerConfigV2Props) => (
  <Get<ResponseNGTriggerConfigV2, Failure | Error, void, void>
    path={`/triggers/dummy-NGTriggerConfigV2-api`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseNGTriggerConfigV2Props = Omit<
  UseGetProps<ResponseNGTriggerConfigV2, Failure | Error, void, void>,
  'path'
>

/**
 * This is dummy api to expose NGTriggerConfigV2
 */
export const useNGTriggerConfigV2 = (props: UseNGTriggerConfigV2Props) =>
  useGet<ResponseNGTriggerConfigV2, Failure | Error, void, void>(`/triggers/dummy-NGTriggerConfigV2-api`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * This is dummy api to expose NGTriggerConfigV2
 */
export const nGTriggerConfigV2Promise = (
  props: GetUsingFetchProps<ResponseNGTriggerConfigV2, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNGTriggerConfigV2, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/triggers/dummy-NGTriggerConfigV2-api`,
    props,
    signal
  )

export interface TriggerEventHistoryBuildSourceTypeQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  targetIdentifier?: string
  artifactType?: string
  searchTerm?: string
  page?: number
  size?: number
  sort?: string[]
}

export type TriggerEventHistoryBuildSourceTypeProps = Omit<
  GetProps<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerEventHistoryBuildSourceTypeQueryParams,
    void
  >,
  'path'
>

/**
 * Get artifact and manifest trigger event history based on build source type
 */
export const TriggerEventHistoryBuildSourceType = (props: TriggerEventHistoryBuildSourceTypeProps) => (
  <Get<ResponsePageNGTriggerEventHistoryResponse, Failure | Error, TriggerEventHistoryBuildSourceTypeQueryParams, void>
    path={`/triggers/eventHistory/artifact-manifest-info`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseTriggerEventHistoryBuildSourceTypeProps = Omit<
  UseGetProps<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerEventHistoryBuildSourceTypeQueryParams,
    void
  >,
  'path'
>

/**
 * Get artifact and manifest trigger event history based on build source type
 */
export const useTriggerEventHistoryBuildSourceType = (props: UseTriggerEventHistoryBuildSourceTypeProps) =>
  useGet<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerEventHistoryBuildSourceTypeQueryParams,
    void
  >(`/triggers/eventHistory/artifact-manifest-info`, { base: getConfig('pipeline/api'), ...props })

/**
 * Get artifact and manifest trigger event history based on build source type
 */
export const triggerEventHistoryBuildSourceTypePromise = (
  props: GetUsingFetchProps<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerEventHistoryBuildSourceTypeQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerEventHistoryBuildSourceTypeQueryParams,
    void
  >(getConfig('pipeline/api'), `/triggers/eventHistory/artifact-manifest-info`, props, signal)

export interface TriggerHistoryEventCorrelationQueryParams {
  accountIdentifier: string
  page?: number
  size?: number
  sort?: string[]
}

export interface TriggerHistoryEventCorrelationPathParams {
  eventCorrelationId: string
}

export type TriggerHistoryEventCorrelationProps = Omit<
  GetProps<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerHistoryEventCorrelationQueryParams,
    TriggerHistoryEventCorrelationPathParams
  >,
  'path'
> &
  TriggerHistoryEventCorrelationPathParams

/**
 * Get Trigger history event correlation
 */
export const TriggerHistoryEventCorrelation = ({
  eventCorrelationId,
  ...props
}: TriggerHistoryEventCorrelationProps) => (
  <Get<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerHistoryEventCorrelationQueryParams,
    TriggerHistoryEventCorrelationPathParams
  >
    path={`/triggers/eventHistory/eventCorrelation/${eventCorrelationId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseTriggerHistoryEventCorrelationProps = Omit<
  UseGetProps<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerHistoryEventCorrelationQueryParams,
    TriggerHistoryEventCorrelationPathParams
  >,
  'path'
> &
  TriggerHistoryEventCorrelationPathParams

/**
 * Get Trigger history event correlation
 */
export const useTriggerHistoryEventCorrelation = ({
  eventCorrelationId,
  ...props
}: UseTriggerHistoryEventCorrelationProps) =>
  useGet<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerHistoryEventCorrelationQueryParams,
    TriggerHistoryEventCorrelationPathParams
  >(
    (paramsInPath: TriggerHistoryEventCorrelationPathParams) =>
      `/triggers/eventHistory/eventCorrelation/${paramsInPath.eventCorrelationId}`,
    { base: getConfig('pipeline/api'), pathParams: { eventCorrelationId }, ...props }
  )

/**
 * Get Trigger history event correlation
 */
export const triggerHistoryEventCorrelationPromise = (
  {
    eventCorrelationId,
    ...props
  }: GetUsingFetchProps<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerHistoryEventCorrelationQueryParams,
    TriggerHistoryEventCorrelationPathParams
  > & { eventCorrelationId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerHistoryEventCorrelationQueryParams,
    TriggerHistoryEventCorrelationPathParams
  >(getConfig('pipeline/api'), `/triggers/eventHistory/eventCorrelation/${eventCorrelationId}`, props, signal)

export interface PolledResponseTriggerIdentifierQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
}

export interface PolledResponseTriggerIdentifierPathParams {
  triggerIdentifier: string
}

export type PolledResponseTriggerIdentifierProps = Omit<
  GetProps<
    ResponsePollingInfoForTriggers,
    Failure | Error,
    PolledResponseTriggerIdentifierQueryParams,
    PolledResponseTriggerIdentifierPathParams
  >,
  'path'
> &
  PolledResponseTriggerIdentifierPathParams

/**
 * Get all the polled response for a given trigger
 */
export const PolledResponseTriggerIdentifier = ({
  triggerIdentifier,
  ...props
}: PolledResponseTriggerIdentifierProps) => (
  <Get<
    ResponsePollingInfoForTriggers,
    Failure | Error,
    PolledResponseTriggerIdentifierQueryParams,
    PolledResponseTriggerIdentifierPathParams
  >
    path={`/triggers/eventHistory/polledResponse/${triggerIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UsePolledResponseTriggerIdentifierProps = Omit<
  UseGetProps<
    ResponsePollingInfoForTriggers,
    Failure | Error,
    PolledResponseTriggerIdentifierQueryParams,
    PolledResponseTriggerIdentifierPathParams
  >,
  'path'
> &
  PolledResponseTriggerIdentifierPathParams

/**
 * Get all the polled response for a given trigger
 */
export const usePolledResponseTriggerIdentifier = ({
  triggerIdentifier,
  ...props
}: UsePolledResponseTriggerIdentifierProps) =>
  useGet<
    ResponsePollingInfoForTriggers,
    Failure | Error,
    PolledResponseTriggerIdentifierQueryParams,
    PolledResponseTriggerIdentifierPathParams
  >(
    (paramsInPath: PolledResponseTriggerIdentifierPathParams) =>
      `/triggers/eventHistory/polledResponse/${paramsInPath.triggerIdentifier}`,
    { base: getConfig('pipeline/api'), pathParams: { triggerIdentifier }, ...props }
  )

/**
 * Get all the polled response for a given trigger
 */
export const polledResponseTriggerIdentifierPromise = (
  {
    triggerIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponsePollingInfoForTriggers,
    Failure | Error,
    PolledResponseTriggerIdentifierQueryParams,
    PolledResponseTriggerIdentifierPathParams
  > & { triggerIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePollingInfoForTriggers,
    Failure | Error,
    PolledResponseTriggerIdentifierQueryParams,
    PolledResponseTriggerIdentifierPathParams
  >(getConfig('pipeline/api'), `/triggers/eventHistory/polledResponse/${triggerIdentifier}`, props, signal)

export interface TriggerHistoryEventCorrelationV2QueryParams {
  accountIdentifier: string
  page?: number
  size?: number
  sort?: string[]
}

export interface TriggerHistoryEventCorrelationV2PathParams {
  eventCorrelationId: string
}

export type TriggerHistoryEventCorrelationV2Props = Omit<
  GetProps<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerHistoryEventCorrelationV2QueryParams,
    TriggerHistoryEventCorrelationV2PathParams
  >,
  'path'
> &
  TriggerHistoryEventCorrelationV2PathParams

/**
 * Get Trigger history event correlation V2
 */
export const TriggerHistoryEventCorrelationV2 = ({
  eventCorrelationId,
  ...props
}: TriggerHistoryEventCorrelationV2Props) => (
  <Get<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerHistoryEventCorrelationV2QueryParams,
    TriggerHistoryEventCorrelationV2PathParams
  >
    path={`/triggers/eventHistory/v2/eventCorrelation/${eventCorrelationId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseTriggerHistoryEventCorrelationV2Props = Omit<
  UseGetProps<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerHistoryEventCorrelationV2QueryParams,
    TriggerHistoryEventCorrelationV2PathParams
  >,
  'path'
> &
  TriggerHistoryEventCorrelationV2PathParams

/**
 * Get Trigger history event correlation V2
 */
export const useTriggerHistoryEventCorrelationV2 = ({
  eventCorrelationId,
  ...props
}: UseTriggerHistoryEventCorrelationV2Props) =>
  useGet<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerHistoryEventCorrelationV2QueryParams,
    TriggerHistoryEventCorrelationV2PathParams
  >(
    (paramsInPath: TriggerHistoryEventCorrelationV2PathParams) =>
      `/triggers/eventHistory/v2/eventCorrelation/${paramsInPath.eventCorrelationId}`,
    { base: getConfig('pipeline/api'), pathParams: { eventCorrelationId }, ...props }
  )

/**
 * Get Trigger history event correlation V2
 */
export const triggerHistoryEventCorrelationV2Promise = (
  {
    eventCorrelationId,
    ...props
  }: GetUsingFetchProps<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerHistoryEventCorrelationV2QueryParams,
    TriggerHistoryEventCorrelationV2PathParams
  > & { eventCorrelationId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerHistoryEventCorrelationV2QueryParams,
    TriggerHistoryEventCorrelationV2PathParams
  >(getConfig('pipeline/api'), `/triggers/eventHistory/v2/eventCorrelation/${eventCorrelationId}`, props, signal)

export interface TriggerEventHistoryNewQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
  searchTerm?: string
  page?: number
  size?: number
  sort?: string[]
}

export interface TriggerEventHistoryNewPathParams {
  triggerIdentifier: string
}

export type TriggerEventHistoryNewProps = Omit<
  GetProps<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerEventHistoryNewQueryParams,
    TriggerEventHistoryNewPathParams
  >,
  'path'
> &
  TriggerEventHistoryNewPathParams

/**
 * Get Trigger event history
 */
export const TriggerEventHistoryNew = ({ triggerIdentifier, ...props }: TriggerEventHistoryNewProps) => (
  <Get<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerEventHistoryNewQueryParams,
    TriggerEventHistoryNewPathParams
  >
    path={`/triggers/eventHistory/${triggerIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseTriggerEventHistoryNewProps = Omit<
  UseGetProps<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerEventHistoryNewQueryParams,
    TriggerEventHistoryNewPathParams
  >,
  'path'
> &
  TriggerEventHistoryNewPathParams

/**
 * Get Trigger event history
 */
export const useTriggerEventHistoryNew = ({ triggerIdentifier, ...props }: UseTriggerEventHistoryNewProps) =>
  useGet<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerEventHistoryNewQueryParams,
    TriggerEventHistoryNewPathParams
  >((paramsInPath: TriggerEventHistoryNewPathParams) => `/triggers/eventHistory/${paramsInPath.triggerIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { triggerIdentifier },
    ...props
  })

/**
 * Get Trigger event history
 */
export const triggerEventHistoryNewPromise = (
  {
    triggerIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerEventHistoryNewQueryParams,
    TriggerEventHistoryNewPathParams
  > & { triggerIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerEventHistoryNewQueryParams,
    TriggerEventHistoryNewPathParams
  >(getConfig('pipeline/api'), `/triggers/eventHistory/${triggerIdentifier}`, props, signal)

export interface UpdateTriggerPollingStatusQueryParams {
  accountIdentifier: string
}

export type UpdateTriggerPollingStatusProps = Omit<
  MutateProps<
    ResponseBoolean,
    Failure | Error,
    UpdateTriggerPollingStatusQueryParams,
    PollingTriggerStatusUpdateDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a trigger's polling status by signature
 */
export const UpdateTriggerPollingStatus = (props: UpdateTriggerPollingStatusProps) => (
  <Mutate<ResponseBoolean, Failure | Error, UpdateTriggerPollingStatusQueryParams, PollingTriggerStatusUpdateDTO, void>
    verb="PUT"
    path={`/triggers/pollingTriggerStatus`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateTriggerPollingStatusProps = Omit<
  UseMutateProps<
    ResponseBoolean,
    Failure | Error,
    UpdateTriggerPollingStatusQueryParams,
    PollingTriggerStatusUpdateDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a trigger's polling status by signature
 */
export const useUpdateTriggerPollingStatus = (props: UseUpdateTriggerPollingStatusProps) =>
  useMutate<
    ResponseBoolean,
    Failure | Error,
    UpdateTriggerPollingStatusQueryParams,
    PollingTriggerStatusUpdateDTO,
    void
  >('PUT', `/triggers/pollingTriggerStatus`, { base: getConfig('pipeline/api'), ...props })

/**
 * Update a trigger's polling status by signature
 */
export const updateTriggerPollingStatusPromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    UpdateTriggerPollingStatusQueryParams,
    PollingTriggerStatusUpdateDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    Failure | Error,
    UpdateTriggerPollingStatusQueryParams,
    PollingTriggerStatusUpdateDTO,
    void
  >('PUT', getConfig('pipeline/api'), `/triggers/pollingTriggerStatus`, props, signal)

export type GenerateWebhookTokenProps = Omit<GetProps<RestResponseString, Failure | Error, void, void>, 'path'>

/**
 * Regenerate webhook token
 */
export const GenerateWebhookToken = (props: GenerateWebhookTokenProps) => (
  <Get<RestResponseString, Failure | Error, void, void>
    path={`/triggers/regenerateToken`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGenerateWebhookTokenProps = Omit<UseGetProps<RestResponseString, Failure | Error, void, void>, 'path'>

/**
 * Regenerate webhook token
 */
export const useGenerateWebhookToken = (props: UseGenerateWebhookTokenProps) =>
  useGet<RestResponseString, Failure | Error, void, void>(`/triggers/regenerateToken`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Regenerate webhook token
 */
export const generateWebhookTokenPromise = (
  props: GetUsingFetchProps<RestResponseString, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseString, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/triggers/regenerateToken`,
    props,
    signal
  )

export interface UpdateBranchName1QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
  operationType?: 'RemoteToInline' | 'InlineToRemote'
  pipelineBranchName?: string
}

export type UpdateBranchName1Props = Omit<
  MutateProps<ResponseTriggerUpdateCount, Failure | Error, UpdateBranchName1QueryParams, void, void>,
  'path' | 'verb'
>

export const UpdateBranchName1 = (props: UpdateBranchName1Props) => (
  <Mutate<ResponseTriggerUpdateCount, Failure | Error, UpdateBranchName1QueryParams, void, void>
    verb="PUT"
    path={`/triggers/update-branch-name`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateBranchName1Props = Omit<
  UseMutateProps<ResponseTriggerUpdateCount, Failure | Error, UpdateBranchName1QueryParams, void, void>,
  'path' | 'verb'
>

export const useUpdateBranchName1 = (props: UseUpdateBranchName1Props) =>
  useMutate<ResponseTriggerUpdateCount, Failure | Error, UpdateBranchName1QueryParams, void, void>(
    'PUT',
    `/triggers/update-branch-name`,
    { base: getConfig('pipeline/api'), ...props }
  )

export const updateBranchName1Promise = (
  props: MutateUsingFetchProps<ResponseTriggerUpdateCount, Failure | Error, UpdateBranchName1QueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseTriggerUpdateCount, Failure | Error, UpdateBranchName1QueryParams, void, void>(
    'PUT',
    getConfig('pipeline/api'),
    `/triggers/update-branch-name`,
    props,
    signal
  )

export interface DeleteTriggerQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
}

export type DeleteTriggerProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a trigger by identifier
 */
export const DeleteTrigger = (props: DeleteTriggerProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>
    verb="DELETE"
    path={`/triggers`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDeleteTriggerProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a trigger by identifier
 */
export const useDeleteTrigger = (props: UseDeleteTriggerProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>('DELETE', `/triggers`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Delete a trigger by identifier
 */
export const deleteTriggerPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteTriggerQueryParams, string, void>(
    'DELETE',
    getConfig('pipeline/api'),
    `/triggers`,
    props,
    signal
  )

export interface GetTriggerQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
}

export interface GetTriggerPathParams {
  triggerIdentifier: string
}

export type GetTriggerProps = Omit<
  GetProps<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>,
  'path'
> &
  GetTriggerPathParams

/**
 * Gets a trigger by identifier
 */
export const GetTrigger = ({ triggerIdentifier, ...props }: GetTriggerProps) => (
  <Get<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>
    path={`/triggers/${triggerIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetTriggerProps = Omit<
  UseGetProps<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>,
  'path'
> &
  GetTriggerPathParams

/**
 * Gets a trigger by identifier
 */
export const useGetTrigger = ({ triggerIdentifier, ...props }: UseGetTriggerProps) =>
  useGet<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>(
    (paramsInPath: GetTriggerPathParams) => `/triggers/${paramsInPath.triggerIdentifier}`,
    { base: getConfig('pipeline/api'), pathParams: { triggerIdentifier }, ...props }
  )

/**
 * Gets a trigger by identifier
 */
export const getTriggerPromise = (
  {
    triggerIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams> & {
    triggerIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNGTriggerResponse, Failure | Error, GetTriggerQueryParams, GetTriggerPathParams>(
    getConfig('pipeline/api'),
    `/triggers/${triggerIdentifier}`,
    props,
    signal
  )

export interface UpdateTriggerQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
  ignoreError?: boolean
}

export interface UpdateTriggerPathParams {
  triggerIdentifier: string
}

export type UpdateTriggerProps = Omit<
  MutateProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    UpdateTriggerBodyRequestBody,
    UpdateTriggerPathParams
  >,
  'path' | 'verb'
> &
  UpdateTriggerPathParams

/**
 * Update a trigger by identifier
 */
export const UpdateTrigger = ({ triggerIdentifier, ...props }: UpdateTriggerProps) => (
  <Mutate<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    UpdateTriggerBodyRequestBody,
    UpdateTriggerPathParams
  >
    verb="PUT"
    path={`/triggers/${triggerIdentifier}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateTriggerProps = Omit<
  UseMutateProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    UpdateTriggerBodyRequestBody,
    UpdateTriggerPathParams
  >,
  'path' | 'verb'
> &
  UpdateTriggerPathParams

/**
 * Update a trigger by identifier
 */
export const useUpdateTrigger = ({ triggerIdentifier, ...props }: UseUpdateTriggerProps) =>
  useMutate<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    UpdateTriggerBodyRequestBody,
    UpdateTriggerPathParams
  >('PUT', (paramsInPath: UpdateTriggerPathParams) => `/triggers/${paramsInPath.triggerIdentifier}`, {
    base: getConfig('pipeline/api'),
    pathParams: { triggerIdentifier },
    ...props
  })

/**
 * Update a trigger by identifier
 */
export const updateTriggerPromise = (
  {
    triggerIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    UpdateTriggerBodyRequestBody,
    UpdateTriggerPathParams
  > & { triggerIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseNGTriggerResponse,
    Failure | Error,
    UpdateTriggerQueryParams,
    UpdateTriggerBodyRequestBody,
    UpdateTriggerPathParams
  >('PUT', getConfig('pipeline/api'), `/triggers/${triggerIdentifier}`, props, signal)

export interface GetTriggerDetailsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
}

export interface GetTriggerDetailsPathParams {
  triggerIdentifier: string
}

export type GetTriggerDetailsProps = Omit<
  GetProps<
    ResponseNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerDetailsQueryParams,
    GetTriggerDetailsPathParams
  >,
  'path'
> &
  GetTriggerDetailsPathParams

/**
 * Fetches Trigger details for a specific pipeline and trigger identifier,
 */
export const GetTriggerDetails = ({ triggerIdentifier, ...props }: GetTriggerDetailsProps) => (
  <Get<ResponseNGTriggerDetailsResponse, Failure | Error, GetTriggerDetailsQueryParams, GetTriggerDetailsPathParams>
    path={`/triggers/${triggerIdentifier}/details`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetTriggerDetailsProps = Omit<
  UseGetProps<
    ResponseNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerDetailsQueryParams,
    GetTriggerDetailsPathParams
  >,
  'path'
> &
  GetTriggerDetailsPathParams

/**
 * Fetches Trigger details for a specific pipeline and trigger identifier,
 */
export const useGetTriggerDetails = ({ triggerIdentifier, ...props }: UseGetTriggerDetailsProps) =>
  useGet<ResponseNGTriggerDetailsResponse, Failure | Error, GetTriggerDetailsQueryParams, GetTriggerDetailsPathParams>(
    (paramsInPath: GetTriggerDetailsPathParams) => `/triggers/${paramsInPath.triggerIdentifier}/details`,
    { base: getConfig('pipeline/api'), pathParams: { triggerIdentifier }, ...props }
  )

/**
 * Fetches Trigger details for a specific pipeline and trigger identifier,
 */
export const getTriggerDetailsPromise = (
  {
    triggerIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerDetailsQueryParams,
    GetTriggerDetailsPathParams
  > & { triggerIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseNGTriggerDetailsResponse,
    Failure | Error,
    GetTriggerDetailsQueryParams,
    GetTriggerDetailsPathParams
  >(getConfig('pipeline/api'), `/triggers/${triggerIdentifier}/details`, props, signal)

export interface TriggerEventHistoryQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
  searchTerm?: string
  page?: number
  size?: number
  sort?: string[]
}

export interface TriggerEventHistoryPathParams {
  triggerIdentifier: string
}

export type TriggerEventHistoryProps = Omit<
  GetProps<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerEventHistoryQueryParams,
    TriggerEventHistoryPathParams
  >,
  'path'
> &
  TriggerEventHistoryPathParams

/**
 * Get Trigger event history
 */
export const TriggerEventHistory = ({ triggerIdentifier, ...props }: TriggerEventHistoryProps) => (
  <Get<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerEventHistoryQueryParams,
    TriggerEventHistoryPathParams
  >
    path={`/triggers/${triggerIdentifier}/eventHistory`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseTriggerEventHistoryProps = Omit<
  UseGetProps<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerEventHistoryQueryParams,
    TriggerEventHistoryPathParams
  >,
  'path'
> &
  TriggerEventHistoryPathParams

/**
 * Get Trigger event history
 */
export const useTriggerEventHistory = ({ triggerIdentifier, ...props }: UseTriggerEventHistoryProps) =>
  useGet<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerEventHistoryQueryParams,
    TriggerEventHistoryPathParams
  >((paramsInPath: TriggerEventHistoryPathParams) => `/triggers/${paramsInPath.triggerIdentifier}/eventHistory`, {
    base: getConfig('pipeline/api'),
    pathParams: { triggerIdentifier },
    ...props
  })

/**
 * Get Trigger event history
 */
export const triggerEventHistoryPromise = (
  {
    triggerIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerEventHistoryQueryParams,
    TriggerEventHistoryPathParams
  > & { triggerIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageNGTriggerEventHistoryResponse,
    Failure | Error,
    TriggerEventHistoryQueryParams,
    TriggerEventHistoryPathParams
  >(getConfig('pipeline/api'), `/triggers/${triggerIdentifier}/eventHistory`, props, signal)

export interface UpdateTriggerStatusQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  targetIdentifier: string
  status: boolean
}

export interface UpdateTriggerStatusPathParams {
  triggerIdentifier: string
}

export type UpdateTriggerStatusProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, UpdateTriggerStatusQueryParams, void, UpdateTriggerStatusPathParams>,
  'path' | 'verb'
> &
  UpdateTriggerStatusPathParams

/**
 * Update a trigger's status by identifier
 */
export const UpdateTriggerStatus = ({ triggerIdentifier, ...props }: UpdateTriggerStatusProps) => (
  <Mutate<ResponseBoolean, Failure | Error, UpdateTriggerStatusQueryParams, void, UpdateTriggerStatusPathParams>
    verb="PUT"
    path={`/triggers/${triggerIdentifier}/status`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseUpdateTriggerStatusProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, UpdateTriggerStatusQueryParams, void, UpdateTriggerStatusPathParams>,
  'path' | 'verb'
> &
  UpdateTriggerStatusPathParams

/**
 * Update a trigger's status by identifier
 */
export const useUpdateTriggerStatus = ({ triggerIdentifier, ...props }: UseUpdateTriggerStatusProps) =>
  useMutate<ResponseBoolean, Failure | Error, UpdateTriggerStatusQueryParams, void, UpdateTriggerStatusPathParams>(
    'PUT',
    (paramsInPath: UpdateTriggerStatusPathParams) => `/triggers/${paramsInPath.triggerIdentifier}/status`,
    { base: getConfig('pipeline/api'), pathParams: { triggerIdentifier }, ...props }
  )

/**
 * Update a trigger's status by identifier
 */
export const updateTriggerStatusPromise = (
  {
    triggerIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    UpdateTriggerStatusQueryParams,
    void,
    UpdateTriggerStatusPathParams
  > & { triggerIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    Failure | Error,
    UpdateTriggerStatusQueryParams,
    void,
    UpdateTriggerStatusPathParams
  >('PUT', getConfig('pipeline/api'), `/triggers/${triggerIdentifier}/status`, props, signal)

export interface ExecutionDetailsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface ExecutionDetailsPathParams {
  nodeExecutionId: string
}

export type ExecutionDetailsProps = Omit<
  GetProps<
    ResponseWaitStepExecutionDetailsDto,
    Failure | Error,
    ExecutionDetailsQueryParams,
    ExecutionDetailsPathParams
  >,
  'path'
> &
  ExecutionDetailsPathParams

/**
 * Get Wait Step execution details
 */
export const ExecutionDetails = ({ nodeExecutionId, ...props }: ExecutionDetailsProps) => (
  <Get<ResponseWaitStepExecutionDetailsDto, Failure | Error, ExecutionDetailsQueryParams, ExecutionDetailsPathParams>
    path={`/waitStep/executionDetails/${nodeExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseExecutionDetailsProps = Omit<
  UseGetProps<
    ResponseWaitStepExecutionDetailsDto,
    Failure | Error,
    ExecutionDetailsQueryParams,
    ExecutionDetailsPathParams
  >,
  'path'
> &
  ExecutionDetailsPathParams

/**
 * Get Wait Step execution details
 */
export const useExecutionDetails = ({ nodeExecutionId, ...props }: UseExecutionDetailsProps) =>
  useGet<ResponseWaitStepExecutionDetailsDto, Failure | Error, ExecutionDetailsQueryParams, ExecutionDetailsPathParams>(
    (paramsInPath: ExecutionDetailsPathParams) => `/waitStep/executionDetails/${paramsInPath.nodeExecutionId}`,
    { base: getConfig('pipeline/api'), pathParams: { nodeExecutionId }, ...props }
  )

/**
 * Get Wait Step execution details
 */
export const executionDetailsPromise = (
  {
    nodeExecutionId,
    ...props
  }: GetUsingFetchProps<
    ResponseWaitStepExecutionDetailsDto,
    Failure | Error,
    ExecutionDetailsQueryParams,
    ExecutionDetailsPathParams
  > & { nodeExecutionId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseWaitStepExecutionDetailsDto,
    Failure | Error,
    ExecutionDetailsQueryParams,
    ExecutionDetailsPathParams
  >(getConfig('pipeline/api'), `/waitStep/executionDetails/${nodeExecutionId}`, props, signal)

export interface MarkWaitStepQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export interface MarkWaitStepPathParams {
  nodeExecutionId: string
}

export type MarkWaitStepProps = Omit<
  MutateProps<
    ResponseWaitStepResponseDto,
    Failure | Error,
    MarkWaitStepQueryParams,
    WaitStepRequestDto,
    MarkWaitStepPathParams
  >,
  'path' | 'verb'
> &
  MarkWaitStepPathParams

/**
 * Marks the Wait Step as fail or success
 */
export const MarkWaitStep = ({ nodeExecutionId, ...props }: MarkWaitStepProps) => (
  <Mutate<
    ResponseWaitStepResponseDto,
    Failure | Error,
    MarkWaitStepQueryParams,
    WaitStepRequestDto,
    MarkWaitStepPathParams
  >
    verb="POST"
    path={`/waitStep/${nodeExecutionId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseMarkWaitStepProps = Omit<
  UseMutateProps<
    ResponseWaitStepResponseDto,
    Failure | Error,
    MarkWaitStepQueryParams,
    WaitStepRequestDto,
    MarkWaitStepPathParams
  >,
  'path' | 'verb'
> &
  MarkWaitStepPathParams

/**
 * Marks the Wait Step as fail or success
 */
export const useMarkWaitStep = ({ nodeExecutionId, ...props }: UseMarkWaitStepProps) =>
  useMutate<
    ResponseWaitStepResponseDto,
    Failure | Error,
    MarkWaitStepQueryParams,
    WaitStepRequestDto,
    MarkWaitStepPathParams
  >('POST', (paramsInPath: MarkWaitStepPathParams) => `/waitStep/${paramsInPath.nodeExecutionId}`, {
    base: getConfig('pipeline/api'),
    pathParams: { nodeExecutionId },
    ...props
  })

/**
 * Marks the Wait Step as fail or success
 */
export const markWaitStepPromise = (
  {
    nodeExecutionId,
    ...props
  }: MutateUsingFetchProps<
    ResponseWaitStepResponseDto,
    Failure | Error,
    MarkWaitStepQueryParams,
    WaitStepRequestDto,
    MarkWaitStepPathParams
  > & { nodeExecutionId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseWaitStepResponseDto,
    Failure | Error,
    MarkWaitStepQueryParams,
    WaitStepRequestDto,
    MarkWaitStepPathParams
  >('POST', getConfig('pipeline/api'), `/waitStep/${nodeExecutionId}`, props, signal)

export interface GetActionsListQueryParams {
  sourceRepo: 'AZURE_REPO' | 'GITHUB' | 'GITLAB' | 'BITBUCKET' | 'AWS_CODECOMMIT' | 'HARNESS' | 'CUSTOM'
  event: string
}

export type GetActionsListProps = Omit<
  GetProps<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>,
  'path'
>

/**
 * Get Actions for event type and source
 */
export const GetActionsList = (props: GetActionsListProps) => (
  <Get<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>
    path={`/webhook/actions`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetActionsListProps = Omit<
  UseGetProps<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>,
  'path'
>

/**
 * Get Actions for event type and source
 */
export const useGetActionsList = (props: UseGetActionsListProps) =>
  useGet<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>(`/webhook/actions`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Actions for event type and source
 */
export const getActionsListPromise = (
  props: GetUsingFetchProps<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListWebhookAction, Failure | Error, GetActionsListQueryParams, void>(
    getConfig('pipeline/api'),
    `/webhook/actions`,
    props,
    signal
  )

export type GetBitbucketPRActionsProps = Omit<
  GetProps<ResponseListBitbucketPRAction, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const GetBitbucketPRActions = (props: GetBitbucketPRActionsProps) => (
  <Get<ResponseListBitbucketPRAction, Failure | Error, void, void>
    path={`/webhook/bitbucketPRActions`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetBitbucketPRActionsProps = Omit<
  UseGetProps<ResponseListBitbucketPRAction, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetBitbucketPRActions = (props: UseGetBitbucketPRActionsProps) =>
  useGet<ResponseListBitbucketPRAction, Failure | Error, void, void>(`/webhook/bitbucketPRActions`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getBitbucketPRActionsPromise = (
  props: GetUsingFetchProps<ResponseListBitbucketPRAction, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListBitbucketPRAction, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/bitbucketPRActions`,
    props,
    signal
  )

export type GetBitbucketTriggerEventsProps = Omit<
  GetProps<ResponseListBitbucketTriggerEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const GetBitbucketTriggerEvents = (props: GetBitbucketTriggerEventsProps) => (
  <Get<ResponseListBitbucketTriggerEvent, Failure | Error, void, void>
    path={`/webhook/bitbucketTriggerEvents`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetBitbucketTriggerEventsProps = Omit<
  UseGetProps<ResponseListBitbucketTriggerEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetBitbucketTriggerEvents = (props: UseGetBitbucketTriggerEventsProps) =>
  useGet<ResponseListBitbucketTriggerEvent, Failure | Error, void, void>(`/webhook/bitbucketTriggerEvents`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getBitbucketTriggerEventsPromise = (
  props: GetUsingFetchProps<ResponseListBitbucketTriggerEvent, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListBitbucketTriggerEvent, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/bitbucketTriggerEvents`,
    props,
    signal
  )

export interface CustomWebhookEndpointQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier?: string
  triggerIdentifier?: string
}

export type CustomWebhookEndpointProps = Omit<
  MutateProps<ResponseString, Failure | Error, CustomWebhookEndpointQueryParams, UpdateTriggerBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * accept custom webhook event
 */
export const CustomWebhookEndpoint = (props: CustomWebhookEndpointProps) => (
  <Mutate<ResponseString, Failure | Error, CustomWebhookEndpointQueryParams, UpdateTriggerBodyRequestBody, void>
    verb="POST"
    path={`/webhook/custom`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCustomWebhookEndpointProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, CustomWebhookEndpointQueryParams, UpdateTriggerBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * accept custom webhook event
 */
export const useCustomWebhookEndpoint = (props: UseCustomWebhookEndpointProps) =>
  useMutate<ResponseString, Failure | Error, CustomWebhookEndpointQueryParams, UpdateTriggerBodyRequestBody, void>(
    'POST',
    `/webhook/custom`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * accept custom webhook event
 */
export const customWebhookEndpointPromise = (
  props: MutateUsingFetchProps<
    ResponseString,
    Failure | Error,
    CustomWebhookEndpointQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseString,
    Failure | Error,
    CustomWebhookEndpointQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/webhook/custom`, props, signal)

export interface CustomWebhookEndpointV2QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier?: string
  triggerIdentifier?: string
}

export type CustomWebhookEndpointV2Props = Omit<
  MutateProps<
    ResponseNGProcessWebhookResponse,
    Failure | Error,
    CustomWebhookEndpointV2QueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * accept custom webhook event V2
 */
export const CustomWebhookEndpointV2 = (props: CustomWebhookEndpointV2Props) => (
  <Mutate<
    ResponseNGProcessWebhookResponse,
    Failure | Error,
    CustomWebhookEndpointV2QueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >
    verb="POST"
    path={`/webhook/custom/v2`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCustomWebhookEndpointV2Props = Omit<
  UseMutateProps<
    ResponseNGProcessWebhookResponse,
    Failure | Error,
    CustomWebhookEndpointV2QueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * accept custom webhook event V2
 */
export const useCustomWebhookEndpointV2 = (props: UseCustomWebhookEndpointV2Props) =>
  useMutate<
    ResponseNGProcessWebhookResponse,
    Failure | Error,
    CustomWebhookEndpointV2QueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >('POST', `/webhook/custom/v2`, { base: getConfig('pipeline/api'), ...props })

/**
 * accept custom webhook event V2
 */
export const customWebhookEndpointV2Promise = (
  props: MutateUsingFetchProps<
    ResponseNGProcessWebhookResponse,
    Failure | Error,
    CustomWebhookEndpointV2QueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseNGProcessWebhookResponse,
    Failure | Error,
    CustomWebhookEndpointV2QueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >('POST', getConfig('pipeline/api'), `/webhook/custom/v2`, props, signal)

export interface CustomWebhookEndpointV3QueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier?: string
  triggerIdentifier?: string
}

export interface CustomWebhookEndpointV3PathParams {
  webhookToken: string
}

export type CustomWebhookEndpointV3Props = Omit<
  MutateProps<
    ResponseNGProcessWebhookResponse,
    Failure | Error,
    CustomWebhookEndpointV3QueryParams,
    UpdateTriggerBodyRequestBody,
    CustomWebhookEndpointV3PathParams
  >,
  'path' | 'verb'
> &
  CustomWebhookEndpointV3PathParams

/**
 * accept custom webhook event V3
 */
export const CustomWebhookEndpointV3 = ({ webhookToken, ...props }: CustomWebhookEndpointV3Props) => (
  <Mutate<
    ResponseNGProcessWebhookResponse,
    Failure | Error,
    CustomWebhookEndpointV3QueryParams,
    UpdateTriggerBodyRequestBody,
    CustomWebhookEndpointV3PathParams
  >
    verb="POST"
    path={`/webhook/custom/${webhookToken}/v3`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseCustomWebhookEndpointV3Props = Omit<
  UseMutateProps<
    ResponseNGProcessWebhookResponse,
    Failure | Error,
    CustomWebhookEndpointV3QueryParams,
    UpdateTriggerBodyRequestBody,
    CustomWebhookEndpointV3PathParams
  >,
  'path' | 'verb'
> &
  CustomWebhookEndpointV3PathParams

/**
 * accept custom webhook event V3
 */
export const useCustomWebhookEndpointV3 = ({ webhookToken, ...props }: UseCustomWebhookEndpointV3Props) =>
  useMutate<
    ResponseNGProcessWebhookResponse,
    Failure | Error,
    CustomWebhookEndpointV3QueryParams,
    UpdateTriggerBodyRequestBody,
    CustomWebhookEndpointV3PathParams
  >('POST', (paramsInPath: CustomWebhookEndpointV3PathParams) => `/webhook/custom/${paramsInPath.webhookToken}/v3`, {
    base: getConfig('pipeline/api'),
    pathParams: { webhookToken },
    ...props
  })

/**
 * accept custom webhook event V3
 */
export const customWebhookEndpointV3Promise = (
  {
    webhookToken,
    ...props
  }: MutateUsingFetchProps<
    ResponseNGProcessWebhookResponse,
    Failure | Error,
    CustomWebhookEndpointV3QueryParams,
    UpdateTriggerBodyRequestBody,
    CustomWebhookEndpointV3PathParams
  > & { webhookToken: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseNGProcessWebhookResponse,
    Failure | Error,
    CustomWebhookEndpointV3QueryParams,
    UpdateTriggerBodyRequestBody,
    CustomWebhookEndpointV3PathParams
  >('POST', getConfig('pipeline/api'), `/webhook/custom/${webhookToken}/v3`, props, signal)

export type GetGitTriggerEventDetailsProps = Omit<
  GetProps<ResponseMapStringMapStringListString, Failure | Error, void, void>,
  'path'
>

/**
 * Get trigger git actions with Events
 */
export const GetGitTriggerEventDetails = (props: GetGitTriggerEventDetailsProps) => (
  <Get<ResponseMapStringMapStringListString, Failure | Error, void, void>
    path={`/webhook/gitTriggerEventDetails`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetGitTriggerEventDetailsProps = Omit<
  UseGetProps<ResponseMapStringMapStringListString, Failure | Error, void, void>,
  'path'
>

/**
 * Get trigger git actions with Events
 */
export const useGetGitTriggerEventDetails = (props: UseGetGitTriggerEventDetailsProps) =>
  useGet<ResponseMapStringMapStringListString, Failure | Error, void, void>(`/webhook/gitTriggerEventDetails`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get trigger git actions with Events
 */
export const getGitTriggerEventDetailsPromise = (
  props: GetUsingFetchProps<ResponseMapStringMapStringListString, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapStringMapStringListString, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/gitTriggerEventDetails`,
    props,
    signal
  )

export type GetGithubIssueCommentActionsProps = Omit<
  GetProps<ResponseListGithubIssueCommentAction, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const GetGithubIssueCommentActions = (props: GetGithubIssueCommentActionsProps) => (
  <Get<ResponseListGithubIssueCommentAction, Failure | Error, void, void>
    path={`/webhook/githubIssueCommentActions`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetGithubIssueCommentActionsProps = Omit<
  UseGetProps<ResponseListGithubIssueCommentAction, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetGithubIssueCommentActions = (props: UseGetGithubIssueCommentActionsProps) =>
  useGet<ResponseListGithubIssueCommentAction, Failure | Error, void, void>(`/webhook/githubIssueCommentActions`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getGithubIssueCommentActionsPromise = (
  props: GetUsingFetchProps<ResponseListGithubIssueCommentAction, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListGithubIssueCommentAction, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/githubIssueCommentActions`,
    props,
    signal
  )

export type GetGithubPRActionsProps = Omit<GetProps<ResponseListGithubPRAction, Failure | Error, void, void>, 'path'>

/**
 * Get Source Repo types with Events
 */
export const GetGithubPRActions = (props: GetGithubPRActionsProps) => (
  <Get<ResponseListGithubPRAction, Failure | Error, void, void>
    path={`/webhook/githubPRActions`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetGithubPRActionsProps = Omit<
  UseGetProps<ResponseListGithubPRAction, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetGithubPRActions = (props: UseGetGithubPRActionsProps) =>
  useGet<ResponseListGithubPRAction, Failure | Error, void, void>(`/webhook/githubPRActions`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getGithubPRActionsPromise = (
  props: GetUsingFetchProps<ResponseListGithubPRAction, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListGithubPRAction, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/githubPRActions`,
    props,
    signal
  )

export type GetGithubTriggerEventsProps = Omit<
  GetProps<ResponseListGithubTriggerEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const GetGithubTriggerEvents = (props: GetGithubTriggerEventsProps) => (
  <Get<ResponseListGithubTriggerEvent, Failure | Error, void, void>
    path={`/webhook/githubTriggerEvents`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetGithubTriggerEventsProps = Omit<
  UseGetProps<ResponseListGithubTriggerEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetGithubTriggerEvents = (props: UseGetGithubTriggerEventsProps) =>
  useGet<ResponseListGithubTriggerEvent, Failure | Error, void, void>(`/webhook/githubTriggerEvents`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getGithubTriggerEventsPromise = (
  props: GetUsingFetchProps<ResponseListGithubTriggerEvent, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListGithubTriggerEvent, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/githubTriggerEvents`,
    props,
    signal
  )

export type GetGitlabPRActionsProps = Omit<GetProps<ResponseListGitlabPRAction, Failure | Error, void, void>, 'path'>

/**
 * Get Source Repo types with Events
 */
export const GetGitlabPRActions = (props: GetGitlabPRActionsProps) => (
  <Get<ResponseListGitlabPRAction, Failure | Error, void, void>
    path={`/webhook/gitlabPRActions`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetGitlabPRActionsProps = Omit<
  UseGetProps<ResponseListGitlabPRAction, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetGitlabPRActions = (props: UseGetGitlabPRActionsProps) =>
  useGet<ResponseListGitlabPRAction, Failure | Error, void, void>(`/webhook/gitlabPRActions`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getGitlabPRActionsPromise = (
  props: GetUsingFetchProps<ResponseListGitlabPRAction, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListGitlabPRAction, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/gitlabPRActions`,
    props,
    signal
  )

export type GetGitlabTriggerEventsProps = Omit<
  GetProps<ResponseListGitlabTriggerEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const GetGitlabTriggerEvents = (props: GetGitlabTriggerEventsProps) => (
  <Get<ResponseListGitlabTriggerEvent, Failure | Error, void, void>
    path={`/webhook/gitlabTriggerEvents`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetGitlabTriggerEventsProps = Omit<
  UseGetProps<ResponseListGitlabTriggerEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetGitlabTriggerEvents = (props: UseGetGitlabTriggerEventsProps) =>
  useGet<ResponseListGitlabTriggerEvent, Failure | Error, void, void>(`/webhook/gitlabTriggerEvents`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getGitlabTriggerEventsPromise = (
  props: GetUsingFetchProps<ResponseListGitlabTriggerEvent, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListGitlabTriggerEvent, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/gitlabTriggerEvents`,
    props,
    signal
  )

export type GetSourceRepoToEventProps = Omit<
  GetProps<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const GetSourceRepoToEvent = (props: GetSourceRepoToEventProps) => (
  <Get<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>
    path={`/webhook/sourceRepos`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetSourceRepoToEventProps = Omit<
  UseGetProps<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetSourceRepoToEvent = (props: UseGetSourceRepoToEventProps) =>
  useGet<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>(`/webhook/sourceRepos`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getSourceRepoToEventPromise = (
  props: GetUsingFetchProps<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapWebhookSourceRepoListWebhookEvent, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/sourceRepos`,
    props,
    signal
  )

export interface WebhookEndpointQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type WebhookEndpointProps = Omit<
  MutateProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, UpdateTriggerBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * accept webhook event
 */
export const WebhookEndpoint = (props: WebhookEndpointProps) => (
  <Mutate<ResponseString, Failure | Error, WebhookEndpointQueryParams, UpdateTriggerBodyRequestBody, void>
    verb="POST"
    path={`/webhook/trigger`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseWebhookEndpointProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, UpdateTriggerBodyRequestBody, void>,
  'path' | 'verb'
>

/**
 * accept webhook event
 */
export const useWebhookEndpoint = (props: UseWebhookEndpointProps) =>
  useMutate<ResponseString, Failure | Error, WebhookEndpointQueryParams, UpdateTriggerBodyRequestBody, void>(
    'POST',
    `/webhook/trigger`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * accept webhook event
 */
export const webhookEndpointPromise = (
  props: MutateUsingFetchProps<
    ResponseString,
    Failure | Error,
    WebhookEndpointQueryParams,
    UpdateTriggerBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, WebhookEndpointQueryParams, UpdateTriggerBodyRequestBody, void>(
    'POST',
    getConfig('pipeline/api'),
    `/webhook/trigger`,
    props,
    signal
  )

export interface TriggerExecutionDetailsQueryParams {
  accountIdentifier: string
}

export interface TriggerExecutionDetailsPathParams {
  eventId: string
}

export type TriggerExecutionDetailsProps = Omit<
  GetProps<
    ResponseWebhookExecutionDetails,
    Failure | Error,
    TriggerExecutionDetailsQueryParams,
    TriggerExecutionDetailsPathParams
  >,
  'path'
> &
  TriggerExecutionDetailsPathParams

/**
 * fetch webhook event details with execution summary
 */
export const TriggerExecutionDetails = ({ eventId, ...props }: TriggerExecutionDetailsProps) => (
  <Get<
    ResponseWebhookExecutionDetails,
    Failure | Error,
    TriggerExecutionDetailsQueryParams,
    TriggerExecutionDetailsPathParams
  >
    path={`/webhook/triggerExecutionDetails/${eventId}`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseTriggerExecutionDetailsProps = Omit<
  UseGetProps<
    ResponseWebhookExecutionDetails,
    Failure | Error,
    TriggerExecutionDetailsQueryParams,
    TriggerExecutionDetailsPathParams
  >,
  'path'
> &
  TriggerExecutionDetailsPathParams

/**
 * fetch webhook event details with execution summary
 */
export const useTriggerExecutionDetails = ({ eventId, ...props }: UseTriggerExecutionDetailsProps) =>
  useGet<
    ResponseWebhookExecutionDetails,
    Failure | Error,
    TriggerExecutionDetailsQueryParams,
    TriggerExecutionDetailsPathParams
  >((paramsInPath: TriggerExecutionDetailsPathParams) => `/webhook/triggerExecutionDetails/${paramsInPath.eventId}`, {
    base: getConfig('pipeline/api'),
    pathParams: { eventId },
    ...props
  })

/**
 * fetch webhook event details with execution summary
 */
export const triggerExecutionDetailsPromise = (
  {
    eventId,
    ...props
  }: GetUsingFetchProps<
    ResponseWebhookExecutionDetails,
    Failure | Error,
    TriggerExecutionDetailsQueryParams,
    TriggerExecutionDetailsPathParams
  > & { eventId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseWebhookExecutionDetails,
    Failure | Error,
    TriggerExecutionDetailsQueryParams,
    TriggerExecutionDetailsPathParams
  >(getConfig('pipeline/api'), `/webhook/triggerExecutionDetails/${eventId}`, props, signal)

export interface TriggerProcessingDetailsQueryParams {
  accountIdentifier: string
  eventId: string
}

export type TriggerProcessingDetailsProps = Omit<
  GetProps<ResponseWebhookEventProcessingDetails, Failure | Error, TriggerProcessingDetailsQueryParams, void>,
  'path'
>

/**
 * fetch webhook event details
 */
export const TriggerProcessingDetails = (props: TriggerProcessingDetailsProps) => (
  <Get<ResponseWebhookEventProcessingDetails, Failure | Error, TriggerProcessingDetailsQueryParams, void>
    path={`/webhook/triggerProcessingDetails`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseTriggerProcessingDetailsProps = Omit<
  UseGetProps<ResponseWebhookEventProcessingDetails, Failure | Error, TriggerProcessingDetailsQueryParams, void>,
  'path'
>

/**
 * fetch webhook event details
 */
export const useTriggerProcessingDetails = (props: UseTriggerProcessingDetailsProps) =>
  useGet<ResponseWebhookEventProcessingDetails, Failure | Error, TriggerProcessingDetailsQueryParams, void>(
    `/webhook/triggerProcessingDetails`,
    { base: getConfig('pipeline/api'), ...props }
  )

/**
 * fetch webhook event details
 */
export const triggerProcessingDetailsPromise = (
  props: GetUsingFetchProps<
    ResponseWebhookEventProcessingDetails,
    Failure | Error,
    TriggerProcessingDetailsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseWebhookEventProcessingDetails, Failure | Error, TriggerProcessingDetailsQueryParams, void>(
    getConfig('pipeline/api'),
    `/webhook/triggerProcessingDetails`,
    props,
    signal
  )

export type GetWebhookTriggerTypesProps = Omit<
  GetProps<ResponseListWebhookTriggerType, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const GetWebhookTriggerTypes = (props: GetWebhookTriggerTypesProps) => (
  <Get<ResponseListWebhookTriggerType, Failure | Error, void, void>
    path={`/webhook/webhookTriggerTypes`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetWebhookTriggerTypesProps = Omit<
  UseGetProps<ResponseListWebhookTriggerType, Failure | Error, void, void>,
  'path'
>

/**
 * Get Source Repo types with Events
 */
export const useGetWebhookTriggerTypes = (props: UseGetWebhookTriggerTypesProps) =>
  useGet<ResponseListWebhookTriggerType, Failure | Error, void, void>(`/webhook/webhookTriggerTypes`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Source Repo types with Events
 */
export const getWebhookTriggerTypesPromise = (
  props: GetUsingFetchProps<ResponseListWebhookTriggerType, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListWebhookTriggerType, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/webhook/webhookTriggerTypes`,
    props,
    signal
  )

export interface GetSchemaYamlQueryParams {
  entityType:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushGAR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'SlsaVerification'
    | 'UpdateGitOpsApp'
    | 'EcsServiceSetup'
    | 'EcsUpgradeContainer'
    | 'EcsBasicRollback'
    | 'ChaosInfrastructure'
    | 'Anchore'
    | 'Overrides'
    | 'AsgShiftTraffic'
    | 'AquaSecurity'
    | 'IDPStage'
    | 'ChaosHub'
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
  identifier?: string
  accountIdentifier: string
}

export type GetSchemaYamlProps = Omit<
  GetProps<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>,
  'path'
>

/**
 * Get Yaml Schema
 */
export const GetSchemaYaml = (props: GetSchemaYamlProps) => (
  <Get<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>
    path={`/yaml-schema`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseGetSchemaYamlProps = Omit<
  UseGetProps<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>,
  'path'
>

/**
 * Get Yaml Schema
 */
export const useGetSchemaYaml = (props: UseGetSchemaYamlProps) =>
  useGet<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>(`/yaml-schema`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * Get Yaml Schema
 */
export const getSchemaYamlPromise = (
  props: GetUsingFetchProps<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJsonNode, Failure | Error, GetSchemaYamlQueryParams, void>(
    getConfig('pipeline/api'),
    `/yaml-schema`,
    props,
    signal
  )

export type DummyApiForSwaggerSchemaCheckProps = Omit<
  GetProps<ResponsePipelineConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking pms schema
 */
export const DummyApiForSwaggerSchemaCheck = (props: DummyApiForSwaggerSchemaCheckProps) => (
  <Get<ResponsePipelineConfig, Failure | Error, void, void>
    path={`/yaml-schema/dummyApiForSwaggerSchemaCheck`}
    base={getConfig('pipeline/api')}
    {...props}
  />
)

export type UseDummyApiForSwaggerSchemaCheckProps = Omit<
  UseGetProps<ResponsePipelineConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking pms schema
 */
export const useDummyApiForSwaggerSchemaCheck = (props: UseDummyApiForSwaggerSchemaCheckProps) =>
  useGet<ResponsePipelineConfig, Failure | Error, void, void>(`/yaml-schema/dummyApiForSwaggerSchemaCheck`, {
    base: getConfig('pipeline/api'),
    ...props
  })

/**
 * dummy api for checking pms schema
 */
export const dummyApiForSwaggerSchemaCheckPromise = (
  props: GetUsingFetchProps<ResponsePipelineConfig, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePipelineConfig, Failure | Error, void, void>(
    getConfig('pipeline/api'),
    `/yaml-schema/dummyApiForSwaggerSchemaCheck`,
    props,
    signal
  )
