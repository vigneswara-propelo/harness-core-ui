/*
 * Copyright 2023 Harness Inc. All rights reserved.
 * Use of this source code is governed by the PolyForm Shield 1.0.0 license
 * that can be found in the licenses directory at the root of this repository, also available at
 * https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt.
 */

/* Generated by restful-react */

import React from 'react'
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'

import { getConfig, getUsingFetch, mutateUsingFetch, GetUsingFetchProps, MutateUsingFetchProps } from '../config'
export const SPEC_VERSION = '2.0'
export type ACRStepInfo = StepSpecType & {
  baseImageConnectorRefs?: string[]
  buildArgs?: {
    [key: string]: string
  }
  cacheFrom?: string[]
  cacheTo?: string
  caching?: boolean
  connectorRef: string
  context?: string
  dockerfile?: string
  labels?: {
    [key: string]: string
  }
  optimize?: boolean
  remoteCacheImage?: string
  repository: string
  resources?: ContainerResource
  runAsUser?: number
  subscriptionId?: string
  tags: string[]
  target?: string
}

export type AbortFailureActionConfig = FailureStrategyActionConfig & {
  type: 'Abort'
}

export type ActionStepInfo = StepSpecType & {
  env?: ParameterFieldMapStringString
  uses: string
  with?: ParameterFieldMapStringString
}

export type ActionStepInfoV1 = StepSpecType & {
  envs?: ParameterFieldMapStringString
  outputs?: string[]
  resources?: ContainerResource
  uses: string
  with?: ParameterFieldMapStringString
}

export interface ActiveDevelopersDTO {
  accountIdentifier?: string
  identifier: string
  lastBuild?: number
  module?: string
  orgIdentifier?: string
  projectIdentifier?: string
  timestamp?: number
}

export type AquaTrivyStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  image?: STOYamlImage
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export interface Attestation {
  spec?: AttestationSpec
  type?: 'cosign'
}

export interface AttestationSpec {
  [key: string]: any
}

export interface AttestationSpecV1 {
  [key: string]: any
}

export interface AttestationV1 {
  spec?: AttestationSpecV1
  type?: 'cosign'
}

export interface AuthorInfo {
  name?: string
  url?: string
}

export type AwsEcrStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  auth?: STOYamlAuth
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  image?: STOYamlImage
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export type AwsSecurityHubStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  auth?: STOYamlAuth
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export type BackgroundStepInfo = StepSpecType & {
  command?: string
  connectorRef?: string
  entrypoint?: string[]
  envVariables?: {
    [key: string]: string
  }
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  portBindings?: {
    [key: string]: string
  }
  privileged?: boolean
  reports?: UnitTestReport
  resources?: ContainerResource
  runAsUser?: number
  shell?: 'Sh' | 'Bash' | 'Powershell' | 'Pwsh' | 'Python'
}

export type BackgroundStepInfoV1 = StepSpecType & {
  args?: string[]
  entrypoint?: string
  entrypointList?: ParameterFieldListString
  envs?: {
    [key: string]: string
  }
  image?: string
  network?: string
  ports?: string[]
  privileged?: boolean
  pull?: 'always' | 'never' | 'if-not-exists'
  resources?: ContainerResource
  run: string
  shell?: 'sh' | 'bash' | 'powershell' | 'pwsh' | 'python'
  user?: number
}

export type BanditStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export type BitriseStepInfo = StepSpecType & {
  env?: ParameterFieldMapStringString
  uses: string
  with?: ParameterFieldMapStringString
}

export type BitriseStepInfoV1 = StepSpecType & {
  envs?: ParameterFieldMapStringString
  outputs?: string[]
  resources?: ContainerResource
  uses: string
  with?: ParameterFieldMapStringString
}

export type BlackDuckStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  auth?: STOYamlAuth
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  image?: STOYamlImage
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  sbom?: STOYamlSBOM
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
  tool?: STOYamlBlackduckToolData
}

export type BrakemanStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export type BranchBuildSpec = BuildSpec & {
  branch: string
}

export type BranchWebhookEvent = WebhookEvent & {
  baseAttributes?: WebhookBaseAttributes
  branchName?: string
  commitDetailsList?: CommitDetails[]
  link?: string
  repository?: Repository
}

export interface Build {
  spec: BuildSpec
  type: 'branch' | 'tag' | 'PR' | 'commitSha'
}

export interface BuildActiveInfo {
  author?: AuthorInfo
  branch?: string
  commit?: string
  commitID?: string
  endTs?: number
  gitInfo?: GitInfo
  pipelineIdentifier?: string
  piplineName?: string
  planExecutionId?: string
  serviceInfoList?: ServiceDeploymentInfo[]
  startTs?: number
  status?: string
  triggerType?: string
}

export interface BuildCount {
  aborted?: number
  expired?: number
  failed?: number
  success?: number
  total?: number
}

export interface BuildExecutionInfo {
  builds?: BuildCount
  time?: number
}

export interface BuildFailureInfo {
  author?: AuthorInfo
  branch?: string
  commit?: string
  commitID?: string
  endTs?: number
  gitInfo?: GitInfo
  pipelineIdentifier?: string
  piplineName?: string
  planExecutionId?: string
  serviceInfoList?: ServiceDeploymentInfo[]
  startTs?: number
  status?: string
  triggerType?: string
}

export interface BuildHealth {
  count?: number
  rate?: number
}

export interface BuildInfo {
  failed?: BuildHealth
  success?: BuildHealth
  total?: BuildHealth
}

export interface BuildJobEnvInfo {
  type?: 'K8' | 'VM' | 'DOCKER'
}

export interface BuildRepositoryCount {
  count?: number
}

export interface BuildSpec {
  [key: string]: any
}

export type BurpStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  auth?: STOYamlAuth
  baseImageConnectorRefs?: ParameterFieldListString
  config:
    | 'default'
    | 'never-stop-crawl-due-to-application-errors'
    | 'never-stop-audit-due-to-application-errors'
    | 'minimize-false-positives'
    | 'minimize-false-negatives'
    | 'crawl-strategy-most-complete'
    | 'crawl-strategy-more-complete'
    | 'crawl-strategy-fastest'
    | 'crawl-strategy-faster'
    | 'crawl-limit-60-minutes'
    | 'crawl-limit-30-minutes'
    | 'crawl-limit-10-minutes'
    | 'crawl-and-audit-lightweight'
    | 'crawl-and-audit-fast'
    | 'crawl-and-audit-deep'
    | 'crawl-and-audit-balanced'
    | 'audit-coverage-thorough'
    | 'audit-coverage-maximum'
    | 'audit-checks-passive'
    | 'audit-checks-medium-active'
    | 'audit-checks-light-active'
    | 'audit-checks-critical-issues-only'
    | 'audit-checks-all-except-time-based-detection-methods'
    | 'audit-checks-all-except-java-script-analysis'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  instance?: STOYamlInstance
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
  tool?: STOYamlBurpToolData
}

export interface CIBuildAuthor {
  avatar?: string
  email?: string
  id?: string
  name?: string
}

export interface CIBuildBranchHook {
  commits?: CIBuildCommit[]
  link?: string
  name?: string
  state?: string
  triggerCommits?: CIBuildCommit[]
}

export interface CIBuildCommit {
  id?: string
  link?: string
  message?: string
  ownerEmail?: string
  ownerId?: string
  ownerName?: string
  timeStamp?: number
}

export interface CIBuildPRHook {
  body?: string
  commits?: CIBuildCommit[]
  id?: number
  link?: string
  sourceBranch?: string
  sourceRepo?: string
  state?: string
  targetBranch?: string
  title?: string
  triggerCommits?: CIBuildCommit[]
}

export interface CIBuildReleaseHook {
  body?: string
  link?: string
  tag?: string
  title?: string
}

export interface CICreditsResult {
  credits?: number
}

export interface CIDevelopersFilterParams {
  developer?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface CIExecutionArgs {
  executionSource?: ExecutionSource
  runSequence?: string
}

export interface CIExecutionImages {
  addonTag?: string
  artifactoryUploadTag?: string
  buildAndPushACRTag?: string
  buildAndPushDockerRegistryTag?: string
  buildAndPushECRTag?: string
  buildAndPushGCRTag?: string
  cacheGCSTag?: string
  cacheS3Tag?: string
  gcsUploadTag?: string
  gitCloneTag?: string
  liteEngineTag?: string
  provenanceTag?: string
  s3UploadTag?: string
  securityTag?: string
  slsaVerificationTag?: string
  sscaEnforcementTag?: string
  sscaOrchestrationTag?: string
}

export interface CIImageDetails {
  imageName?: string
  imageTag?: string
}

export interface CIInfraDetails {
  infraArchType?: string
  infraHostType?: string
  infraOSType?: string
  infraType?: string
}

export interface CILicenseHistoryDTO {
  licenseType?: 'DEVELOPERS'
  licenseUsage?: {
    [key: string]: number
  }
}

export interface CIPipelineModuleInfo {
  branch?: string
  buildType?: string
  ciEditionType?: string
  ciExecutionInfoDTO?: CIWebhookInfoDTO
  ciLicenseType?: string
  ciPipelineStageModuleInfo?: CIPipelineStageModuleInfo
  imageDetailsList?: CIImageDetails[]
  infraDetailsList?: CIInfraDetails[]
  isPrivateRepo?: boolean
  prNumber?: string
  repoName?: string
  scmDetailsList?: CIScmDetails[]
  tag?: string
  tiBuildDetailsList?: TIBuildDetails[]
  triggerRepoName?: string
}

export interface CIPipelineStageModuleInfo {
  buildMultiplier?: number
  cpuTime?: number
  infraType?: string
  osArch?: string
  osType?: string
  stageBuildTime?: number
  stageExecutionId?: string
  stageId?: string
  stageName?: string
  startTs?: number
}

export interface CIScmDetails {
  scmAuthType?: string
  scmHostType?: string
  scmProvider?: string
  scmUrl?: string
}

export type CIServiceInfo = DependencySpecType & {
  args?: string[]
  connectorRef: string
  entrypoint?: string[]
  envVariables?: {
    [key: string]: string
  }
  image: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  portBindings?: {
    [key: string]: string
  }
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
}

export interface CIUsageResult {
  accountIdentifier?: string
  activeCommitters?: UsageDataDTO
  module?: string
  timestamp?: number
}

export interface CIVolume {
  type?: 'EmptyDir' | 'PersistentVolumeClaim' | 'HostPath'
}

export interface CIWebhookInfoDTO {
  author?: CIBuildAuthor
  branch?: CIBuildBranchHook
  event?: string
  pullRequest?: CIBuildPRHook
  release?: CIBuildReleaseHook
  userSource?: string
}

export interface CacheMetadataDetail {
  cachePath?: string
  size?: number
}

export interface CacheMetadataInfo {
  available?: number
  details?: CacheMetadataDetail[]
  total?: number
  unit?: string
  used?: number
}

export interface CacheResponseMetadata {
  cacheState: 'VALID_CACHE' | 'STALE_CACHE' | 'UNKNOWN'
  lastUpdatedAt: number
  ttlLeft: number
}

export interface Caching {
  enabled?: boolean
  key?: string
  paths?: string[]
}

export interface Capabilities {
  add?: string[]
  drop?: string[]
}

export type CheckmarxStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  auth?: STOYamlAuth
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  image?: STOYamlImage
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
  tool?: STOYamlCheckmarxToolData
}

export type ClairStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export type CleanupStepInfo = StepSpecType & {
  infrastructure: Infrastructure
  podName: string
}

export interface Clone {
  depth?: number
  disabled?: boolean
  insecure?: boolean
  ref?: ParameterFieldRef
  resources?: ContainerResource
  strategy?: 'merge' | 'source-branch'
  trace?: boolean
}

export type CloudRuntime = Runtime & {
  spec: CloudRuntimeSpec
  type: 'Cloud'
}

export interface CloudRuntimeSpec {
  size?: string
}

export type CloudRuntimeV1 = RuntimeV1 & {
  spec: CloudRuntimeSpec
  type: 'cloud'
}

export interface CodeBase {
  build: Build
  connectorRef?: string
  depth?: number
  prCloneStrategy?: 'MergeCommit' | 'SourceBranch'
  repoName?: string
  resources?: ContainerResource
  sslVerify?: boolean
}

export type CodeqlStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export interface CommitDetails {
  commitId?: string
  link?: string
  message?: string
  ownerEmail?: string
  ownerId?: string
  ownerName?: string
  timeStamp?: number
}

export type CommitShaBuildSpec = BuildSpec & {
  commitSha: string
}

export interface ConnectorConversionInfo {
  connectorRef?: string
  envToSecretsMap?: {
    [key: string]: string
  }
}

export type ConnectorValidationErrorMetadataDTO = ErrorMetadataDTO & {
  taskId?: string
}

export interface ContainerDefinitionInfo {
  args?: string[]
  commands?: string[]
  containerImageDetails?: ContainerImageDetails
  containerResourceParams?: ContainerResourceParams
  containerType?:
    | 'STEP_EXECUTOR'
    | 'ADD_ON'
    | 'RUN'
    | 'PLUGIN'
    | 'SERVICE'
    | 'LITE_ENGINE'
    | 'TEST_INTELLIGENCE'
    | 'BACKGROUND'
  envVars?: {
    [key: string]: string
  }
  envVarsWithSecretRef?: {
    [key: string]: string
  }
  harnessManagedImage?: boolean
  imagePullPolicy?: string
  mainLiteEngine?: boolean
  name?: string
  ports?: number[]
  privileged?: boolean
  runAsUser?: number
  secretVariables?: SecretNGVariable[]
  stepIdentifier?: string
  stepName?: string
}

export interface ContainerImageDetails {
  connectorIdentifier?: string
  imageDetails?: ImageDetails
}

export interface ContainerInfraYamlSpec {
  annotations?: {
    [key: string]: string
  }
  automountServiceAccountToken?: boolean
  connectorRef: string
  containerSecurityContext?: SecurityContext
  harnessImageConnectorRef?: string
  hostNames?: string[]
  initTimeout?: string
  labels?: {
    [key: string]: string
  }
  namespace: string
  nodeSelector?: {
    [key: string]: string
  }
  os?: 'Linux' | 'MacOS' | 'Windows'
  priorityClassName?: string
  resources?: ContainerResource
  runAsUser?: number
  serviceAccountName?: string
  tolerations?: Toleration[]
  volumes?: CIVolume[]
}

export interface ContainerResource {
  limits: Limits
}

export interface ContainerResourceParams {
  resourceLimitMemoryMiB?: number
  resourceLimitMilliCpu?: number
  resourceRequestMemoryMiB?: number
  resourceRequestMilliCpu?: number
}

export type CosignAttestation = AttestationSpec & {
  password?: string
  privateKey?: string
}

export type CosignAttestationV1 = AttestationSpecV1 & {
  password?: string
  private_key?: string
}

export type CosignSlsaVerifyAttestation = SlsaVerifyAttestationSpec & {
  public_key?: string
}

export type CosignVerifyAttestation = VerifyAttestationSpec & {
  publicKey?: string
}

export type CoverityStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export type CustomExecutionSource = ExecutionSource & {
  branch?: string
  tag?: string
}

export type CustomIngestStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default' | 'sarif'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export interface DashboardBuildExecutionInfo {
  buildExecutionInfoList?: BuildExecutionInfo[]
  buildRate?: number
  buildRateChangeRate?: number
}

export interface DashboardBuildRepositoryInfo {
  repositoryInfo?: RepositoryInfo[]
}

export interface DashboardBuildsActiveAndFailedInfo {
  active?: BuildActiveInfo[]
  failed?: BuildFailureInfo[]
}

export interface DashboardBuildsHealthInfo {
  builds?: BuildInfo
}

export type DataTheoremStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export interface DeleteCacheResponse {
  deleted?: CacheMetadataDetail[]
}

export interface DependencyElement {
  description?: string
  identifier: string
  name?: string
  spec?: DependencySpecType
  type: 'Service'
}

export interface DependencySpecType {
  [key: string]: any
}

export interface DeprecatedImageInfo {
  tag?: string
  version?: string
}

export type DockerContentTrustStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  image?: STOYamlImage
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export interface DockerInfraSpec {
  platform: ParameterFieldPlatform
}

export type DockerInfraYaml = Infrastructure & {
  spec: DockerInfraSpec
  type: 'KubernetesDirect' | 'UseFromStage' | 'VM'
}

export type DockerRuntime = Runtime & {
  spec: DockerRuntimeSpec
  type: 'Docker'
}

export interface DockerRuntimeSpec {
  [key: string]: any
}

export type DockerSourceSpec = ProvenanceSourceSpec & {
  connector?: string
  repo: string
  tags: string[]
}

export type DockerStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  buildArgs?: {
    [key: string]: string
  }
  cacheFrom?: string[]
  cacheTo?: string
  caching?: boolean
  connectorRef: string
  context?: string
  dockerfile?: string
  labels?: {
    [key: string]: string
  }
  optimize?: boolean
  remoteCacheRepo?: string
  repo: string
  resources?: ContainerResource
  runAsUser?: number
  tags: string[]
  target?: string
}

export type ECRStepInfo = StepSpecType & {
  account: string
  baseImageConnectorRefs?: string[]
  buildArgs?: {
    [key: string]: string
  }
  cacheFrom?: string[]
  cacheTo?: string
  caching?: boolean
  connectorRef: string
  context?: string
  dockerfile?: string
  imageName: string
  labels?: {
    [key: string]: string
  }
  optimize?: boolean
  region: string
  remoteCacheImage?: string
  resources?: ContainerResource
  runAsUser?: number
  tags: string[]
  target?: string
}

export type EmptyDirVolume = PodVolume & {
  medium?: string
  mountPath: string
  name: string
  sizeMib?: number
}

export type EmptyDirYaml = CIVolume & {
  mountPath: string
  spec: EmptyDirYamlSpec
  type: 'EmptyDir' | 'PersistentVolumeClaim' | 'HostPath'
}

export interface EmptyDirYamlSpec {
  medium?: string
  size?: string
}

export interface EnforcementPolicy {
  store?: PolicyStore
}

export interface EntityGitDetails {
  branch?: string
  commitId?: string
  filePath?: string
  fileUrl?: string
  objectId?: string
  parentEntityConnectorRef?: string
  parentEntityRepoName?: string
  repoIdentifier?: string
  repoName?: string
  repoUrl?: string
  rootFolder?: string
}

export interface EntityValidityDetails {
  invalidYaml?: string
  valid?: boolean
}

export interface Error {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
  correlationId?: string
  detailedMessage?: string
  message?: string
  metadata?: ErrorMetadataDTO
  responseMessages?: ResponseMessage[]
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ErrorMetadata {
  errorCode?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
  errorMessage?: string
}

export interface ErrorMetadataDTO {
  type?: string
}

export interface ErrorNodeSummary {
  childrenErrorNodes?: ErrorNodeSummary[]
  nodeInfo?: NodeInfo
  templateInfo?: TemplateInfo
  templateResponse?: TemplateResponse
}

export interface ExecutionElementConfig {
  rollbackSteps?: ExecutionWrapperConfig[]
  steps: ExecutionWrapperConfig[]
}

export interface ExecutionQueueLimitDTO {
  macExecutionLimits?: string
  totalExecutionLimits?: string
}

export interface ExecutionSource {
  type?: 'WEBHOOK' | 'MANUAL' | 'CUSTOM'
}

export interface ExecutionWrapperConfig {
  parallel?: ParallelStepElementConfig
  step?: StepElementConfig
  stepGroup?: StepGroupElementConfig
}

export interface Failure {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
  correlationId?: string
  errors?: ValidationError[]
  message?: string
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface FailureStrategyActionConfig {
  type:
    | 'Ignore'
    | 'Retry'
    | 'MarkAsSuccess'
    | 'Abort'
    | 'StageRollback'
    | 'StepGroupRollback'
    | 'PipelineRollback'
    | 'ManualIntervention'
    | 'ProceedWithDefaultValues'
    | 'MarkAsFailure'
    | 'RetryStepGroup'
}

export interface FailureStrategyConfig {
  onFailure: OnFailureConfig
}

export type FilterCreatorErrorResponse = ErrorMetadataDTO & {
  errorMetadataList?: ErrorMetadata[]
}

export type FortifyOnDemandStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  auth?: STOYamlAuth
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  image?: STOYamlImage
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
  tool?: STOYamlFODToolData
}

export type FossaStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  auth?: STOYamlAuth
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
  tool?: STOYamlFossaToolData
}

export type GCRStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  buildArgs?: {
    [key: string]: string
  }
  cacheFrom?: string[]
  cacheTo?: string
  caching?: boolean
  connectorRef: string
  context?: string
  dockerfile?: string
  host: string
  imageName: string
  labels?: {
    [key: string]: string
  }
  optimize?: boolean
  projectID: string
  remoteCacheImage?: string
  resources?: ContainerResource
  runAsUser?: number
  tags: string[]
  target?: string
}

export type GitCloneStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  build: Build
  cloneDirectory?: string
  connectorRef: string
  depth?: number
  outputFilePathsContent?: string[]
  projectName?: string
  repoName?: string
  resources?: ContainerResource
  runAsUser?: number
  sslVerify?: boolean
}

export type GitErrorMetadataDTO = ErrorMetadataDTO & {
  branch?: string
  repo?: string
}

export interface GitInfo {
  commit?: string
  commitID?: string
  eventType?: string
  repoName?: string
  sourceBranch?: string
  targetBranch?: string
}

export type GitleaksStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export type GrypeStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  image?: STOYamlImage
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export interface HarnessForConfig {
  end?: number
  items?: string[]
  maxConcurrency?: number
  partitionSize?: number
  start?: number
  times?: number
  unit?: 'Percentage' | 'Count'
}

export type HarnessStore = StoreSpec & {
  file?: string
}

export type HostPathVolume = PodVolume & {
  hostPathType?: string
  mountPath: string
  name: string
  path: string
}

export type HostPathYaml = CIVolume & {
  mountPath: string
  spec: HostPathYamlSpec
  type: 'EmptyDir' | 'PersistentVolumeClaim' | 'HostPath'
}

export interface HostPathYamlSpec {
  path: string
  type?: string
}

export interface HostedVmInfraSpec {
  platform: ParameterFieldPlatform
}

export type HostedVmInfraYaml = Infrastructure & {
  spec: HostedVmInfraSpec
  type: 'KubernetesDirect' | 'UseFromStage' | 'VM'
}

export type IACMApprovalInfo = StepSpecType & {
  image?: string
}

export type IACMCostEstimationInfo = StepSpecType & {
  image?: string
}

export type IACMStageConfigImpl = StageInfoConfig & {
  cloneCodebase?: boolean
  infrastructure?: Infrastructure
  platform?: Platform
  runtime?: Runtime
  serviceDependencies?: DependencyElement[]
  sharedPaths?: string[]
  workspace: string
}

export type IACMStageConfigImplV1 = StageInfoConfig & {
  clone?: Clone
  platform?: PlatformV1
  runtime?: RuntimeV1
  steps: JsonNode[]
}

export type IACMStepInfo = StepSpecType & { [key: string]: any }

export type IACMTerraformPluginInfo = StepSpecType & {
  command: string
  image?: string
}

export type IgnoreFailureActionConfig = FailureStrategyActionConfig & {
  type: 'Ignore'
}

export interface ImageDetails {
  domainName?: string
  name?: string
  password?: string
  registryUrl?: string
  sourceName?: string
  tag?: string
  username?: string
  usernameRef?: string
}

export type ImageSbomSource = SbomSourceSpec & {
  connector?: string
  image?: string
}

export interface Infrastructure {
  type?: 'KubernetesDirect' | 'UseFromStage' | 'VM'
}

export type InitializeStepInfo = StepSpecType & {
  accountId: string
  buildJobEnvInfo?: BuildJobEnvInfo
  ciCodebase?: CodeBase
  delegateSelectors?: ParameterFieldListTaskSelectorYaml
  executionElementConfig: ExecutionElementConfig
  executionSource?: ExecutionSource
  infrastructure: Infrastructure
  pipelineVariables?: NGVariable[]
  skipGitClone: boolean
  stageElementConfig?: IntegrationStageConfig
  stageIdentifier?: string
  strategyExpansionMap?: {
    [key: string]: StrategyExpansionData
  }
  variables?: NGVariable[]
}

export interface Input {
  allowed_values?: string[]
  default?: string
  description?: string
  name?: string
  required?: boolean
  secret?: boolean
  type?: string
}

export interface InputSetError {
  fieldName?: string
  identifierOfErrorSource?: string
  message?: string
}

export interface InputSetErrorResponse {
  errors?: InputSetError[]
}

export type InputSetErrorWrapper = ErrorMetadataDTO & {
  errorPipelineYaml?: string
  invalidInputSetReferences?: string[]
  uuidToErrorResponseMap?: {
    [key: string]: InputSetErrorResponse
  }
}

export interface InputSetValidator {
  parameters?: string
  validatorType?: 'ALLOWED_VALUES' | 'REGEX'
}

export interface IntegrationStageConfig {
  caching?: Caching
  cloneCodebase?: ParameterFieldBoolean
  execution?: ExecutionElementConfig
  infrastructure?: Infrastructure
  platform?: ParameterFieldPlatform
  runtime?: Runtime
  serviceDependencies?: ParameterFieldListDependencyElement
  sharedPaths?: ParameterFieldListString
}

export type IntegrationStageConfigImpl = StageInfoConfig & {
  caching?: Caching
  cloneCodebase?: boolean
  infrastructure?: Infrastructure
  platform?: Platform
  runtime?: Runtime
  serviceDependencies?: DependencyElement[]
  sharedPaths?: string[]
  slsa_provenance?: SlsaConfig
}

export type IntegrationStageConfigImplV1 = StageInfoConfig & {
  clone?: Clone
  platform?: PlatformV1
  runtime?: RuntimeV1
  steps: JsonNode[]
}

export type InvalidFieldsDTO = ErrorMetadataDTO & {}

export type JUnitTestReport = UnitTestReportSpec & {
  paths?: string[]
}

export type JfrogXrayStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export interface JsonNode {
  [key: string]: any
}

export type K8BuildJobEnvInfo = BuildJobEnvInfo & {
  podsSetupInfo?: PodsSetupInfo
  stepConnectorRefs?: {
    [key: string]: ConnectorConversionInfo[]
  }
  workDir?: string
}

export type K8sDirectInfra = StepGroupInfra & {
  spec: ContainerInfraYamlSpec
  type: 'KubernetesDirect' | 'Delegate' | 'Noop'
}

export type K8sDirectInfraYaml = Infrastructure & {
  spec: K8sDirectInfraYamlSpec
  type: 'KubernetesDirect' | 'UseFromStage' | 'VM'
}

export interface K8sDirectInfraYamlSpec {
  annotations?: {
    [key: string]: string
  }
  automountServiceAccountToken?: boolean
  connectorRef: string
  containerSecurityContext?: SecurityContext
  harnessImageConnectorRef?: string
  hostNames?: string[]
  initTimeout?: string
  labels?: {
    [key: string]: string
  }
  namespace: string
  nodeSelector?: {
    [key: string]: string
  }
  os?: 'Linux' | 'MacOS' | 'Windows'
  priorityClassName?: string
  runAsUser?: number
  serviceAccountName?: string
  tolerations?: Toleration[]
  volumes?: CIVolume[]
}

export interface LastRepositoryInfo {
  author?: AuthorInfo
  commit?: string
  endTime?: number
  startTime?: number
  status?: string
}

export interface Limits {
  cpu?: string
  memory?: string
}

export interface MachineRuntimeSpec {
  [key: string]: any
}

export type MachineRuntimeV1 = RuntimeV1 & {
  spec: MachineRuntimeSpec
  type: 'machine'
}

export type ManualExecutionSource = ExecutionSource & {
  branch?: string
  commitSha?: string
  prNumber?: string
  tag?: string
}

export interface ManualFailureSpecConfig {
  onTimeout: OnTimeoutConfig
  timeout: string
}

export type ManualInterventionFailureActionConfig = FailureStrategyActionConfig & {
  spec: ManualFailureSpecConfig
  type: 'ManualIntervention'
}

export type MarkAsFailFailureActionConfig = FailureStrategyActionConfig & {
  type: 'MarkAsFailure'
}

export type MarkAsSuccessFailureActionConfig = FailureStrategyActionConfig & {
  type: 'MarkAsSuccess'
}

export interface MatrixConfigInterface {
  [key: string]: any
}

export type MendStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  auth?: STOYamlAuth
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  image?: STOYamlImage
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
  tool?: STOYamlMendToolData
}

export type MetasploitStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default' | 'metasploit-weak-ssh' | 'metasploit-openssl-heartbleed'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  instance?: STOYamlInstance
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export interface NGVariable {
  description?: string
  metadata?: string
  name?: string
  required?: boolean
  type?: 'String' | 'Number' | 'Secret'
}

export type NessusStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  instance?: STOYamlInstance
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export type NexusIQStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export type NiktoStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  instance?: STOYamlInstance
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export type NmapStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default' | 'firewall-bypass' | 'unusual-port' | 'smb-security-mode' | 'exploit' | 'no-default-cli-flags'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  instance?: STOYamlInstance
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export interface NodeErrorInfo {
  fqn?: string
  identifier?: string
  name?: string
  type?: string
}

export interface NodeInfo {
  identifier?: string
  localFqn?: string
  name?: string
}

export type NumberNGVariable = NGVariable & {
  default?: number
  name?: string
  type?: 'Number'
  value: number
}

export interface OnFailureConfig {
  action: FailureStrategyActionConfig
  errors: (
    | 'Unknown'
    | 'AllErrors'
    | 'Authentication'
    | 'Connectivity'
    | 'Timeout'
    | 'Authorization'
    | 'Verification'
    | 'DelegateProvisioning'
    | 'PolicyEvaluationFailure'
    | 'InputTimeoutError'
    | 'ApprovalRejection'
    | 'DelegateRestart'
    | 'UserMarkedFailure'
  )[]
}

export interface OnRetryFailureConfig {
  action?: FailureStrategyActionConfig
}

export interface OnTimeoutConfig {
  action?: FailureStrategyActionConfig
}

export type OpenvasStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  auth?: STOYamlAuth
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  instance?: STOYamlInstance
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export interface Operation {
  field: string
  value?: string
}

export interface Output {
  description?: string
  name?: string
}

export interface OutputNGVariable {
  description?: string
  name?: string
}

export type OverlayInputSetErrorWrapper = ErrorMetadataDTO & {
  invalidReferences?: {
    [key: string]: string
  }
}

export type OwaspStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export type PRBuildSpec = BuildSpec & {
  number: string
}

export type PRWebhookEvent = WebhookEvent & {
  baseAttributes?: WebhookBaseAttributes
  closed?: boolean
  commitDetailsList?: CommitDetails[]
  merged?: boolean
  pullRequestBody?: string
  pullRequestId?: number
  pullRequestLink?: string
  repository?: Repository
  sourceBranch?: string
  targetBranch?: string
  title?: string
}

export interface PVCParams {
  claimName?: string
  present?: boolean
  sizeMib?: number
  storageClass?: string
  volumeName?: string
}

export type PVCVolume = PodVolume & {
  claimName: string
  mountPath: string
  name: string
  readOnly?: boolean
}

export interface Page {
  content?: { [key: string]: any }[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface PageActiveDevelopersDTO {
  content?: ActiveDevelopersDTO[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface PagePluginMetadataResponse {
  content?: PluginMetadataResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  pageToken?: string
  totalItems?: number
  totalPages?: number
}

export interface Pageable {
  offset?: number
  pageNumber?: number
  pageSize?: number
  paged?: boolean
  sort?: Sort
  unpaged?: boolean
}

export type ParallelStepElementConfig = ExecutionWrapperConfig[]

export interface ParameterField {
  defaultValue?: { [key: string]: any }
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: { [key: string]: any }
}

export interface ParameterFieldBoolean {
  defaultValue?: boolean
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: boolean
}

export interface ParameterFieldListDependencyElement {
  defaultValue?: DependencyElement[]
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: DependencyElement[]
}

export interface ParameterFieldListString {
  defaultValue?: string[]
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: string[]
}

export interface ParameterFieldListTaskSelectorYaml {
  defaultValue?: TaskSelectorYaml[]
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: TaskSelectorYaml[]
}

export interface ParameterFieldMapStringJsonNode {
  defaultValue?: {
    [key: string]: JsonNode
  }
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: {
    [key: string]: JsonNode
  }
}

export interface ParameterFieldMapStringString {
  defaultValue?: {
    [key: string]: string
  }
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: {
    [key: string]: string
  }
}

export interface ParameterFieldMatrixConfigInterface {
  defaultValue?: MatrixConfigInterface
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: MatrixConfigInterface
}

export interface ParameterFieldPlatform {
  defaultValue?: Platform
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: Platform
}

export interface ParameterFieldRef {
  defaultValue?: Ref
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: Ref
}

export interface ParameterFieldString {
  defaultValue?: string
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: string
}

export interface ParameterFieldTILanguage {
  defaultValue?: 'Java' | 'Kotlin' | 'Scala' | 'Csharp' | 'Python' | 'Ruby'
  executionInput?: boolean
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: 'Java' | 'Kotlin' | 'Scala' | 'Csharp' | 'Python' | 'Ruby'
}

export interface PartialSchemaDTO {
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'GOVERNANCE'
    | 'IDP'
  namespace?: string
  nodeName?: string
  nodeType?: string
  schema?: JsonNode
  skipStageSchema?: boolean
}

export type PersistentVolumeClaimYaml = CIVolume & {
  mountPath: string
  spec: PersistentVolumeClaimYamlSpec
  type: 'EmptyDir' | 'PersistentVolumeClaim' | 'HostPath'
}

export interface PersistentVolumeClaimYamlSpec {
  claimName: string
  readOnly?: boolean
}

export type PipelineRollbackFailureActionConfig = FailureStrategyActionConfig & {
  type: 'PipelineRollback'
}

export interface Platform {
  arch?: 'Amd64' | 'Arm64'
  os?: 'Linux' | 'MacOS' | 'Windows'
}

export interface PlatformV1 {
  arch?: 'amd64' | 'arm64'
  os?: 'linux' | 'windows' | 'macos'
}

export interface PluginMetadataResponse {
  description?: string
  image?: string
  inputs?: Input[]
  kind?: string
  logo?: string
  name?: string
  outputs?: Output[]
  repo?: string
  uses?: string
}

export type PluginStepInfo = StepSpecType & {
  connectorRef?: string
  entrypoint?: string[]
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  privileged?: boolean
  reports?: UnitTestReport
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  uses?: string
}

export type PluginStepInfoV1 = StepSpecType & {
  envs?: {
    [key: string]: string
  }
  image?: string
  privileged?: boolean
  pull?: 'always' | 'never' | 'if-not-exists'
  resources?: ContainerResource
  user?: number
  uses?: string
  with?: ParameterFieldMapStringJsonNode
}

export interface PodSetupInfo {
  name?: string
  podSetupParams?: PodSetupParams
  pvcParamsList?: PVCParams[]
  serviceGrpcPortList?: number[]
  serviceIdList?: string[]
  stageCpuRequest: number
  stageMemoryRequest: number
  volumeToMountPath: {
    [key: string]: string
  }
  volumes?: PodVolume[]
  workDirPath?: string
}

export interface PodSetupParams {
  containerDefinitionInfos?: ContainerDefinitionInfo[]
}

export interface PodVolume {
  type?: 'EmptyDir' | 'PersistentVolumeClaim' | 'HostPath'
}

export interface PodsSetupInfo {
  podSetupInfoList?: PodSetupInfo[]
}

export interface PolicyConfig {
  policySets: string[]
}

export interface PolicyStore {
  spec?: StoreSpec
  type: 'Harness'
}

export type PrismaCloudStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  auth?: STOYamlAuth
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  image?: STOYamlImage
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
  tool?: STOYamlPrismaCloudToolData
}

export type ProceedWithDefaultValuesFailureActionConfig = FailureStrategyActionConfig & {
  type: 'ProceedWithDefaultValues'
}

export interface ProvenanceSource {
  spec?: ProvenanceSourceSpec
  type?: 'docker'
}

export interface ProvenanceSourceSpec {
  [key: string]: any
}

export type ProvenanceStepInfo = StepSpecType & {
  attestation?: AttestationV1
  source?: ProvenanceSource
}

export type ProwlerStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  auth?: STOYamlAuth
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default' | 'hipaa' | 'gdpr' | 'exclude_extras'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export type QualysStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export type ReapsawStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export interface Ref {
  name: string
  sha?: string
  type: 'branch' | 'tag' | 'pr'
}

export interface ReferenceDTO {
  accountIdentifier?: string
  count?: number
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type ReleaseWebhookEvent = WebhookEvent & {
  baseAttributes?: WebhookBaseAttributes
  draft?: boolean
  prerelease?: boolean
  releaseBody?: string
  releaseLink?: string
  releaseTag?: string
  repository?: Repository
  title?: string
}

export interface Repository {
  branch?: string
  httpURL?: string
  link?: string
  name?: string
  namespace?: string
  private?: boolean
  slug?: string
  sshURL?: string
}

export interface RepositoryBuildInfo {
  builds?: BuildRepositoryCount
  time?: number
}

export interface RepositoryInfo {
  buildCount?: number
  countList?: RepositoryBuildInfo[]
  lastRepository?: LastRepositoryInfo
  name?: string
  percentSuccess?: number
  successRate?: number
}

export interface Response {
  correlationId?: string
  data?: { [key: string]: any }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseBoolean {
  correlationId?: string
  data?: boolean
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCICreditsResult {
  correlationId?: string
  data?: CICreditsResult
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCIExecutionImages {
  correlationId?: string
  data?: CIExecutionImages
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCILicenseHistoryDTO {
  correlationId?: string
  data?: CILicenseHistoryDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCIPipelineModuleInfo {
  correlationId?: string
  data?: CIPipelineModuleInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCIUsageResult {
  correlationId?: string
  data?: CIUsageResult
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCacheMetadataInfo {
  correlationId?: string
  data?: CacheMetadataInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDashboardBuildExecutionInfo {
  correlationId?: string
  data?: DashboardBuildExecutionInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDashboardBuildRepositoryInfo {
  correlationId?: string
  data?: DashboardBuildRepositoryInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDashboardBuildsActiveAndFailedInfo {
  correlationId?: string
  data?: DashboardBuildsActiveAndFailedInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDashboardBuildsHealthInfo {
  correlationId?: string
  data?: DashboardBuildsHealthInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDeleteCacheResponse {
  correlationId?: string
  data?: DeleteCacheResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseExecutionQueueLimitDTO {
  correlationId?: string
  data?: ExecutionQueueLimitDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseJsonNode {
  correlationId?: string
  data?: JsonNode
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListDeprecatedImageInfo {
  correlationId?: string
  data?: DeprecatedImageInfo[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListPartialSchemaDTO {
  correlationId?: string
  data?: PartialSchemaDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMessage {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'INVALID_FORMAT'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'INVALID_AGENT_MTLS_AUTHORITY'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'WINRM_COMMAND_EXECUTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'EMAIL_ERROR'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'CUSTOM_APPROVAL_ERROR'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_GLOBAL_DELEGATE_ACCOUNT'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'CG_LICENSE_USAGE_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'DELEGATE_SERVICE_DRIVER_EXCEPTION'
    | 'DELEGATE_INSTALLATION_COMMAND_NOT_SUPPORTED_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_CONFLICT_ERROR_V2'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'SCM_BAD_REQUEST'
    | 'SCM_INTERNAL_SERVER_ERROR'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'TEMPLATE_ALREADY_EXISTS_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
    | 'ACTIVE_SERVICE_INSTANCES_PRESENT_EXCEPTION'
    | 'INVALID_INPUT_SET'
    | 'INVALID_OVERLAY_INPUT_SET'
    | 'RESOURCE_ALREADY_EXISTS'
    | 'INVALID_JSON_PAYLOAD'
    | 'POLICY_EVALUATION_FAILURE'
    | 'POLICY_SET_ERROR'
    | 'INVALID_ARTIFACTORY_REGISTRY_REQUEST'
    | 'INVALID_NEXUS_REGISTRY_REQUEST'
    | 'ENTITY_NOT_FOUND'
    | 'INVALID_AZURE_CONTAINER_REGISTRY_REQUEST'
    | 'AZURE_AUTHENTICATION_ERROR'
    | 'AZURE_CONFIG_ERROR'
    | 'DATA_PROCESSING_ERROR'
    | 'INVALID_AZURE_AKS_REQUEST'
    | 'AWS_IAM_ERROR'
    | 'AWS_CF_ERROR'
    | 'AWS_INSTANCE_ERROR'
    | 'AWS_VPC_ERROR'
    | 'AWS_TAG_ERROR'
    | 'AWS_ASG_ERROR'
    | 'AWS_LOAD_BALANCER_ERROR'
    | 'SCM_INTERNAL_SERVER_ERROR_V2'
    | 'SCM_UNAUTHORIZED_ERROR_V2'
    | 'TOO_MANY_REQUESTS'
    | 'INVALID_IDENTIFIER_REF'
    | 'SPOTINST_NULL_ERROR'
    | 'SCM_UNEXPECTED_ERROR'
    | 'DUPLICATE_FILE_IMPORT'
    | 'AZURE_APP_SERVICES_TASK_EXCEPTION'
    | 'AZURE_ARM_TASK_EXCEPTION'
    | 'AZURE_BP_TASK_EXCEPTION'
    | 'MEDIA_NOT_SUPPORTED'
    | 'AWS_ECS_ERROR'
    | 'AWS_APPLICATION_AUTO_SCALING'
    | 'AWS_ECS_SERVICE_NOT_ACTIVE'
    | 'AWS_ECS_CLIENT_ERROR'
    | 'AWS_STS_ERROR'
    | 'FREEZE_EXCEPTION'
    | 'DELEGATE_TASK_EXPIRED'
    | 'DELEGATE_TASK_VALIDATION_FAILED'
    | 'MONGO_EXECUTION_TIMEOUT_EXCEPTION'
    | 'DELEGATE_NOT_REGISTERED'
    | 'TERRAFORM_VAULT_SECRET_CLEANUP_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'TERRAGRUNT_EXECUTION_ERROR'
    | 'ADFS_ERROR'
    | 'TERRAFORM_CLOUD_ERROR'
    | 'CLUSTER_CREDENTIALS_NOT_FOUND'
    | 'SCM_API_ERROR'
    | 'INTERNAL_SERVER_ERROR'
    | 'SCM_FORBIDDEN'
    | 'AWS_EKS_ERROR'
    | 'OPA_POLICY_EVALUATION_ERROR'
    | 'USER_MARKED_FAILURE'
    | 'SSH_RETRY'
    | 'HTTP_CLIENT_ERROR_RESPONSE'
    | 'HTTP_INTERNAL_SERVER_ERROR'
    | 'HTTP_BAD_GATEWAY'
    | 'HTTP_SERVICE_UNAVAILABLE'
    | 'HTTP_GATEWAY_TIMEOUT'
    | 'HTTP_SERVER_ERROR_RESPONSE'
    | 'PIPELINE_UPDATE_EXCEPTION'
    | 'SERVICENOW_REFRESH_TOKEN_ERROR'
    | 'PARAMETER_FIELD_CAST_ERROR'
  exception?: Throwable
  failureTypes?: (
    | 'EXPIRED'
    | 'DELEGATE_PROVISIONING'
    | 'CONNECTIVITY'
    | 'AUTHENTICATION'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'TIMEOUT_ERROR'
    | 'POLICY_EVALUATION_FAILURE'
    | 'INPUT_TIMEOUT_FAILURE'
    | 'APPROVAL_REJECTION'
    | 'DELEGATE_RESTART'
    | 'USER_MARKED_FAILURE'
  )[]
  level?: 'INFO' | 'ERROR'
  message?: string
}

export interface ResponsePageActiveDevelopersDTO {
  correlationId?: string
  data?: PageActiveDevelopersDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePagePluginMetadataResponse {
  correlationId?: string
  data?: PagePluginMetadataResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSetString {
  correlationId?: string
  data?: string[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseStageElementConfig {
  correlationId?: string
  data?: StageElementConfig
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseStepElementConfig {
  correlationId?: string
  data?: StepElementConfig
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseYamlSchemaDetailsWrapper {
  correlationId?: string
  data?: YamlSchemaDetailsWrapper
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface RestResponseString {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: string
  responseMessages?: ResponseMessage[]
}

export type RestoreCacheGCSStepInfo = StepSpecType & {
  archiveFormat?: 'Tar' | 'Gzip'
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  failIfKeyNotFound?: boolean
  key: string
  resources?: ContainerResource
  runAsUser?: number
}

export type RestoreCacheS3StepInfo = StepSpecType & {
  archiveFormat?: 'Tar' | 'Gzip'
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  endpoint?: string
  failIfKeyNotFound?: boolean
  key: string
  pathStyle?: boolean
  region?: string
  resources?: ContainerResource
  runAsUser?: number
}

export type RetryFailureActionConfig = FailureStrategyActionConfig & {
  spec: RetryFailureSpecConfig
  type: 'Retry'
}

export interface RetryFailureSpecConfig {
  onRetryFailure: OnRetryFailureConfig
  retryCount: number
  retryIntervals: string[]
}

export type RetrySGFailureActionConfig = FailureStrategyActionConfig & {
  spec: RetryStepGroupFailureSpecConfig
  type: 'RetryStepGroup'
}

export interface RetryStepGroupFailureSpecConfig {
  retryCount: number
  retryIntervals: string[]
}

export type RunStepInfo = StepSpecType & {
  command: string
  connectorRef?: string
  envVariables?: {
    [key: string]: string
  }
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  reports?: UnitTestReport
  resources?: ContainerResource
  runAsUser?: number
  shell?: 'Sh' | 'Bash' | 'Powershell' | 'Pwsh' | 'Python'
}

export type RunTestsStepInfo = StepSpecType & {
  args: string
  buildEnvironment?: 'Core' | 'Framework'
  buildTool: 'Maven' | 'Bazel' | 'Gradle' | 'Dotnet' | 'Nunitconsole' | 'SBT' | 'Pytest' | 'Unittest' | 'Rspec'
  connectorRef?: string
  enableTestSplitting?: boolean
  envVariables?: {
    [key: string]: string
  }
  frameworkVersion?: '5.0' | '6.0'
  image?: string
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  language: 'Java' | 'Kotlin' | 'Scala' | 'Csharp' | 'Python' | 'Ruby'
  namespaces?: string
  outputVariables?: OutputNGVariable[]
  packages?: string
  postCommand?: string
  preCommand?: string
  privileged?: boolean
  pythonVersion?: '3' | '2'
  reports?: UnitTestReport
  resources?: ContainerResource
  runAsUser?: number
  runOnlySelectedTests?: boolean
  shell?: 'Sh' | 'Bash' | 'Powershell' | 'Pwsh' | 'Python'
  testAnnotations?: string
  testGlobs?: string
  testRoot?: string
  testSplitStrategy?: 'ClassTiming' | 'TestCount'
}

export interface Runtime {
  type?: 'Docker' | 'Cloud'
}

export interface RuntimeV1 {
  type?: 'machine' | 'cloud' | 'vm' | 'kubernetes'
}

export interface STOYamlAdvancedSettings {
  args?: STOYamlArgs
  fail_on_severity?: 'critical' | 'high' | 'medium' | 'low' | 'none'
  include_raw?: boolean
  log?: STOYamlLog
}

export interface STOYamlArgs {
  cli?: string
  passthrough?: string
}

export interface STOYamlAuth {
  access_id?: string
  access_token: string
  domain?: string
  region?: string
  ssl?: boolean
  type?: 'apiKey' | 'usernamePassword' | 'aws' | 'azure' | 'gcp'
  version?: string
}

export interface STOYamlBlackduckToolData {
  project_name?: string
  project_version?: string
}

export interface STOYamlBurpToolData {
  scan_id?: string
  site_id?: string
}

export interface STOYamlCheckmarxToolData {
  project_name?: string
  team_name?: string
}

export interface STOYamlFODToolData {
  app_name?: string
  audit_type?: string
  data_center?: string
  entitlement?: string
  lookup_type?: string
  owner_id?: string
  release_name?: string
  scan_settings?: string
  scan_type?: string
  target_language?: string
  target_language_version?: string
}

export interface STOYamlFossaToolData {
  policy_name?: string
  project_name?: string
  team_name?: string
}

export interface STOYamlImage {
  access_id?: string
  access_token?: string
  domain?: string
  name?: string
  region?: string
  tag?: string
  type: 'aws_ecr' | 'docker_v2' | 'jfrog_artifactory' | 'local_image'
}

export interface STOYamlIngestion {
  file?: string
}

export interface STOYamlInstance {
  domain?: string
  password?: string
  path?: string
  port?: number
  protocol?: string
  username?: string
}

export interface STOYamlJavaParameters {
  binaries?: string
  libraries?: string
}

export interface STOYamlLog {
  level?: 'info' | 'debug' | 'warning' | 'error'
  serializer?: 'simple' | 'basic' | 'bunyan' | 'simple_onprem' | 'onprem'
}

export interface STOYamlMendToolData {
  exclude?: string
  include?: string
  product_name?: string
  product_token?: string
  project_name?: string
  project_token?: string
}

export interface STOYamlPrismaCloudToolData {
  image_name?: string
}

export interface STOYamlSBOM {
  format?: 'spdx-json' | 'cyclonedx-json'
  generate?: boolean
}

export interface STOYamlSonarqubeToolData {
  exclude?: string
  include?: string
  java?: STOYamlJavaParameters
  project_key?: string
}

export interface STOYamlTarget {
  name: string
  type: 'repository' | 'container' | 'instance' | 'configuration'
  variant: string
  workspace?: string
}

export interface STOYamlVeracodeToolData {
  app_id?: string
  project_name?: string
}

export interface STOYamlZapToolData {
  context?: string
  port?: number
}

export type SampleErrorMetadataDTO = ErrorMetadataDTO & {
  sampleMap?: {
    [key: string]: string
  }
}

export type SaveCacheGCSStepInfo = StepSpecType & {
  archiveFormat?: 'Tar' | 'Gzip'
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  key: string
  override?: boolean
  resources?: ContainerResource
  runAsUser?: number
  sourcePaths: string[]
}

export type SaveCacheS3StepInfo = StepSpecType & {
  archiveFormat?: 'Tar' | 'Gzip'
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  endpoint?: string
  key: string
  override?: boolean
  pathStyle?: boolean
  region?: string
  resources?: ContainerResource
  runAsUser?: number
  sourcePaths: string[]
}

export interface SbomFile {
  file?: string
}

export interface SbomOrchestrationSpec {
  [key: string]: any
}

export interface SbomOrchestrationTool {
  spec?: SbomOrchestrationSpec
  type: 'Syft'
}

export interface SbomSource {
  spec?: SbomSourceSpec
  type: 'image'
}

export interface SbomSourceSpec {
  [key: string]: any
}

export type ScmErrorMetadataDTO = ErrorMetadataDTO & {
  conflictCommitId?: string
}

export type ScriptStepInfo = StepSpecType & {
  envs?: {
    [key: string]: string
  }
  image?: string
  outputs?: string[]
  privileged?: boolean
  pull?: 'always' | 'never' | 'if-not-exists'
  resources?: ContainerResource
  run: string
  shell?: 'sh' | 'bash' | 'powershell' | 'pwsh' | 'python'
  user?: number
}

export type SecretNGVariable = NGVariable & {
  default?: string
  name?: string
  type?: 'Secret'
  value: string
}

export interface SecurityContext {
  allowPrivilegeEscalation?: boolean
  capabilities?: Capabilities
  privileged?: boolean
  procMount?: string
  readOnlyRootFilesystem?: boolean
  runAsGroup?: number
  runAsNonRoot?: boolean
  runAsUser?: number
}

export type SecurityStageConfigImpl = StageInfoConfig & {
  cloneCodebase?: boolean
  infrastructure?: Infrastructure
  platform?: Platform
  runtime?: Runtime
  serviceDependencies?: DependencyElement[]
  sharedPaths?: string[]
}

export type SecurityStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
}

export type SemgrepStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  auth?: STOYamlAuth
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export interface ServiceDeploymentInfo {
  image?: string
  serviceId?: string
  serviceName?: string
  serviceTag?: string
}

export type ShiftLeftStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export interface SlsaConfig {
  attestation?: AttestationV1
  enabled?: boolean
}

export type SlsaDockerSourceSpec = SlsaVerificationSourceSpec & {
  connector?: string
  image_path: string
  tag: string
}

export interface SlsaVerificationSource {
  spec?: SlsaVerificationSourceSpec
  type?: 'Docker'
}

export interface SlsaVerificationSourceSpec {
  [key: string]: any
}

export type SlsaVerificationStepInfo = StepSpecType & {
  source?: SlsaVerificationSource
  verify_attestation?: SlsaVerifyAttestation
}

export interface SlsaVerifyAttestation {
  spec?: SlsaVerifyAttestationSpec
  type?: 'cosign'
}

export interface SlsaVerifyAttestationSpec {
  [key: string]: any
}

export type SniperStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export type SnykStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  auth?: STOYamlAuth
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  image?: STOYamlImage
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export type SonarqubeStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  auth?: STOYamlAuth
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
  tool?: STOYamlSonarqubeToolData
}

export interface Sort {
  empty?: boolean
  sorted?: boolean
  unsorted?: boolean
}

export interface Splitting {
  concurrency?: number
  enabled?: boolean
  strategy?: 'class_timing' | 'test_count'
}

export type SscaEnforcementStepInfo = StepSpecType & {
  policy: EnforcementPolicy
  resources?: ContainerResource
  source: SbomSource
  verifyAttestation?: VerifyAttestation
}

export type SscaOrchestrationStepInfo = StepSpecType & {
  attestation?: Attestation
  ingestion?: SbomFile
  mode?: 'generation' | 'ingestion'
  resources?: ContainerResource
  source: SbomSource
  tool?: SbomOrchestrationTool
}

export interface StackTraceElement {
  classLoaderName?: string
  className?: string
  fileName?: string
  lineNumber?: number
  methodName?: string
  moduleName?: string
  moduleVersion?: string
  nativeMethod?: boolean
}

export interface StageElementConfig {
  delegateSelectors?: string[]
  description?: string
  failureStrategies?: FailureStrategyConfig[]
  identifier: string
  name: string
  skipInstances?: boolean
  spec?: StageInfoConfig
  strategy?: StrategyConfig
  tags?: {
    [key: string]: string
  }
  template?: TemplateLinkConfig
  type?: string
  variables?: NGVariable[]
  when?: StageWhenCondition
}

export interface StageInfoConfig {
  execution?: ExecutionElementConfig
}

export type StageRollbackFailureActionConfig = FailureStrategyActionConfig & {
  type: 'StageRollback'
}

export interface StageWhenCondition {
  condition?: string
  pipelineStatus: 'Success' | 'Failure' | 'All'
}

export interface StepElementConfig {
  description?: string
  enforce?: PolicyConfig
  failureStrategies?: FailureStrategyConfig[]
  identifier: string
  name: string
  spec?: StepSpecType
  strategy?: StrategyConfig
  timeout?: string
  type: string
  when?: StepWhenCondition
}

export interface StepGroupElementConfig {
  delegateSelectors?: string[]
  failureStrategies?: FailureStrategyConfig[]
  identifier: string
  name: string
  sharedPaths?: string[]
  stepGroupInfra?: StepGroupInfra
  steps?: ExecutionWrapperConfig[]
  strategy?: StrategyConfig
  template?: TemplateLinkConfig
  variables?: NGVariable[]
  when?: StepWhenCondition
}

export type StepGroupFailureActionConfig = FailureStrategyActionConfig & {
  type: 'StepGroupRollback'
}

export interface StepGroupInfra {
  type?: 'KubernetesDirect' | 'Delegate' | 'Noop'
}

export interface StepSpecType {
  [key: string]: any
}

export interface StepWhenCondition {
  condition?: string
  stageStatus: 'Success' | 'Failure' | 'All'
}

export interface StoreSpec {
  [key: string]: any
}

export interface StrategyConfig {
  matrix?: ParameterFieldMatrixConfigInterface
  parallelism?: number
  repeat?: HarnessForConfig
}

export interface StrategyExpansionData {
  maxConcurrency?: number
}

export type StringNGVariable = NGVariable & {
  default?: string
  name?: string
  type?: 'String'
  value: string
}

export type SyftSbomOrchestration = SbomOrchestrationSpec & {
  format?: 'spdx-json' | 'cyclonedx-json'
}

export type SysdigStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  auth?: STOYamlAuth
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  image?: STOYamlImage
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export interface TIBuildDetails {
  buildTool?: string
  language?: string
}

export type TagBuildSpec = BuildSpec & {
  tag: string
}

export interface TaskSelectorYaml {
  delegateSelectors?: string
  origin?: string
}

export interface TemplateInfo {
  templateEntityType?:
    | 'Step'
    | 'Stage'
    | 'Pipeline'
    | 'CustomDeployment'
    | 'MonitoredService'
    | 'SecretManager'
    | 'ArtifactSource'
    | 'StepGroup'
  templateIdentifier?: string
  versionLabel?: string
}

export interface TemplateInputsErrorDTO {
  fieldName?: string
  identifierOfErrorSource?: string
  message?: string
}

export type TemplateInputsErrorMetadataDTO = ErrorMetadataDTO & {
  errorMap?: {
    [key: string]: TemplateInputsErrorDTO
  }
  errorYaml?: string
}

export interface TemplateLinkConfig {
  gitBranch?: string
  templateInputs?: JsonNode
  templateRef: string
  templateVariables?: JsonNode
  versionLabel?: string
}

export interface TemplateResponse {
  accountId: string
  cacheResponseMetadata?: CacheResponseMetadata
  childType?: string
  connectorRef?: string
  description?: string
  entityValidityDetails?: EntityValidityDetails
  gitDetails?: EntityGitDetails
  icon?: string
  identifier: string
  lastUpdatedAt?: number
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  stableTemplate?: boolean
  storeType?: 'INLINE' | 'REMOTE'
  tags?: {
    [key: string]: string
  }
  templateEntityType?:
    | 'Step'
    | 'Stage'
    | 'Pipeline'
    | 'CustomDeployment'
    | 'MonitoredService'
    | 'SecretManager'
    | 'ArtifactSource'
    | 'StepGroup'
  templateScope?: 'account' | 'org' | 'project' | 'unknown'
  version?: number
  versionLabel?: string
  yaml?: string
}

export type TenableStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  instance?: STOYamlInstance
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
}

export type TestStepInfo = StepSpecType & {
  envs?: {
    [key: string]: string
  }
  image?: string
  language?: ParameterFieldTILanguage
  outputs?: string[]
  privileged?: boolean
  pull?: 'always' | 'never' | 'if-not-exists'
  resources?: ContainerResource
  shell?: 'sh' | 'bash' | 'powershell' | 'pwsh' | 'python'
  splitting?: Splitting
  user?: number
  uses?: 'maven' | 'bazel' | 'gradle' | 'dotnet' | 'nunit_console' | 'sbt' | 'pytest' | 'unittest' | 'rspec'
  with?: {
    [key: string]: JsonNode
  }
}

export interface Throwable {
  cause?: Throwable
  localizedMessage?: string
  message?: string
  stackTrace?: StackTraceElement[]
  suppressed?: Throwable[]
}

export interface Toleration {
  effect?: string
  key?: string
  operator?: string
  tolerationSeconds?: number
  value?: string
}

export interface UnitTestReport {
  spec?: UnitTestReportSpec
  type?: 'JUnit'
}

export interface UnitTestReportSpec {
  [key: string]: any
}

export type UploadToArtifactoryStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  connectorRef: string
  resources?: ContainerResource
  runAsUser?: number
  sourcePath: string
  target: string
}

export type UploadToGCSStepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  resources?: ContainerResource
  runAsUser?: number
  sourcePath: string
  target?: string
}

export type UploadToS3StepInfo = StepSpecType & {
  baseImageConnectorRefs?: ParameterFieldListString
  bucket: string
  connectorRef: string
  endpoint?: string
  region: string
  resources?: ContainerResource
  runAsUser?: number
  sourcePath: string
  stripPrefix?: string
  target?: string
}

export interface UsageDataDTO {
  count?: number
  displayName?: string
  references?: ReferenceDTO[]
}

export type UseFromStageInfraYaml = Infrastructure & {
  useFromStage: string
}

export interface VMRuntimeSpec {
  pool: ParameterFieldString
}

export type VMRuntimeV1 = RuntimeV1 & {
  spec: VMRuntimeSpec
  type: 'vm'
}

export type ValidateTemplateInputsResponseDTO = ErrorMetadataDTO & {
  errorNodeSummary?: ErrorNodeSummary
  validYaml?: boolean
}

export interface ValidationError {
  error?: string
  fieldId?: string
}

export type VeracodeStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  auth?: STOYamlAuth
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
  tool?: STOYamlVeracodeToolData
}

export interface VerifyAttestation {
  spec?: VerifyAttestationSpec
  type?: 'cosign'
}

export interface VerifyAttestationSpec {
  [key: string]: any
}

export type VmBuildJobInfo = BuildJobEnvInfo & {
  ciExecutionArgs?: CIExecutionArgs
  connectorRefs?: string[]
  serviceDependencies?: DependencyElement[]
  stageVars?: NGVariable[]
  volToMountPath?: {
    [key: string]: string
  }
  workDir?: string
}

export interface VmInfraSpec {
  type?: 'Pool'
}

export type VmInfraYaml = Infrastructure & {
  spec: VmInfraSpec
  type: 'KubernetesDirect' | 'UseFromStage' | 'VM'
}

export type VmPoolYaml = VmInfraSpec & {
  spec: VmPoolYamlSpec
  type: 'Pool'
}

export interface VmPoolYamlSpec {
  harnessImageConnectorRef?: string
  identifier?: string
  initTimeout?: string
  os?: 'Linux' | 'MacOS' | 'Windows'
  poolName?: string
}

export interface WebhookBaseAttributes {
  action?: string
  after?: string
  authorAvatar?: string
  authorEmail?: string
  authorLogin?: string
  authorName?: string
  before?: string
  link?: string
  mergeSha?: string
  message?: string
  ref?: string
  sender?: string
  source?: string
  target?: string
}

export interface WebhookEvent {
  type?: 'PR' | 'BRANCH' | 'RELEASE'
}

export type WebhookExecutionSource = ExecutionSource & {
  triggerName?: string
  user?: WebhookGitUser
  webhookEvent?: WebhookEvent
}

export interface WebhookGitUser {
  avatar?: string
  email?: string
  gitId?: string
  name?: string
}

export interface YamlGroup {
  group?: string
}

export interface YamlSchemaDetailsWrapper {
  yamlSchemaWithDetailsList?: YamlSchemaWithDetails[]
}

export interface YamlSchemaErrorDTO {
  fqn?: string
  hintMessage?: string
  message?: string
  messageWithFQN?: string
  stageInfo?: NodeErrorInfo
  stepInfo?: NodeErrorInfo
}

export type YamlSchemaErrorWrapperDTO = ErrorMetadataDTO & {
  schemaErrors?: YamlSchemaErrorDTO[]
}

export interface YamlSchemaMetadata {
  featureFlags?: string[]
  featureRestrictions?: string[]
  modulesSupported?: (
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'GOVERNANCE'
    | 'IDP'
  )[]
  namespace?: string
  yamlGroup: YamlGroup
}

export interface YamlSchemaWithDetails {
  availableAtAccountLevel?: boolean
  availableAtOrgLevel?: boolean
  availableAtProjectLevel?: boolean
  moduleType?:
    | 'CD'
    | 'CI'
    | 'CV'
    | 'CF'
    | 'CE'
    | 'STO'
    | 'CHAOS'
    | 'SRM'
    | 'IACM'
    | 'CET'
    | 'CODE'
    | 'CORE'
    | 'PMS'
    | 'TEMPLATESERVICE'
    | 'GOVERNANCE'
    | 'IDP'
  schema?: JsonNode
  schemaClassName?: string
  yamlSchemaMetadata?: YamlSchemaMetadata
}

export type ZapStepInfo = StepSpecType & {
  advanced?: STOYamlAdvancedSettings
  baseImageConnectorRefs?: ParameterFieldListString
  config: 'default' | 'quick' | 'attack' | 'standard'
  imagePullPolicy?: 'Always' | 'Never' | 'IfNotPresent'
  ingestion?: STOYamlIngestion
  instance?: STOYamlInstance
  mode: 'ingestion' | 'orchestration' | 'extraction'
  outputVariables?: OutputNGVariable[]
  privileged?: boolean
  resources?: ContainerResource
  runAsUser?: number
  settings?: ParameterFieldMapStringJsonNode
  target: STOYamlTarget
  tool?: STOYamlZapToolData
}

export type CIDevelopersFilterParamsRequestBody = CIDevelopersFilterParams

export type OperationArrayRequestBody = Operation[]

export type YamlSchemaDetailsWrapperRequestBody = YamlSchemaDetailsWrapper

export interface DeleteCacheQueryParams {
  accountIdentifier: string
  path?: string
  cacheType?: string
}

export type DeleteCacheProps = Omit<
  MutateProps<ResponseDeleteCacheResponse, Failure | Error, DeleteCacheQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete cache for certain account
 */
export const DeleteCache = (props: DeleteCacheProps) => (
  <Mutate<ResponseDeleteCacheResponse, Failure | Error, DeleteCacheQueryParams, void, void>
    verb="DELETE"
    path={`/cache`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseDeleteCacheProps = Omit<
  UseMutateProps<ResponseDeleteCacheResponse, Failure | Error, DeleteCacheQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete cache for certain account
 */
export const useDeleteCache = (props: UseDeleteCacheProps) =>
  useMutate<ResponseDeleteCacheResponse, Failure | Error, DeleteCacheQueryParams, void, void>('DELETE', `/cache`, {
    base: getConfig('ci'),
    ...props
  })

/**
 * Delete cache for certain account
 */
export const deleteCachePromise = (
  props: MutateUsingFetchProps<ResponseDeleteCacheResponse, Failure | Error, DeleteCacheQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseDeleteCacheResponse, Failure | Error, DeleteCacheQueryParams, void, void>(
    'DELETE',
    getConfig('ci'),
    `/cache`,
    props,
    signal
  )

export interface GetCacheInfoQueryParams {
  accountIdentifier: string
}

export type GetCacheInfoProps = Omit<
  GetProps<ResponseCacheMetadataInfo, Failure | Error, GetCacheInfoQueryParams, void>,
  'path'
>

/**
 * Get Cache Metadata Information
 */
export const GetCacheInfo = (props: GetCacheInfoProps) => (
  <Get<ResponseCacheMetadataInfo, Failure | Error, GetCacheInfoQueryParams, void>
    path={`/cache/info`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseGetCacheInfoProps = Omit<
  UseGetProps<ResponseCacheMetadataInfo, Failure | Error, GetCacheInfoQueryParams, void>,
  'path'
>

/**
 * Get Cache Metadata Information
 */
export const useGetCacheInfo = (props: UseGetCacheInfoProps) =>
  useGet<ResponseCacheMetadataInfo, Failure | Error, GetCacheInfoQueryParams, void>(`/cache/info`, {
    base: getConfig('ci'),
    ...props
  })

/**
 * Get Cache Metadata Information
 */
export const getCacheInfoPromise = (
  props: GetUsingFetchProps<ResponseCacheMetadataInfo, Failure | Error, GetCacheInfoQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCacheMetadataInfo, Failure | Error, GetCacheInfoQueryParams, void>(
    getConfig('ci'),
    `/cache/info`,
    props,
    signal
  )

export interface GetBuildExecutionQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  groupBy?: 'DAY' | 'WEEK' | 'MONTH'
  startTime: number
  endTime: number
}

export type GetBuildExecutionProps = Omit<
  GetProps<ResponseDashboardBuildExecutionInfo, Failure | Error, GetBuildExecutionQueryParams, void>,
  'path'
>

/**
 * Get build execution
 */
export const GetBuildExecution = (props: GetBuildExecutionProps) => (
  <Get<ResponseDashboardBuildExecutionInfo, Failure | Error, GetBuildExecutionQueryParams, void>
    path={`/ci/buildExecution`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseGetBuildExecutionProps = Omit<
  UseGetProps<ResponseDashboardBuildExecutionInfo, Failure | Error, GetBuildExecutionQueryParams, void>,
  'path'
>

/**
 * Get build execution
 */
export const useGetBuildExecution = (props: UseGetBuildExecutionProps) =>
  useGet<ResponseDashboardBuildExecutionInfo, Failure | Error, GetBuildExecutionQueryParams, void>(
    `/ci/buildExecution`,
    { base: getConfig('ci'), ...props }
  )

/**
 * Get build execution
 */
export const getBuildExecutionPromise = (
  props: GetUsingFetchProps<ResponseDashboardBuildExecutionInfo, Failure | Error, GetBuildExecutionQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDashboardBuildExecutionInfo, Failure | Error, GetBuildExecutionQueryParams, void>(
    getConfig('ci'),
    `/ci/buildExecution`,
    props,
    signal
  )

export interface GetBuildHealthQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  startTime: number
  endTime: number
}

export type GetBuildHealthProps = Omit<
  GetProps<ResponseDashboardBuildsHealthInfo, Failure | Error, GetBuildHealthQueryParams, void>,
  'path'
>

/**
 * Get build health
 */
export const GetBuildHealth = (props: GetBuildHealthProps) => (
  <Get<ResponseDashboardBuildsHealthInfo, Failure | Error, GetBuildHealthQueryParams, void>
    path={`/ci/buildHealth`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseGetBuildHealthProps = Omit<
  UseGetProps<ResponseDashboardBuildsHealthInfo, Failure | Error, GetBuildHealthQueryParams, void>,
  'path'
>

/**
 * Get build health
 */
export const useGetBuildHealth = (props: UseGetBuildHealthProps) =>
  useGet<ResponseDashboardBuildsHealthInfo, Failure | Error, GetBuildHealthQueryParams, void>(`/ci/buildHealth`, {
    base: getConfig('ci'),
    ...props
  })

/**
 * Get build health
 */
export const getBuildHealthPromise = (
  props: GetUsingFetchProps<ResponseDashboardBuildsHealthInfo, Failure | Error, GetBuildHealthQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDashboardBuildsHealthInfo, Failure | Error, GetBuildHealthQueryParams, void>(
    getConfig('ci'),
    `/ci/buildHealth`,
    props,
    signal
  )

export interface GetCreditsQueryParams {
  accountIdentifier: string
  startTime: number
  endTime: number
}

export type GetCreditsProps = Omit<
  GetProps<ResponseCICreditsResult, Failure | Error, GetCreditsQueryParams, void>,
  'path'
>

/**
 * Get build credits
 */
export const GetCredits = (props: GetCreditsProps) => (
  <Get<ResponseCICreditsResult, Failure | Error, GetCreditsQueryParams, void>
    path={`/ci/credits`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseGetCreditsProps = Omit<
  UseGetProps<ResponseCICreditsResult, Failure | Error, GetCreditsQueryParams, void>,
  'path'
>

/**
 * Get build credits
 */
export const useGetCredits = (props: UseGetCreditsProps) =>
  useGet<ResponseCICreditsResult, Failure | Error, GetCreditsQueryParams, void>(`/ci/credits`, {
    base: getConfig('ci'),
    ...props
  })

/**
 * Get build credits
 */
export const getCreditsPromise = (
  props: GetUsingFetchProps<ResponseCICreditsResult, Failure | Error, GetCreditsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCICreditsResult, Failure | Error, GetCreditsQueryParams, void>(
    getConfig('ci'),
    `/ci/credits`,
    props,
    signal
  )

export interface GetBuildsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  top?: number
}

export type GetBuildsProps = Omit<
  GetProps<ResponseDashboardBuildsActiveAndFailedInfo, Failure | Error, GetBuildsQueryParams, void>,
  'path'
>

/**
 * Get builds
 */
export const GetBuilds = (props: GetBuildsProps) => (
  <Get<ResponseDashboardBuildsActiveAndFailedInfo, Failure | Error, GetBuildsQueryParams, void>
    path={`/ci/getBuilds`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseGetBuildsProps = Omit<
  UseGetProps<ResponseDashboardBuildsActiveAndFailedInfo, Failure | Error, GetBuildsQueryParams, void>,
  'path'
>

/**
 * Get builds
 */
export const useGetBuilds = (props: UseGetBuildsProps) =>
  useGet<ResponseDashboardBuildsActiveAndFailedInfo, Failure | Error, GetBuildsQueryParams, void>(`/ci/getBuilds`, {
    base: getConfig('ci'),
    ...props
  })

/**
 * Get builds
 */
export const getBuildsPromise = (
  props: GetUsingFetchProps<ResponseDashboardBuildsActiveAndFailedInfo, Failure | Error, GetBuildsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDashboardBuildsActiveAndFailedInfo, Failure | Error, GetBuildsQueryParams, void>(
    getConfig('ci'),
    `/ci/getBuilds`,
    props,
    signal
  )

export interface GetRepositoryBuildQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  startTime: number
  endTime: number
}

export type GetRepositoryBuildProps = Omit<
  GetProps<ResponseDashboardBuildRepositoryInfo, Failure | Error, GetRepositoryBuildQueryParams, void>,
  'path'
>

/**
 * Get build getRepositoryBuild
 */
export const GetRepositoryBuild = (props: GetRepositoryBuildProps) => (
  <Get<ResponseDashboardBuildRepositoryInfo, Failure | Error, GetRepositoryBuildQueryParams, void>
    path={`/ci/repositoryBuild`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseGetRepositoryBuildProps = Omit<
  UseGetProps<ResponseDashboardBuildRepositoryInfo, Failure | Error, GetRepositoryBuildQueryParams, void>,
  'path'
>

/**
 * Get build getRepositoryBuild
 */
export const useGetRepositoryBuild = (props: UseGetRepositoryBuildProps) =>
  useGet<ResponseDashboardBuildRepositoryInfo, Failure | Error, GetRepositoryBuildQueryParams, void>(
    `/ci/repositoryBuild`,
    { base: getConfig('ci'), ...props }
  )

/**
 * Get build getRepositoryBuild
 */
export const getRepositoryBuildPromise = (
  props: GetUsingFetchProps<ResponseDashboardBuildRepositoryInfo, Failure | Error, GetRepositoryBuildQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDashboardBuildRepositoryInfo, Failure | Error, GetRepositoryBuildQueryParams, void>(
    getConfig('ci'),
    `/ci/repositoryBuild`,
    props,
    signal
  )

export interface GetUsageQueryParams {
  accountIdentifier: string
  timestamp: number
}

export type GetUsageProps = Omit<GetProps<ResponseCIUsageResult, Failure | Error, GetUsageQueryParams, void>, 'path'>

/**
 * Get usage
 */
export const GetUsage = (props: GetUsageProps) => (
  <Get<ResponseCIUsageResult, Failure | Error, GetUsageQueryParams, void>
    path={`/ci/usage/ci`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseGetUsageProps = Omit<
  UseGetProps<ResponseCIUsageResult, Failure | Error, GetUsageQueryParams, void>,
  'path'
>

/**
 * Get usage
 */
export const useGetUsage = (props: UseGetUsageProps) =>
  useGet<ResponseCIUsageResult, Failure | Error, GetUsageQueryParams, void>(`/ci/usage/ci`, {
    base: getConfig('ci'),
    ...props
  })

/**
 * Get usage
 */
export const getUsagePromise = (
  props: GetUsingFetchProps<ResponseCIUsageResult, Failure | Error, GetUsageQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCIUsageResult, Failure | Error, GetUsageQueryParams, void>(
    getConfig('ci'),
    `/ci/usage/ci`,
    props,
    signal
  )

export interface DockerRunnerCommandQueryParams {
  accountId?: string
  os?: string
  arch?: string
}

export type DockerRunnerCommandProps = Omit<
  GetProps<string, Failure | Error, DockerRunnerCommandQueryParams, void>,
  'path'
>

export type UseDockerRunnerCommandProps = Omit<
  UseGetProps<RestResponseString, Failure | Error, DockerRunnerCommandQueryParams, void>,
  'path'
>

/**
 * get docker-runner command
 */
export const useDockerRunnerCommand = (props: UseDockerRunnerCommandProps) =>
  useGet<RestResponseString, Failure | Error, DockerRunnerCommandQueryParams, void>(`/docker-runner`, {
    base: getConfig('ci'),
    ...props
  })

/**
 * get docker-runner command
 */
export const dockerRunnerCommandPromise = (
  props: GetUsingFetchProps<RestResponseString, Failure | Error, DockerRunnerCommandQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseString, Failure | Error, DockerRunnerCommandQueryParams, void>(
    getConfig('ci'),
    `/docker-runner`,
    props,
    signal
  )
export interface DeleteExecutionConfigQueryParams {
  accountIdentifier: string
}

export type DeleteExecutionConfigProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteExecutionConfigQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete execution config
 */
export const DeleteExecutionConfig = (props: DeleteExecutionConfigProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteExecutionConfigQueryParams, void, void>
    verb="DELETE"
    path={`/execution-config`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseDeleteExecutionConfigProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteExecutionConfigQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete execution config
 */
export const useDeleteExecutionConfig = (props: UseDeleteExecutionConfigProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteExecutionConfigQueryParams, void, void>(
    'DELETE',
    `/execution-config`,
    { base: getConfig('ci'), ...props }
  )

/**
 * Delete execution config
 */
export const deleteExecutionConfigPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteExecutionConfigQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteExecutionConfigQueryParams, void, void>(
    'DELETE',
    getConfig('ci'),
    `/execution-config`,
    props,
    signal
  )

export interface GetExecutionConfigQueryParams {
  accountIdentifier: string
}

export type GetExecutionConfigProps = Omit<
  GetProps<ResponseListDeprecatedImageInfo, Failure | Error, GetExecutionConfigQueryParams, void>,
  'path'
>

/**
 * Get execution config
 */
export const GetExecutionConfig = (props: GetExecutionConfigProps) => (
  <Get<ResponseListDeprecatedImageInfo, Failure | Error, GetExecutionConfigQueryParams, void>
    path={`/execution-config`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseGetExecutionConfigProps = Omit<
  UseGetProps<ResponseListDeprecatedImageInfo, Failure | Error, GetExecutionConfigQueryParams, void>,
  'path'
>

/**
 * Get execution config
 */
export const useGetExecutionConfig = (props: UseGetExecutionConfigProps) =>
  useGet<ResponseListDeprecatedImageInfo, Failure | Error, GetExecutionConfigQueryParams, void>(`/execution-config`, {
    base: getConfig('ci'),
    ...props
  })

/**
 * Get execution config
 */
export const getExecutionConfigPromise = (
  props: GetUsingFetchProps<ResponseListDeprecatedImageInfo, Failure | Error, GetExecutionConfigQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListDeprecatedImageInfo, Failure | Error, GetExecutionConfigQueryParams, void>(
    getConfig('ci'),
    `/execution-config`,
    props,
    signal
  )

export interface GetCustomerConfigQueryParams {
  infra: 'K8' | 'VM' | 'DLITE_VM'
  overridesOnly: boolean
  accountIdentifier: string
}

export type GetCustomerConfigProps = Omit<
  GetProps<ResponseCIExecutionImages, Failure | Error, GetCustomerConfigQueryParams, void>,
  'path'
>

/**
 * Get customer's execution config
 */
export const GetCustomerConfig = (props: GetCustomerConfigProps) => (
  <Get<ResponseCIExecutionImages, Failure | Error, GetCustomerConfigQueryParams, void>
    path={`/execution-config/get-customer-config`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseGetCustomerConfigProps = Omit<
  UseGetProps<ResponseCIExecutionImages, Failure | Error, GetCustomerConfigQueryParams, void>,
  'path'
>

/**
 * Get customer's execution config
 */
export const useGetCustomerConfig = (props: UseGetCustomerConfigProps) =>
  useGet<ResponseCIExecutionImages, Failure | Error, GetCustomerConfigQueryParams, void>(
    `/execution-config/get-customer-config`,
    { base: getConfig('ci'), ...props }
  )

/**
 * Get customer's execution config
 */
export const getCustomerConfigPromise = (
  props: GetUsingFetchProps<ResponseCIExecutionImages, Failure | Error, GetCustomerConfigQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCIExecutionImages, Failure | Error, GetCustomerConfigQueryParams, void>(
    getConfig('ci'),
    `/execution-config/get-customer-config`,
    props,
    signal
  )

export interface GetDefaultConfigQueryParams {
  infra: 'K8' | 'VM' | 'DLITE_VM'
}

export type GetDefaultConfigProps = Omit<
  GetProps<ResponseCIExecutionImages, Failure | Error, GetDefaultConfigQueryParams, void>,
  'path'
>

/**
 * Get default execution config
 */
export const GetDefaultConfig = (props: GetDefaultConfigProps) => (
  <Get<ResponseCIExecutionImages, Failure | Error, GetDefaultConfigQueryParams, void>
    path={`/execution-config/get-default-config`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseGetDefaultConfigProps = Omit<
  UseGetProps<ResponseCIExecutionImages, Failure | Error, GetDefaultConfigQueryParams, void>,
  'path'
>

/**
 * Get default execution config
 */
export const useGetDefaultConfig = (props: UseGetDefaultConfigProps) =>
  useGet<ResponseCIExecutionImages, Failure | Error, GetDefaultConfigQueryParams, void>(
    `/execution-config/get-default-config`,
    { base: getConfig('ci'), ...props }
  )

/**
 * Get default execution config
 */
export const getDefaultConfigPromise = (
  props: GetUsingFetchProps<ResponseCIExecutionImages, Failure | Error, GetDefaultConfigQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCIExecutionImages, Failure | Error, GetDefaultConfigQueryParams, void>(
    getConfig('ci'),
    `/execution-config/get-default-config`,
    props,
    signal
  )

export interface GetDeprecatedConfigQueryParams {
  accountIdentifier: string
}

export type GetDeprecatedConfigProps = Omit<
  GetProps<ResponseCIExecutionImages, Failure | Error, GetDeprecatedConfigQueryParams, void>,
  'path'
>

/**
 * Get deprecated config
 */
export const GetDeprecatedConfig = (props: GetDeprecatedConfigProps) => (
  <Get<ResponseCIExecutionImages, Failure | Error, GetDeprecatedConfigQueryParams, void>
    path={`/execution-config/get-deprecated-config`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseGetDeprecatedConfigProps = Omit<
  UseGetProps<ResponseCIExecutionImages, Failure | Error, GetDeprecatedConfigQueryParams, void>,
  'path'
>

/**
 * Get deprecated config
 */
export const useGetDeprecatedConfig = (props: UseGetDeprecatedConfigProps) =>
  useGet<ResponseCIExecutionImages, Failure | Error, GetDeprecatedConfigQueryParams, void>(
    `/execution-config/get-deprecated-config`,
    { base: getConfig('ci'), ...props }
  )

/**
 * Get deprecated config
 */
export const getDeprecatedConfigPromise = (
  props: GetUsingFetchProps<ResponseCIExecutionImages, Failure | Error, GetDeprecatedConfigQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCIExecutionImages, Failure | Error, GetDeprecatedConfigQueryParams, void>(
    getConfig('ci'),
    `/execution-config/get-deprecated-config`,
    props,
    signal
  )

export interface ResetExecutionConfigQueryParams {
  infra: 'K8' | 'VM' | 'DLITE_VM'
  accountIdentifier: string
}

export type ResetExecutionConfigProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, ResetExecutionConfigQueryParams, OperationArrayRequestBody, void>,
  'path' | 'verb'
>

/**
 * Reset execution config
 */
export const ResetExecutionConfig = (props: ResetExecutionConfigProps) => (
  <Mutate<ResponseBoolean, Failure | Error, ResetExecutionConfigQueryParams, OperationArrayRequestBody, void>
    verb="POST"
    path={`/execution-config/reset-config`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseResetExecutionConfigProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, ResetExecutionConfigQueryParams, OperationArrayRequestBody, void>,
  'path' | 'verb'
>

/**
 * Reset execution config
 */
export const useResetExecutionConfig = (props: UseResetExecutionConfigProps) =>
  useMutate<ResponseBoolean, Failure | Error, ResetExecutionConfigQueryParams, OperationArrayRequestBody, void>(
    'POST',
    `/execution-config/reset-config`,
    { base: getConfig('ci'), ...props }
  )

/**
 * Reset execution config
 */
export const resetExecutionConfigPromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    ResetExecutionConfigQueryParams,
    OperationArrayRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, ResetExecutionConfigQueryParams, OperationArrayRequestBody, void>(
    'POST',
    getConfig('ci'),
    `/execution-config/reset-config`,
    props,
    signal
  )

export interface UpdateExecutionConfigQueryParams {
  infra: 'K8' | 'VM' | 'DLITE_VM'
  accountIdentifier: string
}

export type UpdateExecutionConfigProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, UpdateExecutionConfigQueryParams, OperationArrayRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update execution config
 */
export const UpdateExecutionConfig = (props: UpdateExecutionConfigProps) => (
  <Mutate<ResponseBoolean, Failure | Error, UpdateExecutionConfigQueryParams, OperationArrayRequestBody, void>
    verb="POST"
    path={`/execution-config/update-config`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseUpdateExecutionConfigProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, UpdateExecutionConfigQueryParams, OperationArrayRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update execution config
 */
export const useUpdateExecutionConfig = (props: UseUpdateExecutionConfigProps) =>
  useMutate<ResponseBoolean, Failure | Error, UpdateExecutionConfigQueryParams, OperationArrayRequestBody, void>(
    'POST',
    `/execution-config/update-config`,
    { base: getConfig('ci'), ...props }
  )

/**
 * Update execution config
 */
export const updateExecutionConfigPromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    UpdateExecutionConfigQueryParams,
    OperationArrayRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, UpdateExecutionConfigQueryParams, OperationArrayRequestBody, void>(
    'POST',
    getConfig('ci'),
    `/execution-config/update-config`,
    props,
    signal
  )

export interface GetExecutionQueueLimitsQueryParams {
  accountIdentifier: string
}

export type GetExecutionQueueLimitsProps = Omit<
  GetProps<ResponseExecutionQueueLimitDTO, Failure | Error, GetExecutionQueueLimitsQueryParams, void>,
  'path'
>

/**
 * Get execution queue limits
 */
export const GetExecutionQueueLimits = (props: GetExecutionQueueLimitsProps) => (
  <Get<ResponseExecutionQueueLimitDTO, Failure | Error, GetExecutionQueueLimitsQueryParams, void>
    path={`/execution-limit`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseGetExecutionQueueLimitsProps = Omit<
  UseGetProps<ResponseExecutionQueueLimitDTO, Failure | Error, GetExecutionQueueLimitsQueryParams, void>,
  'path'
>

/**
 * Get execution queue limits
 */
export const useGetExecutionQueueLimits = (props: UseGetExecutionQueueLimitsProps) =>
  useGet<ResponseExecutionQueueLimitDTO, Failure | Error, GetExecutionQueueLimitsQueryParams, void>(
    `/execution-limit`,
    { base: getConfig('ci'), ...props }
  )

/**
 * Get execution queue limits
 */
export const getExecutionQueueLimitsPromise = (
  props: GetUsingFetchProps<ResponseExecutionQueueLimitDTO, Failure | Error, GetExecutionQueueLimitsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseExecutionQueueLimitDTO, Failure | Error, GetExecutionQueueLimitsQueryParams, void>(
    getConfig('ci'),
    `/execution-limit`,
    props,
    signal
  )

export interface UpdateExecutionQueueLimitsQueryParams {
  accountIdentifier: string
}

export type UpdateExecutionQueueLimitsProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, UpdateExecutionQueueLimitsQueryParams, ExecutionQueueLimitDTO, void>,
  'path' | 'verb'
>

/**
 * Update execution queue limits
 */
export const UpdateExecutionQueueLimits = (props: UpdateExecutionQueueLimitsProps) => (
  <Mutate<ResponseBoolean, Failure | Error, UpdateExecutionQueueLimitsQueryParams, ExecutionQueueLimitDTO, void>
    verb="POST"
    path={`/execution-limit`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseUpdateExecutionQueueLimitsProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, UpdateExecutionQueueLimitsQueryParams, ExecutionQueueLimitDTO, void>,
  'path' | 'verb'
>

/**
 * Update execution queue limits
 */
export const useUpdateExecutionQueueLimits = (props: UseUpdateExecutionQueueLimitsProps) =>
  useMutate<ResponseBoolean, Failure | Error, UpdateExecutionQueueLimitsQueryParams, ExecutionQueueLimitDTO, void>(
    'POST',
    `/execution-limit`,
    { base: getConfig('ci'), ...props }
  )

/**
 * Update execution queue limits
 */
export const updateExecutionQueueLimitsPromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    UpdateExecutionQueueLimitsQueryParams,
    ExecutionQueueLimitDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    Failure | Error,
    UpdateExecutionQueueLimitsQueryParams,
    ExecutionQueueLimitDTO,
    void
  >('POST', getConfig('ci'), `/execution-limit`, props, signal)

export interface CiLicenseUsageQueryParams {
  accountIdentifier?: string
  page?: number
  size?: number
  sort?: string[]
  timestamp?: number
}

export type CiLicenseUsageProps = Omit<
  MutateProps<
    ResponsePageActiveDevelopersDTO,
    Failure | Error,
    CiLicenseUsageQueryParams,
    CIDevelopersFilterParamsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get CI Licence Usage
 */
export const CiLicenseUsage = (props: CiLicenseUsageProps) => (
  <Mutate<
    ResponsePageActiveDevelopersDTO,
    Failure | Error,
    CiLicenseUsageQueryParams,
    CIDevelopersFilterParamsRequestBody,
    void
  >
    verb="POST"
    path={`/license-usage`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseCiLicenseUsageProps = Omit<
  UseMutateProps<
    ResponsePageActiveDevelopersDTO,
    Failure | Error,
    CiLicenseUsageQueryParams,
    CIDevelopersFilterParamsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get CI Licence Usage
 */
export const useCiLicenseUsage = (props: UseCiLicenseUsageProps) =>
  useMutate<
    ResponsePageActiveDevelopersDTO,
    Failure | Error,
    CiLicenseUsageQueryParams,
    CIDevelopersFilterParamsRequestBody,
    void
  >('POST', `/license-usage`, { base: getConfig('ci'), ...props })

/**
 * Get CI Licence Usage
 */
export const ciLicenseUsagePromise = (
  props: MutateUsingFetchProps<
    ResponsePageActiveDevelopersDTO,
    Failure | Error,
    CiLicenseUsageQueryParams,
    CIDevelopersFilterParamsRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageActiveDevelopersDTO,
    Failure | Error,
    CiLicenseUsageQueryParams,
    CIDevelopersFilterParamsRequestBody,
    void
  >('POST', getConfig('ci'), `/license-usage`, props, signal)

export interface DownloadActiveDevelopersCSVReportQueryParams {
  accountIdentifier?: string
  timestamp?: number
}

export type DownloadActiveDevelopersCSVReportProps = Omit<
  GetProps<void, Failure | Error, DownloadActiveDevelopersCSVReportQueryParams, void>,
  'path'
>

/**
 * Download CSV Active Developers report
 */
export const DownloadActiveDevelopersCSVReport = (props: DownloadActiveDevelopersCSVReportProps) => (
  <Get<void, Failure | Error, DownloadActiveDevelopersCSVReportQueryParams, void>
    path={`/license-usage/csv/download`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseDownloadActiveDevelopersCSVReportProps = Omit<
  UseGetProps<void, Failure | Error, DownloadActiveDevelopersCSVReportQueryParams, void>,
  'path'
>

/**
 * Download CSV Active Developers report
 */
export const useDownloadActiveDevelopersCSVReport = (props: UseDownloadActiveDevelopersCSVReportProps) =>
  useGet<void, Failure | Error, DownloadActiveDevelopersCSVReportQueryParams, void>(`/license-usage/csv/download`, {
    base: getConfig('ci'),
    ...props
  })

/**
 * Download CSV Active Developers report
 */
export const downloadActiveDevelopersCSVReportPromise = (
  props: GetUsingFetchProps<void, Failure | Error, DownloadActiveDevelopersCSVReportQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, Failure | Error, DownloadActiveDevelopersCSVReportQueryParams, void>(
    getConfig('ci'),
    `/license-usage/csv/download`,
    props,
    signal
  )

export interface ListActiveDevelopersQueryParams {
  accountIdentifier?: string
  timestamp?: number
}

export type ListActiveDevelopersProps = Omit<
  GetProps<ResponseSetString, Failure | Error, ListActiveDevelopersQueryParams, void>,
  'path'
>

/**
 * List Active Developers
 */
export const ListActiveDevelopers = (props: ListActiveDevelopersProps) => (
  <Get<ResponseSetString, Failure | Error, ListActiveDevelopersQueryParams, void>
    path={`/license-usage/developers`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseListActiveDevelopersProps = Omit<
  UseGetProps<ResponseSetString, Failure | Error, ListActiveDevelopersQueryParams, void>,
  'path'
>

/**
 * List Active Developers
 */
export const useListActiveDevelopers = (props: UseListActiveDevelopersProps) =>
  useGet<ResponseSetString, Failure | Error, ListActiveDevelopersQueryParams, void>(`/license-usage/developers`, {
    base: getConfig('ci'),
    ...props
  })

/**
 * List Active Developers
 */
export const listActiveDevelopersPromise = (
  props: GetUsingFetchProps<ResponseSetString, Failure | Error, ListActiveDevelopersQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSetString, Failure | Error, ListActiveDevelopersQueryParams, void>(
    getConfig('ci'),
    `/license-usage/developers`,
    props,
    signal
  )

export interface GetLicenseHistoryUsageQueryParams {
  accountIdentifier: string
  licenseType: 'DEVELOPERS'
}

export type GetLicenseHistoryUsageProps = Omit<
  MutateProps<
    ResponseCILicenseHistoryDTO,
    Failure | Error,
    GetLicenseHistoryUsageQueryParams,
    CIDevelopersFilterParamsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get license date usage in CI Module
 */
export const GetLicenseHistoryUsage = (props: GetLicenseHistoryUsageProps) => (
  <Mutate<
    ResponseCILicenseHistoryDTO,
    Failure | Error,
    GetLicenseHistoryUsageQueryParams,
    CIDevelopersFilterParamsRequestBody,
    void
  >
    verb="POST"
    path={`/license-usage/history`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseGetLicenseHistoryUsageProps = Omit<
  UseMutateProps<
    ResponseCILicenseHistoryDTO,
    Failure | Error,
    GetLicenseHistoryUsageQueryParams,
    CIDevelopersFilterParamsRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get license date usage in CI Module
 */
export const useGetLicenseHistoryUsage = (props: UseGetLicenseHistoryUsageProps) =>
  useMutate<
    ResponseCILicenseHistoryDTO,
    Failure | Error,
    GetLicenseHistoryUsageQueryParams,
    CIDevelopersFilterParamsRequestBody,
    void
  >('POST', `/license-usage/history`, { base: getConfig('ci'), ...props })

/**
 * Get license date usage in CI Module
 */
export const getLicenseHistoryUsagePromise = (
  props: MutateUsingFetchProps<
    ResponseCILicenseHistoryDTO,
    Failure | Error,
    GetLicenseHistoryUsageQueryParams,
    CIDevelopersFilterParamsRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseCILicenseHistoryDTO,
    Failure | Error,
    GetLicenseHistoryUsageQueryParams,
    CIDevelopersFilterParamsRequestBody,
    void
  >('POST', getConfig('ci'), `/license-usage/history`, props, signal)

export interface GetPartialYamlSchemaQueryParams {
  accountIdentifier: string
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export type GetPartialYamlSchemaProps = Omit<
  GetProps<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Partial Yaml Schema
 */
export const GetPartialYamlSchema = (props: GetPartialYamlSchemaProps) => (
  <Get<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>
    path={`/partial-yaml-schema`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseGetPartialYamlSchemaProps = Omit<
  UseGetProps<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Partial Yaml Schema
 */
export const useGetPartialYamlSchema = (props: UseGetPartialYamlSchemaProps) =>
  useGet<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>(`/partial-yaml-schema`, {
    base: getConfig('ci'),
    ...props
  })

/**
 * Get Partial Yaml Schema
 */
export const getPartialYamlSchemaPromise = (
  props: GetUsingFetchProps<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>(
    getConfig('ci'),
    `/partial-yaml-schema`,
    props,
    signal
  )

export interface GetStepYamlSchemaQueryParams {
  accountIdentifier: string
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
  entityType?:
    | 'CreatePR'
    | 'GITOPS_MERGE_PR'
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'Email'
    | 'JiraCreate'
    | 'JiraUpdate'
    | 'JiraApproval'
    | 'HarnessApproval'
    | 'CustomApproval'
    | 'Barrier'
    | 'Queue'
    | 'FlagConfiguration'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'K8sApply'
    | 'K8sBlueGreenDeploy'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'K8sScale'
    | 'K8sDelete'
    | 'K8sBGSwapServices'
    | 'K8sCanaryDelete'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'Connectors'
    | 'Secrets'
    | 'Files'
    | 'Service'
    | 'Environment'
    | 'EnvironmentGroup'
    | 'InputSets'
    | 'CvConfig'
    | 'Verify'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'SecurityStage'
    | 'SecuritySteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'PipelineStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'TemplateStage'
    | 'CustomDeployment'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
    | 'ServiceNowCreate'
    | 'ServiceNowUpdate'
    | 'ServiceNowImportSet'
    | 'GovernancePolicies'
    | 'POLICY_STEP'
    | 'Run'
    | 'RunTests'
    | 'Plugin'
    | 'RestoreCacheGCS'
    | 'RestoreCacheS3'
    | 'SaveCacheGCS'
    | 'SaveCacheS3'
    | 'Security'
    | 'AquaTrivy'
    | 'AWSECR'
    | 'Bandit'
    | 'BlackDuck'
    | 'Brakeman'
    | 'Burp'
    | 'Checkmarx'
    | 'Clair'
    | 'DataTheorem'
    | 'DockerContentTrust'
    | 'External'
    | 'FortifyOnDemand'
    | 'Grype'
    | 'JfrogXray'
    | 'Mend'
    | 'Metasploit'
    | 'Nessus'
    | 'NexusIQ'
    | 'Nikto'
    | 'Nmap'
    | 'Openvas'
    | 'Owasp'
    | 'PrismaCloud'
    | 'Prowler'
    | 'Qualys'
    | 'Reapsaw'
    | 'ShiftLeft'
    | 'Sniper'
    | 'Snyk'
    | 'Sonarqube'
    | 'Sysdig'
    | 'Tenable'
    | 'Veracode'
    | 'Zap'
    | 'GitClone'
    | 'ArtifactoryUpload'
    | 'GCSUpload'
    | 'S3Upload'
    | 'BuildAndPushGCR'
    | 'BuildAndPushECR'
    | 'BuildAndPushDockerRegistry'
    | 'CreateStack'
    | 'DeleteStack'
    | 'ServerlessAwsLambdaDeploy'
    | 'ServerlessAwsLambdaRollback'
    | 'CustomStage'
    | 'RollbackStack'
    | 'Infrastructure'
    | 'Command'
    | 'StrategyNode'
    | 'AZURE_SLOT_DEPLOYMENT_STEP'
    | 'AzureTrafficShift'
    | 'FetchInstanceScript'
    | 'AzureSwapSlot'
    | 'AzureWebAppRollback'
    | 'JenkinsBuild'
    | 'EcsRollingDeploy'
    | 'EcsRollingRollback'
    | 'EcsCanaryDeploy'
    | 'EcsCanaryDelete'
    | 'AzureCreateARMResource'
    | 'BuildAndPushACR'
    | 'AzureCreateBPResource'
    | 'AzureARMRollback'
    | 'Background'
    | 'Wait'
    | 'ArtifactSource'
    | 'EcsBlueGreenCreateService'
    | 'EcsBlueGreenSwapTargetGroups'
    | 'EcsBlueGreenRollback'
    | 'ShellScriptProvision'
    | 'Freeze'
    | 'GitOpsUpdateReleaseRepo'
    | 'GitOpsFetchLinkedApps'
    | 'EcsRunTask'
    | 'Chaos'
    | 'ElastigroupDeploy'
    | 'ElastigroupRollback'
    | 'Action'
    | 'ElastigroupSetup'
    | 'Bitrise'
    | 'TerraformPlan'
    | 'TerraformApply'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'IACMStage'
    | 'IACMStep'
    | 'IACM'
    | 'Container'
    | 'IACM'
    | 'IACM'
    | 'ElastigroupBGStageSetup'
    | 'ElastigroupSwapRoute'
    | 'AsgCanaryDeploy'
    | 'AsgCanaryDelete'
    | 'SwapRoutes'
    | 'SwapRollback'
    | 'AppResize'
    | 'AppRollback'
    | 'CanaryAppSetup'
    | 'BGAppSetup'
    | 'BasicAppSetup'
    | 'TanzuCommand'
    | 'AsgRollingDeploy'
    | 'AsgRollingRollback'
    | 'GovernanceRuleAWS'
    | 'TasRollingDeploy'
    | 'TasRollingRollback'
    | 'K8sDryRun'
    | 'AsgBlueGreenSwapService'
    | 'AsgBlueGreenDeploy'
    | 'AsgBlueGreenRollback'
    | 'TerraformCloudRun'
    | 'TerraformCloudRollback'
    | 'DeployCloudFunction'
    | 'DeployCloudFunctionWithNoTraffic'
    | 'CloudFunctionTrafficShift'
    | 'CloudFunctionRollback'
    | 'AwsLambdaDeploy'
    | 'AwsSamDeploy'
    | 'AwsSamRollback'
    | 'SscaOrchestration'
    | 'AwsLambdaRollback'
    | 'GITOPS_SYNC'
    | 'BambooBuild'
    | 'CdSscaOrchestration'
    | 'RouteMapping'
    | 'AWSSecurityHub'
    | 'CustomIngest'
    | 'BackstageEnvironmentVariable'
    | 'Fossa'
    | 'CodeQL'
    | 'Gitleaks'
    | 'DeployCloudFunctionGenOne'
    | 'RollbackCloudFunctionGenOne'
    | 'K8sBlueGreenStageScaleDown'
    | 'AwsSamBuild'
    | 'Semgrep'
    | 'SscaEnforcement'
    | 'IdpConnector'
    | 'CdSscaEnforcement'
    | 'DownloadManifests'
    | 'ServerlessAwsLambdaPrepareRollbackV2'
    | 'ServerlessAwsLambdaRollbackV2'
    | 'Coverity'
    | 'ServerlessAwsLambdaDeployV2'
    | 'AnalyzeDeploymentImpact'
    | 'ServerlessAwsLambdaPackageV2'
    | 'RevertPR'
    | 'AwsCdkBootstrap'
    | 'AwsCdkSynth'
    | 'AwsCdkDiff'
    | 'AwsCdkDeploy'
    | 'AwsCdkDestroy'
    | 'IdpScorecard'
    | 'IdpCheck'
    | 'AwsCdkRollback'
    | 'IACM'
    | 'SlsaVerification'
  yamlGroup?: string
}

export type GetStepYamlSchemaProps = Omit<
  MutateProps<
    ResponseJsonNode,
    Failure | Error,
    GetStepYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get step YAML schema
 */
export const GetStepYamlSchema = (props: GetStepYamlSchemaProps) => (
  <Mutate<ResponseJsonNode, Failure | Error, GetStepYamlSchemaQueryParams, YamlSchemaDetailsWrapperRequestBody, void>
    verb="POST"
    path={`/partial-yaml-schema`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseGetStepYamlSchemaProps = Omit<
  UseMutateProps<
    ResponseJsonNode,
    Failure | Error,
    GetStepYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get step YAML schema
 */
export const useGetStepYamlSchema = (props: UseGetStepYamlSchemaProps) =>
  useMutate<ResponseJsonNode, Failure | Error, GetStepYamlSchemaQueryParams, YamlSchemaDetailsWrapperRequestBody, void>(
    'POST',
    `/partial-yaml-schema`,
    { base: getConfig('ci'), ...props }
  )

/**
 * Get step YAML schema
 */
export const getStepYamlSchemaPromise = (
  props: MutateUsingFetchProps<
    ResponseJsonNode,
    Failure | Error,
    GetStepYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseJsonNode,
    Failure | Error,
    GetStepYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >('POST', getConfig('ci'), `/partial-yaml-schema`, props, signal)

export interface GetPartialYamlSchemaWithDetailsQueryParams {
  accountIdentifier: string
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export type GetPartialYamlSchemaWithDetailsProps = Omit<
  GetProps<ResponseYamlSchemaDetailsWrapper, Failure | Error, GetPartialYamlSchemaWithDetailsQueryParams, void>,
  'path'
>

/**
 * Get Partial Yaml Schema with details
 */
export const GetPartialYamlSchemaWithDetails = (props: GetPartialYamlSchemaWithDetailsProps) => (
  <Get<ResponseYamlSchemaDetailsWrapper, Failure | Error, GetPartialYamlSchemaWithDetailsQueryParams, void>
    path={`/partial-yaml-schema/details`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseGetPartialYamlSchemaWithDetailsProps = Omit<
  UseGetProps<ResponseYamlSchemaDetailsWrapper, Failure | Error, GetPartialYamlSchemaWithDetailsQueryParams, void>,
  'path'
>

/**
 * Get Partial Yaml Schema with details
 */
export const useGetPartialYamlSchemaWithDetails = (props: UseGetPartialYamlSchemaWithDetailsProps) =>
  useGet<ResponseYamlSchemaDetailsWrapper, Failure | Error, GetPartialYamlSchemaWithDetailsQueryParams, void>(
    `/partial-yaml-schema/details`,
    { base: getConfig('ci'), ...props }
  )

/**
 * Get Partial Yaml Schema with details
 */
export const getPartialYamlSchemaWithDetailsPromise = (
  props: GetUsingFetchProps<
    ResponseYamlSchemaDetailsWrapper,
    Failure | Error,
    GetPartialYamlSchemaWithDetailsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseYamlSchemaDetailsWrapper, Failure | Error, GetPartialYamlSchemaWithDetailsQueryParams, void>(
    getConfig('ci'),
    `/partial-yaml-schema/details`,
    props,
    signal
  )

export type DummyApiForSwaggerCIPipelineModuleInfoSchemaCheckProps = Omit<
  GetProps<ResponseCIPipelineModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking CIPipelineModuleInfo
 */
export const DummyApiForSwaggerCIPipelineModuleInfoSchemaCheck = (
  props: DummyApiForSwaggerCIPipelineModuleInfoSchemaCheckProps
) => (
  <Get<ResponseCIPipelineModuleInfo, Failure | Error, void, void>
    path={`/partial-yaml-schema/dummyApiForSwaggerCIPipelineModuleInfoSchemaCheck`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseDummyApiForSwaggerCIPipelineModuleInfoSchemaCheckProps = Omit<
  UseGetProps<ResponseCIPipelineModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking CIPipelineModuleInfo
 */
export const useDummyApiForSwaggerCIPipelineModuleInfoSchemaCheck = (
  props: UseDummyApiForSwaggerCIPipelineModuleInfoSchemaCheckProps
) =>
  useGet<ResponseCIPipelineModuleInfo, Failure | Error, void, void>(
    `/partial-yaml-schema/dummyApiForSwaggerCIPipelineModuleInfoSchemaCheck`,
    { base: getConfig('ci'), ...props }
  )

/**
 * dummy api for checking CIPipelineModuleInfo
 */
export const dummyApiForSwaggerCIPipelineModuleInfoSchemaCheckPromise = (
  props: GetUsingFetchProps<ResponseCIPipelineModuleInfo, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCIPipelineModuleInfo, Failure | Error, void, void>(
    getConfig('ci'),
    `/partial-yaml-schema/dummyApiForSwaggerCIPipelineModuleInfoSchemaCheck`,
    props,
    signal
  )

export type DummyApiForSwaggerStageSchemaCheckProps = Omit<
  GetProps<ResponseStageElementConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking integration stage
 */
export const DummyApiForSwaggerStageSchemaCheck = (props: DummyApiForSwaggerStageSchemaCheckProps) => (
  <Get<ResponseStageElementConfig, Failure | Error, void, void>
    path={`/partial-yaml-schema/dummyApiForSwaggerStageSchemaCheck`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseDummyApiForSwaggerStageSchemaCheckProps = Omit<
  UseGetProps<ResponseStageElementConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking integration stage
 */
export const useDummyApiForSwaggerStageSchemaCheck = (props: UseDummyApiForSwaggerStageSchemaCheckProps) =>
  useGet<ResponseStageElementConfig, Failure | Error, void, void>(
    `/partial-yaml-schema/dummyApiForSwaggerStageSchemaCheck`,
    { base: getConfig('ci'), ...props }
  )

/**
 * dummy api for checking integration stage
 */
export const dummyApiForSwaggerStageSchemaCheckPromise = (
  props: GetUsingFetchProps<ResponseStageElementConfig, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseStageElementConfig, Failure | Error, void, void>(
    getConfig('ci'),
    `/partial-yaml-schema/dummyApiForSwaggerStageSchemaCheck`,
    props,
    signal
  )

export type DummyApiForSwaggerStepSchemaCheckProps = Omit<
  GetProps<ResponseStepElementConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking integration stage
 */
export const DummyApiForSwaggerStepSchemaCheck = (props: DummyApiForSwaggerStepSchemaCheckProps) => (
  <Get<ResponseStepElementConfig, Failure | Error, void, void>
    path={`/partial-yaml-schema/dummyApiForSwaggerStepSchemaCheck`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseDummyApiForSwaggerStepSchemaCheckProps = Omit<
  UseGetProps<ResponseStepElementConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking integration stage
 */
export const useDummyApiForSwaggerStepSchemaCheck = (props: UseDummyApiForSwaggerStepSchemaCheckProps) =>
  useGet<ResponseStepElementConfig, Failure | Error, void, void>(
    `/partial-yaml-schema/dummyApiForSwaggerStepSchemaCheck`,
    { base: getConfig('ci'), ...props }
  )

/**
 * dummy api for checking integration stage
 */
export const dummyApiForSwaggerStepSchemaCheckPromise = (
  props: GetUsingFetchProps<ResponseStepElementConfig, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseStepElementConfig, Failure | Error, void, void>(
    getConfig('ci'),
    `/partial-yaml-schema/dummyApiForSwaggerStepSchemaCheck`,
    props,
    signal
  )

export interface GetMergedPartialYamlSchemaQueryParams {
  accountIdentifier: string
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export type GetMergedPartialYamlSchemaProps = Omit<
  MutateProps<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Merged Partial Yaml Schema
 */
export const GetMergedPartialYamlSchema = (props: GetMergedPartialYamlSchemaProps) => (
  <Mutate<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >
    verb="POST"
    path={`/partial-yaml-schema/merged`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseGetMergedPartialYamlSchemaProps = Omit<
  UseMutateProps<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Merged Partial Yaml Schema
 */
export const useGetMergedPartialYamlSchema = (props: UseGetMergedPartialYamlSchemaProps) =>
  useMutate<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >('POST', `/partial-yaml-schema/merged`, { base: getConfig('ci'), ...props })

/**
 * Get Merged Partial Yaml Schema
 */
export const getMergedPartialYamlSchemaPromise = (
  props: MutateUsingFetchProps<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >('POST', getConfig('ci'), `/partial-yaml-schema/merged`, props, signal)

export interface ListPluginsQueryParams {
  pageIndex?: number
  pageSize?: number
  searchTerm?: string
  kind?: string
}

export type ListPluginsProps = Omit<
  GetProps<ResponsePagePluginMetadataResponse, Failure | Error, ListPluginsQueryParams, void>,
  'path'
>

/**
 * List plugins
 */
export const ListPlugins = (props: ListPluginsProps) => (
  <Get<ResponsePagePluginMetadataResponse, Failure | Error, ListPluginsQueryParams, void>
    path={`/v1/plugins`}
    base={getConfig('ci')}
    {...props}
  />
)

export type UseListPluginsProps = Omit<
  UseGetProps<ResponsePagePluginMetadataResponse, Failure | Error, ListPluginsQueryParams, void>,
  'path'
>

/**
 * List plugins
 */
export const useListPlugins = (props: UseListPluginsProps) =>
  useGet<ResponsePagePluginMetadataResponse, Failure | Error, ListPluginsQueryParams, void>(`/v1/plugins`, {
    base: getConfig('ci'),
    ...props
  })

/**
 * List plugins
 */
export const listPluginsPromise = (
  props: GetUsingFetchProps<ResponsePagePluginMetadataResponse, Failure | Error, ListPluginsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePagePluginMetadataResponse, Failure | Error, ListPluginsQueryParams, void>(
    getConfig('ci'),
    `/v1/plugins`,
    props,
    signal
  )
