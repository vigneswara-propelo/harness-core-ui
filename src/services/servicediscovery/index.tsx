/*
 * Copyright 2023 Harness Inc. All rights reserved.
 * Use of this source code is governed by the PolyForm Shield 1.0.0 license
 * that can be found in the licenses directory at the root of this repository, also available at
 * https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt.
 */

/* Generated by restful-react */

import React from 'react'
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'

import { getConfig, getUsingFetch, GetUsingFetchProps, mutateUsingFetch, MutateUsingFetchProps } from '../config'
export const SPEC_VERSION = ''
export interface ApiContainer {
  id?: string
  image?: string
  name?: string
  type?: string
}

export interface ApiContainerVolume {
  containerName?: string
  containerType?: string
  mountPath?: string
  pvcName?: string
  pvcNamespace?: string
  volumeName?: string
}

export interface ApiCreateAgentRequest {
  config?: DatabaseAgentConfiguration
  description?: string
  identity?: string
  k8sConnectorID?: string
  name?: string
  tags?: string[]
}

export interface ApiCreateNetworkMapRequest {
  connections?: DatabaseConnection[]
  description?: string
  identity?: string
  name?: string
  resources?: DatabaseNetworkMapEntity[]
  tags?: string[]
}

export interface ApiCustomServiceConnection {
  destinationID?: string
  destinationIP?: string
  destinationName?: string
  destinationNamespace?: string
  destinationPort?: string
  id?: string
  sourceID?: string
  sourceIP?: string
  sourceName?: string
  sourceNamespace?: string
  type?: string
}

export interface ApiGetAgentResponse {
  accountIdentifier?: string
  config?: DatabaseAgentConfiguration
  createdAt?: string
  createdBy?: string
  description?: string
  id?: string
  identity?: string
  installationDetails?: DatabaseInstallationCollection
  installationType?: DatabaseInstallationType
  k8sConnectorID?: string
  name?: string
  networkMapCount?: number
  organizationIdentifier?: string
  projectIdentifier?: string
  removed?: boolean
  removedAt?: string
  serviceCount?: number
  tags?: string[]
  updatedAt?: string
  updatedBy?: string
}

export interface ApiGetInstallationResponse {
  agentDetails?: DatabaseAgentDetails
  agentID?: string
  createdAt?: string
  createdBy?: string
  delegateID?: string
  delegateTaskID?: string
  delegateTaskStatus?: DatabaseDelegateTaskStatus
  id?: string
  removed?: boolean
  removedAt?: string
  updatedAt?: string
  updatedBy?: string
}

export interface ApiGetK8sCustomService {
  agentID?: string
  createdAt?: string
  createdBy?: string
  id?: string
  kind?: string
  name?: string
  namespace?: string
  removed?: boolean
  removedAt?: string
  service?: DatabaseK8SCustomServiceV1
  uid?: string
  updatedAt?: string
  updatedBy?: string
  workloads?: DatabaseK8SCustomWorkloadV1[]
}

export interface ApiGetNetworkMapResponse {
  agentID?: string
  connections?: DatabaseConnection[]
  createdAt?: string
  createdBy?: string
  description?: string
  id?: string
  identity?: string
  name?: string
  removed?: boolean
  removedAt?: string
  resources?: DatabaseNetworkMapEntity[]
  tags?: string[]
  updatedAt?: string
  updatedBy?: string
}

export interface ApiGetPodResponse {
  agentID?: string
  annotations?: {
    [key: string]: string
  }
  apiVersion?: string
  createdAt?: string
  createdBy?: string
  creationTimestamp?: string
  deletionTimestamp?: string
  id?: string
  kind?: string
  labels?: {
    [key: string]: string
  }
  name?: string
  namespace?: string
  ownerReference?: V1OwnerReference[]
  removed?: boolean
  removedAt?: string
  resourceVersion?: string
  spec?: V1PodSpec
  status?: V1PodStatus
  uid?: string
  updatedAt?: string
  updatedBy?: string
}

export interface ApiGetServiceResponse {
  agentID?: string
  annotations?: {
    [key: string]: string
  }
  apiVersion?: string
  createdAt?: string
  createdBy?: string
  creationTimestamp?: string
  deletionTimestamp?: string
  id?: string
  kind?: string
  labels?: {
    [key: string]: string
  }
  name?: string
  namespace?: string
  ownerReference?: V1OwnerReference[]
  removed?: boolean
  removedAt?: string
  resourceVersion?: string
  spec?: V1ServiceSpec
  status?: V1ServiceStatus
  uid?: string
  updatedAt?: string
  updatedBy?: string
}

export interface ApiListAgentResponse {
  items?: ApiGetAgentResponse[]
  page?: ApiPagination
}

export interface ApiListConnection {
  items?: DatabaseConnectionCollection[]
}

export interface ApiListContainer {
  items?: ApiContainer[]
}

export interface ApiListContainerVolume {
  items?: ApiContainerVolume[]
}

export interface ApiListCronJobResponse {
  items?: DatabaseCronJobCollection[]
  page?: ApiPagination
}

export interface ApiListCustomServiceConnection {
  items?: ApiCustomServiceConnection[]
}

export interface ApiListDaemonSetResponse {
  items?: DatabaseDaemonSetCollection[]
  page?: ApiPagination
}

export interface ApiListDeploymentResponse {
  items?: DatabaseDeploymentCollection[]
  page?: ApiPagination
}

export interface ApiListInstallationResponse {
  items?: DatabaseInstallationCollection[]
  page?: ApiPagination
}

export interface ApiListJobResponse {
  items?: DatabaseJobCollection[]
  page?: ApiPagination
}

export interface ApiListK8sCustomService {
  items?: DatabaseK8SCustomServiceCollection[]
  page?: ApiPagination
}

export interface ApiListNamespaceResponse {
  items?: DatabaseNamespaceCollection[]
  page?: ApiPagination
}

export interface ApiListNetworkMapResponse {
  items?: DatabaseNetworkMapCollection[]
  page?: ApiPagination
}

export interface ApiListNodeResponse {
  items?: DatabaseNodeCollection[]
  page?: ApiPagination
}

export interface ApiListPersistentVolumeClaimResponse {
  items?: DatabasePersistentVolumeClaimCollection[]
  page?: ApiPagination
}

export interface ApiListPersistentVolumeResponse {
  items?: DatabasePersistentVolumeCollection[]
  page?: ApiPagination
}

export interface ApiListPodResponse {
  items?: DatabasePodCollection[]
  page?: ApiPagination
}

export interface ApiListProcess {
  items?: DatabaseProcessCollection[]
}

export interface ApiListReplicaSetResponse {
  items?: DatabaseReplicaSetCollection[]
  page?: ApiPagination
}

export interface ApiListReplicationControllerResponse {
  items?: DatabaseReplicationControllerCollection[]
  page?: ApiPagination
}

export interface ApiListServiceResponse {
  items?: DatabaseServiceCollection[]
  page?: ApiPagination
}

export interface ApiListStatefulSetResponse {
  items?: DatabaseStatefulSetCollection[]
  page?: ApiPagination
}

export interface ApiPagination {
  all?: boolean
  index?: number
  limit?: number
  totalItems?: number
  totalPages?: number
}

export interface ApiUpdateAgentRequest {
  data?: DatabaseDataCollectionConfiguration
  kubernetes?: DatabaseKubernetesAgentConfiguration
}

export interface ApiUpdateNetworkMapRequest {
  connections?: DatabaseConnection[]
  resources?: DatabaseNetworkMapEntity[]
}

export interface DatabaseAgentConfiguration {
  data?: DatabaseDataCollectionConfiguration
  kubernetes?: DatabaseKubernetesAgentConfiguration
}

export interface DatabaseAgentDetails {
  cluster?: DatabaseAgentPodInfo
  node?: DatabaseAgentPodInfo[]
}

export interface DatabaseAgentPodInfo {
  name?: string
  namespace?: string
  status?: V1PodPhase
  uid?: string
}

export interface DatabaseConnection {
  from?: DatabaseNetworkMapEntity
  params?: {
    [key: string]: string
  }
  port?: string
  to?: DatabaseNetworkMapEntity
  type?: string
}

export interface DatabaseConnectionCollection {
  agentID?: string
  createdAt?: string
  createdBy?: string
  destinationIP?: string
  destinationPort?: string
  id?: string
  nodeName?: string
  podUID?: string
  removed?: boolean
  removedAt?: string
  serviceUID?: string
  sourceIP?: string
  type?: string
  updatedAt?: string
  updatedBy?: string
}

export interface DatabaseCronJobCollection {
  agentID?: string
  annotations?: {
    [key: string]: string
  }
  apiVersion?: string
  createdAt?: string
  createdBy?: string
  creationTimestamp?: string
  deletionTimestamp?: string
  id?: string
  kind?: string
  labels?: {
    [key: string]: string
  }
  name?: string
  namespace?: string
  ownerReference?: V1OwnerReference[]
  removed?: boolean
  removedAt?: string
  resourceVersion?: string
  spec?: V1CronJobSpec
  status?: V1CronJobStatus
  uid?: string
  updatedAt?: string
  updatedBy?: string
}

export interface DatabaseDaemonSetCollection {
  agentID?: string
  annotations?: {
    [key: string]: string
  }
  apiVersion?: string
  createdAt?: string
  createdBy?: string
  creationTimestamp?: string
  deletionTimestamp?: string
  id?: string
  kind?: string
  labels?: {
    [key: string]: string
  }
  name?: string
  namespace?: string
  ownerReference?: V1OwnerReference[]
  removed?: boolean
  removedAt?: string
  resourceVersion?: string
  spec?: V1DaemonSetSpec
  status?: V1DaemonSetStatus
  uid?: string
  updatedAt?: string
  updatedBy?: string
}

export interface DatabaseDataCollectionConfiguration {
  batchSize?: number
  blacklistedNamespaces?: string[]
  collectionWindowInMin?: number
  enableBatchResources?: boolean
  enableNodeAgent?: boolean
  enableStorageResources?: boolean
  nodeAgentSelector?: string
  retryCount?: number
  retryInSecond?: number
}

export type DatabaseDelegateTaskStatus = 'SUCCESS' | 'FAILED' | 'ERROR' | 'PROCESSED'

export interface DatabaseDeploymentCollection {
  agentID?: string
  annotations?: {
    [key: string]: string
  }
  apiVersion?: string
  createdAt?: string
  createdBy?: string
  creationTimestamp?: string
  deletionTimestamp?: string
  id?: string
  kind?: string
  labels?: {
    [key: string]: string
  }
  name?: string
  namespace?: string
  ownerReference?: V1OwnerReference[]
  removed?: boolean
  removedAt?: string
  resourceVersion?: string
  spec?: V1DeploymentSpec
  status?: V1DeploymentStatus
  uid?: string
  updatedAt?: string
  updatedBy?: string
}

export interface DatabaseInstallationCollection {
  agentDetails?: DatabaseAgentDetails
  agentID?: string
  createdAt?: string
  createdBy?: string
  delegateID?: string
  delegateTaskID?: string
  delegateTaskStatus?: DatabaseDelegateTaskStatus
  id?: string
  removed?: boolean
  removedAt?: string
  updatedAt?: string
  updatedBy?: string
}

export type DatabaseInstallationType = 'CONNECTOR'

export interface DatabaseJobCollection {
  agentID?: string
  annotations?: {
    [key: string]: string
  }
  apiVersion?: string
  createdAt?: string
  createdBy?: string
  creationTimestamp?: string
  deletionTimestamp?: string
  id?: string
  kind?: string
  labels?: {
    [key: string]: string
  }
  name?: string
  namespace?: string
  ownerReference?: V1OwnerReference[]
  removed?: boolean
  removedAt?: string
  resourceVersion?: string
  spec?: V1JobSpec
  status?: V1JobStatus
  uid?: string
  updatedAt?: string
  updatedBy?: string
}

export interface DatabaseK8SCustomServiceCollection {
  agentID?: string
  createdAt?: string
  createdBy?: string
  id?: string
  kind?: string
  name?: string
  namespace?: string
  removed?: boolean
  removedAt?: string
  service?: DatabaseK8SCustomServiceV1
  uid?: string
  updatedAt?: string
  updatedBy?: string
  workloads?: DatabaseK8SCustomWorkloadV1[]
}

export interface DatabaseK8SCustomServiceV1 {
  annotations?: {
    [key: string]: string
  }
  clusterIP?: string
  clusterIPs?: string[]
  externalIPs?: string[]
  externalName?: string
  labels?: {
    [key: string]: string
  }
  loadBalancerIP?: string
  owner?: V1ObjectReference
  ports?: V1ServicePort[]
  type?: V1ServiceType
}

export interface DatabaseK8SCustomWorkloadV1 {
  owner?: V1ObjectReference
  podAnnotations?: {
    [key: string]: string
  }
  podLabels?: {
    [key: string]: string
  }
  replicas?: DatabaseReplicaV1[]
}

export interface DatabaseKubernetesAgentConfiguration {
  affinity?: V1Affinity
  imagePullPolicy?: V1PullPolicy
  imagePullSecrets?: V1LocalObjectReference[]
  imageRegistry?: string
  imageTag?: string
  namespace?: string
  namespaced?: boolean
  podSecurityContext?: V1PodSecurityContext
  resources?: V1ResourceRequirements
  serviceAccount?: string
  toleration?: V1Toleration[]
}

export interface DatabaseNamespaceCollection {
  agentID?: string
  annotations?: {
    [key: string]: string
  }
  apiVersion?: string
  createdAt?: string
  createdBy?: string
  creationTimestamp?: string
  deletionTimestamp?: string
  id?: string
  kind?: string
  labels?: {
    [key: string]: string
  }
  name?: string
  ownerReference?: V1OwnerReference[]
  removed?: boolean
  removedAt?: string
  resourceVersion?: string
  spec?: V1NamespaceSpec
  status?: V1NamespaceStatus
  uid?: string
  updatedAt?: string
  updatedBy?: string
}

export interface DatabaseNetworkMapCollection {
  agentID?: string
  connections?: DatabaseConnection[]
  createdAt?: string
  createdBy?: string
  description?: string
  id?: string
  identity?: string
  name?: string
  removed?: boolean
  removedAt?: string
  resources?: DatabaseNetworkMapEntity[]
  tags?: string[]
  updatedAt?: string
  updatedBy?: string
}

export interface DatabaseNetworkMapEntity {
  id?: string
  kind?: string
}

export interface DatabaseNodeCollection {
  agentID?: string
  annotations?: {
    [key: string]: string
  }
  apiVersion?: string
  createdAt?: string
  createdBy?: string
  creationTimestamp?: string
  deletionTimestamp?: string
  id?: string
  kind?: string
  labels?: {
    [key: string]: string
  }
  name?: string
  ownerReference?: V1OwnerReference[]
  removed?: boolean
  removedAt?: string
  resourceVersion?: string
  spec?: V1NodeSpec
  status?: V1NodeStatus
  uid?: string
  updatedAt?: string
  updatedBy?: string
}

export interface DatabasePersistentVolumeClaimCollection {
  agentID?: string
  annotations?: {
    [key: string]: string
  }
  apiVersion?: string
  createdAt?: string
  createdBy?: string
  creationTimestamp?: string
  deletionTimestamp?: string
  id?: string
  kind?: string
  labels?: {
    [key: string]: string
  }
  name?: string
  namespace?: string
  ownerReference?: V1OwnerReference[]
  removed?: boolean
  removedAt?: string
  resourceVersion?: string
  spec?: V1PersistentVolumeClaimSpec
  status?: V1PersistentVolumeClaimStatus
  uid?: string
  updatedAt?: string
  updatedBy?: string
}

export interface DatabasePersistentVolumeCollection {
  agentID?: string
  annotations?: {
    [key: string]: string
  }
  apiVersion?: string
  createdAt?: string
  createdBy?: string
  creationTimestamp?: string
  deletionTimestamp?: string
  id?: string
  kind?: string
  labels?: {
    [key: string]: string
  }
  name?: string
  ownerReference?: V1OwnerReference[]
  removed?: boolean
  removedAt?: string
  resourceVersion?: string
  spec?: V1PersistentVolumeSpec
  status?: V1PersistentVolumeStatus
  uid?: string
  updatedAt?: string
  updatedBy?: string
}

export interface DatabasePodCollection {
  agentID?: string
  annotations?: {
    [key: string]: string
  }
  apiVersion?: string
  createdAt?: string
  createdBy?: string
  creationTimestamp?: string
  deletionTimestamp?: string
  id?: string
  kind?: string
  labels?: {
    [key: string]: string
  }
  name?: string
  namespace?: string
  ownerReference?: V1OwnerReference[]
  removed?: boolean
  removedAt?: string
  resourceVersion?: string
  spec?: V1PodSpec
  status?: V1PodStatus
  uid?: string
  updatedAt?: string
  updatedBy?: string
}

export interface DatabaseProcessCollection {
  agentID?: string
  cmd?: string
  containerID?: string
  createdAt?: string
  createdBy?: string
  id?: string
  nodeName?: string
  pid?: number
  podUID?: string
  removed?: boolean
  removedAt?: string
  updatedAt?: string
  updatedBy?: string
}

export interface DatabaseReplicaSetCollection {
  agentID?: string
  annotations?: {
    [key: string]: string
  }
  apiVersion?: string
  createdAt?: string
  createdBy?: string
  creationTimestamp?: string
  deletionTimestamp?: string
  id?: string
  kind?: string
  labels?: {
    [key: string]: string
  }
  name?: string
  namespace?: string
  ownerReference?: V1OwnerReference[]
  removed?: boolean
  removedAt?: string
  resourceVersion?: string
  spec?: V1ReplicaSetSpec
  status?: V1ReplicaSetStatus
  uid?: string
  updatedAt?: string
  updatedBy?: string
}

export interface DatabaseReplicaV1 {
  phase?: V1PodPhase
  pod?: V1ObjectReference
}

export interface DatabaseReplicationControllerCollection {
  agentID?: string
  annotations?: {
    [key: string]: string
  }
  apiVersion?: string
  createdAt?: string
  createdBy?: string
  creationTimestamp?: string
  deletionTimestamp?: string
  id?: string
  kind?: string
  labels?: {
    [key: string]: string
  }
  name?: string
  namespace?: string
  ownerReference?: V1OwnerReference[]
  removed?: boolean
  removedAt?: string
  resourceVersion?: string
  spec?: V1ReplicationControllerSpec
  status?: V1ReplicationControllerStatus
  uid?: string
  updatedAt?: string
  updatedBy?: string
}

export interface DatabaseServiceCollection {
  agentID?: string
  annotations?: {
    [key: string]: string
  }
  apiVersion?: string
  createdAt?: string
  createdBy?: string
  creationTimestamp?: string
  deletionTimestamp?: string
  id?: string
  kind?: string
  labels?: {
    [key: string]: string
  }
  name?: string
  namespace?: string
  ownerReference?: V1OwnerReference[]
  removed?: boolean
  removedAt?: string
  resourceVersion?: string
  spec?: V1ServiceSpec
  status?: V1ServiceStatus
  uid?: string
  updatedAt?: string
  updatedBy?: string
}

export interface DatabaseStatefulSetCollection {
  agentID?: string
  annotations?: {
    [key: string]: string
  }
  apiVersion?: string
  createdAt?: string
  createdBy?: string
  creationTimestamp?: string
  deletionTimestamp?: string
  id?: string
  kind?: string
  labels?: {
    [key: string]: string
  }
  name?: string
  namespace?: string
  ownerReference?: V1OwnerReference[]
  removed?: boolean
  removedAt?: string
  resourceVersion?: string
  spec?: V1StatefulSetSpec
  status?: V1StatefulSetStatus
  uid?: string
  updatedAt?: string
  updatedBy?: string
}

export interface GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiEmpty {
  [key: string]: any
}

export interface GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError {
  description?: string
  message?: string
}

export interface IntstrIntOrString {
  intVal?: number
  strVal?: string
  type?: IntstrType
}

export type IntstrType = number

export type K8sIoApiCoreV1ConditionStatus = 'True' | 'False' | 'Unknown'

export type K8sIoApimachineryPkgApisMetaV1ConditionStatus = 'True' | 'False' | 'Unknown'

export interface ResourceQuantity {
  Format?: string
}

export interface V1AWSElasticBlockStoreVolumeSource {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   */
  fsType?: string
  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * +optional
   */
  partition?: number
  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * +optional
   */
  readOnly?: boolean
  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   */
  volumeID?: string
}

export interface V1Affinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   * +optional
   */
  nodeAffinity?: V1NodeAffinity
  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   * +optional
   */
  podAffinity?: V1PodAffinity
  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   * +optional
   */
  podAntiAffinity?: V1PodAntiAffinity
}

export interface V1AttachedVolume {
  /**
   * DevicePath represents the device path where the volume should be available
   */
  devicePath?: string
  /**
   * Name of the attached volume
   */
  name?: string
}

export type V1AzureDataDiskCachingMode = 'None' | 'ReadOnly' | 'ReadWrite'

export type V1AzureDataDiskKind = 'Shared' | 'Dedicated' | 'Managed'

export interface V1AzureDiskVolumeSource {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   * +optional
   */
  cachingMode?: V1AzureDataDiskCachingMode
  /**
   * diskName is the Name of the data disk in the blob storage
   */
  diskName?: string
  /**
   * diskURI is the URI of data disk in the blob storage
   */
  diskURI?: string
  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * +optional
   */
  fsType?: string
  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   */
  kind?: V1AzureDataDiskKind
  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   */
  readOnly?: boolean
}

export interface V1AzureFilePersistentVolumeSource {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   */
  readOnly?: boolean
  /**
   * secretName is the name of secret that contains Azure Storage Account Name and Key
   */
  secretName?: string
  /**
   * secretNamespace is the namespace of the secret that contains Azure Storage Account Name and Key
   * default is the same as the Pod
   * +optional
   */
  secretNamespace?: string
  /**
   * shareName is the azure Share Name
   */
  shareName?: string
}

export interface V1AzureFileVolumeSource {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   */
  readOnly?: boolean
  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   */
  secretName?: string
  /**
   * shareName is the azure share Name
   */
  shareName?: string
}

export interface V1CSIPersistentVolumeSource {
  /**
   * controllerExpandSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * ControllerExpandVolume call.
   * This is an beta field and requires enabling ExpandCSIVolumes feature gate.
   * This field is optional, and may be empty if no secret is required. If the
   * secret object contains more than one secret, all secrets are passed.
   * +optional
   */
  controllerExpandSecretRef?: V1SecretReference
  /**
   * controllerPublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * ControllerPublishVolume and ControllerUnpublishVolume calls.
   * This field is optional, and may be empty if no secret is required. If the
   * secret object contains more than one secret, all secrets are passed.
   * +optional
   */
  controllerPublishSecretRef?: V1SecretReference
  /**
   * driver is the name of the driver to use for this volume.
   * Required.
   */
  driver?: string
  /**
   * fsType to mount. Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * +optional
   */
  fsType?: string
  /**
   * nodeExpandSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodeExpandVolume call.
   * This is an alpha field and requires enabling CSINodeExpandSecret feature gate.
   * This field is optional, may be omitted if no secret is required. If the
   * secret object contains more than one secret, all secrets are passed.
   * +optional
   */
  nodeExpandSecretRef?: V1SecretReference
  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and may be empty if no secret is required. If the
   * secret object contains more than one secret, all secrets are passed.
   * +optional
   */
  nodePublishSecretRef?: V1SecretReference
  /**
   * nodeStageSecretRef is a reference to the secret object containing sensitive
   * information to pass to the CSI driver to complete the CSI NodeStageVolume
   * and NodeStageVolume and NodeUnstageVolume calls.
   * This field is optional, and may be empty if no secret is required. If the
   * secret object contains more than one secret, all secrets are passed.
   * +optional
   */
  nodeStageSecretRef?: V1SecretReference
  /**
   * readOnly value to pass to ControllerPublishVolumeRequest.
   * Defaults to false (read/write).
   * +optional
   */
  readOnly?: boolean
  /**
   * volumeAttributes of the volume to publish.
   * +optional
   */
  volumeAttributes?: {
    [key: string]: string
  }
  /**
   * volumeHandle is the unique volume name returned by the CSI volume
   * pluginâ€™s CreateVolume to refer to the volume on all subsequent calls.
   * Required.
   */
  volumeHandle?: string
}

export interface V1CSIVolumeSource {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   */
  driver?: string
  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   * +optional
   */
  fsType?: string
  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   * +optional
   */
  nodePublishSecretRef?: V1LocalObjectReference
  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   * +optional
   */
  readOnly?: boolean
  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   * +optional
   */
  volumeAttributes?: {
    [key: string]: string
  }
}

export interface V1Capabilities {
  /**
   * Added capabilities
   * +optional
   */
  add?: string[]
  /**
   * Removed capabilities
   * +optional
   */
  drop?: string[]
}

export interface V1CephFSPersistentVolumeSource {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   */
  monitors?: string[]
  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   * +optional
   */
  path?: string
  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   */
  readOnly?: boolean
  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   */
  secretFile?: string
  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   */
  secretRef?: V1SecretReference
  /**
   * user is Optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   */
  user?: string
}

export interface V1CephFSVolumeSource {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   */
  monitors?: string[]
  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   * +optional
   */
  path?: string
  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   */
  readOnly?: boolean
  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   */
  secretFile?: string
  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   */
  secretRef?: V1LocalObjectReference
  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   */
  user?: string
}

export interface V1CinderPersistentVolumeSource {
  /**
   * fsType Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   */
  fsType?: string
  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   */
  readOnly?: boolean
  /**
   * secretRef is Optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   * +optional
   */
  secretRef?: V1SecretReference
  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   */
  volumeID?: string
}

export interface V1CinderVolumeSource {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   */
  fsType?: string
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   */
  readOnly?: boolean
  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   * +optional
   */
  secretRef?: V1LocalObjectReference
  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   */
  volumeID?: string
}

export interface V1ClientIPConfig {
  /**
   * timeoutSeconds specifies the seconds of ClientIP type session sticky time.
   * The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
   * Default value is 10800(for 3 hours).
   * +optional
   */
  timeoutSeconds?: number
}

export type V1CompletionMode = 'NonIndexed' | 'Indexed'

export type V1ConcurrencyPolicy = 'Allow' | 'Forbid' | 'Replace'

export interface V1Condition {
  /**
   * lastTransitionTime is the last time the condition transitioned from one status to another.
   * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
   * +required
   * +kubebuilder:validation:Required
   * +kubebuilder:validation:Type=string
   * +kubebuilder:validation:Format=date-time
   */
  lastTransitionTime?: string
  /**
   * message is a human readable message indicating details about the transition.
   * This may be an empty string.
   * +required
   * +kubebuilder:validation:Required
   * +kubebuilder:validation:MaxLength=32768
   */
  message?: string
  /**
   * observedGeneration represents the .metadata.generation that the condition was set based upon.
   * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
   * with respect to the current state of the instance.
   * +optional
   * +kubebuilder:validation:Minimum=0
   */
  observedGeneration?: number
  /**
   * reason contains a programmatic identifier indicating the reason for the condition's last transition.
   * Producers of specific condition types may define expected values and meanings for this field,
   * and whether the values are considered a guaranteed API.
   * The value should be a CamelCase string.
   * This field may not be empty.
   * +required
   * +kubebuilder:validation:Required
   * +kubebuilder:validation:MaxLength=1024
   * +kubebuilder:validation:MinLength=1
   * +kubebuilder:validation:Pattern=`^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$`
   */
  reason?: string
  /**
   * status of the condition, one of True, False, Unknown.
   * +required
   * +kubebuilder:validation:Required
   * +kubebuilder:validation:Enum=True;False;Unknown
   */
  status?: K8sIoApimachineryPkgApisMetaV1ConditionStatus
  /**
   * type of condition in CamelCase or in foo.example.com/CamelCase.
   * ---
   * Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
   * useful (see .node.status.conditions), the ability to deconflict is important.
   * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
   * +required
   * +kubebuilder:validation:Required
   * +kubebuilder:validation:MaxLength=316
   */
  type?: string
}

export interface V1ConfigMapEnvSource {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * +optional
   */
  name?: string
  /**
   * Specify whether the ConfigMap must be defined
   * +optional
   */
  optional?: boolean
}

export interface V1ConfigMapKeySelector {
  /**
   * The key to select.
   */
  key?: string
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * +optional
   */
  name?: string
  /**
   * Specify whether the ConfigMap or its key must be defined
   * +optional
   */
  optional?: boolean
}

export interface V1ConfigMapNodeConfigSource {
  /**
   * KubeletConfigKey declares which key of the referenced ConfigMap corresponds to the KubeletConfiguration structure
   * This field is required in all cases.
   */
  kubeletConfigKey?: string
  /**
   * Name is the metadata.name of the referenced ConfigMap.
   * This field is required in all cases.
   */
  name?: string
  /**
   * Namespace is the metadata.namespace of the referenced ConfigMap.
   * This field is required in all cases.
   */
  namespace?: string
  /**
   * ResourceVersion is the metadata.ResourceVersion of the referenced ConfigMap.
   * This field is forbidden in Node.Spec, and required in Node.Status.
   * +optional
   */
  resourceVersion?: string
  /**
   * UID is the metadata.UID of the referenced ConfigMap.
   * This field is forbidden in Node.Spec, and required in Node.Status.
   * +optional
   */
  uid?: string
}

export interface V1ConfigMapProjection {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   * +optional
   */
  items?: V1KeyToPath[]
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * +optional
   */
  name?: string
  /**
   * optional specify whether the ConfigMap or its keys must be defined
   * +optional
   */
  optional?: boolean
}

export interface V1ConfigMapVolumeSource {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   */
  defaultMode?: number
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   * +optional
   */
  items?: V1KeyToPath[]
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * +optional
   */
  name?: string
  /**
   * optional specify whether the ConfigMap or its keys must be defined
   * +optional
   */
  optional?: boolean
}

export interface V1Container {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   * +optional
   */
  args?: string[]
  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   * +optional
   */
  command?: string[]
  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge
   */
  env?: V1EnvVar[]
  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   * +optional
   */
  envFrom?: V1EnvFromSource[]
  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   * +optional
   */
  image?: string
  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * +optional
   */
  imagePullPolicy?: V1PullPolicy
  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   * +optional
   */
  lifecycle?: V1Lifecycle
  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * +optional
   */
  livenessProbe?: V1Probe
  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   */
  name?: string
  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   * +optional
   * +patchMergeKey=containerPort
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=containerPort
   * +listMapKey=protocol
   */
  ports?: V1ContainerPort[]
  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * +optional
   */
  readinessProbe?: V1Probe
  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * +optional
   */
  resources?: V1ResourceRequirements
  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   * +optional
   */
  securityContext?: V1SecurityContext
  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * +optional
   */
  startupProbe?: V1Probe
  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   * +optional
   */
  stdin?: boolean
  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   * +optional
   */
  stdinOnce?: boolean
  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   * +optional
   */
  terminationMessagePath?: string
  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   * +optional
   */
  terminationMessagePolicy?: V1TerminationMessagePolicy
  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   * +optional
   */
  tty?: boolean
  /**
   * volumeDevices is the list of block devices to be used by the container.
   * +patchMergeKey=devicePath
   * +patchStrategy=merge
   * +optional
   */
  volumeDevices?: V1VolumeDevice[]
  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   * +optional
   * +patchMergeKey=mountPath
   * +patchStrategy=merge
   */
  volumeMounts?: V1VolumeMount[]
  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   * +optional
   */
  workingDir?: string
}

export interface V1ContainerImage {
  /**
   * Names by which this image is known.
   * e.g. ["kubernetes.example/hyperkube:v1.0.7", "cloud-vendor.registry.example/cloud-vendor/hyperkube:v1.0.7"]
   * +optional
   */
  names?: string[]
  /**
   * The size of the image in bytes.
   * +optional
   */
  sizeBytes?: number
}

export interface V1ContainerPort {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   */
  containerPort?: number
  /**
   * What host IP to bind the external port to.
   * +optional
   */
  hostIP?: string
  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   * +optional
   */
  hostPort?: number
  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   * +optional
   */
  name?: string
  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   * +optional
   * +default="TCP"
   */
  protocol?: V1Protocol
}

export interface V1ContainerState {
  /**
   * Details about a running container
   * +optional
   */
  running?: V1ContainerStateRunning
  /**
   * Details about a terminated container
   * +optional
   */
  terminated?: V1ContainerStateTerminated
  /**
   * Details about a waiting container
   * +optional
   */
  waiting?: V1ContainerStateWaiting
}

export interface V1ContainerStateRunning {
  /**
   * Time at which the container was last (re-)started
   * +optional
   */
  startedAt?: string
}

export interface V1ContainerStateTerminated {
  /**
   * Container's ID in the format '<type>://<container_id>'
   * +optional
   */
  containerID?: string
  /**
   * Exit status from the last termination of the container
   */
  exitCode?: number
  /**
   * Time at which the container last terminated
   * +optional
   */
  finishedAt?: string
  /**
   * Message regarding the last termination of the container
   * +optional
   */
  message?: string
  /**
   * (brief) reason from the last termination of the container
   * +optional
   */
  reason?: string
  /**
   * Signal from the last termination of the container
   * +optional
   */
  signal?: number
  /**
   * Time at which previous execution of the container started
   * +optional
   */
  startedAt?: string
}

export interface V1ContainerStateWaiting {
  /**
   * Message regarding why the container is not yet running.
   * +optional
   */
  message?: string
  /**
   * (brief) reason the container is not yet running.
   * +optional
   */
  reason?: string
}

export interface V1ContainerStatus {
  /**
   * Container's ID in the format '<type>://<container_id>'.
   * +optional
   */
  containerID?: string
  /**
   * The image the container is running.
   * More info: https://kubernetes.io/docs/concepts/containers/images.
   */
  image?: string
  /**
   * ImageID of the container's image.
   */
  imageID?: string
  /**
   * Details about the container's last termination condition.
   * +optional
   */
  lastState?: V1ContainerState
  /**
   * This must be a DNS_LABEL. Each container in a pod must have a unique name.
   * Cannot be updated.
   */
  name?: string
  /**
   * Specifies whether the container has passed its readiness probe.
   */
  ready?: boolean
  /**
   * The number of times the container has been restarted.
   */
  restartCount?: number
  /**
   * Specifies whether the container has passed its startup probe.
   * Initialized as false, becomes true after startupProbe is considered successful.
   * Resets to false when the container is restarted, or if kubelet loses state temporarily.
   * Is always true when no startupProbe is defined.
   * +optional
   */
  started?: boolean
  /**
   * Details about the container's current condition.
   * +optional
   */
  state?: V1ContainerState
}

export interface V1CronJobSpec {
  /**
   * Specifies how to treat concurrent executions of a Job.
   * Valid values are:
   * - "Allow" (default): allows CronJobs to run concurrently;
   * - "Forbid": forbids concurrent runs, skipping next run if previous run hasn't finished yet;
   * - "Replace": cancels currently running job and replaces it with a new one
   * +optional
   */
  concurrencyPolicy?: V1ConcurrencyPolicy
  /**
   * The number of failed finished jobs to retain. Value must be non-negative integer.
   * Defaults to 1.
   * +optional
   */
  failedJobsHistoryLimit?: number
  /**
   * Specifies the job that will be created when executing a CronJob.
   */
  jobTemplate?: V1JobTemplateSpec
  /**
   * The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
   */
  schedule?: string
  /**
   * Optional deadline in seconds for starting the job if it misses scheduled
   * time for any reason.  Missed jobs executions will be counted as failed ones.
   * +optional
   */
  startingDeadlineSeconds?: number
  /**
   * The number of successful finished jobs to retain. Value must be non-negative integer.
   * Defaults to 3.
   * +optional
   */
  successfulJobsHistoryLimit?: number
  /**
   * This flag tells the controller to suspend subsequent executions, it does
   * not apply to already started executions.  Defaults to false.
   * +optional
   */
  suspend?: boolean
  /**
   * The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
   * If not specified, this will default to the time zone of the kube-controller-manager process.
   * The set of valid time zone names and the time zone offset is loaded from the system-wide time zone
   * database by the API server during CronJob validation and the controller manager during execution.
   * If no system-wide time zone database can be found a bundled version of the database is used instead.
   * If the time zone name becomes invalid during the lifetime of a CronJob or due to a change in host
   * configuration, the controller will stop creating new new Jobs and will create a system event with the
   * reason UnknownTimeZone.
   * More information can be found in https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#time-zones
   * This is beta field and must be enabled via the `CronJobTimeZone` feature gate.
   * +optional
   */
  timeZone?: string
}

export interface V1CronJobStatus {
  /**
   * A list of pointers to currently running jobs.
   * +optional
   * +listType=atomic
   */
  active?: V1ObjectReference[]
  /**
   * Information when was the last time the job was successfully scheduled.
   * +optional
   */
  lastScheduleTime?: string
  /**
   * Information when was the last time the job successfully completed.
   * +optional
   */
  lastSuccessfulTime?: string
}

export type V1DNSPolicy = 'ClusterFirstWithHostNet' | 'ClusterFirst' | 'Default' | 'None'

export interface V1DaemonEndpoint {
  /**
   * Port number of the given endpoint.
   */
  Port?: number
}

export interface V1DaemonSetCondition {
  /**
   * Last time the condition transitioned from one status to another.
   * +optional
   */
  lastTransitionTime?: string
  /**
   * A human readable message indicating details about the transition.
   * +optional
   */
  message?: string
  /**
   * The reason for the condition's last transition.
   * +optional
   */
  reason?: string
  /**
   * Status of the condition, one of True, False, Unknown.
   */
  status?: K8sIoApiCoreV1ConditionStatus
  /**
   * Type of DaemonSet condition.
   */
  type?: string
}

export interface V1DaemonSetSpec {
  /**
   * The minimum number of seconds for which a newly created DaemonSet pod should
   * be ready without any of its container crashing, for it to be considered
   * available. Defaults to 0 (pod will be considered available as soon as it
   * is ready).
   * +optional
   */
  minReadySeconds?: number
  /**
   * The number of old history to retain to allow rollback.
   * This is a pointer to distinguish between explicit zero and not specified.
   * Defaults to 10.
   * +optional
   */
  revisionHistoryLimit?: number
  /**
   * A label query over pods that are managed by the daemon set.
   * Must match in order to be controlled.
   * It must match the pod template's labels.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
   */
  selector?: V1LabelSelector
  /**
   * An object that describes the pod that will be created.
   * The DaemonSet will create exactly one copy of this pod on every node
   * that matches the template's node selector (or on every node if no node
   * selector is specified).
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
   */
  template?: V1PodTemplateSpec
  /**
   * An update strategy to replace existing DaemonSet pods with new pods.
   * +optional
   */
  updateStrategy?: V1DaemonSetUpdateStrategy
}

export interface V1DaemonSetStatus {
  /**
   * Count of hash collisions for the DaemonSet. The DaemonSet controller
   * uses this field as a collision avoidance mechanism when it needs to
   * create the name for the newest ControllerRevision.
   * +optional
   */
  collisionCount?: number
  /**
   * Represents the latest available observations of a DaemonSet's current state.
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   */
  conditions?: V1DaemonSetCondition[]
  /**
   * The number of nodes that are running at least 1
   * daemon pod and are supposed to run the daemon pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
   */
  currentNumberScheduled?: number
  /**
   * The total number of nodes that should be running the daemon
   * pod (including nodes correctly running the daemon pod).
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
   */
  desiredNumberScheduled?: number
  /**
   * The number of nodes that should be running the
   * daemon pod and have one or more of the daemon pod running and
   * available (ready for at least spec.minReadySeconds)
   * +optional
   */
  numberAvailable?: number
  /**
   * The number of nodes that are running the daemon pod, but are
   * not supposed to run the daemon pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
   */
  numberMisscheduled?: number
  /**
   * numberReady is the number of nodes that should be running the daemon pod and have one
   * or more of the daemon pod running with a Ready Condition.
   */
  numberReady?: number
  /**
   * The number of nodes that should be running the
   * daemon pod and have none of the daemon pod running and available
   * (ready for at least spec.minReadySeconds)
   * +optional
   */
  numberUnavailable?: number
  /**
   * The most recent generation observed by the daemon set controller.
   * +optional
   */
  observedGeneration?: number
  /**
   * The total number of nodes that are running updated daemon pod
   * +optional
   */
  updatedNumberScheduled?: number
}

export interface V1DaemonSetUpdateStrategy {
  /**
   * Rolling update config params. Present only if type = "RollingUpdate".
   * ---
   * TODO: Update this to follow our convention for oneOf, whatever we decide it
   * to be. Same as Deployment `strategy.rollingUpdate`.
   * See https://github.com/kubernetes/kubernetes/issues/35345
   * +optional
   */
  rollingUpdate?: V1RollingUpdateDaemonSet
  /**
   * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
   * +optional
   */
  type?: V1DaemonSetUpdateStrategyType
}

export type V1DaemonSetUpdateStrategyType = 'RollingUpdate' | 'OnDelete'

export interface V1DeploymentCondition {
  /**
   * Last time the condition transitioned from one status to another.
   */
  lastTransitionTime?: string
  /**
   * The last time this condition was updated.
   */
  lastUpdateTime?: string
  /**
   * A human readable message indicating details about the transition.
   */
  message?: string
  /**
   * The reason for the condition's last transition.
   */
  reason?: string
  /**
   * Status of the condition, one of True, False, Unknown.
   */
  status?: K8sIoApiCoreV1ConditionStatus
  /**
   * Type of deployment condition.
   */
  type?: V1DeploymentConditionType
}

export type V1DeploymentConditionType = 'Available' | 'Progressing' | 'ReplicaFailure'

export interface V1DeploymentSpec {
  /**
   * Minimum number of seconds for which a newly created pod should be ready
   * without any of its container crashing, for it to be considered available.
   * Defaults to 0 (pod will be considered available as soon as it is ready)
   * +optional
   */
  minReadySeconds?: number
  /**
   * Indicates that the deployment is paused.
   * +optional
   */
  paused?: boolean
  /**
   * The maximum time in seconds for a deployment to make progress before it
   * is considered to be failed. The deployment controller will continue to
   * process failed deployments and a condition with a ProgressDeadlineExceeded
   * reason will be surfaced in the deployment status. Note that progress will
   * not be estimated during the time a deployment is paused. Defaults to 600s.
   */
  progressDeadlineSeconds?: number
  /**
   * Number of desired pods. This is a pointer to distinguish between explicit
   * zero and not specified. Defaults to 1.
   * +optional
   */
  replicas?: number
  /**
   * The number of old ReplicaSets to retain to allow rollback.
   * This is a pointer to distinguish between explicit zero and not specified.
   * Defaults to 10.
   * +optional
   */
  revisionHistoryLimit?: number
  /**
   * Label selector for pods. Existing ReplicaSets whose pods are
   * selected by this will be the ones affected by this deployment.
   * It must match the pod template's labels.
   */
  selector?: V1LabelSelector
  /**
   * The deployment strategy to use to replace existing pods with new ones.
   * +optional
   * +patchStrategy=retainKeys
   */
  strategy?: V1DeploymentStrategy
  /**
   * Template describes the pods that will be created.
   */
  template?: V1PodTemplateSpec
}

export interface V1DeploymentStatus {
  /**
   * Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
   * +optional
   */
  availableReplicas?: number
  /**
   * Count of hash collisions for the Deployment. The Deployment controller uses this
   * field as a collision avoidance mechanism when it needs to create the name for the
   * newest ReplicaSet.
   * +optional
   */
  collisionCount?: number
  /**
   * Represents the latest available observations of a deployment's current state.
   * +patchMergeKey=type
   * +patchStrategy=merge
   */
  conditions?: V1DeploymentCondition[]
  /**
   * The generation observed by the deployment controller.
   * +optional
   */
  observedGeneration?: number
  /**
   * readyReplicas is the number of pods targeted by this Deployment with a Ready Condition.
   * +optional
   */
  readyReplicas?: number
  /**
   * Total number of non-terminated pods targeted by this deployment (their labels match the selector).
   * +optional
   */
  replicas?: number
  /**
   * Total number of unavailable pods targeted by this deployment. This is the total number of
   * pods that are still required for the deployment to have 100% available capacity. They may
   * either be pods that are running but not yet available or pods that still have not been created.
   * +optional
   */
  unavailableReplicas?: number
  /**
   * Total number of non-terminated pods targeted by this deployment that have the desired template spec.
   * +optional
   */
  updatedReplicas?: number
}

export interface V1DeploymentStrategy {
  /**
   * Rolling update config params. Present only if DeploymentStrategyType =
   * RollingUpdate.
   * ---
   * TODO: Update this to follow our convention for oneOf, whatever we decide it
   * to be.
   * +optional
   */
  rollingUpdate?: V1RollingUpdateDeployment
  /**
   * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
   * +optional
   */
  type?: V1DeploymentStrategyType
}

export type V1DeploymentStrategyType = 'Recreate' | 'RollingUpdate'

export interface V1DownwardAPIProjection {
  /**
   * Items is a list of DownwardAPIVolume file
   * +optional
   */
  items?: V1DownwardAPIVolumeFile[]
}

export interface V1DownwardAPIVolumeFile {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   * +optional
   */
  fieldRef?: V1ObjectFieldSelector
  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   */
  mode?: number
  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   */
  path?: string
  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   * +optional
   */
  resourceFieldRef?: V1ResourceFieldSelector
}

export interface V1DownwardAPIVolumeSource {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   */
  defaultMode?: number
  /**
   * Items is a list of downward API volume file
   * +optional
   */
  items?: V1DownwardAPIVolumeFile[]
}

export interface V1EmptyDirVolumeSource {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   * +optional
   */
  medium?: V1StorageMedium
  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
   * +optional
   */
  sizeLimit?: ResourceQuantity
}

export interface V1EnvFromSource {
  /**
   * The ConfigMap to select from
   * +optional
   */
  configMapRef?: V1ConfigMapEnvSource
  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   * +optional
   */
  prefix?: string
  /**
   * The Secret to select from
   * +optional
   */
  secretRef?: V1SecretEnvSource
}

export interface V1EnvVar {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   */
  name?: string
  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   * +optional
   */
  value?: string
  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   * +optional
   */
  valueFrom?: V1EnvVarSource
}

export interface V1EnvVarSource {
  /**
   * Selects a key of a ConfigMap.
   * +optional
   */
  configMapKeyRef?: V1ConfigMapKeySelector
  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   * +optional
   */
  fieldRef?: V1ObjectFieldSelector
  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   * +optional
   */
  resourceFieldRef?: V1ResourceFieldSelector
  /**
   * Selects a key of a secret in the pod's namespace
   * +optional
   */
  secretKeyRef?: V1SecretKeySelector
}

export interface V1EphemeralContainer {
  /**
   * Arguments to the entrypoint.
   * The image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   * +optional
   */
  args?: string[]
  /**
   * Entrypoint array. Not executed within a shell.
   * The image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   * +optional
   */
  command?: string[]
  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge
   */
  env?: V1EnvVar[]
  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   * +optional
   */
  envFrom?: V1EnvFromSource[]
  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   */
  image?: string
  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * +optional
   */
  imagePullPolicy?: V1PullPolicy
  /**
   * Lifecycle is not allowed for ephemeral containers.
   * +optional
   */
  lifecycle?: V1Lifecycle
  /**
   * Probes are not allowed for ephemeral containers.
   * +optional
   */
  livenessProbe?: V1Probe
  /**
   * Name of the ephemeral container specified as a DNS_LABEL.
   * This name must be unique among all containers, init containers and ephemeral containers.
   */
  name?: string
  /**
   * Ports are not allowed for ephemeral containers.
   * +optional
   * +patchMergeKey=containerPort
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=containerPort
   * +listMapKey=protocol
   */
  ports?: V1ContainerPort[]
  /**
   * Probes are not allowed for ephemeral containers.
   * +optional
   */
  readinessProbe?: V1Probe
  /**
   * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
   * already allocated to the pod.
   * +optional
   */
  resources?: V1ResourceRequirements
  /**
   * Optional: SecurityContext defines the security options the ephemeral container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * +optional
   */
  securityContext?: V1SecurityContext
  /**
   * Probes are not allowed for ephemeral containers.
   * +optional
   */
  startupProbe?: V1Probe
  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   * +optional
   */
  stdin?: boolean
  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   * +optional
   */
  stdinOnce?: boolean
  /**
   * If set, the name of the container from PodSpec that this ephemeral container targets.
   * The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
   * If not set then the ephemeral container uses the namespaces configured in the Pod spec.
   *
   * The container runtime must implement support for this feature. If the runtime does not
   * support namespace targeting then the result of setting this field is undefined.
   * +optional
   */
  targetContainerName?: string
  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   * +optional
   */
  terminationMessagePath?: string
  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   * +optional
   */
  terminationMessagePolicy?: V1TerminationMessagePolicy
  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   * +optional
   */
  tty?: boolean
  /**
   * volumeDevices is the list of block devices to be used by the container.
   * +patchMergeKey=devicePath
   * +patchStrategy=merge
   * +optional
   */
  volumeDevices?: V1VolumeDevice[]
  /**
   * Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers.
   * Cannot be updated.
   * +optional
   * +patchMergeKey=mountPath
   * +patchStrategy=merge
   */
  volumeMounts?: V1VolumeMount[]
  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   * +optional
   */
  workingDir?: string
}

export interface V1EphemeralVolumeSource {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   * Required, must not be nil.
   */
  volumeClaimTemplate?: V1PersistentVolumeClaimTemplate
}

export interface V1ExecAction {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   * +optional
   */
  command?: string[]
}

export interface V1FCVolumeSource {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   */
  fsType?: string
  /**
   * lun is Optional: FC target lun number
   * +optional
   */
  lun?: number
  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   */
  readOnly?: boolean
  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   * +optional
   */
  targetWWNs?: string[]
  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   * +optional
   */
  wwids?: string[]
}

export interface V1FieldsV1 {
  [key: string]: any
}

export type V1FinalizerName = 'kubernetes'

export interface V1FlexPersistentVolumeSource {
  /**
   * driver is the name of the driver to use for this volume.
   */
  driver?: string
  /**
   * fsType is the Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   * +optional
   */
  fsType?: string
  /**
   * options is Optional: this field holds extra command options if any.
   * +optional
   */
  options?: {
    [key: string]: string
  }
  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   */
  readOnly?: boolean
  /**
   * secretRef is Optional: SecretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   * +optional
   */
  secretRef?: V1SecretReference
}

export interface V1FlexVolumeSource {
  /**
   * driver is the name of the driver to use for this volume.
   */
  driver?: string
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   * +optional
   */
  fsType?: string
  /**
   * options is Optional: this field holds extra command options if any.
   * +optional
   */
  options?: {
    [key: string]: string
  }
  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   */
  readOnly?: boolean
  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   * +optional
   */
  secretRef?: V1LocalObjectReference
}

export interface V1FlockerVolumeSource {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   * +optional
   */
  datasetName?: string
  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   * +optional
   */
  datasetUUID?: string
}

export interface V1GCEPersistentDiskVolumeSource {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   */
  fsType?: string
  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * +optional
   */
  partition?: number
  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   */
  pdName?: string
  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * +optional
   */
  readOnly?: boolean
}

export interface V1GRPCAction {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   */
  port?: number
  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   * +optional
   * +default=""
   */
  service?: string
}

export interface V1GitRepoVolumeSource {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   * +optional
   */
  directory?: string
  /**
   * repository is the URL
   */
  repository?: string
  /**
   * revision is the commit hash for the specified revision.
   * +optional
   */
  revision?: string
}

export interface V1GlusterfsPersistentVolumeSource {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   */
  endpoints?: string
  /**
   * endpointsNamespace is the namespace that contains Glusterfs endpoint.
   * If this field is empty, the EndpointNamespace defaults to the same namespace as the bound PVC.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * +optional
   */
  endpointsNamespace?: string
  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   */
  path?: string
  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * +optional
   */
  readOnly?: boolean
}

export interface V1GlusterfsVolumeSource {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   */
  endpoints?: string
  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   */
  path?: string
  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * +optional
   */
  readOnly?: boolean
}

export interface V1HTTPGetAction {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   * +optional
   */
  host?: string
  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   * +optional
   */
  httpHeaders?: V1HTTPHeader[]
  /**
   * Path to access on the HTTP server.
   * +optional
   */
  path?: string
  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   */
  port?: IntstrIntOrString
  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   * +optional
   */
  scheme?: V1URIScheme
}

export interface V1HTTPHeader {
  /**
   * The header field name
   */
  name?: string
  /**
   * The header field value
   */
  value?: string
}

export interface V1HostAlias {
  /**
   * Hostnames for the above IP address.
   */
  hostnames?: string[]
  /**
   * IP address of the host file entry.
   */
  ip?: string
}

export type V1HostPathType =
  | ''
  | 'DirectoryOrCreate'
  | 'Directory'
  | 'FileOrCreate'
  | 'File'
  | 'Socket'
  | 'CharDevice'
  | 'BlockDevice'

export interface V1HostPathVolumeSource {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   */
  path?: string
  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * +optional
   */
  type?: V1HostPathType
}

export type V1IPFamily = 'IPv4' | 'IPv6'

export type V1IPFamilyPolicy = 'SingleStack' | 'PreferDualStack' | 'RequireDualStack'

export interface V1ISCSIPersistentVolumeSource {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   * +optional
   */
  chapAuthDiscovery?: boolean
  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   * +optional
   */
  chapAuthSession?: boolean
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   */
  fsType?: string
  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   * +optional
   */
  initiatorName?: string
  /**
   * iqn is Target iSCSI Qualified Name.
   */
  iqn?: string
  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   * +optional
   */
  iscsiInterface?: string
  /**
   * lun is iSCSI Target Lun number.
   */
  lun?: number
  /**
   * portals is the iSCSI Target Portal List. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   * +optional
   */
  portals?: string[]
  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * +optional
   */
  readOnly?: boolean
  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   * +optional
   */
  secretRef?: V1SecretReference
  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   */
  targetPortal?: string
}

export interface V1ISCSIVolumeSource {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   * +optional
   */
  chapAuthDiscovery?: boolean
  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   * +optional
   */
  chapAuthSession?: boolean
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   */
  fsType?: string
  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   * +optional
   */
  initiatorName?: string
  /**
   * iqn is the target iSCSI Qualified Name.
   */
  iqn?: string
  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   * +optional
   */
  iscsiInterface?: string
  /**
   * lun represents iSCSI Target Lun number.
   */
  lun?: number
  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   * +optional
   */
  portals?: string[]
  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * +optional
   */
  readOnly?: boolean
  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   * +optional
   */
  secretRef?: V1LocalObjectReference
  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   */
  targetPortal?: string
}

export interface V1JobCondition {
  /**
   * Last time the condition was checked.
   * +optional
   */
  lastProbeTime?: string
  /**
   * Last time the condition transit from one status to another.
   * +optional
   */
  lastTransitionTime?: string
  /**
   * Human readable message indicating details about last transition.
   * +optional
   */
  message?: string
  /**
   * (brief) reason for the condition's last transition.
   * +optional
   */
  reason?: string
  /**
   * Status of the condition, one of True, False, Unknown.
   */
  status?: K8sIoApiCoreV1ConditionStatus
  /**
   * Type of job condition, Complete or Failed.
   */
  type?: V1JobConditionType
}

export type V1JobConditionType = 'Suspended' | 'Complete' | 'Failed' | 'FailureTarget'

export interface V1JobSpec {
  /**
   * Specifies the duration in seconds relative to the startTime that the job
   * may be continuously active before the system tries to terminate it; value
   * must be positive integer. If a Job is suspended (at creation or through an
   * update), this timer will effectively be stopped and reset when the Job is
   * resumed again.
   * +optional
   */
  activeDeadlineSeconds?: number
  /**
   * Specifies the number of retries before marking this job failed.
   * Defaults to 6
   * +optional
   */
  backoffLimit?: number
  /**
   * CompletionMode specifies how Pod completions are tracked. It can be
   * `NonIndexed` (default) or `Indexed`.
   *
   * `NonIndexed` means that the Job is considered complete when there have
   * been .spec.completions successfully completed Pods. Each Pod completion is
   * homologous to each other.
   *
   * `Indexed` means that the Pods of a
   * Job get an associated completion index from 0 to (.spec.completions - 1),
   * available in the annotation batch.kubernetes.io/job-completion-index.
   * The Job is considered complete when there is one successfully completed Pod
   * for each index.
   * When value is `Indexed`, .spec.completions must be specified and
   * `.spec.parallelism` must be less than or equal to 10^5.
   * In addition, The Pod name takes the form
   * `$(job-name)-$(index)-$(random-string)`,
   * the Pod hostname takes the form `$(job-name)-$(index)`.
   *
   * More completion modes can be added in the future.
   * If the Job controller observes a mode that it doesn't recognize, which
   * is possible during upgrades due to version skew, the controller
   * skips updates for the Job.
   * +optional
   */
  completionMode?: V1CompletionMode
  /**
   * Specifies the desired number of successfully finished pods the
   * job should be run with.  Setting to nil means that the success of any
   * pod signals the success of all pods, and allows parallelism to have any positive
   * value.  Setting to 1 means that parallelism is limited to 1 and the success of that
   * pod signals the success of the job.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
   * +optional
   */
  completions?: number
  /**
   * manualSelector controls generation of pod labels and pod selectors.
   * Leave `manualSelector` unset unless you are certain what you are doing.
   * When false or unset, the system pick labels unique to this job
   * and appends those labels to the pod template.  When true,
   * the user is responsible for picking unique labels and specifying
   * the selector.  Failure to pick a unique label may cause this
   * and other jobs to not function correctly.  However, You may see
   * `manualSelector=true` in jobs that were created with the old `extensions/v1beta1`
   * API.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector
   * +optional
   */
  manualSelector?: boolean
  /**
   * Specifies the maximum desired number of pods the job should
   * run at any given time. The actual number of pods running in steady state will
   * be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism),
   * i.e. when the work left to do is less than max parallelism.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
   * +optional
   */
  parallelism?: number
  /**
   * Specifies the policy of handling failed pods. In particular, it allows to
   * specify the set of actions and conditions which need to be
   * satisfied to take the associated action.
   * If empty, the default behaviour applies - the counter of failed pods,
   * represented by the jobs's .status.failed field, is incremented and it is
   * checked against the backoffLimit. This field cannot be used in combination
   * with restartPolicy=OnFailure.
   *
   * This field is alpha-level. To use this field, you must enable the
   * `JobPodFailurePolicy` feature gate (disabled by default).
   * +optional
   */
  podFailurePolicy?: V1PodFailurePolicy
  /**
   * A label query over pods that should match the pod count.
   * Normally, the system sets this field for you.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
   * +optional
   */
  selector?: V1LabelSelector
  /**
   * Suspend specifies whether the Job controller should create Pods or not. If
   * a Job is created with suspend set to true, no Pods are created by the Job
   * controller. If a Job is suspended after creation (i.e. the flag goes from
   * false to true), the Job controller will delete all active Pods associated
   * with this Job. Users must design their workload to gracefully handle this.
   * Suspending a Job will reset the StartTime field of the Job, effectively
   * resetting the ActiveDeadlineSeconds timer too. Defaults to false.
   *
   * +optional
   */
  suspend?: boolean
  /**
   * Describes the pod that will be created when executing a job.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
   */
  template?: V1PodTemplateSpec
  /**
   * ttlSecondsAfterFinished limits the lifetime of a Job that has finished
   * execution (either Complete or Failed). If this field is set,
   * ttlSecondsAfterFinished after the Job finishes, it is eligible to be
   * automatically deleted. When the Job is being deleted, its lifecycle
   * guarantees (e.g. finalizers) will be honored. If this field is unset,
   * the Job won't be automatically deleted. If this field is set to zero,
   * the Job becomes eligible to be deleted immediately after it finishes.
   * +optional
   */
  ttlSecondsAfterFinished?: number
}

export interface V1JobStatus {
  /**
   * The number of pending and running pods.
   * +optional
   */
  active?: number
  /**
   * CompletedIndexes holds the completed indexes when .spec.completionMode =
   * "Indexed" in a text format. The indexes are represented as decimal integers
   * separated by commas. The numbers are listed in increasing order. Three or
   * more consecutive numbers are compressed and represented by the first and
   * last element of the series, separated by a hyphen.
   * For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
   * represented as "1,3-5,7".
   * +optional
   */
  completedIndexes?: string
  /**
   * Represents time when the job was completed. It is not guaranteed to
   * be set in happens-before order across separate operations.
   * It is represented in RFC3339 form and is in UTC.
   * The completion time is only set when the job finishes successfully.
   * +optional
   */
  completionTime?: string
  /**
   * The latest available observations of an object's current state. When a Job
   * fails, one of the conditions will have type "Failed" and status true. When
   * a Job is suspended, one of the conditions will have type "Suspended" and
   * status true; when the Job is resumed, the status of this condition will
   * become false. When a Job is completed, one of the conditions will have
   * type "Complete" and status true.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   * +listType=atomic
   */
  conditions?: V1JobCondition[]
  /**
   * The number of pods which reached phase Failed.
   * +optional
   */
  failed?: number
  /**
   * The number of pods which have a Ready condition.
   *
   * This field is beta-level. The job controller populates the field when
   * the feature gate JobReadyPods is enabled (enabled by default).
   * +optional
   */
  ready?: number
  /**
   * Represents time when the job controller started processing a job. When a
   * Job is created in the suspended state, this field is not set until the
   * first time it is resumed. This field is reset every time a Job is resumed
   * from suspension. It is represented in RFC3339 form and is in UTC.
   * +optional
   */
  startTime?: string
  /**
   * The number of pods which reached phase Succeeded.
   * +optional
   */
  succeeded?: number
  /**
   * UncountedTerminatedPods holds the UIDs of Pods that have terminated but
   * the job controller hasn't yet accounted for in the status counters.
   *
   * The job controller creates pods with a finalizer. When a pod terminates
   * (succeeded or failed), the controller does three steps to account for it
   * in the job status:
   * (1) Add the pod UID to the arrays in this field.
   * (2) Remove the pod finalizer.
   * (3) Remove the pod UID from the arrays while increasing the corresponding
   *     counter.
   *
   * This field is beta-level. The job controller only makes use of this field
   * when the feature gate JobTrackingWithFinalizers is enabled (enabled
   * by default).
   * Old jobs might not be tracked using this field, in which case the field
   * remains null.
   * +optional
   */
  uncountedTerminatedPods?: V1UncountedTerminatedPods
}

export interface V1JobTemplateSpec {
  /**
   * Standard object's metadata of the jobs created from this template.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   */
  metadata?: V1ObjectMeta
  /**
   * Specification of the desired behavior of the job.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   */
  spec?: V1JobSpec
}

export interface V1KeyToPath {
  /**
   * key is the key to project.
   */
  key?: string
  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   */
  mode?: number
  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   */
  path?: string
}

export interface V1LabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   * +optional
   */
  matchExpressions?: V1LabelSelectorRequirement[]
  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   * +optional
   */
  matchLabels?: {
    [key: string]: string
  }
}

export type V1LabelSelectorOperator = 'In' | 'NotIn' | 'Exists' | 'DoesNotExist'

export interface V1LabelSelectorRequirement {
  /**
   * key is the label key that the selector applies to.
   * +patchMergeKey=key
   * +patchStrategy=merge
   */
  key?: string
  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   */
  operator?: V1LabelSelectorOperator
  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   * +optional
   */
  values?: string[]
}

export interface V1Lifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   * +optional
   */
  postStart?: V1LifecycleHandler
  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   * +optional
   */
  preStop?: V1LifecycleHandler
}

export interface V1LifecycleHandler {
  /**
   * Exec specifies the action to take.
   * +optional
   */
  exec?: V1ExecAction
  /**
   * HTTPGet specifies the http request to perform.
   * +optional
   */
  httpGet?: V1HTTPGetAction
  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for the backward compatibility. There are no validation of this field and
   * lifecycle hooks will fail in runtime when tcp handler is specified.
   * +optional
   */
  tcpSocket?: V1TCPSocketAction
}

export interface V1LoadBalancerIngress {
  /**
   * Hostname is set for load-balancer ingress points that are DNS based
   * (typically AWS load-balancers)
   * +optional
   */
  hostname?: string
  /**
   * IP is set for load-balancer ingress points that are IP based
   * (typically GCE or OpenStack load-balancers)
   * +optional
   */
  ip?: string
  /**
   * Ports is a list of records of service ports
   * If used, every port defined in the service should have an entry in it
   * +listType=atomic
   * +optional
   */
  ports?: V1PortStatus[]
}

export interface V1LoadBalancerStatus {
  /**
   * Ingress is a list containing ingress points for the load-balancer.
   * Traffic intended for the service should be sent to these ingress points.
   * +optional
   */
  ingress?: V1LoadBalancerIngress[]
}

export interface V1LocalObjectReference {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * +optional
   */
  name?: string
}

export interface V1LocalVolumeSource {
  /**
   * fsType is the filesystem type to mount.
   * It applies only when the Path is a block device.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default value is to auto-select a filesystem if unspecified.
   * +optional
   */
  fsType?: string
  /**
   * path of the full path to the volume on the node.
   * It can be either a directory or block device (disk, partition, ...).
   */
  path?: string
}

export interface V1ManagedFieldsEntry {
  /**
   * APIVersion defines the version of this resource that this field set
   * applies to. The format is "group/version" just like the top-level
   * APIVersion field. It is necessary to track the version of a field
   * set because it cannot be automatically converted.
   */
  apiVersion?: string
  /**
   * FieldsType is the discriminator for the different fields format and version.
   * There is currently only one possible value: "FieldsV1"
   */
  fieldsType?: string
  /**
   * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
   * +optional
   */
  fieldsV1?: V1FieldsV1
  /**
   * Manager is an identifier of the workflow managing these fields.
   */
  manager?: string
  /**
   * Operation is the type of operation which lead to this ManagedFieldsEntry being created.
   * The only valid values for this field are 'Apply' and 'Update'.
   */
  operation?: V1ManagedFieldsOperationType
  /**
   * Subresource is the name of the subresource used to update that object, or
   * empty string if the object was updated through the main resource. The
   * value of this field is used to distinguish between managers, even if they
   * share the same name. For example, a status update will be distinct from a
   * regular update using the same manager name.
   * Note that the APIVersion field is not related to the Subresource field and
   * it always corresponds to the version of the main resource.
   */
  subresource?: string
  /**
   * Time is the timestamp of when the ManagedFields entry was added. The
   * timestamp will also be updated if a field is added, the manager
   * changes any of the owned fields value or removes a field. The
   * timestamp does not update when a field is removed from the entry
   * because another manager took it over.
   * +optional
   */
  time?: string
}

export type V1ManagedFieldsOperationType = 'Apply' | 'Update'

export type V1MountPropagationMode = 'None' | 'HostToContainer' | 'Bidirectional'

export interface V1NFSVolumeSource {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   */
  path?: string
  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * +optional
   */
  readOnly?: boolean
  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   */
  server?: string
}

export interface V1NamespaceCondition {
  /**
   * +optional
   */
  lastTransitionTime?: string
  /**
   * +optional
   */
  message?: string
  /**
   * +optional
   */
  reason?: string
  /**
   * Status of the condition, one of True, False, Unknown.
   */
  status?: K8sIoApiCoreV1ConditionStatus
  /**
   * Type of namespace controller condition.
   */
  type?: V1NamespaceConditionType
}

export type V1NamespaceConditionType =
  | 'NamespaceDeletionDiscoveryFailure'
  | 'NamespaceDeletionContentFailure'
  | 'NamespaceDeletionGroupVersionParsingFailure'
  | 'NamespaceContentRemaining'
  | 'NamespaceFinalizersRemaining'

export type V1NamespacePhase = 'Active' | 'Terminating'

export interface V1NamespaceSpec {
  /**
   * Finalizers is an opaque list of values that must be empty to permanently remove object from storage.
   * More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
   * +optional
   */
  finalizers?: V1FinalizerName[]
}

export interface V1NamespaceStatus {
  /**
   * Represents the latest available observations of a namespace's current state.
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   */
  conditions?: V1NamespaceCondition[]
  /**
   * Phase is the current lifecycle phase of the namespace.
   * More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
   * +optional
   */
  phase?: V1NamespacePhase
}

export interface V1NodeAddress {
  /**
   * The node address.
   */
  address?: string
  /**
   * Node address type, one of Hostname, ExternalIP or InternalIP.
   */
  type?: V1NodeAddressType
}

export type V1NodeAddressType = 'Hostname' | 'InternalIP' | 'ExternalIP' | 'InternalDNS' | 'ExternalDNS'

export interface V1NodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   * +optional
   */
  preferredDuringSchedulingIgnoredDuringExecution?: V1PreferredSchedulingTerm[]
  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   * +optional
   */
  requiredDuringSchedulingIgnoredDuringExecution?: V1NodeSelector
}

export interface V1NodeCondition {
  /**
   * Last time we got an update on a given condition.
   * +optional
   */
  lastHeartbeatTime?: string
  /**
   * Last time the condition transit from one status to another.
   * +optional
   */
  lastTransitionTime?: string
  /**
   * Human readable message indicating details about last transition.
   * +optional
   */
  message?: string
  /**
   * (brief) reason for the condition's last transition.
   * +optional
   */
  reason?: string
  /**
   * Status of the condition, one of True, False, Unknown.
   */
  status?: K8sIoApiCoreV1ConditionStatus
  /**
   * Type of node condition.
   */
  type?: V1NodeConditionType
}

export type V1NodeConditionType = 'Ready' | 'MemoryPressure' | 'DiskPressure' | 'PIDPressure' | 'NetworkUnavailable'

export interface V1NodeConfigSource {
  /**
   * ConfigMap is a reference to a Node's ConfigMap
   */
  configMap?: V1ConfigMapNodeConfigSource
}

export interface V1NodeConfigStatus {
  /**
   * Active reports the checkpointed config the node is actively using.
   * Active will represent either the current version of the Assigned config,
   * or the current LastKnownGood config, depending on whether attempting to use the
   * Assigned config results in an error.
   * +optional
   */
  active?: V1NodeConfigSource
  /**
   * Assigned reports the checkpointed config the node will try to use.
   * When Node.Spec.ConfigSource is updated, the node checkpoints the associated
   * config payload to local disk, along with a record indicating intended
   * config. The node refers to this record to choose its config checkpoint, and
   * reports this record in Assigned. Assigned only updates in the status after
   * the record has been checkpointed to disk. When the Kubelet is restarted,
   * it tries to make the Assigned config the Active config by loading and
   * validating the checkpointed payload identified by Assigned.
   * +optional
   */
  assigned?: V1NodeConfigSource
  /**
   * Error describes any problems reconciling the Spec.ConfigSource to the Active config.
   * Errors may occur, for example, attempting to checkpoint Spec.ConfigSource to the local Assigned
   * record, attempting to checkpoint the payload associated with Spec.ConfigSource, attempting
   * to load or validate the Assigned config, etc.
   * Errors may occur at different points while syncing config. Earlier errors (e.g. download or
   * checkpointing errors) will not result in a rollback to LastKnownGood, and may resolve across
   * Kubelet retries. Later errors (e.g. loading or validating a checkpointed config) will result in
   * a rollback to LastKnownGood. In the latter case, it is usually possible to resolve the error
   * by fixing the config assigned in Spec.ConfigSource.
   * You can find additional information for debugging by searching the error message in the Kubelet log.
   * Error is a human-readable description of the error state; machines can check whether or not Error
   * is empty, but should not rely on the stability of the Error text across Kubelet versions.
   * +optional
   */
  error?: string
  /**
   * LastKnownGood reports the checkpointed config the node will fall back to
   * when it encounters an error attempting to use the Assigned config.
   * The Assigned config becomes the LastKnownGood config when the node determines
   * that the Assigned config is stable and correct.
   * This is currently implemented as a 10-minute soak period starting when the local
   * record of Assigned config is updated. If the Assigned config is Active at the end
   * of this period, it becomes the LastKnownGood. Note that if Spec.ConfigSource is
   * reset to nil (use local defaults), the LastKnownGood is also immediately reset to nil,
   * because the local default config is always assumed good.
   * You should not make assumptions about the node's method of determining config stability
   * and correctness, as this may change or become configurable in the future.
   * +optional
   */
  lastKnownGood?: V1NodeConfigSource
}

export interface V1NodeDaemonEndpoints {
  /**
   * Endpoint on which Kubelet is listening.
   * +optional
   */
  kubeletEndpoint?: V1DaemonEndpoint
}

export type V1NodeInclusionPolicy = 'Ignore' | 'Honor'

export type V1NodePhase = 'Pending' | 'Running' | 'Terminated'

export interface V1NodeSelector {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   */
  nodeSelectorTerms?: V1NodeSelectorTerm[]
}

export type V1NodeSelectorOperator = 'In' | 'NotIn' | 'Exists' | 'DoesNotExist' | 'Gt' | 'Lt'

export interface V1NodeSelectorRequirement {
  /**
   * The label key that the selector applies to.
   */
  key?: string
  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   */
  operator?: V1NodeSelectorOperator
  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   * +optional
   */
  values?: string[]
}

export interface V1NodeSelectorTerm {
  /**
   * A list of node selector requirements by node's labels.
   * +optional
   */
  matchExpressions?: V1NodeSelectorRequirement[]
  /**
   * A list of node selector requirements by node's fields.
   * +optional
   */
  matchFields?: V1NodeSelectorRequirement[]
}

export interface V1NodeSpec {
  /**
   * Deprecated: Previously used to specify the source of the node's configuration for the DynamicKubeletConfig feature. This feature is removed from Kubelets as of 1.24 and will be fully removed in 1.26.
   * +optional
   */
  configSource?: V1NodeConfigSource
  /**
   * Deprecated. Not all kubelets will set this field. Remove field after 1.13.
   * see: https://issues.k8s.io/61966
   * +optional
   */
  externalID?: string
  /**
   * PodCIDR represents the pod IP range assigned to the node.
   * +optional
   */
  podCIDR?: string
  /**
   * podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node. If this
   * field is specified, the 0th entry must match the podCIDR field. It may contain at most 1 value for
   * each of IPv4 and IPv6.
   * +optional
   * +patchStrategy=merge
   */
  podCIDRs?: string[]
  /**
   * ID of the node assigned by the cloud provider in the format: <ProviderName>://<ProviderSpecificNodeID>
   * +optional
   */
  providerID?: string
  /**
   * If specified, the node's taints.
   * +optional
   */
  taints?: V1Taint[]
  /**
   * Unschedulable controls node schedulability of new pods. By default, node is schedulable.
   * More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration
   * +optional
   */
  unschedulable?: boolean
}

export interface V1NodeStatus {
  /**
   * List of addresses reachable to the node.
   * Queried from cloud provider, if available.
   * More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses
   * Note: This field is declared as mergeable, but the merge key is not sufficiently
   * unique, which can cause data corruption when it is merged. Callers should instead
   * use a full-replacement patch. See http://pr.k8s.io/79391 for an example.
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   */
  addresses?: V1NodeAddress[]
  /**
   * Allocatable represents the resources of a node that are available for scheduling.
   * Defaults to Capacity.
   * +optional
   */
  allocatable?: V1ResourceList
  /**
   * Capacity represents the total resources of a node.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
   * +optional
   */
  capacity?: V1ResourceList
  /**
   * Conditions is an array of current observed node conditions.
   * More info: https://kubernetes.io/docs/concepts/nodes/node/#condition
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   */
  conditions?: V1NodeCondition[]
  /**
   * Status of the config assigned to the node via the dynamic Kubelet config feature.
   * +optional
   */
  config?: V1NodeConfigStatus
  /**
   * Endpoints of daemons running on the Node.
   * +optional
   */
  daemonEndpoints?: V1NodeDaemonEndpoints
  /**
   * List of container images on this node
   * +optional
   */
  images?: V1ContainerImage[]
  /**
   * Set of ids/uuids to uniquely identify the node.
   * More info: https://kubernetes.io/docs/concepts/nodes/node/#info
   * +optional
   */
  nodeInfo?: V1NodeSystemInfo
  /**
   * NodePhase is the recently observed lifecycle phase of the node.
   * More info: https://kubernetes.io/docs/concepts/nodes/node/#phase
   * The field is never populated, and now is deprecated.
   * +optional
   */
  phase?: V1NodePhase
  /**
   * List of volumes that are attached to the node.
   * +optional
   */
  volumesAttached?: V1AttachedVolume[]
  /**
   * List of attachable volumes in use (mounted) by the node.
   * +optional
   */
  volumesInUse?: string[]
}

export interface V1NodeSystemInfo {
  /**
   * The Architecture reported by the node
   */
  architecture?: string
  /**
   * Boot ID reported by the node.
   */
  bootID?: string
  /**
   * ContainerRuntime Version reported by the node through runtime remote API (e.g. containerd://1.4.2).
   */
  containerRuntimeVersion?: string
  /**
   * Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
   */
  kernelVersion?: string
  /**
   * KubeProxy Version reported by the node.
   */
  kubeProxyVersion?: string
  /**
   * Kubelet Version reported by the node.
   */
  kubeletVersion?: string
  /**
   * MachineID reported by the node. For unique machine identification
   * in the cluster this field is preferred. Learn more from man(5)
   * machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
   */
  machineID?: string
  /**
   * The Operating System reported by the node
   */
  operatingSystem?: string
  /**
   * OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
   */
  osImage?: string
  /**
   * SystemUUID reported by the node. For unique machine identification
   * MachineID is preferred. This field is specific to Red Hat hosts
   * https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid
   */
  systemUUID?: string
}

export type V1OSName = 'linux' | 'windows'

export interface V1ObjectFieldSelector {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   * +optional
   */
  apiVersion?: string
  /**
   * Path of the field to select in the specified API version.
   */
  fieldPath?: string
}

export interface V1ObjectMeta {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: http://kubernetes.io/docs/user-guide/annotations
   * +optional
   */
  annotations?: {
    [key: string]: string
  }
  /**
   * CreationTimestamp is a timestamp representing the server time when this object was
   * created. It is not guaranteed to be set in happens-before order across separate operations.
   * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
   *
   * Populated by the system.
   * Read-only.
   * Null for lists.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   */
  creationTimestamp?: string
  /**
   * Number of seconds allowed for this object to gracefully terminate before
   * it will be removed from the system. Only set when deletionTimestamp is also set.
   * May only be shortened.
   * Read-only.
   * +optional
   */
  deletionGracePeriodSeconds?: number
  /**
   * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
   * field is set by the server when a graceful deletion is requested by the user, and is not
   * directly settable by a client. The resource is expected to be deleted (no longer visible
   * from resource lists, and not reachable by name) after the time in this field, once the
   * finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
   * Once the deletionTimestamp is set, this value may not be unset or be set further into the
   * future, although it may be shortened or the resource may be deleted prior to this time.
   * For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
   * by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
   * the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
   * remove the pod from the API. In the presence of network partitions, this object may still
   * exist after this timestamp, until an administrator or automated process can determine the
   * resource is fully terminated.
   * If not set, graceful deletion of the object has not been requested.
   *
   * Populated by the system when a graceful deletion is requested.
   * Read-only.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   */
  deletionTimestamp?: string
  /**
   * Must be empty before the object is deleted from the registry. Each entry
   * is an identifier for the responsible component that will remove the entry
   * from the list. If the deletionTimestamp of the object is non-nil, entries
   * in this list can only be removed.
   * Finalizers may be processed and removed in any order.  Order is NOT enforced
   * because it introduces significant risk of stuck finalizers.
   * finalizers is a shared field, any actor with permission can reorder it.
   * If the finalizer list is processed in order, then this can lead to a situation
   * in which the component responsible for the first finalizer in the list is
   * waiting for a signal (field value, external system, or other) produced by a
   * component responsible for a finalizer later in the list, resulting in a deadlock.
   * Without enforced ordering finalizers are free to order amongst themselves and
   * are not vulnerable to ordering changes in the list.
   * +optional
   * +patchStrategy=merge
   */
  finalizers?: string[]
  /**
   * GenerateName is an optional prefix, used by the server, to generate a unique
   * name ONLY IF the Name field has not been provided.
   * If this field is used, the name returned to the client will be different
   * than the name passed. This value will also be combined with a unique suffix.
   * The provided value has the same validation rules as the Name field,
   * and may be truncated by the length of the suffix required to make the value
   * unique on the server.
   *
   * If this field is specified and the generated name exists, the server will return a 409.
   *
   * Applied only if Name is not specified.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
   * +optional
   */
  generateName?: string
  /**
   * A sequence number representing a specific generation of the desired state.
   * Populated by the system. Read-only.
   * +optional
   */
  generation?: number
  /**
   * Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: http://kubernetes.io/docs/user-guide/labels
   * +optional
   */
  labels?: {
    [key: string]: string
  }
  /**
   * ManagedFields maps workflow-id and version to the set of fields
   * that are managed by that workflow. This is mostly for internal
   * housekeeping, and users typically shouldn't need to set or
   * understand this field. A workflow can be the user's name, a
   * controller's name, or the name of a specific apply path like
   * "ci-cd". The set of fields is always in the version that the
   * workflow used when modifying the object.
   *
   * +optional
   */
  managedFields?: V1ManagedFieldsEntry[]
  /**
   * Name must be unique within a namespace. Is required when creating resources, although
   * some resources may allow a client to request the generation of an appropriate name
   * automatically. Name is primarily intended for creation idempotence and configuration
   * definition.
   * Cannot be updated.
   * More info: http://kubernetes.io/docs/user-guide/identifiers#names
   * +optional
   */
  name?: string
  /**
   * Namespace defines the space within which each name must be unique. An empty namespace is
   * equivalent to the "default" namespace, but "default" is the canonical representation.
   * Not all objects are required to be scoped to a namespace - the value of this field for
   * those objects will be empty.
   *
   * Must be a DNS_LABEL.
   * Cannot be updated.
   * More info: http://kubernetes.io/docs/user-guide/namespaces
   * +optional
   */
  namespace?: string
  /**
   * List of objects depended by this object. If ALL objects in the list have
   * been deleted, this object will be garbage collected. If this object is managed by a controller,
   * then an entry in this list will point to this controller, with the controller field set to true.
   * There cannot be more than one managing controller.
   * +optional
   * +patchMergeKey=uid
   * +patchStrategy=merge
   */
  ownerReferences?: V1OwnerReference[]
  /**
   * An opaque value that represents the internal version of this object that can
   * be used by clients to determine when objects have changed. May be used for optimistic
   * concurrency, change detection, and the watch operation on a resource or set of resources.
   * Clients must treat these values as opaque and passed unmodified back to the server.
   * They may only be valid for a particular resource or set of resources.
   *
   * Populated by the system.
   * Read-only.
   * Value must be treated as opaque by clients and .
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   * +optional
   */
  resourceVersion?: string
  /**
   * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
   * +optional
   */
  selfLink?: string
  /**
   * UID is the unique in time and space value for this object. It is typically generated by
   * the server on successful creation of a resource and is not allowed to change on PUT
   * operations.
   *
   * Populated by the system.
   * Read-only.
   * More info: http://kubernetes.io/docs/user-guide/identifiers#uids
   * +optional
   */
  uid?: string
}

export interface V1ObjectReference {
  /**
   * API version of the referent.
   * +optional
   */
  apiVersion?: string
  /**
   * If referring to a piece of an object instead of an entire object, this string
   * should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
   * For example, if the object reference is to a container within a pod, this would take on a value like:
   * "spec.containers{name}" (where "name" refers to the name of the container that triggered
   * the event) or if no container name is specified "spec.containers[2]" (container with
   * index 2 in this pod). This syntax is chosen only to have some well-defined way of
   * referencing a part of an object.
   * TODO: this design is not final and this field is subject to change in the future.
   * +optional
   */
  fieldPath?: string
  /**
   * Kind of the referent.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   */
  kind?: string
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * +optional
   */
  name?: string
  /**
   * Namespace of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   * +optional
   */
  namespace?: string
  /**
   * Specific resourceVersion to which this reference is made, if any.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   * +optional
   */
  resourceVersion?: string
  /**
   * UID of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
   * +optional
   */
  uid?: string
}

export interface V1OwnerReference {
  /**
   * API version of the referent.
   */
  apiVersion?: string
  /**
   * If true, AND if the owner has the "foregroundDeletion" finalizer, then
   * the owner cannot be deleted from the key-value store until this
   * reference is removed.
   * See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
   * for how the garbage collector interacts with this field and enforces the foreground deletion.
   * Defaults to false.
   * To set this field, a user needs "delete" permission of the owner,
   * otherwise 422 (Unprocessable Entity) will be returned.
   * +optional
   */
  blockOwnerDeletion?: boolean
  /**
   * If true, this reference points to the managing controller.
   * +optional
   */
  controller?: boolean
  /**
   * Kind of the referent.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  kind?: string
  /**
   * Name of the referent.
   * More info: http://kubernetes.io/docs/user-guide/identifiers#names
   */
  name?: string
  /**
   * UID of the referent.
   * More info: http://kubernetes.io/docs/user-guide/identifiers#uids
   */
  uid?: string
}

export type V1PersistentVolumeAccessMode = 'ReadWriteOnce' | 'ReadOnlyMany' | 'ReadWriteMany' | 'ReadWriteOncePod'

export interface V1PersistentVolumeClaim {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   * +optional
   */
  apiVersion?: string
  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   */
  kind?: string
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   */
  metadata?: V1ObjectMeta
  /**
   * spec defines the desired characteristics of a volume requested by a pod author.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   * +optional
   */
  spec?: V1PersistentVolumeClaimSpec
  /**
   * status represents the current information/status of a persistent volume claim.
   * Read-only.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   * +optional
   */
  status?: V1PersistentVolumeClaimStatus
}

export interface V1PersistentVolumeClaimCondition {
  /**
   * lastProbeTime is the time we probed the condition.
   * +optional
   */
  lastProbeTime?: string
  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   * +optional
   */
  lastTransitionTime?: string
  /**
   * message is the human-readable message indicating details about last transition.
   * +optional
   */
  message?: string
  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason
   * for condition's last transition. If it reports "ResizeStarted" that means the underlying
   * persistent volume is being resized.
   * +optional
   */
  reason?: string
  status?: K8sIoApiCoreV1ConditionStatus
  type?: V1PersistentVolumeClaimConditionType
}

export type V1PersistentVolumeClaimConditionType = 'Resizing' | 'FileSystemResizePending'

export type V1PersistentVolumeClaimPhase = 'Pending' | 'Bound' | 'Lost'

export type V1PersistentVolumeClaimResizeStatus =
  | ''
  | 'ControllerExpansionInProgress'
  | 'ControllerExpansionFailed'
  | 'NodeExpansionPending'
  | 'NodeExpansionInProgress'
  | 'NodeExpansionFailed'

export type V1PersistentVolumeClaimRetentionPolicyType = 'Retain' | 'Delete'

export interface V1PersistentVolumeClaimSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   * +optional
   */
  accessModes?: V1PersistentVolumeAccessMode[]
  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * If the AnyVolumeDataSource feature gate is enabled, this field will always have
   * the same contents as the DataSourceRef field.
   * +optional
   */
  dataSource?: V1TypedLocalObjectReference
  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any local object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the DataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, both fields (DataSource and DataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * There are two important differences between DataSource and DataSourceRef:
   * * While DataSource only allows two specific types of objects, DataSourceRef
   *   allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While DataSource ignores disallowed values (dropping them), DataSourceRef
   *   preserves all values, and generates an error if a disallowed value is
   *   specified.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * +optional
   */
  dataSourceRef?: V1TypedLocalObjectReference
  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   * +optional
   */
  resources?: V1ResourceRequirements
  /**
   * selector is a label query over volumes to consider for binding.
   * +optional
   */
  selector?: V1LabelSelector
  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   * +optional
   */
  storageClassName?: string
  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   * +optional
   */
  volumeMode?: V1PersistentVolumeMode
  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   * +optional
   */
  volumeName?: string
}

export interface V1PersistentVolumeClaimStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   * +optional
   */
  accessModes?: V1PersistentVolumeAccessMode[]
  /**
   * allocatedResources is the storage resource within AllocatedResources tracks the capacity allocated to a PVC. It may
   * be larger than the actual capacity when a volume expansion operation is requested.
   * For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
   * If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
   * If a volume expansion capacity request is lowered, allocatedResources is only
   * lowered if there are no expansion operations in progress and if the actual volume capacity
   * is equal or lower than the requested capacity.
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   * +featureGate=RecoverVolumeExpansionFailure
   * +optional
   */
  allocatedResources?: V1ResourceList
  /**
   * capacity represents the actual resources of the underlying volume.
   * +optional
   */
  capacity?: V1ResourceList
  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
   * resized then the Condition will be set to 'ResizeStarted'.
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   */
  conditions?: V1PersistentVolumeClaimCondition[]
  /**
   * phase represents the current phase of PersistentVolumeClaim.
   * +optional
   */
  phase?: V1PersistentVolumeClaimPhase
  /**
   * resizeStatus stores status of resize operation.
   * ResizeStatus is not set by default but when expansion is complete resizeStatus is set to empty
   * string by resize controller or kubelet.
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   * +featureGate=RecoverVolumeExpansionFailure
   * +optional
   */
  resizeStatus?: V1PersistentVolumeClaimResizeStatus
}

export interface V1PersistentVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * +optional
   */
  metadata?: V1ObjectMeta
  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   */
  spec?: V1PersistentVolumeClaimSpec
}

export interface V1PersistentVolumeClaimVolumeSource {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   */
  claimName?: string
  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   * +optional
   */
  readOnly?: boolean
}

export type V1PersistentVolumeMode = 'Block' | 'Filesystem'

export type V1PersistentVolumePhase = 'Pending' | 'Available' | 'Bound' | 'Released' | 'Failed'

export type V1PersistentVolumeReclaimPolicy = 'Recycle' | 'Delete' | 'Retain'

export interface V1PersistentVolumeSpec {
  /**
   * accessModes contains all ways the volume can be mounted.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
   * +optional
   */
  accessModes?: V1PersistentVolumeAccessMode[]
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * +optional
   */
  awsElasticBlockStore?: V1AWSElasticBlockStoreVolumeSource
  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * +optional
   */
  azureDisk?: V1AzureDiskVolumeSource
  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * +optional
   */
  azureFile?: V1AzureFilePersistentVolumeSource
  /**
   * capacity is the description of the persistent volume's resources and capacity.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
   * +optional
   */
  capacity?: V1ResourceList
  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   * +optional
   */
  cephfs?: V1CephFSPersistentVolumeSource
  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   */
  cinder?: V1CinderPersistentVolumeSource
  /**
   * claimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim.
   * Expected to be non-nil when bound.
   * claim.VolumeName is the authoritative bind between PV and PVC.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
   * +optional
   * +structType=granular
   */
  claimRef?: V1ObjectReference
  /**
   * csi represents storage that is handled by an external CSI driver (Beta feature).
   * +optional
   */
  csi?: V1CSIPersistentVolumeSource
  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   * +optional
   */
  fc?: V1FCVolumeSource
  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   * +optional
   */
  flexVolume?: V1FlexPersistentVolumeSource
  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
   * +optional
   */
  flocker?: V1FlockerVolumeSource
  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod. Provisioned by an admin.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * +optional
   */
  gcePersistentDisk?: V1GCEPersistentDiskVolumeSource
  /**
   * glusterfs represents a Glusterfs volume that is attached to a host and
   * exposed to the pod. Provisioned by an admin.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   * +optional
   */
  glusterfs?: V1GlusterfsPersistentVolumeSource
  /**
   * hostPath represents a directory on the host.
   * Provisioned by a developer or tester.
   * This is useful for single-node development and testing only!
   * On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * +optional
   */
  hostPath?: V1HostPathVolumeSource
  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod. Provisioned by an admin.
   * +optional
   */
  iscsi?: V1ISCSIPersistentVolumeSource
  /**
   * local represents directly-attached storage with node affinity
   * +optional
   */
  local?: V1LocalVolumeSource
  /**
   * mountOptions is the list of mount options, e.g. ["ro", "soft"]. Not validated - mount will
   * simply fail if one is invalid.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
   * +optional
   */
  mountOptions?: string[]
  /**
   * nfs represents an NFS mount on the host. Provisioned by an admin.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * +optional
   */
  nfs?: V1NFSVolumeSource
  /**
   * nodeAffinity defines constraints that limit what nodes this volume can be accessed from.
   * This field influences the scheduling of pods that use this volume.
   * +optional
   */
  nodeAffinity?: V1VolumeNodeAffinity
  /**
   * persistentVolumeReclaimPolicy defines what happens to a persistent volume when released from its claim.
   * Valid options are Retain (default for manually created PersistentVolumes), Delete (default
   * for dynamically provisioned PersistentVolumes), and Recycle (deprecated).
   * Recycle must be supported by the volume plugin underlying this PersistentVolume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
   * +optional
   */
  persistentVolumeReclaimPolicy?: V1PersistentVolumeReclaimPolicy
  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   */
  photonPersistentDisk?: V1PhotonPersistentDiskVolumeSource
  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   * +optional
   */
  portworxVolume?: V1PortworxVolumeSource
  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   * +optional
   */
  quobyte?: V1QuobyteVolumeSource
  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   * +optional
   */
  rbd?: V1RBDPersistentVolumeSource
  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * +optional
   */
  scaleIO?: V1ScaleIOPersistentVolumeSource
  /**
   * storageClassName is the name of StorageClass to which this persistent volume belongs. Empty value
   * means that this volume does not belong to any StorageClass.
   * +optional
   */
  storageClassName?: string
  /**
   * storageOS represents a StorageOS volume that is attached to the kubelet's host machine and mounted into the pod
   * More info: https://examples.k8s.io/volumes/storageos/README.md
   * +optional
   */
  storageos?: V1StorageOSPersistentVolumeSource
  /**
   * volumeMode defines if a volume is intended to be used with a formatted filesystem
   * or to remain in raw block state. Value of Filesystem is implied when not included in spec.
   * +optional
   */
  volumeMode?: V1PersistentVolumeMode
  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   * +optional
   */
  vsphereVolume?: V1VsphereVirtualDiskVolumeSource
}

export interface V1PersistentVolumeStatus {
  /**
   * message is a human-readable message indicating details about why the volume is in this state.
   * +optional
   */
  message?: string
  /**
   * phase indicates if a volume is available, bound to a claim, or released by a claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#phase
   * +optional
   */
  phase?: V1PersistentVolumePhase
  /**
   * reason is a brief CamelCase string that describes any failure and is meant
   * for machine parsing and tidy display in the CLI.
   * +optional
   */
  reason?: string
}

export interface V1PhotonPersistentDiskVolumeSource {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   */
  fsType?: string
  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   */
  pdID?: string
}

export interface V1PodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   * +optional
   */
  preferredDuringSchedulingIgnoredDuringExecution?: V1WeightedPodAffinityTerm[]
  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   * +optional
   */
  requiredDuringSchedulingIgnoredDuringExecution?: V1PodAffinityTerm[]
}

export interface V1PodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * +optional
   */
  labelSelector?: V1LabelSelector
  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   * +optional
   */
  namespaceSelector?: V1LabelSelector
  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   * +optional
   */
  namespaces?: string[]
  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   */
  topologyKey?: string
}

export interface V1PodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   * +optional
   */
  preferredDuringSchedulingIgnoredDuringExecution?: V1WeightedPodAffinityTerm[]
  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   * +optional
   */
  requiredDuringSchedulingIgnoredDuringExecution?: V1PodAffinityTerm[]
}

export interface V1PodCondition {
  /**
   * Last time we probed the condition.
   * +optional
   */
  lastProbeTime?: string
  /**
   * Last time the condition transitioned from one status to another.
   * +optional
   */
  lastTransitionTime?: string
  /**
   * Human-readable message indicating details about last transition.
   * +optional
   */
  message?: string
  /**
   * Unique, one-word, CamelCase reason for the condition's last transition.
   * +optional
   */
  reason?: string
  /**
   * Status is the status of the condition.
   * Can be True, False, Unknown.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
   */
  status?: K8sIoApiCoreV1ConditionStatus
  /**
   * Type is the type of the condition.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
   */
  type?: V1PodConditionType
}

export type V1PodConditionType = 'ContainersReady' | 'Initialized' | 'Ready' | 'PodScheduled' | 'DisruptionTarget'

export interface V1PodDNSConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   * +optional
   */
  nameservers?: string[]
  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   * +optional
   */
  options?: V1PodDNSConfigOption[]
  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   * +optional
   */
  searches?: string[]
}

export interface V1PodDNSConfigOption {
  /**
   * Required.
   */
  name?: string
  /**
   * +optional
   */
  value?: string
}

export type V1PodFSGroupChangePolicy = 'OnRootMismatch' | 'Always'

export interface V1PodFailurePolicy {
  /**
   * A list of pod failure policy rules. The rules are evaluated in order.
   * Once a rule matches a Pod failure, the remaining of the rules are ignored.
   * When no rule matches the Pod failure, the default handling applies - the
   * counter of pod failures is incremented and it is checked against
   * the backoffLimit. At most 20 elements are allowed.
   * +listType=atomic
   */
  rules?: V1PodFailurePolicyRule[]
}

export type V1PodFailurePolicyAction = 'FailJob' | 'Ignore' | 'Count'

export type V1PodFailurePolicyOnExitCodesOperator = 'In' | 'NotIn'

export interface V1PodFailurePolicyOnExitCodesRequirement {
  /**
   * Restricts the check for exit codes to the container with the
   * specified name. When null, the rule applies to all containers.
   * When specified, it should match one the container or initContainer
   * names in the pod template.
   * +optional
   */
  containerName?: string
  /**
   * Represents the relationship between the container exit code(s) and the
   * specified values. Containers completed with success (exit code 0) are
   * excluded from the requirement check. Possible values are:
   * - In: the requirement is satisfied if at least one container exit code
   *   (might be multiple if there are multiple containers not restricted
   *   by the 'containerName' field) is in the set of specified values.
   * - NotIn: the requirement is satisfied if at least one container exit code
   *   (might be multiple if there are multiple containers not restricted
   *   by the 'containerName' field) is not in the set of specified values.
   * Additional values are considered to be added in the future. Clients should
   * react to an unknown operator by assuming the requirement is not satisfied.
   */
  operator?: V1PodFailurePolicyOnExitCodesOperator
  /**
   * Specifies the set of values. Each returned container exit code (might be
   * multiple in case of multiple containers) is checked against this set of
   * values with respect to the operator. The list of values must be ordered
   * and must not contain duplicates. Value '0' cannot be used for the In operator.
   * At least one element is required. At most 255 elements are allowed.
   * +listType=set
   */
  values?: number[]
}

export interface V1PodFailurePolicyOnPodConditionsPattern {
  /**
   * Specifies the required Pod condition status. To match a pod condition
   * it is required that the specified status equals the pod condition status.
   * Defaults to True.
   */
  status?: K8sIoApiCoreV1ConditionStatus
  /**
   * Specifies the required Pod condition type. To match a pod condition
   * it is required that specified type equals the pod condition type.
   */
  type?: V1PodConditionType
}

export interface V1PodFailurePolicyRule {
  /**
   * Specifies the action taken on a pod failure when the requirements are satisfied.
   * Possible values are:
   * - FailJob: indicates that the pod's job is marked as Failed and all
   *   running pods are terminated.
   * - Ignore: indicates that the counter towards the .backoffLimit is not
   *   incremented and a replacement pod is created.
   * - Count: indicates that the pod is handled in the default way - the
   *   counter towards the .backoffLimit is incremented.
   * Additional values are considered to be added in the future. Clients should
   * react to an unknown action by skipping the rule.
   */
  action?: V1PodFailurePolicyAction
  /**
   * Represents the requirement on the container exit codes.
   * +optional
   */
  onExitCodes?: V1PodFailurePolicyOnExitCodesRequirement
  /**
   * Represents the requirement on the pod conditions. The requirement is represented
   * as a list of pod condition patterns. The requirement is satisfied if at
   * least one pattern matches an actual pod condition. At most 20 elements are allowed.
   * +listType=atomic
   */
  onPodConditions?: V1PodFailurePolicyOnPodConditionsPattern[]
}

export interface V1PodIP {
  /**
   * ip is an IP address (IPv4 or IPv6) assigned to the pod
   */
  ip?: string
}

export type V1PodManagementPolicyType = 'OrderedReady' | 'Parallel'

export interface V1PodOS {
  /**
   * Name is the name of the operating system. The currently supported values are linux and windows.
   * Additional value may be defined in future and can be one of:
   * https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration
   * Clients should expect to handle additional values and treat unrecognized values in this field as os: null
   */
  name?: V1OSName
}

export type V1PodPhase = 'Pending' | 'Running' | 'Succeeded' | 'Failed' | 'Unknown'

export type V1PodQOSClass = 'Guaranteed' | 'Burstable' | 'BestEffort'

export interface V1PodReadinessGate {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   */
  conditionType?: V1PodConditionType
}

export interface V1PodSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  fsGroup?: number
  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  fsGroupChangePolicy?: V1PodFSGroupChangePolicy
  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  runAsGroup?: number
  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * +optional
   */
  runAsNonRoot?: boolean
  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  runAsUser?: number
  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  seLinuxOptions?: V1SELinuxOptions
  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  seccompProfile?: V1SeccompProfile
  /**
   * A list of groups applied to the first process run in each container, in addition
   * to the container's primary GID.  If unspecified, no groups will be added to
   * any container.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  supplementalGroups?: number[]
  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  sysctls?: V1Sysctl[]
  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   * +optional
   */
  windowsOptions?: V1WindowsSecurityContextOptions
}

export interface V1PodSpec {
  /**
   * Optional duration in seconds the pod may be active on the node relative to
   * StartTime before the system will actively try to mark it failed and kill associated containers.
   * Value must be a positive integer.
   * +optional
   */
  activeDeadlineSeconds?: number
  /**
   * If specified, the pod's scheduling constraints
   * +optional
   */
  affinity?: V1Affinity
  /**
   * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
   * +optional
   */
  automountServiceAccountToken?: boolean
  /**
   * List of containers belonging to the pod.
   * Containers cannot currently be added or removed.
   * There must be at least one container in a Pod.
   * Cannot be updated.
   * +patchMergeKey=name
   * +patchStrategy=merge
   */
  containers?: V1Container[]
  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   * +optional
   */
  dnsConfig?: V1PodDNSConfig
  /**
   * Set DNS policy for the pod.
   * Defaults to "ClusterFirst".
   * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
   * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
   * To have DNS options set along with hostNetwork, you have to specify DNS policy
   * explicitly to 'ClusterFirstWithHostNet'.
   * +optional
   */
  dnsPolicy?: V1DNSPolicy
  /**
   * EnableServiceLinks indicates whether information about services should be injected into pod's
   * environment variables, matching the syntax of Docker links.
   * Optional: Defaults to true.
   * +optional
   */
  enableServiceLinks?: boolean
  /**
   * List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
   * pod to perform user-initiated actions such as debugging. This list cannot be specified when
   * creating a pod, and it cannot be modified by updating the pod spec. In order to add an
   * ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge
   */
  ephemeralContainers?: V1EphemeralContainer[]
  /**
   * HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
   * file if specified. This is only valid for non-hostNetwork pods.
   * +optional
   * +patchMergeKey=ip
   * +patchStrategy=merge
   */
  hostAliases?: V1HostAlias[]
  /**
   * Use the host's ipc namespace.
   * Optional: Default to false.
   * +k8s:conversion-gen=false
   * +optional
   */
  hostIPC?: boolean
  /**
   * Host networking requested for this pod. Use the host's network namespace.
   * If this option is set, the ports that will be used must be specified.
   * Default to false.
   * +k8s:conversion-gen=false
   * +optional
   */
  hostNetwork?: boolean
  /**
   * Use the host's pid namespace.
   * Optional: Default to false.
   * +k8s:conversion-gen=false
   * +optional
   */
  hostPID?: boolean
  /**
   * Use the host's user namespace.
   * Optional: Default to true.
   * If set to true or not present, the pod will be run in the host user namespace, useful
   * for when the pod needs a feature only available to the host user namespace, such as
   * loading a kernel module with CAP_SYS_MODULE.
   * When set to false, a new userns is created for the pod. Setting false is useful for
   * mitigating container breakout vulnerabilities even allowing users to run their
   * containers as root without actually having root privileges on the host.
   * This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
   * +k8s:conversion-gen=false
   * +optional
   */
  hostUsers?: boolean
  /**
   * Specifies the hostname of the Pod
   * If not specified, the pod's hostname will be set to a system-defined value.
   * +optional
   */
  hostname?: string
  /**
   * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
   * If specified, these secrets will be passed to individual puller implementations for them to use.
   * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge
   */
  imagePullSecrets?: V1LocalObjectReference[]
  /**
   * List of initialization containers belonging to the pod.
   * Init containers are executed in order prior to containers being started. If any
   * init container fails, the pod is considered to have failed and is handled according
   * to its restartPolicy. The name for an init container or normal container must be
   * unique among all containers.
   * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
   * The resourceRequirements of an init container are taken into account during scheduling
   * by finding the highest request/limit for each resource type, and then using the max of
   * of that value or the sum of the normal containers. Limits are applied to init containers
   * in a similar fashion.
   * Init containers cannot currently be added or removed.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   * +patchMergeKey=name
   * +patchStrategy=merge
   */
  initContainers?: V1Container[]
  /**
   * NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
   * the scheduler simply schedules this pod onto that node, assuming that it fits resource
   * requirements.
   * +optional
   */
  nodeName?: string
  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   * +optional
   * +mapType=atomic
   */
  nodeSelector?: {
    [key: string]: string
  }
  /**
   * Specifies the OS of the containers in the pod.
   * Some pod and container fields are restricted if this is set.
   *
   * If the OS field is set to linux, the following fields must be unset:
   * -securityContext.windowsOptions
   *
   * If the OS field is set to windows, following fields must be unset:
   * - spec.hostPID
   * - spec.hostIPC
   * - spec.hostUsers
   * - spec.securityContext.seLinuxOptions
   * - spec.securityContext.seccompProfile
   * - spec.securityContext.fsGroup
   * - spec.securityContext.fsGroupChangePolicy
   * - spec.securityContext.sysctls
   * - spec.shareProcessNamespace
   * - spec.securityContext.runAsUser
   * - spec.securityContext.runAsGroup
   * - spec.securityContext.supplementalGroups
   * - spec.containers[*].securityContext.seLinuxOptions
   * - spec.containers[*].securityContext.seccompProfile
   * - spec.containers[*].securityContext.capabilities
   * - spec.containers[*].securityContext.readOnlyRootFilesystem
   * - spec.containers[*].securityContext.privileged
   * - spec.containers[*].securityContext.allowPrivilegeEscalation
   * - spec.containers[*].securityContext.procMount
   * - spec.containers[*].securityContext.runAsUser
   * - spec.containers[*].securityContext.runAsGroup
   * +optional
   */
  os?: V1PodOS
  /**
   * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
   * This field will be autopopulated at admission time by the RuntimeClass admission controller. If
   * the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
   * The RuntimeClass admission controller will reject Pod create requests which have the overhead already
   * set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
   * defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md
   * +optional
   */
  overhead?: V1ResourceList
  /**
   * PreemptionPolicy is the Policy for preempting pods with lower priority.
   * One of Never, PreemptLowerPriority.
   * Defaults to PreemptLowerPriority if unset.
   * +optional
   */
  preemptionPolicy?: V1PreemptionPolicy
  /**
   * The priority value. Various system components use this field to find the
   * priority of the pod. When Priority Admission Controller is enabled, it
   * prevents users from setting this field. The admission controller populates
   * this field from PriorityClassName.
   * The higher the value, the higher the priority.
   * +optional
   */
  priority?: number
  /**
   * If specified, indicates the pod's priority. "system-node-critical" and
   * "system-cluster-critical" are two special keywords which indicate the
   * highest priorities with the former being the highest priority. Any other
   * name must be defined by creating a PriorityClass object with that name.
   * If not specified, the pod priority will be default or zero if there is no
   * default.
   * +optional
   */
  priorityClassName?: string
  /**
   * If specified, all readiness gates will be evaluated for pod readiness.
   * A pod is ready when all its containers are ready AND
   * all conditions specified in the readiness gates have status equal to "True"
   * More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
   * +optional
   */
  readinessGates?: V1PodReadinessGate[]
  /**
   * Restart policy for all containers within the pod.
   * One of Always, OnFailure, Never.
   * Default to Always.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
   * +optional
   */
  restartPolicy?: V1RestartPolicy
  /**
   * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
   * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
   * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
   * empty definition that uses the default runtime handler.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
   * +optional
   */
  runtimeClassName?: string
  /**
   * If specified, the pod will be dispatched by specified scheduler.
   * If not specified, the pod will be dispatched by default scheduler.
   * +optional
   */
  schedulerName?: string
  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * Optional: Defaults to empty.  See type description for default values of each field.
   * +optional
   */
  securityContext?: V1PodSecurityContext
  /**
   * DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.
   * Deprecated: Use serviceAccountName instead.
   * +k8s:conversion-gen=false
   * +optional
   */
  serviceAccount?: string
  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
   * +optional
   */
  serviceAccountName?: string
  /**
   * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
   * In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).
   * In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
   * If a pod does not have FQDN, this has no effect.
   * Default to false.
   * +optional
   */
  setHostnameAsFQDN?: boolean
  /**
   * Share a single process namespace between all of the containers in a pod.
   * When this is set containers will be able to view and signal processes from other containers
   * in the same pod, and the first process in each container will not be assigned PID 1.
   * HostPID and ShareProcessNamespace cannot both be set.
   * Optional: Default to false.
   * +k8s:conversion-gen=false
   * +optional
   */
  shareProcessNamespace?: boolean
  /**
   * If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
   * If not specified, the pod will not have a domainname at all.
   * +optional
   */
  subdomain?: string
  /**
   * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * If this value is nil, the default grace period will be used instead.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * Defaults to 30 seconds.
   * +optional
   */
  terminationGracePeriodSeconds?: number
  /**
   * If specified, the pod's tolerations.
   * +optional
   */
  tolerations?: V1Toleration[]
  /**
   * TopologySpreadConstraints describes how a group of pods ought to spread across topology
   * domains. Scheduler will schedule pods in a way which abides by the constraints.
   * All topologySpreadConstraints are ANDed.
   * +optional
   * +patchMergeKey=topologyKey
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=topologyKey
   * +listMapKey=whenUnsatisfiable
   */
  topologySpreadConstraints?: V1TopologySpreadConstraint[]
  /**
   * List of volumes that can be mounted by containers belonging to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge,retainKeys
   */
  volumes?: V1Volume[]
}

export interface V1PodStatus {
  /**
   * Current service state of pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   */
  conditions?: V1PodCondition[]
  /**
   * The list has one entry per container in the manifest.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
   * +optional
   */
  containerStatuses?: V1ContainerStatus[]
  /**
   * Status for any ephemeral containers that have run in this pod.
   * +optional
   */
  ephemeralContainerStatuses?: V1ContainerStatus[]
  /**
   * IP address of the host to which the pod is assigned. Empty if not yet scheduled.
   * +optional
   */
  hostIP?: string
  /**
   * The list has one entry per init container in the manifest. The most recent successful
   * init container will have ready = true, the most recently started container will have
   * startTime set.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
   */
  initContainerStatuses?: V1ContainerStatus[]
  /**
   * A human readable message indicating details about why the pod is in this condition.
   * +optional
   */
  message?: string
  /**
   * nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
   * scheduled right away as preemption victims receive their graceful termination periods.
   * This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
   * to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
   * give the resources on this node to a higher priority pod that is created after preemption.
   * As a result, this field may be different than PodSpec.nodeName when the pod is
   * scheduled.
   * +optional
   */
  nominatedNodeName?: string
  /**
   * The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
   * The conditions array, the reason and message fields, and the individual container status
   * arrays contain more detail about the pod's status.
   * There are five possible phase values:
   *
   * Pending: The pod has been accepted by the Kubernetes system, but one or more of the
   * container images has not been created. This includes time before being scheduled as
   * well as time spent downloading images over the network, which could take a while.
   * Running: The pod has been bound to a node, and all of the containers have been created.
   * At least one container is still running, or is in the process of starting or restarting.
   * Succeeded: All containers in the pod have terminated in success, and will not be restarted.
   * Failed: All containers in the pod have terminated, and at least one container has
   * terminated in failure. The container either exited with non-zero status or was terminated
   * by the system.
   * Unknown: For some reason the state of the pod could not be obtained, typically due to an
   * error in communicating with the host of the pod.
   *
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
   * +optional
   */
  phase?: V1PodPhase
  /**
   * IP address allocated to the pod. Routable at least within the cluster.
   * Empty if not yet allocated.
   * +optional
   */
  podIP?: string
  /**
   * podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th entry must
   * match the podIP field. Pods may be allocated at most 1 value for each of IPv4 and IPv6. This list
   * is empty if no IPs have been allocated yet.
   * +optional
   * +patchStrategy=merge
   * +patchMergeKey=ip
   */
  podIPs?: V1PodIP[]
  /**
   * The Quality of Service (QOS) classification assigned to the pod based on resource requirements
   * See PodQOSClass type for available QOS classes
   * More info: https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md
   * +optional
   */
  qosClass?: V1PodQOSClass
  /**
   * A brief CamelCase message indicating details about why the pod is in this state.
   * e.g. 'Evicted'
   * +optional
   */
  reason?: string
  /**
   * RFC 3339 date and time at which the object was acknowledged by the Kubelet.
   * This is before the Kubelet pulled the container image(s) for the pod.
   * +optional
   */
  startTime?: string
}

export interface V1PodTemplateSpec {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   */
  metadata?: V1ObjectMeta
  /**
   * Specification of the desired behavior of the pod.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   */
  spec?: V1PodSpec
}

export interface V1PortStatus {
  /**
   * Error is to record the problem with the service port
   * The format of the error shall comply with the following rules:
   * - built-in error values shall be specified in this file and those shall use
   *   CamelCase names
   * - cloud provider specific error values must have names that comply with the
   *   format foo.example.com/CamelCase.
   * ---
   * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
   * +optional
   * +kubebuilder:validation:Required
   * +kubebuilder:validation:MaxLength=316
   */
  error?: string
  /**
   * Port is the port number of the service port of which status is recorded here
   */
  port?: number
  /**
   * Protocol is the protocol of the service port of which status is recorded here
   * The supported values are: "TCP", "UDP", "SCTP"
   */
  protocol?: V1Protocol
}

export interface V1PortworxVolumeSource {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   */
  fsType?: string
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   */
  readOnly?: boolean
  /**
   * volumeID uniquely identifies a Portworx volume
   */
  volumeID?: string
}

export type V1PreemptionPolicy = 'PreemptLowerPriority' | 'Never'

export interface V1PreferredSchedulingTerm {
  /**
   * A node selector term, associated with the corresponding weight.
   */
  preference?: V1NodeSelectorTerm
  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   */
  weight?: number
}

export interface V1Probe {
  /**
   * Exec specifies the action to take.
   * +optional
   */
  exec?: V1ExecAction
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   * +optional
   */
  failureThreshold?: number
  /**
   * GRPC specifies an action involving a GRPC port.
   * This is a beta field and requires enabling GRPCContainerProbe feature gate.
   * +featureGate=GRPCContainerProbe
   * +optional
   */
  grpc?: V1GRPCAction
  /**
   * HTTPGet specifies the http request to perform.
   * +optional
   */
  httpGet?: V1HTTPGetAction
  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * +optional
   */
  initialDelaySeconds?: number
  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   * +optional
   */
  periodSeconds?: number
  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   * +optional
   */
  successThreshold?: number
  /**
   * TCPSocket specifies an action involving a TCP port.
   * +optional
   */
  tcpSocket?: V1TCPSocketAction
  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   * +optional
   */
  terminationGracePeriodSeconds?: number
  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * +optional
   */
  timeoutSeconds?: number
}

export type V1ProcMountType = 'Default' | 'Unmasked'

export interface V1ProjectedVolumeSource {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   */
  defaultMode?: number
  /**
   * sources is the list of volume projections
   * +optional
   */
  sources?: V1VolumeProjection[]
}

export type V1Protocol = 'TCP' | 'UDP' | 'SCTP'

export type V1PullPolicy = 'Always' | 'Never' | 'IfNotPresent'

export interface V1QuobyteVolumeSource {
  /**
   * group to map volume access to
   * Default is no group
   * +optional
   */
  group?: string
  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   * +optional
   */
  readOnly?: boolean
  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   */
  registry?: string
  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   * +optional
   */
  tenant?: string
  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   * +optional
   */
  user?: string
  /**
   * volume is a string that references an already created Quobyte volume by name.
   */
  volume?: string
}

export interface V1RBDPersistentVolumeSource {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   */
  fsType?: string
  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   */
  image?: string
  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   */
  keyring?: string
  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   */
  monitors?: string[]
  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   */
  pool?: string
  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   */
  readOnly?: boolean
  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   */
  secretRef?: V1SecretReference
  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   */
  user?: string
}

export interface V1RBDVolumeSource {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   */
  fsType?: string
  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   */
  image?: string
  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   */
  keyring?: string
  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   */
  monitors?: string[]
  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   */
  pool?: string
  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   */
  readOnly?: boolean
  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   */
  secretRef?: V1LocalObjectReference
  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   */
  user?: string
}

export interface V1ReplicaSetCondition {
  /**
   * The last time the condition transitioned from one status to another.
   * +optional
   */
  lastTransitionTime?: string
  /**
   * A human readable message indicating details about the transition.
   * +optional
   */
  message?: string
  /**
   * The reason for the condition's last transition.
   * +optional
   */
  reason?: string
  /**
   * Status of the condition, one of True, False, Unknown.
   */
  status?: K8sIoApiCoreV1ConditionStatus
  /**
   * Type of replica set condition.
   */
  type?: V1ReplicaSetConditionType
}

export type V1ReplicaSetConditionType = 'ReplicaFailure'

export interface V1ReplicaSetSpec {
  /**
   * Minimum number of seconds for which a newly created pod should be ready
   * without any of its container crashing, for it to be considered available.
   * Defaults to 0 (pod will be considered available as soon as it is ready)
   * +optional
   */
  minReadySeconds?: number
  /**
   * Replicas is the number of desired replicas.
   * This is a pointer to distinguish between explicit zero and unspecified.
   * Defaults to 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
   * +optional
   */
  replicas?: number
  /**
   * Selector is a label query over pods that should match the replica count.
   * Label keys and values that must match in order to be controlled by this replica set.
   * It must match the pod template's labels.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
   */
  selector?: V1LabelSelector
  /**
   * Template is the object that describes the pod that will be created if
   * insufficient replicas are detected.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
   * +optional
   */
  template?: V1PodTemplateSpec
}

export interface V1ReplicaSetStatus {
  /**
   * The number of available replicas (ready for at least minReadySeconds) for this replica set.
   * +optional
   */
  availableReplicas?: number
  /**
   * Represents the latest available observations of a replica set's current state.
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   */
  conditions?: V1ReplicaSetCondition[]
  /**
   * The number of pods that have labels matching the labels of the pod template of the replicaset.
   * +optional
   */
  fullyLabeledReplicas?: number
  /**
   * ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
   * +optional
   */
  observedGeneration?: number
  /**
   * readyReplicas is the number of pods targeted by this ReplicaSet with a Ready Condition.
   * +optional
   */
  readyReplicas?: number
  /**
   * Replicas is the most recently oberved number of replicas.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
   */
  replicas?: number
}

export interface V1ReplicationControllerCondition {
  /**
   * The last time the condition transitioned from one status to another.
   * +optional
   */
  lastTransitionTime?: string
  /**
   * A human readable message indicating details about the transition.
   * +optional
   */
  message?: string
  /**
   * The reason for the condition's last transition.
   * +optional
   */
  reason?: string
  /**
   * Status of the condition, one of True, False, Unknown.
   */
  status?: K8sIoApiCoreV1ConditionStatus
  /**
   * Type of replication controller condition.
   */
  type?: V1ReplicationControllerConditionType
}

export type V1ReplicationControllerConditionType = 'ReplicaFailure'

export interface V1ReplicationControllerSpec {
  /**
   * Minimum number of seconds for which a newly created pod should be ready
   * without any of its container crashing, for it to be considered available.
   * Defaults to 0 (pod will be considered available as soon as it is ready)
   * +optional
   */
  minReadySeconds?: number
  /**
   * Replicas is the number of desired replicas.
   * This is a pointer to distinguish between explicit zero and unspecified.
   * Defaults to 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
   * +optional
   */
  replicas?: number
  /**
   * Selector is a label query over pods that should match the Replicas count.
   * If Selector is empty, it is defaulted to the labels present on the Pod template.
   * Label keys and values that must match in order to be controlled by this replication
   * controller, if empty defaulted to labels on Pod template.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
   * +optional
   * +mapType=atomic
   */
  selector?: {
    [key: string]: string
  }
  /**
   * Template is the object that describes the pod that will be created if
   * insufficient replicas are detected. This takes precedence over a TemplateRef.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
   * +optional
   */
  template?: V1PodTemplateSpec
}

export interface V1ReplicationControllerStatus {
  /**
   * The number of available replicas (ready for at least minReadySeconds) for this replication controller.
   * +optional
   */
  availableReplicas?: number
  /**
   * Represents the latest available observations of a replication controller's current state.
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   */
  conditions?: V1ReplicationControllerCondition[]
  /**
   * The number of pods that have labels matching the labels of the pod template of the replication controller.
   * +optional
   */
  fullyLabeledReplicas?: number
  /**
   * ObservedGeneration reflects the generation of the most recently observed replication controller.
   * +optional
   */
  observedGeneration?: number
  /**
   * The number of ready replicas for this replication controller.
   * +optional
   */
  readyReplicas?: number
  /**
   * Replicas is the most recently oberved number of replicas.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
   */
  replicas?: number
}

export interface V1ResourceFieldSelector {
  /**
   * Container name: required for volumes, optional for env vars
   * +optional
   */
  containerName?: string
  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   * +optional
   */
  divisor?: ResourceQuantity
  /**
   * Required: resource to select
   */
  resource?: string
}

export interface V1ResourceList {
  [key: string]: ResourceQuantity
}

export interface V1ResourceRequirements {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * +optional
   */
  limits?: V1ResourceList
  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * +optional
   */
  requests?: V1ResourceList
}

export type V1RestartPolicy = 'Always' | 'OnFailure' | 'Never'

export interface V1RollingUpdateDaemonSet {
  /**
   * The maximum number of nodes with an existing available DaemonSet pod that
   * can have an updated DaemonSet pod during during an update.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * This can not be 0 if MaxUnavailable is 0.
   * Absolute number is calculated from percentage by rounding up to a minimum of 1.
   * Default value is 0.
   * Example: when this is set to 30%, at most 30% of the total number of nodes
   * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
   * can have their a new pod created before the old pod is marked as deleted.
   * The update starts by launching new pods on 30% of nodes. Once an updated
   * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
   * on that node is marked deleted. If the old pod becomes unavailable for any
   * reason (Ready transitions to false, is evicted, or is drained) an updated
   * pod is immediatedly created on that node without considering surge limits.
   * Allowing surge implies the possibility that the resources consumed by the
   * daemonset on any given node can double if the readiness check fails, and
   * so resource intensive daemonsets should take into account that they may
   * cause evictions during disruption.
   * +optional
   */
  maxSurge?: IntstrIntOrString
  /**
   * The maximum number of DaemonSet pods that can be unavailable during the
   * update. Value can be an absolute number (ex: 5) or a percentage of total
   * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
   * number is calculated from percentage by rounding up.
   * This cannot be 0 if MaxSurge is 0
   * Default value is 1.
   * Example: when this is set to 30%, at most 30% of the total number of nodes
   * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
   * can have their pods stopped for an update at any given time. The update
   * starts by stopping at most 30% of those DaemonSet pods and then brings
   * up new DaemonSet pods in their place. Once the new pods are available,
   * it then proceeds onto other DaemonSet pods, thus ensuring that at least
   * 70% of original number of DaemonSet pods are available at all times during
   * the update.
   * +optional
   */
  maxUnavailable?: IntstrIntOrString
}

export interface V1RollingUpdateDeployment {
  /**
   * The maximum number of pods that can be scheduled above the desired number of
   * pods.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * This can not be 0 if MaxUnavailable is 0.
   * Absolute number is calculated from percentage by rounding up.
   * Defaults to 25%.
   * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
   * the rolling update starts, such that the total number of old and new pods do not exceed
   * 130% of desired pods. Once old pods have been killed,
   * new ReplicaSet can be scaled up further, ensuring that total number of pods running
   * at any time during the update is at most 130% of desired pods.
   * +optional
   */
  maxSurge?: IntstrIntOrString
  /**
   * The maximum number of pods that can be unavailable during the update.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * Absolute number is calculated from percentage by rounding down.
   * This can not be 0 if MaxSurge is 0.
   * Defaults to 25%.
   * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
   * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
   * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
   * that the total number of pods available at all times during the update is at
   * least 70% of desired pods.
   * +optional
   */
  maxUnavailable?: IntstrIntOrString
}

export interface V1RollingUpdateStatefulSetStrategy {
  /**
   * The maximum number of pods that can be unavailable during the update.
   * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
   * Absolute number is calculated from percentage by rounding up. This can not be 0.
   * Defaults to 1. This field is alpha-level and is only honored by servers that enable the
   * MaxUnavailableStatefulSet feature. The field applies to all pods in the range 0 to
   * Replicas-1. That means if there is any unavailable pod in the range 0 to Replicas-1, it
   * will be counted towards MaxUnavailable.
   * +optional
   */
  maxUnavailable?: IntstrIntOrString
  /**
   * Partition indicates the ordinal at which the StatefulSet should be partitioned
   * for updates. During a rolling update, all pods from ordinal Replicas-1 to
   * Partition are updated. All pods from ordinal Partition-1 to 0 remain untouched.
   * This is helpful in being able to do a canary based deployment. The default value is 0.
   * +optional
   */
  partition?: number
}

export interface V1SELinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   * +optional
   */
  level?: string
  /**
   * Role is a SELinux role label that applies to the container.
   * +optional
   */
  role?: string
  /**
   * Type is a SELinux type label that applies to the container.
   * +optional
   */
  type?: string
  /**
   * User is a SELinux user label that applies to the container.
   * +optional
   */
  user?: string
}

export interface V1ScaleIOPersistentVolumeSource {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs"
   * +optional
   */
  fsType?: string
  /**
   * gateway is the host address of the ScaleIO API Gateway.
   */
  gateway?: string
  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   * +optional
   */
  protectionDomain?: string
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   */
  readOnly?: boolean
  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   */
  secretRef?: V1SecretReference
  /**
   * sslEnabled is the flag to enable/disable SSL communication with Gateway, default false
   * +optional
   */
  sslEnabled?: boolean
  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   * +optional
   */
  storageMode?: string
  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   * +optional
   */
  storagePool?: string
  /**
   * system is the name of the storage system as configured in ScaleIO.
   */
  system?: string
  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   */
  volumeName?: string
}

export interface V1ScaleIOVolumeSource {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   * +optional
   */
  fsType?: string
  /**
   * gateway is the host address of the ScaleIO API Gateway.
   */
  gateway?: string
  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   * +optional
   */
  protectionDomain?: string
  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   */
  readOnly?: boolean
  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   */
  secretRef?: V1LocalObjectReference
  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   * +optional
   */
  sslEnabled?: boolean
  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   * +optional
   */
  storageMode?: string
  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   * +optional
   */
  storagePool?: string
  /**
   * system is the name of the storage system as configured in ScaleIO.
   */
  system?: string
  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   */
  volumeName?: string
}

export interface V1SeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must only be set if type is "Localhost".
   * +optional
   */
  localhostProfile?: string
  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   * +unionDiscriminator
   */
  type?: V1SeccompProfileType
}

export type V1SeccompProfileType = 'Unconfined' | 'RuntimeDefault' | 'Localhost'

export interface V1SecretEnvSource {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * +optional
   */
  name?: string
  /**
   * Specify whether the Secret must be defined
   * +optional
   */
  optional?: boolean
}

export interface V1SecretKeySelector {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key?: string
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * +optional
   */
  name?: string
  /**
   * Specify whether the Secret or its key must be defined
   * +optional
   */
  optional?: boolean
}

export interface V1SecretProjection {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   * +optional
   */
  items?: V1KeyToPath[]
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * +optional
   */
  name?: string
  /**
   * optional field specify whether the Secret or its key must be defined
   * +optional
   */
  optional?: boolean
}

export interface V1SecretReference {
  /**
   * name is unique within a namespace to reference a secret resource.
   * +optional
   */
  name?: string
  /**
   * namespace defines the space within which the secret name must be unique.
   * +optional
   */
  namespace?: string
}

export interface V1SecretVolumeSource {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   */
  defaultMode?: number
  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   * +optional
   */
  items?: V1KeyToPath[]
  /**
   * optional field specify whether the Secret or its keys must be defined
   * +optional
   */
  optional?: boolean
  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   * +optional
   */
  secretName?: string
}

export interface V1SecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  allowPrivilegeEscalation?: boolean
  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  capabilities?: V1Capabilities
  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  privileged?: boolean
  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default is DefaultProcMount which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  procMount?: V1ProcMountType
  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  readOnlyRootFilesystem?: boolean
  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  runAsGroup?: number
  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * +optional
   */
  runAsNonRoot?: boolean
  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  runAsUser?: number
  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  seLinuxOptions?: V1SELinuxOptions
  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   */
  seccompProfile?: V1SeccompProfile
  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   * +optional
   */
  windowsOptions?: V1WindowsSecurityContextOptions
}

export interface V1ServiceAccountTokenProjection {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   * +optional
   */
  audience?: string
  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   * +optional
   */
  expirationSeconds?: number
  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   */
  path?: string
}

export type V1ServiceAffinity = 'ClientIP' | 'None'

export type V1ServiceExternalTrafficPolicyType = 'Cluster' | 'Local'

export type V1ServiceInternalTrafficPolicyType = 'Cluster' | 'Local'

export interface V1ServicePort {
  /**
   * The application protocol for this port.
   * This field follows standard Kubernetes label syntax.
   * Un-prefixed names are reserved for IANA standard service names (as per
   * RFC-6335 and https://www.iana.org/assignments/service-names).
   * Non-standard protocols should use prefixed names such as
   * mycompany.com/my-custom-protocol.
   * +optional
   */
  appProtocol?: string
  /**
   * The name of this port within the service. This must be a DNS_LABEL.
   * All ports within a ServiceSpec must have unique names. When considering
   * the endpoints for a Service, this must match the 'name' field in the
   * EndpointPort.
   * Optional if only one ServicePort is defined on this service.
   * +optional
   */
  name?: string
  /**
   * The port on each node on which this service is exposed when type is
   * NodePort or LoadBalancer.  Usually assigned by the system. If a value is
   * specified, in-range, and not in use it will be used, otherwise the
   * operation will fail.  If not specified, a port will be allocated if this
   * Service requires one.  If this field is specified when creating a
   * Service which does not need it, creation will fail. This field will be
   * wiped when updating a Service to no longer need it (e.g. changing type
   * from NodePort to ClusterIP).
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
   * +optional
   */
  nodePort?: number
  /**
   * The port that will be exposed by this service.
   */
  port?: number
  /**
   * The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
   * Default is TCP.
   * +default="TCP"
   * +optional
   */
  protocol?: V1Protocol
  /**
   * Number or name of the port to access on the pods targeted by the service.
   * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   * If this is a string, it will be looked up as a named port in the
   * target Pod's container ports. If this is not specified, the value
   * of the 'port' field is used (an identity map).
   * This field is ignored for services with clusterIP=None, and should be
   * omitted or set equal to the 'port' field.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
   * +optional
   */
  targetPort?: IntstrIntOrString
}

export interface V1ServiceSpec {
  /**
   * allocateLoadBalancerNodePorts defines if NodePorts will be automatically
   * allocated for services with type LoadBalancer.  Default is "true". It
   * may be set to "false" if the cluster load-balancer does not rely on
   * NodePorts.  If the caller requests specific NodePorts (by specifying a
   * value), those requests will be respected, regardless of this field.
   * This field may only be set for services with type LoadBalancer and will
   * be cleared if the type is changed to any other type.
   * +optional
   */
  allocateLoadBalancerNodePorts?: boolean
  /**
   * clusterIP is the IP address of the service and is usually assigned
   * randomly. If an address is specified manually, is in-range (as per
   * system configuration), and is not in use, it will be allocated to the
   * service; otherwise creation of the service will fail. This field may not
   * be changed through updates unless the type field is also being changed
   * to ExternalName (which requires this field to be blank) or the type
   * field is being changed from ExternalName (in which case this field may
   * optionally be specified, as describe above).  Valid values are "None",
   * empty string (""), or a valid IP address. Setting this to "None" makes a
   * "headless service" (no virtual IP), which is useful when direct endpoint
   * connections are preferred and proxying is not required.  Only applies to
   * types ClusterIP, NodePort, and LoadBalancer. If this field is specified
   * when creating a Service of type ExternalName, creation will fail. This
   * field will be wiped when updating a Service to type ExternalName.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   * +optional
   */
  clusterIP?: string
  /**
   * ClusterIPs is a list of IP addresses assigned to this service, and are
   * usually assigned randomly.  If an address is specified manually, is
   * in-range (as per system configuration), and is not in use, it will be
   * allocated to the service; otherwise creation of the service will fail.
   * This field may not be changed through updates unless the type field is
   * also being changed to ExternalName (which requires this field to be
   * empty) or the type field is being changed from ExternalName (in which
   * case this field may optionally be specified, as describe above).  Valid
   * values are "None", empty string (""), or a valid IP address.  Setting
   * this to "None" makes a "headless service" (no virtual IP), which is
   * useful when direct endpoint connections are preferred and proxying is
   * not required.  Only applies to types ClusterIP, NodePort, and
   * LoadBalancer. If this field is specified when creating a Service of type
   * ExternalName, creation will fail. This field will be wiped when updating
   * a Service to type ExternalName.  If this field is not specified, it will
   * be initialized from the clusterIP field.  If this field is specified,
   * clients must ensure that clusterIPs[0] and clusterIP have the same
   * value.
   *
   * This field may hold a maximum of two entries (dual-stack IPs, in either order).
   * These IPs must correspond to the values of the ipFamilies field. Both
   * clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   * +listType=atomic
   * +optional
   */
  clusterIPs?: string[]
  /**
   * externalIPs is a list of IP addresses for which nodes in the cluster
   * will also accept traffic for this service.  These IPs are not managed by
   * Kubernetes.  The user is responsible for ensuring that traffic arrives
   * at a node with this IP.  A common example is external load-balancers
   * that are not part of the Kubernetes system.
   * +optional
   */
  externalIPs?: string[]
  /**
   * externalName is the external reference that discovery mechanisms will
   * return as an alias for this service (e.g. a DNS CNAME record). No
   * proxying will be involved.  Must be a lowercase RFC-1123 hostname
   * (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
   * +optional
   */
  externalName?: string
  /**
   * externalTrafficPolicy describes how nodes distribute service traffic they
   * receive on one of the Service's "externally-facing" addresses (NodePorts,
   * ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
   * the service in a way that assumes that external load balancers will take care
   * of balancing the service traffic between nodes, and so each node will deliver
   * traffic only to the node-local endpoints of the service, without masquerading
   * the client source IP. (Traffic mistakenly sent to a node with no endpoints will
   * be dropped.) The default value, "Cluster", uses the standard behavior of
   * routing to all endpoints evenly (possibly modified by topology and other
   * features). Note that traffic sent to an External IP or LoadBalancer IP from
   * within the cluster will always get "Cluster" semantics, but clients sending to
   * a NodePort from within the cluster may need to take traffic policy into account
   * when picking a node.
   * +optional
   */
  externalTrafficPolicy?: V1ServiceExternalTrafficPolicyType
  /**
   * healthCheckNodePort specifies the healthcheck nodePort for the service.
   * This only applies when type is set to LoadBalancer and
   * externalTrafficPolicy is set to Local. If a value is specified, is
   * in-range, and is not in use, it will be used.  If not specified, a value
   * will be automatically allocated.  External systems (e.g. load-balancers)
   * can use this port to determine if a given node holds endpoints for this
   * service or not.  If this field is specified when creating a Service
   * which does not need it, creation will fail. This field will be wiped
   * when updating a Service to no longer need it (e.g. changing type).
   * This field cannot be updated once set.
   * +optional
   */
  healthCheckNodePort?: number
  /**
   * InternalTrafficPolicy describes how nodes distribute service traffic they
   * receive on the ClusterIP. If set to "Local", the proxy will assume that pods
   * only want to talk to endpoints of the service on the same node as the pod,
   * dropping the traffic if there are no local endpoints. The default value,
   * "Cluster", uses the standard behavior of routing to all endpoints evenly
   * (possibly modified by topology and other features).
   * +featureGate=ServiceInternalTrafficPolicy
   * +optional
   */
  internalTrafficPolicy?: V1ServiceInternalTrafficPolicyType
  /**
   * IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
   * service. This field is usually assigned automatically based on cluster
   * configuration and the ipFamilyPolicy field. If this field is specified
   * manually, the requested family is available in the cluster,
   * and ipFamilyPolicy allows it, it will be used; otherwise creation of
   * the service will fail. This field is conditionally mutable: it allows
   * for adding or removing a secondary IP family, but it does not allow
   * changing the primary IP family of the Service. Valid values are "IPv4"
   * and "IPv6".  This field only applies to Services of types ClusterIP,
   * NodePort, and LoadBalancer, and does apply to "headless" services.
   * This field will be wiped when updating a Service to type ExternalName.
   *
   * This field may hold a maximum of two entries (dual-stack families, in
   * either order).  These families must correspond to the values of the
   * clusterIPs field, if specified. Both clusterIPs and ipFamilies are
   * governed by the ipFamilyPolicy field.
   * +listType=atomic
   * +optional
   */
  ipFamilies?: V1IPFamily[]
  /**
   * IPFamilyPolicy represents the dual-stack-ness requested or required by
   * this Service. If there is no value provided, then this field will be set
   * to SingleStack. Services can be "SingleStack" (a single IP family),
   * "PreferDualStack" (two IP families on dual-stack configured clusters or
   * a single IP family on single-stack clusters), or "RequireDualStack"
   * (two IP families on dual-stack configured clusters, otherwise fail). The
   * ipFamilies and clusterIPs fields depend on the value of this field. This
   * field will be wiped when updating a service to type ExternalName.
   * +optional
   */
  ipFamilyPolicy?: V1IPFamilyPolicy
  /**
   * loadBalancerClass is the class of the load balancer implementation this Service belongs to.
   * If specified, the value of this field must be a label-style identifier, with an optional prefix,
   * e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
   * This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
   * balancer implementation is used, today this is typically done through the cloud provider integration,
   * but should apply for any default implementation. If set, it is assumed that a load balancer
   * implementation is watching for Services with a matching class. Any default load balancer
   * implementation (e.g. cloud providers) should ignore Services that set this field.
   * This field can only be set when creating or updating a Service to type 'LoadBalancer'.
   * Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
   * +featureGate=LoadBalancerClass
   * +optional
   */
  loadBalancerClass?: string
  /**
   * Only applies to Service Type: LoadBalancer.
   * This feature depends on whether the underlying cloud-provider supports specifying
   * the loadBalancerIP when a load balancer is created.
   * This field will be ignored if the cloud-provider does not support the feature.
   * Deprecated: This field was under-specified and its meaning varies across implementations,
   * and it cannot support dual-stack.
   * As of Kubernetes v1.24, users are encouraged to use implementation-specific annotations when available.
   * This field may be removed in a future API version.
   * +optional
   */
  loadBalancerIP?: string
  /**
   * If specified and supported by the platform, this will restrict traffic through the cloud-provider
   * load-balancer will be restricted to the specified client IPs. This field will be ignored if the
   * cloud-provider does not support the feature."
   * More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
   * +optional
   */
  loadBalancerSourceRanges?: string[]
  /**
   * The list of ports that are exposed by this service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   * +patchMergeKey=port
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=port
   * +listMapKey=protocol
   */
  ports?: V1ServicePort[]
  /**
   * publishNotReadyAddresses indicates that any agent which deals with endpoints for this
   * Service should disregard any indications of ready/not-ready.
   * The primary use case for setting this field is for a StatefulSet's Headless Service to
   * propagate SRV DNS records for its Pods for the purpose of peer discovery.
   * The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
   * Services interpret this to mean that all endpoints are considered "ready" even if the
   * Pods themselves are not. Agents which consume only Kubernetes generated endpoints
   * through the Endpoints or EndpointSlice resources can safely assume this behavior.
   * +optional
   */
  publishNotReadyAddresses?: boolean
  /**
   * Route service traffic to pods with label keys and values matching this
   * selector. If empty or not present, the service is assumed to have an
   * external process managing its endpoints, which Kubernetes will not
   * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
   * Ignored if type is ExternalName.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   * +optional
   * +mapType=atomic
   */
  selector?: {
    [key: string]: string
  }
  /**
   * Supports "ClientIP" and "None". Used to maintain session affinity.
   * Enable client IP based session affinity.
   * Must be ClientIP or None.
   * Defaults to None.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   * +optional
   */
  sessionAffinity?: V1ServiceAffinity
  /**
   * sessionAffinityConfig contains the configurations of session affinity.
   * +optional
   */
  sessionAffinityConfig?: V1SessionAffinityConfig
  /**
   * type determines how the Service is exposed. Defaults to ClusterIP. Valid
   * options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
   * "ClusterIP" allocates a cluster-internal IP address for load-balancing
   * to endpoints. Endpoints are determined by the selector or if that is not
   * specified, by manual construction of an Endpoints object or
   * EndpointSlice objects. If clusterIP is "None", no virtual IP is
   * allocated and the endpoints are published as a set of endpoints rather
   * than a virtual IP.
   * "NodePort" builds on ClusterIP and allocates a port on every node which
   * routes to the same endpoints as the clusterIP.
   * "LoadBalancer" builds on NodePort and creates an external load-balancer
   * (if supported in the current cloud) which routes to the same endpoints
   * as the clusterIP.
   * "ExternalName" aliases this service to the specified externalName.
   * Several other fields do not apply to ExternalName services.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
   * +optional
   */
  type?: V1ServiceType
}

export interface V1ServiceStatus {
  /**
   * Current service state
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=type
   */
  conditions?: V1Condition[]
  /**
   * LoadBalancer contains the current status of the load-balancer,
   * if one is present.
   * +optional
   */
  loadBalancer?: V1LoadBalancerStatus
}

export type V1ServiceType = 'ClusterIP' | 'NodePort' | 'LoadBalancer' | 'ExternalName'

export interface V1SessionAffinityConfig {
  /**
   * clientIP contains the configurations of Client IP based session affinity.
   * +optional
   */
  clientIP?: V1ClientIPConfig
}

export interface V1StatefulSetCondition {
  /**
   * Last time the condition transitioned from one status to another.
   * +optional
   */
  lastTransitionTime?: string
  /**
   * A human readable message indicating details about the transition.
   * +optional
   */
  message?: string
  /**
   * The reason for the condition's last transition.
   * +optional
   */
  reason?: string
  /**
   * Status of the condition, one of True, False, Unknown.
   */
  status?: K8sIoApiCoreV1ConditionStatus
  /**
   * Type of statefulset condition.
   */
  type?: string
}

export interface V1StatefulSetPersistentVolumeClaimRetentionPolicy {
  /**
   * WhenDeleted specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is deleted. The default policy
   * of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
   * `Delete` policy causes those PVCs to be deleted.
   */
  whenDeleted?: V1PersistentVolumeClaimRetentionPolicyType
  /**
   * WhenScaled specifies what happens to PVCs created from StatefulSet
   * VolumeClaimTemplates when the StatefulSet is scaled down. The default
   * policy of `Retain` causes PVCs to not be affected by a scaledown. The
   * `Delete` policy causes the associated PVCs for any excess pods above
   * the replica count to be deleted.
   */
  whenScaled?: V1PersistentVolumeClaimRetentionPolicyType
}

export interface V1StatefulSetSpec {
  /**
   * Minimum number of seconds for which a newly created pod should be ready
   * without any of its container crashing for it to be considered available.
   * Defaults to 0 (pod will be considered available as soon as it is ready)
   * +optional
   */
  minReadySeconds?: number
  /**
   * persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent
   * volume claims created from volumeClaimTemplates. By default, all persistent
   * volume claims are created as needed and retained until manually deleted. This
   * policy allows the lifecycle to be altered, for example by deleting persistent
   * volume claims when their stateful set is deleted, or when their pod is scaled
   * down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled,
   * which is alpha.  +optional
   */
  persistentVolumeClaimRetentionPolicy?: V1StatefulSetPersistentVolumeClaimRetentionPolicy
  /**
   * podManagementPolicy controls how pods are created during initial scale up,
   * when replacing pods on nodes, or when scaling down. The default policy is
   * `OrderedReady`, where pods are created in increasing order (pod-0, then
   * pod-1, etc) and the controller will wait until each pod is ready before
   * continuing. When scaling down, the pods are removed in the opposite order.
   * The alternative policy is `Parallel` which will create pods in parallel
   * to match the desired scale without waiting, and on scale down will delete
   * all pods at once.
   * +optional
   */
  podManagementPolicy?: V1PodManagementPolicyType
  /**
   * replicas is the desired number of replicas of the given Template.
   * These are replicas in the sense that they are instantiations of the
   * same Template, but individual replicas also have a consistent identity.
   * If unspecified, defaults to 1.
   * TODO: Consider a rename of this field.
   * +optional
   */
  replicas?: number
  /**
   * revisionHistoryLimit is the maximum number of revisions that will
   * be maintained in the StatefulSet's revision history. The revision history
   * consists of all revisions not represented by a currently applied
   * StatefulSetSpec version. The default value is 10.
   */
  revisionHistoryLimit?: number
  /**
   * selector is a label query over pods that should match the replica count.
   * It must match the pod template's labels.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
   */
  selector?: V1LabelSelector
  /**
   * serviceName is the name of the service that governs this StatefulSet.
   * This service must exist before the StatefulSet, and is responsible for
   * the network identity of the set. Pods get DNS/hostnames that follow the
   * pattern: pod-specific-string.serviceName.default.svc.cluster.local
   * where "pod-specific-string" is managed by the StatefulSet controller.
   */
  serviceName?: string
  /**
   * template is the object that describes the pod that will be created if
   * insufficient replicas are detected. Each pod stamped out by the StatefulSet
   * will fulfill this Template, but have a unique identity from the rest
   * of the StatefulSet.
   */
  template?: V1PodTemplateSpec
  /**
   * updateStrategy indicates the StatefulSetUpdateStrategy that will be
   * employed to update Pods in the StatefulSet when a revision is made to
   * Template.
   */
  updateStrategy?: V1StatefulSetUpdateStrategy
  /**
   * volumeClaimTemplates is a list of claims that pods are allowed to reference.
   * The StatefulSet controller is responsible for mapping network identities to
   * claims in a way that maintains the identity of a pod. Every claim in
   * this list must have at least one matching (by name) volumeMount in one
   * container in the template. A claim in this list takes precedence over
   * any volumes in the template, with the same name.
   * TODO: Define the behavior if a claim already exists with the same name.
   * +optional
   */
  volumeClaimTemplates?: V1PersistentVolumeClaim[]
}

export interface V1StatefulSetStatus {
  /**
   * Total number of available pods (ready for at least minReadySeconds) targeted by this statefulset.
   * +optional
   */
  availableReplicas?: number
  /**
   * collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller
   * uses this field as a collision avoidance mechanism when it needs to create the name for the
   * newest ControllerRevision.
   * +optional
   */
  collisionCount?: number
  /**
   * Represents the latest available observations of a statefulset's current state.
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   */
  conditions?: V1StatefulSetCondition[]
  /**
   * currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
   * indicated by currentRevision.
   */
  currentReplicas?: number
  /**
   * currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
   * sequence [0,currentReplicas).
   */
  currentRevision?: string
  /**
   * observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the
   * StatefulSet's generation, which is updated on mutation by the API Server.
   * +optional
   */
  observedGeneration?: number
  /**
   * readyReplicas is the number of pods created for this StatefulSet with a Ready Condition.
   */
  readyReplicas?: number
  /**
   * replicas is the number of Pods created by the StatefulSet controller.
   */
  replicas?: number
  /**
   * updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
   * [replicas-updatedReplicas,replicas)
   */
  updateRevision?: string
  /**
   * updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
   * indicated by updateRevision.
   */
  updatedReplicas?: number
}

export interface V1StatefulSetUpdateStrategy {
  /**
   * RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
   * +optional
   */
  rollingUpdate?: V1RollingUpdateStatefulSetStrategy
  /**
   * Type indicates the type of the StatefulSetUpdateStrategy.
   * Default is RollingUpdate.
   * +optional
   */
  type?: V1StatefulSetUpdateStrategyType
}

export type V1StatefulSetUpdateStrategyType = 'RollingUpdate' | 'OnDelete'

export type V1StorageMedium = '' | 'Memory' | 'HugePages' | 'HugePages-'

export interface V1StorageOSPersistentVolumeSource {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * +optional
   */
  fsType?: string
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   */
  readOnly?: boolean
  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   * +optional
   */
  secretRef?: V1ObjectReference
  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   */
  volumeName?: string
  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   * +optional
   */
  volumeNamespace?: string
}

export interface V1StorageOSVolumeSource {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * +optional
   */
  fsType?: string
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   */
  readOnly?: boolean
  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   * +optional
   */
  secretRef?: V1LocalObjectReference
  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   */
  volumeName?: string
  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   * +optional
   */
  volumeNamespace?: string
}

export interface V1Sysctl {
  /**
   * Name of a property to set
   */
  name?: string
  /**
   * Value of a property to set
   */
  value?: string
}

export interface V1TCPSocketAction {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   * +optional
   */
  host?: string
  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   */
  port?: IntstrIntOrString
}

export interface V1Taint {
  /**
   * Required. The effect of the taint on pods
   * that do not tolerate the taint.
   * Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
   */
  effect?: V1TaintEffect
  /**
   * Required. The taint key to be applied to a node.
   */
  key?: string
  /**
   * TimeAdded represents the time at which the taint was added.
   * It is only written for NoExecute taints.
   * +optional
   */
  timeAdded?: string
  /**
   * The taint value corresponding to the taint key.
   * +optional
   */
  value?: string
}

export type V1TaintEffect = 'NoSchedule' | 'PreferNoSchedule' | 'NoExecute'

export type V1TerminationMessagePolicy = 'File' | 'FallbackToLogsOnError'

export interface V1Toleration {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   * +optional
   */
  effect?: V1TaintEffect
  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   * +optional
   */
  key?: string
  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   * +optional
   */
  operator?: V1TolerationOperator
  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   * +optional
   */
  tolerationSeconds?: number
  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   * +optional
   */
  value?: string
}

export type V1TolerationOperator = 'Exists' | 'Equal'

export interface V1TopologySpreadConstraint {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   * +optional
   */
  labelSelector?: V1LabelSelector
  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are ANDed with labelSelector
   * to select the group of existing pods over which spreading will be calculated
   * for the incoming pod. Keys that don't exist in the incoming pod labels will
   * be ignored. A null or empty list means only match against labelSelector.
   * +listType=atomic
   * +optional
   */
  matchLabelKeys?: string[]
  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * +-------+-------+-------+
   * | zone1 | zone2 | zone3 |
   * +-------+-------+-------+
   * |  P P  |  P P  |   P   |
   * +-------+-------+-------+
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   */
  maxSkew?: number
  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * +-------+-------+-------+
   * | zone1 | zone2 | zone3 |
   * +-------+-------+-------+
   * |  P P  |  P P  |  P P  |
   * +-------+-------+-------+
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   * This is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default).
   * +optional
   */
  minDomains?: number
  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   *
   * If this value is nil, the behavior is equivalent to the Honor policy.
   * This is a alpha-level feature enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   * +optional
   */
  nodeAffinityPolicy?: V1NodeInclusionPolicy
  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * If this value is nil, the behavior is equivalent to the Ignore policy.
   * This is a alpha-level feature enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   * +optional
   */
  nodeTaintsPolicy?: V1NodeInclusionPolicy
  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes meet the requirements of
   * nodeAffinityPolicy and nodeTaintsPolicy.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   */
  topologyKey?: string
  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   *   but giving higher precedence to topologies that would help reduce the
   *   skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * +-------+-------+-------+
   * | zone1 | zone2 | zone3 |
   * +-------+-------+-------+
   * | P P P |   P   |   P   |
   * +-------+-------+-------+
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   */
  whenUnsatisfiable?: V1UnsatisfiableConstraintAction
}

export interface V1TypedLocalObjectReference {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   * +optional
   */
  apiGroup?: string
  /**
   * Kind is the type of resource being referenced
   */
  kind?: string
  /**
   * Name is the name of resource being referenced
   */
  name?: string
}

export type V1URIScheme = 'HTTP' | 'HTTPS'

export interface V1UncountedTerminatedPods {
  /**
   * Failed holds UIDs of failed Pods.
   * +listType=set
   * +optional
   */
  failed?: string[]
  /**
   * Succeeded holds UIDs of succeeded Pods.
   * +listType=set
   * +optional
   */
  succeeded?: string[]
}

export type V1UnsatisfiableConstraintAction = 'DoNotSchedule' | 'ScheduleAnyway'

export interface V1Volume {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * +optional
   */
  awsElasticBlockStore?: V1AWSElasticBlockStoreVolumeSource
  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * +optional
   */
  azureDisk?: V1AzureDiskVolumeSource
  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * +optional
   */
  azureFile?: V1AzureFileVolumeSource
  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   * +optional
   */
  cephfs?: V1CephFSVolumeSource
  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   */
  cinder?: V1CinderVolumeSource
  /**
   * configMap represents a configMap that should populate this volume
   * +optional
   */
  configMap?: V1ConfigMapVolumeSource
  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   * +optional
   */
  csi?: V1CSIVolumeSource
  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   * +optional
   */
  downwardAPI?: V1DownwardAPIVolumeSource
  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   * +optional
   */
  emptyDir?: V1EmptyDirVolumeSource
  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   *    tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   *    a PersistentVolumeClaim (see EphemeralVolumeSource for more
   *    information on the connection between this volume type
   *    and PersistentVolumeClaim).
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * +optional
   */
  ephemeral?: V1EphemeralVolumeSource
  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   * +optional
   */
  fc?: V1FCVolumeSource
  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   * +optional
   */
  flexVolume?: V1FlexVolumeSource
  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   * +optional
   */
  flocker?: V1FlockerVolumeSource
  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * +optional
   */
  gcePersistentDisk?: V1GCEPersistentDiskVolumeSource
  /**
   * gitRepo represents a git repository at a particular revision.
   * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   * +optional
   */
  gitRepo?: V1GitRepoVolumeSource
  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   * +optional
   */
  glusterfs?: V1GlusterfsVolumeSource
  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * ---
   * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
   * mount host directories as read/write.
   * +optional
   */
  hostPath?: V1HostPathVolumeSource
  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   * +optional
   */
  iscsi?: V1ISCSIVolumeSource
  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string
  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * +optional
   */
  nfs?: V1NFSVolumeSource
  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   * +optional
   */
  persistentVolumeClaim?: V1PersistentVolumeClaimVolumeSource
  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   */
  photonPersistentDisk?: V1PhotonPersistentDiskVolumeSource
  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   * +optional
   */
  portworxVolume?: V1PortworxVolumeSource
  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   */
  projected?: V1ProjectedVolumeSource
  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   * +optional
   */
  quobyte?: V1QuobyteVolumeSource
  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   * +optional
   */
  rbd?: V1RBDVolumeSource
  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * +optional
   */
  scaleIO?: V1ScaleIOVolumeSource
  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   * +optional
   */
  secret?: V1SecretVolumeSource
  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   * +optional
   */
  storageos?: V1StorageOSVolumeSource
  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   * +optional
   */
  vsphereVolume?: V1VsphereVirtualDiskVolumeSource
}

export interface V1VolumeDevice {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   */
  devicePath?: string
  /**
   * name must match the name of a persistentVolumeClaim in the pod
   */
  name?: string
}

export interface V1VolumeMount {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   */
  mountPath?: string
  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * +optional
   */
  mountPropagation?: V1MountPropagationMode
  /**
   * This must match the Name of a Volume.
   */
  name?: string
  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   * +optional
   */
  readOnly?: boolean
  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   * +optional
   */
  subPath?: string
  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   * +optional
   */
  subPathExpr?: string
}

export interface V1VolumeNodeAffinity {
  /**
   * required specifies hard node constraints that must be met.
   */
  required?: V1NodeSelector
}

export interface V1VolumeProjection {
  /**
   * configMap information about the configMap data to project
   * +optional
   */
  configMap?: V1ConfigMapProjection
  /**
   * downwardAPI information about the downwardAPI data to project
   * +optional
   */
  downwardAPI?: V1DownwardAPIProjection
  /**
   * secret information about the secret data to project
   * +optional
   */
  secret?: V1SecretProjection
  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   * +optional
   */
  serviceAccountToken?: V1ServiceAccountTokenProjection
}

export interface V1VsphereVirtualDiskVolumeSource {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * +optional
   */
  fsType?: string
  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   * +optional
   */
  storagePolicyID?: string
  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   * +optional
   */
  storagePolicyName?: string
  /**
   * volumePath is the path that identifies vSphere volume vmdk
   */
  volumePath?: string
}

export interface V1WeightedPodAffinityTerm {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   */
  podAffinityTerm?: V1PodAffinityTerm
  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   */
  weight?: number
}

export interface V1WindowsSecurityContextOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   * +optional
   */
  gmsaCredentialSpec?: string
  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   * +optional
   */
  gmsaCredentialSpecName?: string
  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * This field is alpha-level and will only be honored by components that enable the
   * WindowsHostProcessContainers feature flag. Setting this field without the feature
   * flag will result in errors when validating the Pod. All of a Pod's containers must
   * have the same effective HostProcess value (it is not allowed to have a mix of HostProcess
   * containers and non-HostProcess containers).  In addition, if HostProcess is true
   * then HostNetwork must also be set to true.
   * +optional
   */
  hostProcess?: boolean
  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * +optional
   */
  runAsUserName?: string
}

export interface ListAgentQueryParams {
  /**
   * account id is the account where you want to access the resource
   */
  accountIdentifier?: string
  /**
   * organization id is the organization where you want to access the resource
   */
  organizationIdentifier?: string
  /**
   * project id is the project where you want to access the resource
   */
  projectIdentifier?: string
  /**
   * page number
   */
  page: number
  /**
   * limit per page
   */
  limit: number
  /**
   * search based on name
   */
  search?: string
  /**
   * get all
   */
  all: boolean
}

export type ListAgentProps = Omit<
  GetProps<
    ApiListAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListAgentQueryParams,
    void
  >,
  'path'
>

/**
 * Get list of agents
 *
 * Get list of agents
 */
export const ListAgent = (props: ListAgentProps) => (
  <Get<ApiListAgentResponse, GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError, ListAgentQueryParams, void>
    path={`/api/v1/agents`}
    base={getConfig('servicediscovery')}
    {...props}
  />
)

export type UseListAgentProps = Omit<
  UseGetProps<
    ApiListAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListAgentQueryParams,
    void
  >,
  'path'
>

/**
 * Get list of agents
 *
 * Get list of agents
 */
export const useListAgent = (props: UseListAgentProps) =>
  useGet<
    ApiListAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListAgentQueryParams,
    void
  >(`/api/v1/agents`, { base: getConfig('servicediscovery'), ...props })

/**
 * Get list of agents
 *
 * Get list of agents
 */
export const listAgentPromise = (
  props: GetUsingFetchProps<
    ApiListAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListAgentQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ApiListAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListAgentQueryParams,
    void
  >(getConfig('servicediscovery'), `/api/v1/agents`, props, signal)

export interface CreateAgentQueryParams {
  /**
   * account id is the account where you want to create the resource
   */
  accountIdentifier?: string
  /**
   * organization id is the organization where you want to create the resource
   */
  organizationIdentifier?: string
  /**
   * project id is the project where you want to create the resource
   */
  projectIdentifier?: string
}

export type CreateAgentProps = Omit<
  MutateProps<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateAgentQueryParams,
    ApiCreateAgentRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an agent
 *
 * Create a new agent
 */
export const CreateAgent = (props: CreateAgentProps) => (
  <Mutate<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateAgentQueryParams,
    ApiCreateAgentRequest,
    void
  >
    verb="POST"
    path={`/api/v1/agents`}
    base={getConfig('servicediscovery')}
    {...props}
  />
)

export type UseCreateAgentProps = Omit<
  UseMutateProps<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateAgentQueryParams,
    ApiCreateAgentRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an agent
 *
 * Create a new agent
 */
export const useCreateAgent = (props: UseCreateAgentProps) =>
  useMutate<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateAgentQueryParams,
    ApiCreateAgentRequest,
    void
  >('POST', `/api/v1/agents`, { base: getConfig('servicediscovery'), ...props })

/**
 * Create an agent
 *
 * Create a new agent
 */
export const createAgentPromise = (
  props: MutateUsingFetchProps<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateAgentQueryParams,
    ApiCreateAgentRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateAgentQueryParams,
    ApiCreateAgentRequest,
    void
  >('POST', getConfig('servicediscovery'), `/api/v1/agents`, props, signal)

export interface DeleteAgentQueryParams {
  /**
   * account id is the account where you want to access the resource
   */
  accountIdentifier?: string
  /**
   * organization id is the organization where you want to access the resource
   */
  organizationIdentifier?: string
  /**
   * project id is the project where you want to access the resource
   */
  projectIdentifier?: string
}

export type DeleteAgentProps = Omit<
  MutateProps<
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiEmpty,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    DeleteAgentQueryParams,
    string,
    void
  >,
  'path' | 'verb'
>

/**
 * Delete an agent
 *
 * Delete an agent
 */
export const DeleteAgent = (props: DeleteAgentProps) => (
  <Mutate<
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiEmpty,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    DeleteAgentQueryParams,
    string,
    void
  >
    verb="DELETE"
    path={`/api/v1/agents`}
    base={getConfig('servicediscovery')}
    {...props}
  />
)

export type UseDeleteAgentProps = Omit<
  UseMutateProps<
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiEmpty,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    DeleteAgentQueryParams,
    string,
    void
  >,
  'path' | 'verb'
>

/**
 * Delete an agent
 *
 * Delete an agent
 */
export const useDeleteAgent = (props: UseDeleteAgentProps) =>
  useMutate<
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiEmpty,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    DeleteAgentQueryParams,
    string,
    void
  >('DELETE', `/api/v1/agents`, { base: getConfig('servicediscovery'), ...props })

/**
 * Delete an agent
 *
 * Delete an agent
 */
export const deleteAgentPromise = (
  props: MutateUsingFetchProps<
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiEmpty,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    DeleteAgentQueryParams,
    string,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiEmpty,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    DeleteAgentQueryParams,
    string,
    void
  >('DELETE', getConfig('servicediscovery'), `/api/v1/agents`, props, signal)

export interface GetAgentQueryParams {
  /**
   * account id is the account where you want to access the resource
   */
  accountIdentifier?: string
  /**
   * organization id is the organization where you want to access the resource
   */
  organizationIdentifier?: string
  /**
   * project id is the project where you want to access the resource
   */
  projectIdentifier?: string
}

export interface GetAgentPathParams {
  /**
   * agent identity
   */
  agentIdentity: string
}

export type GetAgentProps = Omit<
  GetProps<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetAgentQueryParams,
    GetAgentPathParams
  >,
  'path'
> &
  GetAgentPathParams

/**
 * Get an agent
 *
 * Get an agent
 */
export const GetAgent = ({ agentIdentity, ...props }: GetAgentProps) => (
  <Get<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetAgentQueryParams,
    GetAgentPathParams
  >
    path={`/api/v1/agents/${agentIdentity}`}
    base={getConfig('servicediscovery')}
    {...props}
  />
)

export type UseGetAgentProps = Omit<
  UseGetProps<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetAgentQueryParams,
    GetAgentPathParams
  >,
  'path'
> &
  GetAgentPathParams

/**
 * Get an agent
 *
 * Get an agent
 */
export const useGetAgent = ({ agentIdentity, ...props }: UseGetAgentProps) =>
  useGet<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetAgentQueryParams,
    GetAgentPathParams
  >((paramsInPath: GetAgentPathParams) => `/api/v1/agents/${paramsInPath.agentIdentity}`, {
    base: getConfig('servicediscovery'),
    pathParams: { agentIdentity },
    ...props
  })

/**
 * Get an agent
 *
 * Get an agent
 */
export const getAgentPromise = (
  {
    agentIdentity,
    ...props
  }: GetUsingFetchProps<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetAgentQueryParams,
    GetAgentPathParams
  > & {
    /**
     * agent identity
     */
    agentIdentity: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetAgentQueryParams,
    GetAgentPathParams
  >(getConfig('servicediscovery'), `/api/v1/agents/${agentIdentity}`, props, signal)

export interface UpdateAgentQueryParams {
  /**
   * account id that want to access the resource
   */
  accountIdentifier?: string
  /**
   * organization id that want to access the resource
   */
  organizationIdentifier?: string
  /**
   * project id that want to access the resource
   */
  projectIdentifier?: string
}

export interface UpdateAgentPathParams {
  /**
   * agent identity
   */
  agentIdentity: string
}

export type UpdateAgentProps = Omit<
  MutateProps<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    UpdateAgentQueryParams,
    ApiUpdateAgentRequest,
    UpdateAgentPathParams
  >,
  'path' | 'verb'
> &
  UpdateAgentPathParams

/**
 * Update an agent
 *
 * Update an agent
 */
export const UpdateAgent = ({ agentIdentity, ...props }: UpdateAgentProps) => (
  <Mutate<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    UpdateAgentQueryParams,
    ApiUpdateAgentRequest,
    UpdateAgentPathParams
  >
    verb="PUT"
    path={`/api/v1/agents/${agentIdentity}`}
    base={getConfig('servicediscovery')}
    {...props}
  />
)

export type UseUpdateAgentProps = Omit<
  UseMutateProps<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    UpdateAgentQueryParams,
    ApiUpdateAgentRequest,
    UpdateAgentPathParams
  >,
  'path' | 'verb'
> &
  UpdateAgentPathParams

/**
 * Update an agent
 *
 * Update an agent
 */
export const useUpdateAgent = ({ agentIdentity, ...props }: UseUpdateAgentProps) =>
  useMutate<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    UpdateAgentQueryParams,
    ApiUpdateAgentRequest,
    UpdateAgentPathParams
  >('PUT', (paramsInPath: UpdateAgentPathParams) => `/api/v1/agents/${paramsInPath.agentIdentity}`, {
    base: getConfig('servicediscovery'),
    pathParams: { agentIdentity },
    ...props
  })

/**
 * Update an agent
 *
 * Update an agent
 */
export const updateAgentPromise = (
  {
    agentIdentity,
    ...props
  }: MutateUsingFetchProps<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    UpdateAgentQueryParams,
    ApiUpdateAgentRequest,
    UpdateAgentPathParams
  > & {
    /**
     * agent identity
     */
    agentIdentity: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ApiGetAgentResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    UpdateAgentQueryParams,
    ApiUpdateAgentRequest,
    UpdateAgentPathParams
  >('PUT', getConfig('servicediscovery'), `/api/v1/agents/${agentIdentity}`, props, signal)

export interface ListInstallationQueryParams {
  /**
   * account id is the account where you want to access the resource
   */
  accountIdentifier?: string
  /**
   * organization id is the organization where you want to access the resource
   */
  organizationIdentifier?: string
  /**
   * project id is the project where you want to access the resource
   */
  projectIdentifier?: string
  /**
   * page number
   */
  page: number
  /**
   * limit per page
   */
  limit: number
  /**
   * get all
   */
  all: boolean
}

export interface ListInstallationPathParams {
  /**
   * agent identity
   */
  agentIdentity: string
}

export type ListInstallationProps = Omit<
  GetProps<
    ApiListInstallationResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListInstallationQueryParams,
    ListInstallationPathParams
  >,
  'path'
> &
  ListInstallationPathParams

/**
 * Get list of agent installations
 *
 * Get list of agent installations
 */
export const ListInstallation = ({ agentIdentity, ...props }: ListInstallationProps) => (
  <Get<
    ApiListInstallationResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListInstallationQueryParams,
    ListInstallationPathParams
  >
    path={`/api/v1/agents/${agentIdentity}/installations`}
    base={getConfig('servicediscovery')}
    {...props}
  />
)

export type UseListInstallationProps = Omit<
  UseGetProps<
    ApiListInstallationResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListInstallationQueryParams,
    ListInstallationPathParams
  >,
  'path'
> &
  ListInstallationPathParams

/**
 * Get list of agent installations
 *
 * Get list of agent installations
 */
export const useListInstallation = ({ agentIdentity, ...props }: UseListInstallationProps) =>
  useGet<
    ApiListInstallationResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListInstallationQueryParams,
    ListInstallationPathParams
  >((paramsInPath: ListInstallationPathParams) => `/api/v1/agents/${paramsInPath.agentIdentity}/installations`, {
    base: getConfig('servicediscovery'),
    pathParams: { agentIdentity },
    ...props
  })

/**
 * Get list of agent installations
 *
 * Get list of agent installations
 */
export const listInstallationPromise = (
  {
    agentIdentity,
    ...props
  }: GetUsingFetchProps<
    ApiListInstallationResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListInstallationQueryParams,
    ListInstallationPathParams
  > & {
    /**
     * agent identity
     */
    agentIdentity: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ApiListInstallationResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListInstallationQueryParams,
    ListInstallationPathParams
  >(getConfig('servicediscovery'), `/api/v1/agents/${agentIdentity}/installations`, props, signal)

export interface CreateInstallationQueryParams {
  /**
   * account id is the account where you want to access the resource
   */
  accountIdentifier?: string
  /**
   * organization id is the organization where you want to access the resource
   */
  organizationIdentifier?: string
  /**
   * project id is the project where you want to access the resource
   */
  projectIdentifier?: string
}

export interface CreateInstallationPathParams {
  /**
   * agent identity
   */
  agentIdentity: string
}

export type CreateInstallationProps = Omit<
  MutateProps<
    ApiGetInstallationResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateInstallationQueryParams,
    void,
    CreateInstallationPathParams
  >,
  'path' | 'verb'
> &
  CreateInstallationPathParams

/**
 * Install an agent
 *
 * Install agent
 */
export const CreateInstallation = ({ agentIdentity, ...props }: CreateInstallationProps) => (
  <Mutate<
    ApiGetInstallationResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateInstallationQueryParams,
    void,
    CreateInstallationPathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentity}/installations`}
    base={getConfig('servicediscovery')}
    {...props}
  />
)

export type UseCreateInstallationProps = Omit<
  UseMutateProps<
    ApiGetInstallationResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateInstallationQueryParams,
    void,
    CreateInstallationPathParams
  >,
  'path' | 'verb'
> &
  CreateInstallationPathParams

/**
 * Install an agent
 *
 * Install agent
 */
export const useCreateInstallation = ({ agentIdentity, ...props }: UseCreateInstallationProps) =>
  useMutate<
    ApiGetInstallationResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateInstallationQueryParams,
    void,
    CreateInstallationPathParams
  >(
    'POST',
    (paramsInPath: CreateInstallationPathParams) => `/api/v1/agents/${paramsInPath.agentIdentity}/installations`,
    { base: getConfig('servicediscovery'), pathParams: { agentIdentity }, ...props }
  )

/**
 * Install an agent
 *
 * Install agent
 */
export const createInstallationPromise = (
  {
    agentIdentity,
    ...props
  }: MutateUsingFetchProps<
    ApiGetInstallationResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateInstallationQueryParams,
    void,
    CreateInstallationPathParams
  > & {
    /**
     * agent identity
     */
    agentIdentity: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ApiGetInstallationResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateInstallationQueryParams,
    void,
    CreateInstallationPathParams
  >('POST', getConfig('servicediscovery'), `/api/v1/agents/${agentIdentity}/installations`, props, signal)

export interface ListK8sCustomServiceConnectionQueryParams {
  /**
   * account id that want to access the resource
   */
  accountIdentifier?: string
  /**
   * organization id that want to access the resource
   */
  organizationIdentifier?: string
  /**
   * project id that want to access the resource
   */
  projectIdentifier?: string
}

export interface ListK8sCustomServiceConnectionPathParams {
  /**
   * agent identity
   */
  agentIdentity: string
}

export type ListK8sCustomServiceConnectionProps = Omit<
  GetProps<
    ApiListCustomServiceConnection,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListK8sCustomServiceConnectionQueryParams,
    ListK8sCustomServiceConnectionPathParams
  >,
  'path'
> &
  ListK8sCustomServiceConnectionPathParams

/**
 * List k8s CustomService Connection
 *
 * List connections in the context of k8s CustomService
 */
export const ListK8sCustomServiceConnection = ({ agentIdentity, ...props }: ListK8sCustomServiceConnectionProps) => (
  <Get<
    ApiListCustomServiceConnection,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListK8sCustomServiceConnectionQueryParams,
    ListK8sCustomServiceConnectionPathParams
  >
    path={`/api/v1/agents/${agentIdentity}/k8scustomserviceconnections`}
    base={getConfig('servicediscovery')}
    {...props}
  />
)

export type UseListK8sCustomServiceConnectionProps = Omit<
  UseGetProps<
    ApiListCustomServiceConnection,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListK8sCustomServiceConnectionQueryParams,
    ListK8sCustomServiceConnectionPathParams
  >,
  'path'
> &
  ListK8sCustomServiceConnectionPathParams

/**
 * List k8s CustomService Connection
 *
 * List connections in the context of k8s CustomService
 */
export const useListK8sCustomServiceConnection = ({
  agentIdentity,
  ...props
}: UseListK8sCustomServiceConnectionProps) =>
  useGet<
    ApiListCustomServiceConnection,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListK8sCustomServiceConnectionQueryParams,
    ListK8sCustomServiceConnectionPathParams
  >(
    (paramsInPath: ListK8sCustomServiceConnectionPathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentity}/k8scustomserviceconnections`,
    { base: getConfig('servicediscovery'), pathParams: { agentIdentity }, ...props }
  )

/**
 * List k8s CustomService Connection
 *
 * List connections in the context of k8s CustomService
 */
export const listK8sCustomServiceConnectionPromise = (
  {
    agentIdentity,
    ...props
  }: GetUsingFetchProps<
    ApiListCustomServiceConnection,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListK8sCustomServiceConnectionQueryParams,
    ListK8sCustomServiceConnectionPathParams
  > & {
    /**
     * agent identity
     */
    agentIdentity: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ApiListCustomServiceConnection,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListK8sCustomServiceConnectionQueryParams,
    ListK8sCustomServiceConnectionPathParams
  >(getConfig('servicediscovery'), `/api/v1/agents/${agentIdentity}/k8scustomserviceconnections`, props, signal)

export interface ListK8SCustomServiceQueryParams {
  /**
   * account id that want to access the resource
   */
  accountIdentifier?: string
  /**
   * organization id that want to access the resource
   */
  organizationIdentifier?: string
  /**
   * project id that want to access the resource
   */
  projectIdentifier?: string
  /**
   * namespace of the custom service
   */
  namespace?: string
  /**
   * page number
   */
  page: number
  /**
   * limit per page
   */
  limit: number
  /**
   * search based on name
   */
  search?: string
  /**
   * get all
   */
  all: boolean
}

export interface ListK8SCustomServicePathParams {
  /**
   * agent identity
   */
  agentIdentity: string
}

export type ListK8SCustomServiceProps = Omit<
  GetProps<
    ApiListK8sCustomService,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListK8SCustomServiceQueryParams,
    ListK8SCustomServicePathParams
  >,
  'path'
> &
  ListK8SCustomServicePathParams

/**
 * Get list of custom services
 *
 * Get list of custom services
 */
export const ListK8SCustomService = ({ agentIdentity, ...props }: ListK8SCustomServiceProps) => (
  <Get<
    ApiListK8sCustomService,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListK8SCustomServiceQueryParams,
    ListK8SCustomServicePathParams
  >
    path={`/api/v1/agents/${agentIdentity}/k8scustomservices`}
    base={getConfig('servicediscovery')}
    {...props}
  />
)

export type UseListK8SCustomServiceProps = Omit<
  UseGetProps<
    ApiListK8sCustomService,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListK8SCustomServiceQueryParams,
    ListK8SCustomServicePathParams
  >,
  'path'
> &
  ListK8SCustomServicePathParams

/**
 * Get list of custom services
 *
 * Get list of custom services
 */
export const useListK8SCustomService = ({ agentIdentity, ...props }: UseListK8SCustomServiceProps) =>
  useGet<
    ApiListK8sCustomService,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListK8SCustomServiceQueryParams,
    ListK8SCustomServicePathParams
  >(
    (paramsInPath: ListK8SCustomServicePathParams) => `/api/v1/agents/${paramsInPath.agentIdentity}/k8scustomservices`,
    { base: getConfig('servicediscovery'), pathParams: { agentIdentity }, ...props }
  )

/**
 * Get list of custom services
 *
 * Get list of custom services
 */
export const listK8SCustomServicePromise = (
  {
    agentIdentity,
    ...props
  }: GetUsingFetchProps<
    ApiListK8sCustomService,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListK8SCustomServiceQueryParams,
    ListK8SCustomServicePathParams
  > & {
    /**
     * agent identity
     */
    agentIdentity: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ApiListK8sCustomService,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListK8SCustomServiceQueryParams,
    ListK8SCustomServicePathParams
  >(getConfig('servicediscovery'), `/api/v1/agents/${agentIdentity}/k8scustomservices`, props, signal)

export interface GetK8SCustomServiceQueryParams {
  /**
   * account id that want to access the resource
   */
  accountIdentifier?: string
  /**
   * organization id that want to access the resource
   */
  organizationIdentifier?: string
  /**
   * project id that want to access the resource
   */
  projectIdentifier?: string
}

export interface GetK8SCustomServicePathParams {
  /**
   * agent identity
   */
  agentIdentity: string
  /**
   * custom service id
   */
  kcs_id: string
}

export type GetK8SCustomServiceProps = Omit<
  GetProps<
    ApiGetK8sCustomService,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetK8SCustomServiceQueryParams,
    GetK8SCustomServicePathParams
  >,
  'path'
> &
  GetK8SCustomServicePathParams

/**
 * Get custom service by id
 *
 * Get custom service by id
 */
export const GetK8SCustomService = ({ agentIdentity, kcs_id, ...props }: GetK8SCustomServiceProps) => (
  <Get<
    ApiGetK8sCustomService,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetK8SCustomServiceQueryParams,
    GetK8SCustomServicePathParams
  >
    path={`/api/v1/agents/${agentIdentity}/k8scustomservices/${kcs_id}`}
    base={getConfig('servicediscovery')}
    {...props}
  />
)

export type UseGetK8SCustomServiceProps = Omit<
  UseGetProps<
    ApiGetK8sCustomService,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetK8SCustomServiceQueryParams,
    GetK8SCustomServicePathParams
  >,
  'path'
> &
  GetK8SCustomServicePathParams

/**
 * Get custom service by id
 *
 * Get custom service by id
 */
export const useGetK8SCustomService = ({ agentIdentity, kcs_id, ...props }: UseGetK8SCustomServiceProps) =>
  useGet<
    ApiGetK8sCustomService,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetK8SCustomServiceQueryParams,
    GetK8SCustomServicePathParams
  >(
    (paramsInPath: GetK8SCustomServicePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentity}/k8scustomservices/${paramsInPath.kcs_id}`,
    { base: getConfig('servicediscovery'), pathParams: { agentIdentity, kcs_id }, ...props }
  )

/**
 * Get custom service by id
 *
 * Get custom service by id
 */
export const getK8SCustomServicePromise = (
  {
    agentIdentity,
    kcs_id,
    ...props
  }: GetUsingFetchProps<
    ApiGetK8sCustomService,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetK8SCustomServiceQueryParams,
    GetK8SCustomServicePathParams
  > & {
    /**
     * agent identity
     */
    agentIdentity: string
    /**
     * custom service id
     */
    kcs_id: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ApiGetK8sCustomService,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetK8SCustomServiceQueryParams,
    GetK8SCustomServicePathParams
  >(getConfig('servicediscovery'), `/api/v1/agents/${agentIdentity}/k8scustomservices/${kcs_id}`, props, signal)

export interface GetServiceFromK8SCustomServiceQueryParams {
  /**
   * account id that want to access the resource
   */
  accountIdentifier?: string
  /**
   * organization id that want to access the resource
   */
  organizationIdentifier?: string
  /**
   * project id that want to access the resource
   */
  projectIdentifier?: string
}

export interface GetServiceFromK8SCustomServicePathParams {
  /**
   * agent identity
   */
  agentIdentity: string
  /**
   * custom service id
   */
  kcs_id: string
}

export type GetServiceFromK8SCustomServiceProps = Omit<
  GetProps<
    ApiGetServiceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetServiceFromK8SCustomServiceQueryParams,
    GetServiceFromK8SCustomServicePathParams
  >,
  'path'
> &
  GetServiceFromK8SCustomServicePathParams

/**
 * Get service linked to custom service
 *
 * Get service linked to custom service
 */
export const GetServiceFromK8SCustomService = ({
  agentIdentity,
  kcs_id,
  ...props
}: GetServiceFromK8SCustomServiceProps) => (
  <Get<
    ApiGetServiceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetServiceFromK8SCustomServiceQueryParams,
    GetServiceFromK8SCustomServicePathParams
  >
    path={`/api/v1/agents/${agentIdentity}/k8scustomservices/${kcs_id}/service`}
    base={getConfig('servicediscovery')}
    {...props}
  />
)

export type UseGetServiceFromK8SCustomServiceProps = Omit<
  UseGetProps<
    ApiGetServiceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetServiceFromK8SCustomServiceQueryParams,
    GetServiceFromK8SCustomServicePathParams
  >,
  'path'
> &
  GetServiceFromK8SCustomServicePathParams

/**
 * Get service linked to custom service
 *
 * Get service linked to custom service
 */
export const useGetServiceFromK8SCustomService = ({
  agentIdentity,
  kcs_id,
  ...props
}: UseGetServiceFromK8SCustomServiceProps) =>
  useGet<
    ApiGetServiceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetServiceFromK8SCustomServiceQueryParams,
    GetServiceFromK8SCustomServicePathParams
  >(
    (paramsInPath: GetServiceFromK8SCustomServicePathParams) =>
      `/api/v1/agents/${paramsInPath.agentIdentity}/k8scustomservices/${paramsInPath.kcs_id}/service`,
    { base: getConfig('servicediscovery'), pathParams: { agentIdentity, kcs_id }, ...props }
  )

/**
 * Get service linked to custom service
 *
 * Get service linked to custom service
 */
export const getServiceFromK8SCustomServicePromise = (
  {
    agentIdentity,
    kcs_id,
    ...props
  }: GetUsingFetchProps<
    ApiGetServiceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetServiceFromK8SCustomServiceQueryParams,
    GetServiceFromK8SCustomServicePathParams
  > & {
    /**
     * agent identity
     */
    agentIdentity: string
    /**
     * custom service id
     */
    kcs_id: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ApiGetServiceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    GetServiceFromK8SCustomServiceQueryParams,
    GetServiceFromK8SCustomServicePathParams
  >(getConfig('servicediscovery'), `/api/v1/agents/${agentIdentity}/k8scustomservices/${kcs_id}/service`, props, signal)

export interface ListNamespaceQueryParams {
  /**
   * account id that want to access the resource
   */
  accountIdentifier?: string
  /**
   * organization id that want to access the resource
   */
  organizationIdentifier?: string
  /**
   * project id that want to access the resource
   */
  projectIdentifier?: string
  /**
   * name of the namespace
   */
  name?: string
  /**
   * page number
   */
  page: number
  /**
   * limit per page
   */
  limit: number
  /**
   * get all
   */
  all: boolean
}

export interface ListNamespacePathParams {
  /**
   * agent identity
   */
  agentIdentity: string
}

export type ListNamespaceProps = Omit<
  GetProps<
    ApiListNamespaceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListNamespaceQueryParams,
    ListNamespacePathParams
  >,
  'path'
> &
  ListNamespacePathParams

/**
 * Get list of namespaces
 *
 * Get list of namespaces present in the kubernetes agent, name can be passed as filter in query param
 */
export const ListNamespace = ({ agentIdentity, ...props }: ListNamespaceProps) => (
  <Get<
    ApiListNamespaceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListNamespaceQueryParams,
    ListNamespacePathParams
  >
    path={`/api/v1/agents/${agentIdentity}/namespaces`}
    base={getConfig('servicediscovery')}
    {...props}
  />
)

export type UseListNamespaceProps = Omit<
  UseGetProps<
    ApiListNamespaceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListNamespaceQueryParams,
    ListNamespacePathParams
  >,
  'path'
> &
  ListNamespacePathParams

/**
 * Get list of namespaces
 *
 * Get list of namespaces present in the kubernetes agent, name can be passed as filter in query param
 */
export const useListNamespace = ({ agentIdentity, ...props }: UseListNamespaceProps) =>
  useGet<
    ApiListNamespaceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListNamespaceQueryParams,
    ListNamespacePathParams
  >((paramsInPath: ListNamespacePathParams) => `/api/v1/agents/${paramsInPath.agentIdentity}/namespaces`, {
    base: getConfig('servicediscovery'),
    pathParams: { agentIdentity },
    ...props
  })

/**
 * Get list of namespaces
 *
 * Get list of namespaces present in the kubernetes agent, name can be passed as filter in query param
 */
export const listNamespacePromise = (
  {
    agentIdentity,
    ...props
  }: GetUsingFetchProps<
    ApiListNamespaceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListNamespaceQueryParams,
    ListNamespacePathParams
  > & {
    /**
     * agent identity
     */
    agentIdentity: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ApiListNamespaceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListNamespaceQueryParams,
    ListNamespacePathParams
  >(getConfig('servicediscovery'), `/api/v1/agents/${agentIdentity}/namespaces`, props, signal)

export interface ListNetworkMapQueryParams {
  /**
   * account id that want to access the resource
   */
  accountIdentifier?: string
  /**
   * organization id that want to access the resource
   */
  organizationIdentifier?: string
  /**
   * project id that want to access the resource
   */
  projectIdentifier?: string
  /**
   * page number
   */
  page: number
  /**
   * limit per page
   */
  limit: number
  /**
   * search based on name
   */
  search?: string
  /**
   * get all
   */
  all: boolean
}

export interface ListNetworkMapPathParams {
  /**
   * agent identity
   */
  agentIdentity: string
}

export type ListNetworkMapProps = Omit<
  GetProps<
    ApiListNetworkMapResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListNetworkMapQueryParams,
    ListNetworkMapPathParams
  >,
  'path'
> &
  ListNetworkMapPathParams

/**
 * Get list of networkmaps
 *
 * Get list of networkmaps
 */
export const ListNetworkMap = ({ agentIdentity, ...props }: ListNetworkMapProps) => (
  <Get<
    ApiListNetworkMapResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListNetworkMapQueryParams,
    ListNetworkMapPathParams
  >
    path={`/api/v1/agents/${agentIdentity}/networkmaps`}
    base={getConfig('servicediscovery')}
    {...props}
  />
)

export type UseListNetworkMapProps = Omit<
  UseGetProps<
    ApiListNetworkMapResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListNetworkMapQueryParams,
    ListNetworkMapPathParams
  >,
  'path'
> &
  ListNetworkMapPathParams

/**
 * Get list of networkmaps
 *
 * Get list of networkmaps
 */
export const useListNetworkMap = ({ agentIdentity, ...props }: UseListNetworkMapProps) =>
  useGet<
    ApiListNetworkMapResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListNetworkMapQueryParams,
    ListNetworkMapPathParams
  >((paramsInPath: ListNetworkMapPathParams) => `/api/v1/agents/${paramsInPath.agentIdentity}/networkmaps`, {
    base: getConfig('servicediscovery'),
    pathParams: { agentIdentity },
    ...props
  })

/**
 * Get list of networkmaps
 *
 * Get list of networkmaps
 */
export const listNetworkMapPromise = (
  {
    agentIdentity,
    ...props
  }: GetUsingFetchProps<
    ApiListNetworkMapResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListNetworkMapQueryParams,
    ListNetworkMapPathParams
  > & {
    /**
     * agent identity
     */
    agentIdentity: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ApiListNetworkMapResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListNetworkMapQueryParams,
    ListNetworkMapPathParams
  >(getConfig('servicediscovery'), `/api/v1/agents/${agentIdentity}/networkmaps`, props, signal)

export interface CreateNetworkMapQueryParams {
  /**
   * account id that want to access the resource
   */
  accountIdentifier?: string
  /**
   * organization id that want to access the resource
   */
  organizationIdentifier?: string
  /**
   * project id that want to access the resource
   */
  projectIdentifier?: string
}

export interface CreateNetworkMapPathParams {
  /**
   * agent identity
   */
  agentIdentity: string
}

export type CreateNetworkMapProps = Omit<
  MutateProps<
    ApiGetNetworkMapResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateNetworkMapQueryParams,
    ApiCreateNetworkMapRequest,
    CreateNetworkMapPathParams
  >,
  'path' | 'verb'
> &
  CreateNetworkMapPathParams

/**
 * Get list of networkmaps
 *
 * Get list of networkmaps
 */
export const CreateNetworkMap = ({ agentIdentity, ...props }: CreateNetworkMapProps) => (
  <Mutate<
    ApiGetNetworkMapResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateNetworkMapQueryParams,
    ApiCreateNetworkMapRequest,
    CreateNetworkMapPathParams
  >
    verb="POST"
    path={`/api/v1/agents/${agentIdentity}/networkmaps`}
    base={getConfig('servicediscovery')}
    {...props}
  />
)

export type UseCreateNetworkMapProps = Omit<
  UseMutateProps<
    ApiGetNetworkMapResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateNetworkMapQueryParams,
    ApiCreateNetworkMapRequest,
    CreateNetworkMapPathParams
  >,
  'path' | 'verb'
> &
  CreateNetworkMapPathParams

/**
 * Get list of networkmaps
 *
 * Get list of networkmaps
 */
export const useCreateNetworkMap = ({ agentIdentity, ...props }: UseCreateNetworkMapProps) =>
  useMutate<
    ApiGetNetworkMapResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateNetworkMapQueryParams,
    ApiCreateNetworkMapRequest,
    CreateNetworkMapPathParams
  >('POST', (paramsInPath: CreateNetworkMapPathParams) => `/api/v1/agents/${paramsInPath.agentIdentity}/networkmaps`, {
    base: getConfig('servicediscovery'),
    pathParams: { agentIdentity },
    ...props
  })

/**
 * Get list of networkmaps
 *
 * Get list of networkmaps
 */
export const createNetworkMapPromise = (
  {
    agentIdentity,
    ...props
  }: MutateUsingFetchProps<
    ApiGetNetworkMapResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateNetworkMapQueryParams,
    ApiCreateNetworkMapRequest,
    CreateNetworkMapPathParams
  > & {
    /**
     * agent identity
     */
    agentIdentity: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ApiGetNetworkMapResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    CreateNetworkMapQueryParams,
    ApiCreateNetworkMapRequest,
    CreateNetworkMapPathParams
  >('POST', getConfig('servicediscovery'), `/api/v1/agents/${agentIdentity}/networkmaps`, props, signal)

export interface DeleteNetworkMapQueryParams {
  /**
   * account id that want to access the resource
   */
  accountIdentifier?: string
  /**
   * organization id that want to access the resource
   */
  organizationIdentifier?: string
  /**
   * project id that want to access the resource
   */
  projectIdentifier?: string
}

export interface DeleteNetworkMapPathParams {
  /**
   * agent identity
   */
  agentIdentity: string
}

export type DeleteNetworkMapProps = Omit<
  MutateProps<
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiEmpty,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    DeleteNetworkMapQueryParams,
    string,
    DeleteNetworkMapPathParams
  >,
  'path' | 'verb'
> &
  DeleteNetworkMapPathParams

/**
 * Delete a networkmap
 *
 * Delete a networkmap
 */
export const DeleteNetworkMap = ({ agentIdentity, ...props }: DeleteNetworkMapProps) => (
  <Mutate<
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiEmpty,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    DeleteNetworkMapQueryParams,
    string,
    DeleteNetworkMapPathParams
  >
    verb="DELETE"
    path={`/api/v1/agents/${agentIdentity}/networkmaps`}
    base={getConfig('servicediscovery')}
    {...props}
  />
)

export type UseDeleteNetworkMapProps = Omit<
  UseMutateProps<
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiEmpty,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    DeleteNetworkMapQueryParams,
    string,
    DeleteNetworkMapPathParams
  >,
  'path' | 'verb'
> &
  DeleteNetworkMapPathParams

/**
 * Delete a networkmap
 *
 * Delete a networkmap
 */
export const useDeleteNetworkMap = ({ agentIdentity, ...props }: UseDeleteNetworkMapProps) =>
  useMutate<
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiEmpty,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    DeleteNetworkMapQueryParams,
    string,
    DeleteNetworkMapPathParams
  >(
    'DELETE',
    (paramsInPath: DeleteNetworkMapPathParams) => `/api/v1/agents/${paramsInPath.agentIdentity}/networkmaps`,
    { base: getConfig('servicediscovery'), pathParams: { agentIdentity }, ...props }
  )

/**
 * Delete a networkmap
 *
 * Delete a networkmap
 */
export const deleteNetworkMapPromise = (
  {
    agentIdentity,
    ...props
  }: MutateUsingFetchProps<
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiEmpty,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    DeleteNetworkMapQueryParams,
    string,
    DeleteNetworkMapPathParams
  > & {
    /**
     * agent identity
     */
    agentIdentity: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiEmpty,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    DeleteNetworkMapQueryParams,
    string,
    DeleteNetworkMapPathParams
  >('DELETE', getConfig('servicediscovery'), `/api/v1/agents/${agentIdentity}/networkmaps`, props, signal)

export interface ListServiceQueryParams {
  /**
   * account id that want to access the resource
   */
  accountIdentifier?: string
  /**
   * organization id that want to access the resource
   */
  organizationIdentifier?: string
  /**
   * project id that want to access the resource
   */
  projectIdentifier?: string
  /**
   * name of the service
   */
  name?: string
  /**
   * namespace of the service
   */
  namespace?: string
  /**
   * page number
   */
  page: number
  /**
   * limit per page
   */
  limit: number
  /**
   * get all
   */
  all: boolean
}

export interface ListServicePathParams {
  /**
   * agent identity
   */
  agentIdentity: string
}

export type ListServiceProps = Omit<
  GetProps<
    ApiListServiceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListServiceQueryParams,
    ListServicePathParams
  >,
  'path'
> &
  ListServicePathParams

/**
 * Get list of servces
 *
 * Get list of services present in the kubernetes agent, name and namespace can be passed as filter in query param
 */
export const ListService = ({ agentIdentity, ...props }: ListServiceProps) => (
  <Get<
    ApiListServiceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListServiceQueryParams,
    ListServicePathParams
  >
    path={`/api/v1/agents/${agentIdentity}/services`}
    base={getConfig('servicediscovery')}
    {...props}
  />
)

export type UseListServiceProps = Omit<
  UseGetProps<
    ApiListServiceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListServiceQueryParams,
    ListServicePathParams
  >,
  'path'
> &
  ListServicePathParams

/**
 * Get list of servces
 *
 * Get list of services present in the kubernetes agent, name and namespace can be passed as filter in query param
 */
export const useListService = ({ agentIdentity, ...props }: UseListServiceProps) =>
  useGet<
    ApiListServiceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListServiceQueryParams,
    ListServicePathParams
  >((paramsInPath: ListServicePathParams) => `/api/v1/agents/${paramsInPath.agentIdentity}/services`, {
    base: getConfig('servicediscovery'),
    pathParams: { agentIdentity },
    ...props
  })

/**
 * Get list of servces
 *
 * Get list of services present in the kubernetes agent, name and namespace can be passed as filter in query param
 */
export const listServicePromise = (
  {
    agentIdentity,
    ...props
  }: GetUsingFetchProps<
    ApiListServiceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListServiceQueryParams,
    ListServicePathParams
  > & {
    /**
     * agent identity
     */
    agentIdentity: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ApiListServiceResponse,
    GithubComWingsSoftwareServiceDiscoveryPkgTypesServerApiError,
    ListServiceQueryParams,
    ListServicePathParams
  >(getConfig('servicediscovery'), `/api/v1/agents/${agentIdentity}/services`, props, signal)
